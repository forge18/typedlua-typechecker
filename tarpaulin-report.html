<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>:root {
  --color: black;
  --bg: white;
  --head-bg: white;
  --link: #338;

  --blue: #ccf;
  --red: #fcc;
  --yellow: #ffc;
  --green: #cfc;
}

[data-theme='dark'] {
  --color: white;
  --bg: black;
  --head-bg: #333;
  --link: #aaf;

  --blue: #225;
  --red: #522;
  --yellow: #552;
  --green: #252;
}

html,
body {
  margin: 0;
  padding: 0;
  color: var(--color);
  background: var(--bg);
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: var(--head-bg);
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: var(--blue);
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: var(--red);
}
.files-list__file_medium {
  background: var(--yellow);
}
.files-list__file_high {
  background: var(--green);
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: var(--bg);
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: var(--link);
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
  content: counter(line);
  margin-right: 72px;
}
.code-line {
  margin: 0;
  height: 1em;
  counter-increment: line;

  position: absolute;
  padding: 0 0.3em 0.3em 0.3em;
  display: inherit;
  width: 100%;
}
.code-line_covered {
  background: var(--green);
}
.code-line_uncovered {
  background: var(--red);
}

.code-text-container {
  position: relative;
  height: 1em;
  padding: 0.3em 0;
}

.cover-indicator {
  display: flex;
  width: 100%;
  position: absolute;
  justify-content: end;
  height: 1em;
  align-items: center;
  padding: 0 0.3em 0.3em 0.3em;
}

.cover-indicator.check-cover::after {
  content: "\2713";
  font-weight: bold;
  background-color: var(--green);
  height: 1em;
}

.cover-indicator.no-cover::after {
  content: "\2716";
  font-weight: bold;
  background-color: var(--red);
  height: 1em;
}

.stat-line-hit {
  max-width: 48px;
  overflow: hidden;
  font-weight: bold;
  margin-right: 4px;
  background-color: var(--green);
  position: relative;
  top: 0.1em;
}

#theme-toggle-label {
  margin-left: 1ch;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","config.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::Path;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum LuaVersion {\n    #[serde(rename = \"5.1\")]\n    Lua51,\n    #[serde(rename = \"5.2\")]\n    Lua52,\n    #[serde(rename = \"5.3\")]\n    Lua53,\n    #[serde(rename = \"5.4\")]\n    #[default]\n    Lua54,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum StrictLevel {\n    #[serde(rename = \"off\")]\n    Off,\n    #[serde(rename = \"warning\")]\n    Warning,\n    #[serde(rename = \"error\")]\n    #[default]\n    Error,\n}\n\n/// Module code generation mode\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum ModuleMode {\n    /// Generate separate files with require() calls (default)\n    #[default]\n    Require,\n    /// Bundle all modules into a single file\n    Bundle,\n}\n\n/// Optimization level for code generation\n/// Auto mode defaults to O1 in dev mode, O2 in release mode\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum OptimizationLevel {\n    /// No optimizations - fastest compilation\n    O0,\n    /// Basic optimizations - safe transformations (constant folding, DCE, etc.)\n    O1,\n    /// Standard optimizations - includes function inlining\n    O2,\n    /// Aggressive optimizations - may increase compile time\n    O3,\n    /// Auto-detect based on build profile (default)\n    /// O1 for debug/dev builds, O2 for release builds\n    #[default]\n    Auto,\n}\n\n/// Output format for generated Lua code\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum OutputFormat {\n    /// Human-readable format with proper indentation and newlines (default)\n    #[default]\n    Readable,\n    /// Compact format with minimal whitespace (single space between tokens)\n    Compact,\n    /// Minified format with no unnecessary whitespace\n    Minified,\n}\n\nimpl OptimizationLevel {\n    /// Resolve Auto to an actual optimization level based on build profile\n    #[cfg(debug_assertions)]\n    pub fn resolved(self) -\u003e Self {\n        match self {\n            OptimizationLevel::Auto =\u003e OptimizationLevel::O1,\n            other =\u003e other,\n        }\n    }\n\n    #[cfg(not(debug_assertions))]\n    pub fn resolved(self) -\u003e Self {\n        match self {\n            OptimizationLevel::Auto =\u003e OptimizationLevel::O2,\n            other =\u003e other,\n        }\n    }\n\n    /// Get the effective optimization level for this configuration\n    pub fn effective(\u0026self) -\u003e OptimizationLevel {\n        self.resolved()\n    }\n}\n\n/// Compiler options that control type checking and code generation\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CompilerOptions {\n    /// Enable strict null checking (default: true)\n    #[serde(default = \"default_true\")]\n    pub strict_null_checks: bool,\n\n    /// Naming convention enforcement (default: error)\n    #[serde(default)]\n    pub strict_naming: StrictLevel,\n\n    /// Disallow implicit unknown types (default: false)\n    #[serde(default)]\n    pub no_implicit_unknown: bool,\n\n    /// Disallow explicit unknown types (default: false)\n    #[serde(default)]\n    pub no_explicit_unknown: bool,\n\n    /// Target Lua version (default: 5.4)\n    #[serde(default)]\n    pub target: LuaVersion,\n\n    /// Enable decorator syntax (default: true)\n    #[serde(default = \"default_true\")]\n    pub enable_decorators: bool,\n\n    /// Allow importing non-typed Lua files (default: true)\n    #[serde(default = \"default_true\")]\n    pub allow_non_typed_lua: bool,\n\n    /// Copy plain .lua files to output directory during compilation (default: false)\n    #[serde(default)]\n    pub copy_lua_to_output: bool,\n\n    /// Output directory for compiled files\n    #[serde(default)]\n    pub out_dir: Option\u003cString\u003e,\n\n    /// Output file (bundle all into one file)\n    #[serde(default)]\n    pub out_file: Option\u003cString\u003e,\n\n    /// Generate source maps (default: false)\n    #[serde(default)]\n    pub source_map: bool,\n\n    /// Don't emit output files (type check only, default: false)\n    #[serde(default)]\n    pub no_emit: bool,\n\n    /// Pretty-print diagnostics (default: true)\n    #[serde(default = \"default_true\")]\n    pub pretty: bool,\n\n    /// Module code generation mode (default: require)\n    #[serde(default)]\n    pub module_mode: ModuleMode,\n\n    /// Module search paths for package imports\n    #[serde(default = \"default_module_paths\")]\n    pub module_paths: Vec\u003cString\u003e,\n\n    /// Enforce that namespace declarations match file paths (default: false)\n    #[serde(default)]\n    pub enforce_namespace_path: bool,\n\n    /// Output format for generated Lua code (default: readable)\n    #[serde(default)]\n    pub output_format: OutputFormat,\n}\n\nfn default_true() -\u003e bool {\n    true\n}\n\nfn default_module_paths() -\u003e Vec\u003cString\u003e {\n    vec![\n        \"./?.tl\".to_string(),\n        \"./lua_modules/?.tl\".to_string(),\n        \"./lua_modules/?/init.tl\".to_string(),\n    ]\n}\n\nimpl Default for CompilerOptions {\n    fn default() -\u003e Self {\n        Self {\n            strict_null_checks: true,\n            strict_naming: StrictLevel::Error,\n            no_implicit_unknown: false,\n            no_explicit_unknown: false,\n            target: LuaVersion::Lua54,\n            enable_decorators: true,\n            allow_non_typed_lua: true,\n            copy_lua_to_output: false,\n            out_dir: None,\n            out_file: None,\n            source_map: false,\n            no_emit: false,\n            pretty: true,\n            module_mode: ModuleMode::Require,\n            module_paths: default_module_paths(),\n            enforce_namespace_path: false,\n            output_format: OutputFormat::Readable,\n        }\n    }\n}\n\n/// Main compiler configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CompilerConfig {\n    /// Compiler options\n    #[serde(default)]\n    pub compiler_options: CompilerOptions,\n\n    /// Files to include (glob patterns)\n    #[serde(default)]\n    pub include: Vec\u003cString\u003e,\n\n    /// Files to exclude (glob patterns)\n    #[serde(default = \"default_exclude\")]\n    pub exclude: Vec\u003cString\u003e,\n}\n\nfn default_exclude() -\u003e Vec\u003cString\u003e {\n    vec![\"**/node_modules/**\".to_string(), \"**/dist/**\".to_string()]\n}\n\nimpl Default for CompilerConfig {\n    fn default() -\u003e Self {\n        Self {\n            compiler_options: CompilerOptions::default(),\n            include: vec![\"**/*.tl\".to_string()],\n            exclude: default_exclude(),\n        }\n    }\n}\n\nimpl CompilerConfig {\n    /// Load configuration from a YAML file (tlconfig.yaml)\n    pub fn from_file(path: \u0026Path) -\u003e Result\u003cSelf, crate::cli::errors::CompilationError\u003e {\n        let content = std::fs::read_to_string(path)?;\n        let config: CompilerConfig = serde_yaml::from_str(\u0026content)\n            .map_err(|e| crate::cli::errors::CompilationError::ConfigError(e.to_string()))?;\n        Ok(config)\n    }\n\n    /// Create a default configuration and write it to tlconfig.yaml\n    pub fn init_file(path: \u0026Path) -\u003e Result\u003c(), crate::cli::errors::CompilationError\u003e {\n        let config = CompilerConfig::default();\n        let yaml = serde_yaml::to_string(\u0026config)\n            .map_err(|e| crate::cli::errors::CompilationError::ConfigError(e.to_string()))?;\n        std::fs::write(path, yaml)?;\n        Ok(())\n    }\n\n    /// Merge this configuration with CLI overrides\n    /// Only non-None/non-default CLI values override file config\n    pub fn merge(\u0026mut self, overrides: \u0026CliOverrides) {\n        // Merge compiler options\n        if let Some(strict_null_checks) = overrides.strict_null_checks {\n            self.compiler_options.strict_null_checks = strict_null_checks;\n        }\n        if let Some(strict_naming) = overrides.strict_naming {\n            self.compiler_options.strict_naming = strict_naming;\n        }\n        if let Some(no_implicit_unknown) = overrides.no_implicit_unknown {\n            self.compiler_options.no_implicit_unknown = no_implicit_unknown;\n        }\n        if let Some(no_explicit_unknown) = overrides.no_explicit_unknown {\n            self.compiler_options.no_explicit_unknown = no_explicit_unknown;\n        }\n        if let Some(target) = overrides.target {\n            self.compiler_options.target = target;\n        }\n        if let Some(enable_decorators) = overrides.enable_decorators {\n            self.compiler_options.enable_decorators = enable_decorators;\n        }\n        if let Some(allow_non_typed_lua) = overrides.allow_non_typed_lua {\n            self.compiler_options.allow_non_typed_lua = allow_non_typed_lua;\n        }\n        if let Some(copy_lua_to_output) = overrides.copy_lua_to_output {\n            self.compiler_options.copy_lua_to_output = copy_lua_to_output;\n        }\n        if let Some(ref out_dir) = overrides.out_dir {\n            self.compiler_options.out_dir = Some(out_dir.clone());\n        }\n        if let Some(ref out_file) = overrides.out_file {\n            self.compiler_options.out_file = Some(out_file.clone());\n        }\n        if let Some(source_map) = overrides.source_map {\n            self.compiler_options.source_map = source_map;\n        }\n        if let Some(no_emit) = overrides.no_emit {\n            self.compiler_options.no_emit = no_emit;\n        }\n        if let Some(pretty) = overrides.pretty {\n            self.compiler_options.pretty = pretty;\n        }\n        if let Some(module_mode) = overrides.module_mode {\n            self.compiler_options.module_mode = module_mode;\n        }\n        if let Some(ref module_paths) = overrides.module_paths {\n            self.compiler_options.module_paths = module_paths.clone();\n        }\n        if let Some(enforce_namespace_path) = overrides.enforce_namespace_path {\n            self.compiler_options.enforce_namespace_path = enforce_namespace_path;\n        }\n        if let Some(output_format) = overrides.output_format {\n            self.compiler_options.output_format = output_format;\n        }\n    }\n}\n\n/// CLI overrides for configuration\n/// All fields are optional - only specified flags override file config\n#[derive(Debug, Default, Clone)]\npub struct CliOverrides {\n    pub strict_null_checks: Option\u003cbool\u003e,\n    pub strict_naming: Option\u003cStrictLevel\u003e,\n    pub no_implicit_unknown: Option\u003cbool\u003e,\n    pub no_explicit_unknown: Option\u003cbool\u003e,\n    pub target: Option\u003cLuaVersion\u003e,\n    pub enable_decorators: Option\u003cbool\u003e,\n    pub allow_non_typed_lua: Option\u003cbool\u003e,\n    pub copy_lua_to_output: Option\u003cbool\u003e,\n    pub out_dir: Option\u003cString\u003e,\n    pub out_file: Option\u003cString\u003e,\n    pub source_map: Option\u003cbool\u003e,\n    pub no_emit: Option\u003cbool\u003e,\n    pub pretty: Option\u003cbool\u003e,\n    pub module_mode: Option\u003cModuleMode\u003e,\n    pub module_paths: Option\u003cVec\u003cString\u003e\u003e,\n    pub enforce_namespace_path: Option\u003cbool\u003e,\n    pub output_format: Option\u003cOutputFormat\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = CompilerConfig::default();\n        assert!(config.compiler_options.strict_null_checks);\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua54);\n    }\n\n    #[test]\n    fn test_serialize_config() {\n        let config = CompilerConfig::default();\n        let yaml = serde_yaml::to_string(\u0026config).unwrap();\n        assert!(yaml.contains(\"compilerOptions\"));\n    }\n\n    #[test]\n    fn test_deserialize_config() {\n        let yaml = r#\"\ncompilerOptions:\n  target: \"5.3\"\n  enableDecorators: false\n\"#;\n        let config: CompilerConfig = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua53);\n        assert!(!config.compiler_options.enable_decorators);\n    }\n\n    #[test]\n    fn test_config_merge_overrides_file() {\n        let mut config = CompilerConfig::default();\n        // Default has Lua54 and strict_null_checks = true\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua54);\n        assert!(config.compiler_options.strict_null_checks);\n\n        // CLI overrides both\n        let overrides = CliOverrides {\n            target: Some(LuaVersion::Lua51),\n            strict_null_checks: Some(false),\n            ..Default::default()\n        };\n\n        config.merge(\u0026overrides);\n\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua51);\n        assert!(!config.compiler_options.strict_null_checks);\n    }\n\n    #[test]\n    fn test_config_merge_partial_overrides() {\n        let mut config = CompilerConfig::default();\n        assert!(config.compiler_options.strict_null_checks);\n        assert!(config.compiler_options.enable_decorators);\n\n        // Only override one field\n        let overrides = CliOverrides {\n            enable_decorators: Some(false),\n            ..Default::default()\n        };\n\n        config.merge(\u0026overrides);\n\n        // This field was overridden\n        assert!(!config.compiler_options.enable_decorators);\n        // This field remains from file/default\n        assert!(config.compiler_options.strict_null_checks);\n    }\n\n    #[test]\n    fn test_config_merge_empty_overrides() {\n        let mut config = CompilerConfig::default();\n        let original_target = config.compiler_options.target;\n        let original_decorators = config.compiler_options.enable_decorators;\n\n        // Empty overrides shouldn't change anything\n        let overrides = CliOverrides::default();\n        config.merge(\u0026overrides);\n\n        assert_eq!(config.compiler_options.target, original_target);\n        assert_eq!(\n            config.compiler_options.enable_decorators,\n            original_decorators\n        );\n    }\n\n    #[test]\n    fn test_config_merge_output_options() {\n        let mut config = CompilerConfig::default();\n        assert!(config.compiler_options.out_dir.is_none());\n        assert!(config.compiler_options.out_file.is_none());\n\n        let overrides = CliOverrides {\n            out_dir: Some(\"dist\".to_string()),\n            source_map: Some(true),\n            ..Default::default()\n        };\n\n        config.merge(\u0026overrides);\n\n        assert_eq!(config.compiler_options.out_dir, Some(\"dist\".to_string()));\n        assert!(config.compiler_options.source_map);\n        assert!(config.compiler_options.out_file.is_none()); // Not overridden\n    }\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":296}},{"line":173,"address":[],"length":0,"stats":{"Line":296}},{"line":174,"address":[],"length":0,"stats":{"Line":592}},{"line":175,"address":[],"length":0,"stats":{"Line":592}},{"line":176,"address":[],"length":0,"stats":{"Line":592}},{"line":181,"address":[],"length":0,"stats":{"Line":295}},{"line":197,"address":[],"length":0,"stats":{"Line":295}},{"line":221,"address":[],"length":0,"stats":{"Line":7}},{"line":222,"address":[],"length":0,"stats":{"Line":35}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":18}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":6}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":6}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":4}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":4}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":0}}],"covered":38,"coverable":67},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","diagnostics.rs"],"content":"use std::sync::Mutex;\nuse typedlua_parser::span::Span;\n\n// Bridge implementation for parser crate compatibility\n// This allows core's diagnostic handlers to be used with the parser crate's Lexer and Parser\n\n/// Diagnostic severity level\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DiagnosticLevel {\n    Error,\n    Warning,\n    Info,\n}\n\n/// Diagnostic code for categorization and documentation\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct DiagnosticCode {\n    /// Numeric code (e.g., 1001, 2004)\n    pub code: u16,\n    /// Category prefix (e.g., \"E\" for error, \"W\" for warning)\n    pub prefix: char,\n}\n\nimpl DiagnosticCode {\n    pub const fn new(prefix: char, code: u16) -\u003e Self {\n        Self { code, prefix }\n    }\n\n    /// Format as string (e.g., \"E1001\", \"W2004\")\n    pub fn as_str(\u0026self) -\u003e String {\n        format!(\"{}{:04}\", self.prefix, self.code)\n    }\n}\n\n/// Related information for a diagnostic (additional context from other locations)\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DiagnosticRelatedInformation {\n    pub span: Span,\n    pub message: String,\n}\n\n/// Suggested fix for a diagnostic\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DiagnosticSuggestion {\n    pub span: Span,\n    pub replacement: String,\n    pub message: String,\n}\n\n/// A diagnostic message with location, severity, and optional metadata\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Diagnostic {\n    pub level: DiagnosticLevel,\n    pub span: Span,\n    pub message: String,\n    pub code: Option\u003cDiagnosticCode\u003e,\n    pub related_information: Vec\u003cDiagnosticRelatedInformation\u003e,\n    pub suggestions: Vec\u003cDiagnosticSuggestion\u003e,\n}\n\nimpl Diagnostic {\n    pub fn error(span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Error,\n            span,\n            message: message.into(),\n            code: None,\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    pub fn warning(span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Warning,\n            span,\n            message: message.into(),\n            code: None,\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    pub fn info(span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Info,\n            span,\n            message: message.into(),\n            code: None,\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    /// Create an error with a diagnostic code\n    pub fn error_with_code(span: Span, code: DiagnosticCode, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Error,\n            span,\n            message: message.into(),\n            code: Some(code),\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    /// Add related information to this diagnostic\n    pub fn with_related(mut self, span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        self.related_information.push(DiagnosticRelatedInformation {\n            span,\n            message: message.into(),\n        });\n        self\n    }\n\n    /// Add a suggestion to this diagnostic\n    pub fn with_suggestion(\n        mut self,\n        span: Span,\n        replacement: String,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        self.suggestions.push(DiagnosticSuggestion {\n            span,\n            replacement,\n            message: message.into(),\n        });\n        self\n    }\n\n    /// Set the diagnostic code\n    pub fn with_code(mut self, code: DiagnosticCode) -\u003e Self {\n        self.code = Some(code);\n        self\n    }\n}\n\n/// Trait for handling diagnostics\n/// This allows for dependency injection and testing with mock handlers\npub trait DiagnosticHandler: Send + Sync {\n    fn report(\u0026self, diagnostic: Diagnostic);\n\n    fn error(\u0026self, span: Span, message: \u0026str) {\n        self.report(Diagnostic::error(span, message.to_string()));\n    }\n\n    fn warning(\u0026self, span: Span, message: \u0026str) {\n        self.report(Diagnostic::warning(span, message.to_string()));\n    }\n\n    fn info(\u0026self, span: Span, message: \u0026str) {\n        self.report(Diagnostic::info(span, message.to_string()));\n    }\n\n    fn has_errors(\u0026self) -\u003e bool;\n    fn error_count(\u0026self) -\u003e usize;\n    fn warning_count(\u0026self) -\u003e usize;\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003cDiagnostic\u003e;\n}\n\n/// Console-based diagnostic handler that prints to stderr\npub struct ConsoleDiagnosticHandler {\n    diagnostics: Mutex\u003cVec\u003cDiagnostic\u003e\u003e,\n    pretty: bool,\n}\n\nimpl ConsoleDiagnosticHandler {\n    pub fn new(pretty: bool) -\u003e Self {\n        Self {\n            diagnostics: Mutex::new(Vec::new()),\n            pretty,\n        }\n    }\n}\n\nimpl DiagnosticHandler for ConsoleDiagnosticHandler {\n    fn report(\u0026self, diagnostic: Diagnostic) {\n        let level_str = match diagnostic.level {\n            DiagnosticLevel::Error =\u003e \"error\",\n            DiagnosticLevel::Warning =\u003e \"warning\",\n            DiagnosticLevel::Info =\u003e \"info\",\n        };\n\n        if self.pretty {\n            let code_str = if let Some(code) = \u0026diagnostic.code {\n                format!(\"[{}] \", code.as_str())\n            } else {\n                String::new()\n            };\n            eprintln!(\n                \"\\x1b[1m{}\\x1b[0m {}at {}: {}\",\n                level_str, code_str, diagnostic.span, diagnostic.message\n            );\n\n            // Print related information\n            for related in \u0026diagnostic.related_information {\n                eprintln!(\n                    \"  \\x1b[36mNote\\x1b[0m at {}: {}\",\n                    related.span, related.message\n                );\n            }\n\n            // Print suggestions\n            for suggestion in \u0026diagnostic.suggestions {\n                eprintln!(\"  \\x1b[32mSuggestion\\x1b[0m: {}\", suggestion.message);\n            }\n        } else {\n            let code_str = if let Some(code) = \u0026diagnostic.code {\n                format!(\"[{}] \", code.as_str())\n            } else {\n                String::new()\n            };\n            eprintln!(\n                \"{} {}at {}: {}\",\n                level_str, code_str, diagnostic.span, diagnostic.message\n            );\n\n            // Print related information\n            for related in \u0026diagnostic.related_information {\n                eprintln!(\"  Note at {}: {}\", related.span, related.message);\n            }\n\n            // Print suggestions\n            for suggestion in \u0026diagnostic.suggestions {\n                eprintln!(\"  Suggestion: {}\", suggestion.message);\n            }\n        }\n\n        self.diagnostics.lock().unwrap().push(diagnostic);\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .any(|d| d.level == DiagnosticLevel::Error)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Error)\n            .count()\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Warning)\n            .count()\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003cDiagnostic\u003e {\n        self.diagnostics.lock().unwrap().clone()\n    }\n}\n\n/// Error codes for TypedLua diagnostics\n///\n/// Error codes are organized by component:\n/// - E1000-E1999: Lexer errors\n/// - E2000-E2999: Parser errors\n/// - E3000-E3999: Type checker errors\n/// - E4000-E4999: Code generator errors\n/// - E5000-E5999: Configuration errors\n/// - W1000-W9999: Warnings\npub mod error_codes {\n    use super::DiagnosticCode;\n\n    // ========================================\n    // Lexer Errors (E1000-E1999)\n    // ========================================\n\n    /// Unterminated string literal\n    pub const UNTERMINATED_STRING: DiagnosticCode = DiagnosticCode::new('E', 1001);\n\n    /// Unterminated multi-line comment\n    pub const UNTERMINATED_COMMENT: DiagnosticCode = DiagnosticCode::new('E', 1002);\n\n    /// Invalid number literal format\n    pub const INVALID_NUMBER: DiagnosticCode = DiagnosticCode::new('E', 1003);\n\n    /// Unexpected character\n    pub const UNEXPECTED_CHAR: DiagnosticCode = DiagnosticCode::new('E', 1004);\n\n    /// Invalid escape sequence in string\n    pub const INVALID_ESCAPE: DiagnosticCode = DiagnosticCode::new('E', 1005);\n\n    /// Unterminated template literal\n    pub const UNTERMINATED_TEMPLATE: DiagnosticCode = DiagnosticCode::new('E', 1006);\n\n    /// Invalid hexadecimal number\n    pub const INVALID_HEX_NUMBER: DiagnosticCode = DiagnosticCode::new('E', 1007);\n\n    /// Invalid binary number\n    pub const INVALID_BINARY_NUMBER: DiagnosticCode = DiagnosticCode::new('E', 1008);\n\n    // ========================================\n    // Parser Errors (E2000-E2999)\n    // ========================================\n\n    /// Expected a specific token but found something else\n    pub const EXPECTED_TOKEN: DiagnosticCode = DiagnosticCode::new('E', 2001);\n\n    /// Unexpected token encountered\n    pub const UNEXPECTED_TOKEN: DiagnosticCode = DiagnosticCode::new('E', 2002);\n\n    /// Expected an identifier\n    pub const EXPECTED_IDENTIFIER: DiagnosticCode = DiagnosticCode::new('E', 2003);\n\n    /// Expected an expression\n    pub const EXPECTED_EXPRESSION: DiagnosticCode = DiagnosticCode::new('E', 2004);\n\n    /// Expected a type annotation\n    pub const EXPECTED_TYPE: DiagnosticCode = DiagnosticCode::new('E', 2005);\n\n    /// Expected a pattern\n    pub const EXPECTED_PATTERN: DiagnosticCode = DiagnosticCode::new('E', 2006);\n\n    /// Missing semicolon or statement terminator\n    pub const MISSING_SEMICOLON: DiagnosticCode = DiagnosticCode::new('E', 2007);\n\n    /// Missing 'end' keyword\n    pub const MISSING_END: DiagnosticCode = DiagnosticCode::new('E', 2008);\n\n    /// Missing 'then' keyword after if condition\n    pub const MISSING_THEN: DiagnosticCode = DiagnosticCode::new('E', 2009);\n\n    /// Missing 'do' keyword\n    pub const MISSING_DO: DiagnosticCode = DiagnosticCode::new('E', 2010);\n\n    /// Invalid function parameter\n    pub const INVALID_PARAMETER: DiagnosticCode = DiagnosticCode::new('E', 2011);\n\n    /// Invalid destructuring pattern\n    pub const INVALID_DESTRUCTURING: DiagnosticCode = DiagnosticCode::new('E', 2012);\n\n    /// Break statement outside of loop\n    pub const BREAK_OUTSIDE_LOOP: DiagnosticCode = DiagnosticCode::new('E', 2013);\n\n    /// Continue statement outside of loop\n    pub const CONTINUE_OUTSIDE_LOOP: DiagnosticCode = DiagnosticCode::new('E', 2014);\n\n    /// Invalid assignment target\n    pub const INVALID_ASSIGNMENT: DiagnosticCode = DiagnosticCode::new('E', 2015);\n\n    /// Expected '\u003e\u003e' but found end of tokens (generic type parsing)\n    pub const EXPECTED_DOUBLE_GT: DiagnosticCode = DiagnosticCode::new('E', 2016);\n\n    /// Classes disabled in configuration\n    pub const CLASSES_DISABLED: DiagnosticCode = DiagnosticCode::new('E', 2020);\n\n    /// Decorators disabled in configuration\n    pub const DECORATORS_DISABLED: DiagnosticCode = DiagnosticCode::new('E', 2021);\n\n    /// Functional programming features disabled\n    pub const FP_DISABLED: DiagnosticCode = DiagnosticCode::new('E', 2022);\n\n    // ========================================\n    // Type Checker Errors (E3000-E3999)\n    // ========================================\n\n    /// Type mismatch between expected and actual types\n    pub const TYPE_MISMATCH: DiagnosticCode = DiagnosticCode::new('E', 3001);\n\n    /// Undefined variable or identifier\n    pub const UNDEFINED_VARIABLE: DiagnosticCode = DiagnosticCode::new('E', 3002);\n\n    /// Duplicate declaration\n    pub const DUPLICATE_DECLARATION: DiagnosticCode = DiagnosticCode::new('E', 3003);\n\n    /// Cannot assign to constant\n    pub const ASSIGN_TO_CONST: DiagnosticCode = DiagnosticCode::new('E', 3004);\n\n    /// Type not found\n    pub const TYPE_NOT_FOUND: DiagnosticCode = DiagnosticCode::new('E', 3005);\n\n    /// Property not found on type\n    pub const PROPERTY_NOT_FOUND: DiagnosticCode = DiagnosticCode::new('E', 3006);\n\n    /// Wrong number of arguments in function call\n    pub const WRONG_ARG_COUNT: DiagnosticCode = DiagnosticCode::new('E', 3007);\n\n    /// Cannot call non-function type\n    pub const NOT_CALLABLE: DiagnosticCode = DiagnosticCode::new('E', 3008);\n\n    /// Cannot index non-indexable type\n    pub const NOT_INDEXABLE: DiagnosticCode = DiagnosticCode::new('E', 3009);\n\n    /// Missing return statement\n    pub const MISSING_RETURN: DiagnosticCode = DiagnosticCode::new('E', 3010);\n\n    /// Circular type reference\n    pub const CIRCULAR_TYPE: DiagnosticCode = DiagnosticCode::new('E', 3011);\n\n    /// Interface not found\n    pub const INTERFACE_NOT_FOUND: DiagnosticCode = DiagnosticCode::new('E', 3012);\n\n    /// Class does not implement interface\n    pub const INTERFACE_NOT_IMPLEMENTED: DiagnosticCode = DiagnosticCode::new('E', 3013);\n\n    /// Abstract method has implementation\n    pub const ABSTRACT_METHOD_BODY: DiagnosticCode = DiagnosticCode::new('E', 3014);\n\n    /// Non-abstract class has abstract methods\n    pub const ABSTRACT_METHODS_IN_CONCRETE_CLASS: DiagnosticCode = DiagnosticCode::new('E', 3015);\n\n    /// Multiple constructors in class\n    pub const MULTIPLE_CONSTRUCTORS: DiagnosticCode = DiagnosticCode::new('E', 3016);\n\n    /// Generic type parameter constraint not satisfied\n    pub const CONSTRAINT_NOT_SATISFIED: DiagnosticCode = DiagnosticCode::new('E', 3017);\n\n    /// Wrong number of type arguments\n    pub const WRONG_TYPE_ARG_COUNT: DiagnosticCode = DiagnosticCode::new('E', 3018);\n\n    /// Cannot infer type\n    pub const CANNOT_INFER_TYPE: DiagnosticCode = DiagnosticCode::new('E', 3019);\n\n    /// Pattern match not exhaustive\n    pub const NON_EXHAUSTIVE_MATCH: DiagnosticCode = DiagnosticCode::new('E', 3020);\n\n    /// Invalid type in pattern match\n    pub const INVALID_MATCH_TYPE: DiagnosticCode = DiagnosticCode::new('E', 3021);\n\n    /// Getter and setter type mismatch\n    pub const GETTER_SETTER_MISMATCH: DiagnosticCode = DiagnosticCode::new('E', 3022);\n\n    /// Property marked readonly\n    pub const READONLY_PROPERTY: DiagnosticCode = DiagnosticCode::new('E', 3023);\n\n    /// Access to private member\n    pub const PRIVATE_ACCESS: DiagnosticCode = DiagnosticCode::new('E', 3024);\n\n    /// Access to protected member\n    pub const PROTECTED_ACCESS: DiagnosticCode = DiagnosticCode::new('E', 3025);\n\n    /// Or-pattern alternatives bind different variables\n    pub const INCONSISTENT_OR_PATTERN_BINDINGS: DiagnosticCode = DiagnosticCode::new('E', 3026);\n\n    /// Or-pattern alternatives bind variables with incompatible types\n    pub const INCOMPATIBLE_OR_PATTERN_TYPES: DiagnosticCode = DiagnosticCode::new('E', 3027);\n\n    /// Or-pattern has no alternatives\n    pub const EMPTY_OR_PATTERN: DiagnosticCode = DiagnosticCode::new('E', 3028);\n\n    // ========================================\n    // Code Generator Errors (E4000-E4999)\n    // ========================================\n\n    /// Unsupported feature for target Lua version\n    pub const UNSUPPORTED_FEATURE: DiagnosticCode = DiagnosticCode::new('E', 4001);\n\n    /// Source map generation failed\n    pub const SOURCE_MAP_ERROR: DiagnosticCode = DiagnosticCode::new('E', 4002);\n\n    // ========================================\n    // Configuration Errors (E5000-E5999)\n    // ========================================\n\n    /// Invalid configuration file\n    pub const INVALID_CONFIG: DiagnosticCode = DiagnosticCode::new('E', 5001);\n\n    /// Missing configuration file\n    pub const MISSING_CONFIG: DiagnosticCode = DiagnosticCode::new('E', 5002);\n\n    /// Invalid Lua target version\n    pub const INVALID_TARGET: DiagnosticCode = DiagnosticCode::new('E', 5003);\n\n    // ========================================\n    // Warnings (W1000-W9999)\n    // ========================================\n\n    /// Unused variable\n    pub const UNUSED_VARIABLE: DiagnosticCode = DiagnosticCode::new('W', 1001);\n\n    /// Unused import\n    pub const UNUSED_IMPORT: DiagnosticCode = DiagnosticCode::new('W', 1002);\n\n    /// Deprecated feature\n    pub const DEPRECATED: DiagnosticCode = DiagnosticCode::new('W', 1003);\n\n    /// Unreachable code\n    pub const UNREACHABLE_CODE: DiagnosticCode = DiagnosticCode::new('W', 1004);\n\n    /// Implicit any type\n    pub const IMPLICIT_ANY: DiagnosticCode = DiagnosticCode::new('W', 1005);\n\n    /// Possible nil value\n    pub const POSSIBLE_NIL: DiagnosticCode = DiagnosticCode::new('W', 1006);\n\n    /// Shadowed variable\n    pub const SHADOWED_VARIABLE: DiagnosticCode = DiagnosticCode::new('W', 1007);\n\n    /// Empty block\n    pub const EMPTY_BLOCK: DiagnosticCode = DiagnosticCode::new('W', 1008);\n\n    /// Type could be narrower\n    pub const TYPE_TOO_WIDE: DiagnosticCode = DiagnosticCode::new('W', 1009);\n\n    /// Pattern is unreachable\n    pub const UNREACHABLE_PATTERN: DiagnosticCode = DiagnosticCode::new('W', 1010);\n}\n\n/// Collecting diagnostic handler for testing\n/// Collects all diagnostics without printing\npub struct CollectingDiagnosticHandler {\n    diagnostics: Mutex\u003cVec\u003cDiagnostic\u003e\u003e,\n}\n\nimpl CollectingDiagnosticHandler {\n    pub fn new() -\u003e Self {\n        Self {\n            diagnostics: Mutex::new(Vec::new()),\n        }\n    }\n}\n\nimpl Default for CollectingDiagnosticHandler {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl DiagnosticHandler for CollectingDiagnosticHandler {\n    fn report(\u0026self, diagnostic: Diagnostic) {\n        self.diagnostics.lock().unwrap().push(diagnostic);\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .any(|d| d.level == DiagnosticLevel::Error)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Error)\n            .count()\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Warning)\n            .count()\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003cDiagnostic\u003e {\n        self.diagnostics.lock().unwrap().clone()\n    }\n}\n\n// Bridge implementations for parser crate compatibility\n// These allow the core's diagnostic handlers to work with typedlua_parser's Lexer and Parser\n\n/// Convert a parser diagnostic to a core diagnostic\nfn convert_parser_diagnostic(diag: typedlua_parser::Diagnostic) -\u003e Diagnostic {\n    let level = match diag.level {\n        typedlua_parser::diagnostics::DiagnosticLevel::Error =\u003e DiagnosticLevel::Error,\n        typedlua_parser::diagnostics::DiagnosticLevel::Warning =\u003e DiagnosticLevel::Warning,\n        typedlua_parser::diagnostics::DiagnosticLevel::Info =\u003e DiagnosticLevel::Info,\n    };\n\n    let code = diag.code.map(|c| DiagnosticCode::new(c.prefix, c.code));\n\n    let related_information = diag\n        .related_information\n        .into_iter()\n        .map(|r| DiagnosticRelatedInformation {\n            span: r.span,\n            message: r.message,\n        })\n        .collect();\n\n    let suggestions = diag\n        .suggestions\n        .into_iter()\n        .map(|s| DiagnosticSuggestion {\n            span: s.span,\n            replacement: s.replacement,\n            message: s.message,\n        })\n        .collect();\n\n    Diagnostic {\n        level,\n        span: diag.span,\n        message: diag.message,\n        code,\n        related_information,\n        suggestions,\n    }\n}\n\nimpl typedlua_parser::DiagnosticHandler for ConsoleDiagnosticHandler {\n    fn report(\u0026self, diagnostic: typedlua_parser::Diagnostic) {\n        DiagnosticHandler::report(self, convert_parser_diagnostic(diagnostic));\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        DiagnosticHandler::has_errors(self)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::error_count(self)\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::warning_count(self)\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003ctypedlua_parser::Diagnostic\u003e {\n        // Convert core diagnostics back to parser diagnostics\n        DiagnosticHandler::get_diagnostics(self)\n            .into_iter()\n            .map(|d| {\n                let level = match d.level {\n                    DiagnosticLevel::Error =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Error,\n                    DiagnosticLevel::Warning =\u003e {\n                        typedlua_parser::diagnostics::DiagnosticLevel::Warning\n                    }\n                    DiagnosticLevel::Info =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Info,\n                };\n                let code = d\n                    .code\n                    .map(|c| typedlua_parser::diagnostics::DiagnosticCode::new(c.prefix, c.code));\n                typedlua_parser::Diagnostic {\n                    level,\n                    span: d.span,\n                    message: d.message,\n                    code,\n                    related_information: d\n                        .related_information\n                        .into_iter()\n                        .map(\n                            |r| typedlua_parser::diagnostics::DiagnosticRelatedInformation {\n                                span: r.span,\n                                message: r.message,\n                            },\n                        )\n                        .collect(),\n                    suggestions: d\n                        .suggestions\n                        .into_iter()\n                        .map(|s| typedlua_parser::diagnostics::DiagnosticSuggestion {\n                            span: s.span,\n                            replacement: s.replacement,\n                            message: s.message,\n                        })\n                        .collect(),\n                }\n            })\n            .collect()\n    }\n}\n\nimpl typedlua_parser::DiagnosticHandler for CollectingDiagnosticHandler {\n    fn report(\u0026self, diagnostic: typedlua_parser::Diagnostic) {\n        DiagnosticHandler::report(self, convert_parser_diagnostic(diagnostic));\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        DiagnosticHandler::has_errors(self)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::error_count(self)\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::warning_count(self)\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003ctypedlua_parser::Diagnostic\u003e {\n        DiagnosticHandler::get_diagnostics(self)\n            .into_iter()\n            .map(|d| {\n                let level = match d.level {\n                    DiagnosticLevel::Error =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Error,\n                    DiagnosticLevel::Warning =\u003e {\n                        typedlua_parser::diagnostics::DiagnosticLevel::Warning\n                    }\n                    DiagnosticLevel::Info =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Info,\n                };\n                let code = d\n                    .code\n                    .map(|c| typedlua_parser::diagnostics::DiagnosticCode::new(c.prefix, c.code));\n                typedlua_parser::Diagnostic {\n                    level,\n                    span: d.span,\n                    message: d.message,\n                    code,\n                    related_information: d\n                        .related_information\n                        .into_iter()\n                        .map(\n                            |r| typedlua_parser::diagnostics::DiagnosticRelatedInformation {\n                                span: r.span,\n                                message: r.message,\n                            },\n                        )\n                        .collect(),\n                    suggestions: d\n                        .suggestions\n                        .into_iter()\n                        .map(|s| typedlua_parser::diagnostics::DiagnosticSuggestion {\n                            span: s.span,\n                            replacement: s.replacement,\n                            message: s.message,\n                        })\n                        .collect(),\n                }\n            })\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_diagnostic_creation() {\n        let span = Span::new(0, 5, 1, 1);\n        let diag = Diagnostic::error(span, \"Test error\");\n\n        assert_eq!(diag.level, DiagnosticLevel::Error);\n        assert_eq!(diag.message, \"Test error\");\n        assert!(diag.code.is_none());\n        assert!(diag.related_information.is_empty());\n        assert!(diag.suggestions.is_empty());\n    }\n\n    #[test]\n    fn test_diagnostic_with_code() {\n        let span = Span::new(0, 5, 1, 1);\n        let code = DiagnosticCode::new('E', 1001);\n        let diag = Diagnostic::error_with_code(span, code, \"Syntax error\");\n\n        assert_eq!(diag.code, Some(code));\n        assert_eq!(code.as_str(), \"E1001\");\n    }\n\n    #[test]\n    fn test_diagnostic_with_related_info() {\n        let span = Span::new(0, 5, 1, 1);\n        let related_span = Span::new(10, 15, 2, 1);\n\n        let diag = Diagnostic::error(span, \"Duplicate declaration\")\n            .with_related(related_span, \"Previously declared here\");\n\n        assert_eq!(diag.related_information.len(), 1);\n        assert_eq!(diag.related_information[0].span, related_span);\n        assert_eq!(\n            diag.related_information[0].message,\n            \"Previously declared here\"\n        );\n    }\n\n    #[test]\n    fn test_diagnostic_with_suggestion() {\n        let span = Span::new(0, 5, 1, 1);\n\n        let diag = Diagnostic::error(span, \"Use 'const' instead\").with_suggestion(\n            span,\n            \"const\".to_string(),\n            \"Replace with 'const'\",\n        );\n\n        assert_eq!(diag.suggestions.len(), 1);\n        assert_eq!(diag.suggestions[0].replacement, \"const\");\n        assert_eq!(diag.suggestions[0].message, \"Replace with 'const'\");\n    }\n\n    #[test]\n    fn test_diagnostic_builder_chain() {\n        let span = Span::new(0, 5, 1, 1);\n        let related_span = Span::new(10, 15, 2, 1);\n        let code = DiagnosticCode::new('E', 2004);\n\n        let diag = Diagnostic::error(span, \"Type mismatch\")\n            .with_code(code)\n            .with_related(related_span, \"Expected type defined here\")\n            .with_suggestion(span, \"number\".to_string(), \"Use 'number' type\");\n\n        assert_eq!(diag.code, Some(code));\n        assert_eq!(diag.related_information.len(), 1);\n        assert_eq!(diag.suggestions.len(), 1);\n    }\n\n    #[test]\n    fn test_collecting_handler() {\n        let handler = CollectingDiagnosticHandler::new();\n        let span = Span::new(0, 5, 1, 1);\n\n        handler.error(span, \"Error 1\");\n        handler.warning(span, \"Warning 1\");\n        handler.error(span, \"Error 2\");\n\n        assert_eq!(handler.error_count(), 2);\n        assert_eq!(handler.warning_count(), 1);\n        assert!(handler.has_errors());\n        assert_eq!(handler.get_diagnostics().len(), 3);\n    }\n\n    #[test]\n    fn test_no_errors() {\n        let handler = CollectingDiagnosticHandler::new();\n        let span = Span::new(0, 5, 1, 1);\n\n        handler.warning(span, \"Warning 1\");\n        handler.info(span, \"Info 1\");\n\n        assert!(!handler.has_errors());\n        assert_eq!(handler.error_count(), 0);\n    }\n\n    #[test]\n    fn test_diagnostic_code_formatting() {\n        let code1 = DiagnosticCode::new('E', 1);\n        assert_eq!(code1.as_str(), \"E0001\");\n\n        let code2 = DiagnosticCode::new('W', 1234);\n        assert_eq!(code2.as_str(), \"W1234\");\n\n        let code3 = DiagnosticCode::new('I', 999);\n        assert_eq!(code3.as_str(), \"I0999\");\n    }\n\n    #[test]\n    fn test_error_code_constants() {\n        use super::error_codes::*;\n\n        // Test lexer error codes\n        assert_eq!(UNTERMINATED_STRING.as_str(), \"E1001\");\n        assert_eq!(UNTERMINATED_COMMENT.as_str(), \"E1002\");\n        assert_eq!(INVALID_NUMBER.as_str(), \"E1003\");\n        assert_eq!(UNEXPECTED_CHAR.as_str(), \"E1004\");\n\n        // Test parser error codes\n        assert_eq!(EXPECTED_TOKEN.as_str(), \"E2001\");\n        assert_eq!(UNEXPECTED_TOKEN.as_str(), \"E2002\");\n        assert_eq!(MISSING_END.as_str(), \"E2008\");\n        assert_eq!(CLASSES_DISABLED.as_str(), \"E2020\");\n\n        // Test type checker error codes\n        assert_eq!(TYPE_MISMATCH.as_str(), \"E3001\");\n        assert_eq!(UNDEFINED_VARIABLE.as_str(), \"E3002\");\n        assert_eq!(DUPLICATE_DECLARATION.as_str(), \"E3003\");\n\n        // Test code generator error codes\n        assert_eq!(UNSUPPORTED_FEATURE.as_str(), \"E4001\");\n\n        // Test configuration error codes\n        assert_eq!(INVALID_CONFIG.as_str(), \"E5001\");\n\n        // Test warning codes\n        assert_eq!(UNUSED_VARIABLE.as_str(), \"W1001\");\n        assert_eq!(DEPRECATED.as_str(), \"W1003\");\n    }\n\n    #[test]\n    fn test_error_codes_are_unique() {\n        use super::error_codes::*;\n        use std::collections::HashSet;\n\n        let mut codes = HashSet::new();\n\n        // Collect all error codes\n        let all_codes = vec![\n            // Lexer\n            UNTERMINATED_STRING,\n            UNTERMINATED_COMMENT,\n            INVALID_NUMBER,\n            UNEXPECTED_CHAR,\n            INVALID_ESCAPE,\n            UNTERMINATED_TEMPLATE,\n            INVALID_HEX_NUMBER,\n            INVALID_BINARY_NUMBER,\n            // Parser\n            EXPECTED_TOKEN,\n            UNEXPECTED_TOKEN,\n            EXPECTED_IDENTIFIER,\n            EXPECTED_EXPRESSION,\n            EXPECTED_TYPE,\n            EXPECTED_PATTERN,\n            MISSING_SEMICOLON,\n            MISSING_END,\n            MISSING_THEN,\n            MISSING_DO,\n            INVALID_PARAMETER,\n            INVALID_DESTRUCTURING,\n            BREAK_OUTSIDE_LOOP,\n            CONTINUE_OUTSIDE_LOOP,\n            INVALID_ASSIGNMENT,\n            EXPECTED_DOUBLE_GT,\n            CLASSES_DISABLED,\n            DECORATORS_DISABLED,\n            FP_DISABLED,\n            // Type checker\n            TYPE_MISMATCH,\n            UNDEFINED_VARIABLE,\n            DUPLICATE_DECLARATION,\n            ASSIGN_TO_CONST,\n            TYPE_NOT_FOUND,\n            PROPERTY_NOT_FOUND,\n            WRONG_ARG_COUNT,\n            NOT_CALLABLE,\n            NOT_INDEXABLE,\n            MISSING_RETURN,\n            CIRCULAR_TYPE,\n            INTERFACE_NOT_FOUND,\n            INTERFACE_NOT_IMPLEMENTED,\n            ABSTRACT_METHOD_BODY,\n            ABSTRACT_METHODS_IN_CONCRETE_CLASS,\n            MULTIPLE_CONSTRUCTORS,\n            CONSTRAINT_NOT_SATISFIED,\n            WRONG_TYPE_ARG_COUNT,\n            CANNOT_INFER_TYPE,\n            NON_EXHAUSTIVE_MATCH,\n            INVALID_MATCH_TYPE,\n            GETTER_SETTER_MISMATCH,\n            READONLY_PROPERTY,\n            PRIVATE_ACCESS,\n            PROTECTED_ACCESS,\n            INCONSISTENT_OR_PATTERN_BINDINGS,\n            INCOMPATIBLE_OR_PATTERN_TYPES,\n            EMPTY_OR_PATTERN,\n            // Code generator\n            UNSUPPORTED_FEATURE,\n            SOURCE_MAP_ERROR,\n            // Configuration\n            INVALID_CONFIG,\n            MISSING_CONFIG,\n            INVALID_TARGET,\n            // Warnings\n            UNUSED_VARIABLE,\n            UNUSED_IMPORT,\n            DEPRECATED,\n            UNREACHABLE_CODE,\n            IMPLICIT_ANY,\n            POSSIBLE_NIL,\n            SHADOWED_VARIABLE,\n            EMPTY_BLOCK,\n            TYPE_TOO_WIDE,\n            UNREACHABLE_PATTERN,\n        ];\n\n        // Check all codes are unique\n        for code in all_codes {\n            let key = (code.prefix, code.code);\n            assert!(codes.insert(key), \"Duplicate error code: {}\", code.as_str());\n        }\n    }\n\n    #[test]\n    fn test_error_with_code_and_suggestion() {\n        use super::error_codes::*;\n\n        let span = Span::new(0, 5, 1, 1);\n        let diag = Diagnostic::error_with_code(\n            span,\n            TYPE_MISMATCH,\n            \"Type 'string' is not assignable to type 'number'\",\n        )\n        .with_suggestion(\n            span,\n            \"tonumber(value)\".to_string(),\n            \"Convert to number using tonumber()\",\n        );\n\n        assert_eq!(diag.code, Some(TYPE_MISMATCH));\n        assert_eq!(diag.code.unwrap().as_str(), \"E3001\");\n        assert_eq!(diag.suggestions.len(), 1);\n        assert_eq!(diag.suggestions[0].replacement, \"tonumber(value)\");\n    }\n\n    #[test]\n    fn test_error_with_code_and_related() {\n        use super::error_codes::*;\n\n        let error_span = Span::new(10, 15, 2, 1);\n        let decl_span = Span::new(0, 5, 1, 1);\n\n        let diag = Diagnostic::error_with_code(\n            error_span,\n            DUPLICATE_DECLARATION,\n            \"Duplicate declaration of 'x'\",\n        )\n        .with_related(decl_span, \"Previously declared here\");\n\n        assert_eq!(diag.code, Some(DUPLICATE_DECLARATION));\n        assert_eq!(diag.code.unwrap().as_str(), \"E3003\");\n        assert_eq!(diag.related_information.len(), 1);\n        assert_eq!(\n            diag.related_information[0].message,\n            \"Previously declared here\"\n        );\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":71}},{"line":30,"address":[],"length":0,"stats":{"Line":21}},{"line":31,"address":[],"length":0,"stats":{"Line":42}},{"line":62,"address":[],"length":0,"stats":{"Line":31}},{"line":66,"address":[],"length":0,"stats":{"Line":93}},{"line":68,"address":[],"length":0,"stats":{"Line":31}},{"line":69,"address":[],"length":0,"stats":{"Line":31}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":9}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":9}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":27}},{"line":144,"address":[],"length":0,"stats":{"Line":162}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":36}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":6}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":369}},{"line":519,"address":[],"length":0,"stats":{"Line":369}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":100}},{"line":532,"address":[],"length":0,"stats":{"Line":300}},{"line":535,"address":[],"length":0,"stats":{"Line":2}},{"line":536,"address":[],"length":0,"stats":{"Line":4}},{"line":540,"address":[],"length":0,"stats":{"Line":8}},{"line":543,"address":[],"length":0,"stats":{"Line":2}},{"line":544,"address":[],"length":0,"stats":{"Line":4}},{"line":548,"address":[],"length":0,"stats":{"Line":12}},{"line":552,"address":[],"length":0,"stats":{"Line":1}},{"line":553,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":7}},{"line":561,"address":[],"length":0,"stats":{"Line":32}},{"line":562,"address":[],"length":0,"stats":{"Line":64}},{"line":570,"address":[],"length":0,"stats":{"Line":66}},{"line":571,"address":[],"length":0,"stats":{"Line":132}},{"line":572,"address":[],"length":0,"stats":{"Line":66}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":396}},{"line":579,"address":[],"length":0,"stats":{"Line":132}},{"line":580,"address":[],"length":0,"stats":{"Line":66}},{"line":582,"address":[],"length":0,"stats":{"Line":66}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":132}},{"line":589,"address":[],"length":0,"stats":{"Line":66}},{"line":591,"address":[],"length":0,"stats":{"Line":66}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":132}},{"line":601,"address":[],"length":0,"stats":{"Line":132}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":66}},{"line":672,"address":[],"length":0,"stats":{"Line":264}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}}],"covered":69,"coverable":190},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","errors.rs"],"content":"use thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum CompilationError {\n    #[error(\"I/O error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Lexical analysis failed with {0} errors\")]\n    LexicalErrors(usize),\n\n    #[error(\"Parsing failed with {0} errors\")]\n    ParseErrors(usize),\n\n    #[error(\"Type checking failed with {0} errors\")]\n    TypeErrors(usize),\n\n    #[error(\"Code generation failed: {0}\")]\n    CodeGenError(String),\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigError(String),\n}\n\n#[derive(Debug, Error)]\npub enum ResolutionError {\n    #[error(\"Module not found: {0}\")]\n    ModuleNotFound(String),\n\n    #[error(\"Circular dependency detected: {0}\")]\n    CircularDependency(String),\n\n    #[error(\"Non-typed Lua file without type definitions: {0}\")]\n    MissingTypeDefinitions(String),\n\n    #[error(\"Ambiguous module resolution: {0}\")]\n    AmbiguousResolution(String),\n}\n\n#[derive(Debug, Error)]\npub enum LexerError {\n    #[error(\"Unexpected character: {0}\")]\n    UnexpectedCharacter(char),\n\n    #[error(\"Unterminated string literal\")]\n    UnterminatedString,\n\n    #[error(\"Unterminated comment\")]\n    UnterminatedComment,\n\n    #[error(\"Invalid number literal: {0}\")]\n    InvalidNumber(String),\n\n    #[error(\"Invalid escape sequence: {0}\")]\n    InvalidEscape(String),\n}\n\n#[derive(Debug, Error)]\npub enum ParserError {\n    #[error(\"Unexpected token: expected {expected}, found {found}\")]\n    UnexpectedToken { expected: String, found: String },\n\n    #[error(\"Unexpected end of file\")]\n    UnexpectedEof,\n\n    #[error(\"Feature disabled: {0}\")]\n    DisabledFeature(String),\n\n    #[error(\"Invalid syntax: {0}\")]\n    InvalidSyntax(String),\n}\n\n#[derive(Debug, Error)]\npub enum TypeCheckError {\n    #[error(\"Type mismatch: expected {expected}, found {actual}\")]\n    TypeMismatch { expected: String, actual: String },\n\n    #[error(\"Undefined variable: {0}\")]\n    UndefinedVariable(String),\n\n    #[error(\"Undefined type: {0}\")]\n    UndefinedType(String),\n\n    #[error(\"Cannot reassign const variable: {0}\")]\n    ConstReassignment(String),\n\n    #[error(\"Duplicate declaration: {0}\")]\n    DuplicateDeclaration(String),\n\n    #[error(\"Invalid operation: {0}\")]\n    InvalidOperation(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","fs.rs"],"content":"use rustc_hash::FxHashMap;\nuse std::path::{Path, PathBuf};\n\n/// File system abstraction for dependency injection\npub trait FileSystem: Send + Sync {\n    fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, std::io::Error\u003e;\n    fn write_file(\u0026self, path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), std::io::Error\u003e;\n    fn exists(\u0026self, path: \u0026Path) -\u003e bool;\n    fn resolve_path(\u0026self, base: \u0026Path, relative: \u0026str) -\u003e PathBuf;\n}\n\n/// Real file system implementation\npub struct RealFileSystem;\n\nimpl RealFileSystem {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl Default for RealFileSystem {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl FileSystem for RealFileSystem {\n    fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, std::io::Error\u003e {\n        std::fs::read_to_string(path)\n    }\n\n    fn write_file(\u0026self, path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), std::io::Error\u003e {\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        std::fs::write(path, content)\n    }\n\n    fn exists(\u0026self, path: \u0026Path) -\u003e bool {\n        path.exists()\n    }\n\n    fn resolve_path(\u0026self, base: \u0026Path, relative: \u0026str) -\u003e PathBuf {\n        base.join(relative)\n    }\n}\n\n/// Mock file system for testing\npub struct MockFileSystem {\n    files: FxHashMap\u003cPathBuf, String\u003e,\n}\n\nimpl MockFileSystem {\n    pub fn new() -\u003e Self {\n        Self {\n            files: FxHashMap::default(),\n        }\n    }\n\n    pub fn add_file(\u0026mut self, path: impl Into\u003cPathBuf\u003e, content: impl Into\u003cString\u003e) {\n        self.files.insert(path.into(), content.into());\n    }\n}\n\nimpl Default for MockFileSystem {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl FileSystem for MockFileSystem {\n    fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, std::io::Error\u003e {\n        self.files.get(path).cloned().ok_or_else(|| {\n            std::io::Error::new(\n                std::io::ErrorKind::NotFound,\n                format!(\"File not found: {}\", path.display()),\n            )\n        })\n    }\n\n    fn write_file(\u0026self, _path: \u0026Path, _content: \u0026str) -\u003e Result\u003c(), std::io::Error\u003e {\n        // Mock implementation - could track writes if needed\n        Ok(())\n    }\n\n    fn exists(\u0026self, path: \u0026Path) -\u003e bool {\n        self.files.contains_key(path)\n    }\n\n    fn resolve_path(\u0026self, base: \u0026Path, relative: \u0026str) -\u003e PathBuf {\n        base.join(relative)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mock_fs_read() {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/test.txt\", \"Hello, world!\");\n\n        let content = fs.read_file(Path::new(\"/test.txt\")).unwrap();\n        assert_eq!(content, \"Hello, world!\");\n    }\n\n    #[test]\n    fn test_mock_fs_not_found() {\n        let fs = MockFileSystem::new();\n        let result = fs.read_file(Path::new(\"/nonexistent.txt\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mock_fs_exists() {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/test.txt\", \"content\");\n\n        assert!(fs.exists(Path::new(\"/test.txt\")));\n        assert!(!fs.exists(Path::new(\"/other.txt\")));\n    }\n\n    #[test]\n    fn test_resolve_path() {\n        let fs = RealFileSystem::new();\n        let resolved = fs.resolve_path(Path::new(\"/base\"), \"relative/path.txt\");\n        assert_eq!(resolved, PathBuf::from(\"/base/relative/path.txt\"));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":56,"address":[],"length":0,"stats":{"Line":10}},{"line":60,"address":[],"length":0,"stats":{"Line":34}},{"line":61,"address":[],"length":0,"stats":{"Line":204}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":11}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":23}},{"line":87,"address":[],"length":0,"stats":{"Line":69}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}}],"covered":15,"coverable":31},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","mod.rs"],"content":"pub mod config;\npub mod diagnostics;\npub mod errors;\npub mod fs;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","mod.rs"],"content":"pub mod type_checker;\npub mod type_compat;\npub mod type_environment;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","type_checker.rs"],"content":"use crate::cli::config::CompilerOptions;\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_compat::TypeCompatibility;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::helpers::{control_flow, type_utilities};\nuse crate::phases;\nuse crate::phases::declaration_checking_phase;\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::visitors::{\n    AccessControl, AccessControlVisitor, ClassContext, ClassMemberInfo, ClassMemberKind,\n    NarrowingVisitor, TypeInferenceVisitor, TypeInferrer, TypeNarrower,\n};\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse std::sync::Arc;\nuse tracing::{debug, error, info, instrument, span, Level};\nuse typedlua_parser::ast::expression::*;\nuse typedlua_parser::ast::pattern::Pattern;\nuse typedlua_parser::ast::statement::*;\nuse typedlua_parser::ast::types::*;\nuse typedlua_parser::ast::Program;\nuse typedlua_parser::span::Span;\n\n/// Type checker for TypedLua programs\npub struct TypeChecker\u003c'a\u003e {\n    symbol_table: SymbolTable,\n    type_env: TypeEnvironment,\n    current_function_return_type: Option\u003cType\u003e,\n    // Visitor pattern integration - Phase 6\n    narrowing: TypeNarrower,\n    access_control: AccessControl,\n    // Note: TypeInferrer is created on-demand in infer_expression_type due to borrowing requirements\n    options: CompilerOptions,\n    /// Module registry for multi-module compilation\n    module_registry: Option\u003cArc\u003ccrate::module_resolver::ModuleRegistry\u003e\u003e,\n    /// Current module ID\n    current_module_id: Option\u003ccrate::module_resolver::ModuleId\u003e,\n    /// Module resolver for imports\n    module_resolver: Option\u003cArc\u003ccrate::module_resolver::ModuleResolver\u003e\u003e,\n    /// Track module dependencies for cache invalidation\n    module_dependencies: Vec\u003cstd::path::PathBuf\u003e,\n    /// Stack of whether we're inside a catch block (for rethrow validation)\n    in_catch_block: Vec\u003cbool\u003e,\n    /// Current namespace path for this module\n    current_namespace: Option\u003cVec\u003cString\u003e\u003e,\n    /// Type parameters for each generic class (needed for override checking)\n    class_type_params: FxHashMap\u003cString, Vec\u003ctypedlua_parser::ast::statement::TypeParameter\u003e\u003e,\n    /// Track class inheritance for circular dependency detection\n    class_parents: FxHashMap\u003cString, String\u003e,\n    /// Track exported names to detect duplicates\n    exported_names: std::collections::HashSet\u003cString\u003e,\n    diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n    interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n    common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n}\n\nimpl\u003c'a\u003e TypeChecker\u003c'a\u003e {\n    /// Create a new TypeChecker without loading the standard library.\n    ///\n    /// This creates a lightweight type checker instance suitable for testing\n    /// or scenarios where stdlib is not needed. Use `with_stdlib()` or\n    /// `new_with_stdlib()` to load the standard library.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let checker = TypeChecker::new(handler, \u0026interner, \u0026common);\n    /// ```\n    pub fn new(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n        common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n    ) -\u003e Self {\n        Self {\n            symbol_table: SymbolTable::new(),\n            type_env: TypeEnvironment::new(),\n            current_function_return_type: None,\n            narrowing: TypeNarrower::new(),\n            options: CompilerOptions::default(),\n            access_control: AccessControl::new(),\n            module_registry: None,\n            current_module_id: None,\n            module_resolver: None,\n            module_dependencies: Vec::new(),\n            in_catch_block: Vec::new(),\n            current_namespace: None,\n            class_type_params: FxHashMap::default(),\n            class_parents: FxHashMap::default(),\n            exported_names: std::collections::HashSet::new(),\n            diagnostic_handler,\n            interner,\n            common,\n        }\n    }\n\n    /// Create a new TypeChecker with the standard library loaded.\n    ///\n    /// This is a convenience method that combines `new()` and `with_stdlib()`.\n    /// For backward compatibility with existing code.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let checker = TypeChecker::new_with_stdlib(handler, \u0026interner, \u0026common)?;\n    /// ```\n    pub fn new_with_stdlib(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n        common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n    ) -\u003e Result\u003cSelf, String\u003e {\n        let mut checker = Self::new(diagnostic_handler, interner, common);\n        checker.load_stdlib()?;\n        checker.register_minimal_stdlib();\n        Ok(checker)\n    }\n\n    /// Load the standard library into this type checker.\n    ///\n    /// This method loads the standard library for the configured Lua version.\n    /// It can be called multiple times if the Lua version changes.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if stdlib parsing fails.\n    pub fn with_stdlib(mut self) -\u003e Result\u003cSelf, String\u003e {\n        self.load_stdlib()?;\n        self.register_minimal_stdlib();\n        Ok(self)\n    }\n\n    pub fn with_options(mut self, options: CompilerOptions) -\u003e Self {\n        // Check if target version changed\n        let version_changed = self.options.target != options.target;\n        self.options = options;\n\n        // Only reload stdlib if the target version changed\n        if version_changed {\n            // Reset symbol table and type environment\n            self.symbol_table = SymbolTable::new();\n            self.type_env = TypeEnvironment::new();\n            self.access_control = AccessControl::new();\n            self.class_type_params = FxHashMap::default();\n            self.exported_names = std::collections::HashSet::new();\n\n            // Reload stdlib with the new target version\n            if let Err(e) = self.load_stdlib() {\n                eprintln!(\"Warning: Failed to load stdlib: {}\", e);\n            }\n        }\n\n        self\n    }\n\n    /// Create a TypeChecker with module support for multi-module compilation\n    pub fn new_with_module_support(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n        common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n        registry: Arc\u003ccrate::module_resolver::ModuleRegistry\u003e,\n        module_id: crate::module_resolver::ModuleId,\n        resolver: Arc\u003ccrate::module_resolver::ModuleResolver\u003e,\n    ) -\u003e Self {\n        let mut checker = Self::new(diagnostic_handler, interner, common);\n        checker.module_registry = Some(registry);\n        checker.current_module_id = Some(module_id);\n        checker.module_resolver = Some(resolver);\n        checker\n    }\n\n    /// Load the standard library for the configured Lua version\n    ///\n    /// This method parses the stdlib definition files and processes their\n    /// statements to populate the type checker's symbol table and type environment.\n    pub fn load_stdlib(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        use crate::state::stdlib_loader;\n\n        let programs =\n            stdlib_loader::parse_stdlib_files(self.options.target, self.interner, self.common)?;\n\n        for mut program in programs {\n            for statement in \u0026mut program.statements {\n                // Ignore errors from stdlib - best-effort population\n                let _ = self.check_statement(statement);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Type check a program\n    #[instrument(skip(self, program))]\n    pub fn check_program(\u0026mut self, program: \u0026mut Program) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let span = span!(\n            Level::INFO,\n            \"check_program\",\n            statements = program.statements.len()\n        );\n        let _guard = span.enter();\n\n        debug!(\n            \"Starting type checking for program with {} statements\",\n            program.statements.len()\n        );\n\n        // PASS 1: Register all function declarations (hoisting)\n        // This allows functions to be called before they appear in source order\n        for statement in program.statements.iter() {\n            if let Statement::Function(func_decl) = statement {\n                self.register_function_signature(func_decl)?;\n            }\n        }\n\n        debug!(\"Completed pass 1: function signatures registered\");\n\n        // PASS 2: Type check all statements (including function bodies)\n        let mut first_error: Option\u003cTypeCheckError\u003e = None;\n        let mut statements_checked = 0;\n        for statement in program.statements.iter_mut() {\n            if let Err(e) = self.check_statement(statement) {\n                if first_error.is_none() {\n                    first_error = Some(e);\n                }\n            }\n            statements_checked += 1;\n        }\n\n        debug!(\n            \"Completed pass 2: checked {} statements\",\n            statements_checked\n        );\n\n        if let Some(err) = first_error {\n            error!(error = %err, \"Type checking failed\");\n            Err(err)\n        } else {\n            info!(\"Type checking completed successfully\");\n            Ok(())\n        }\n    }\n\n    /// Register a function's signature in the symbol table without checking its body\n    /// This is used during the first pass of check_program to enable function hoisting\n    fn register_function_signature(\n        \u0026mut self,\n        decl: \u0026FunctionDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_phase\n        phases::declaration_phase::register_function_signature(\n            decl,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Type check a statement\n    #[instrument(skip(self, stmt), fields(stmt_type))]\n    fn check_statement(\u0026mut self, stmt: \u0026mut Statement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let stmt_type = match stmt {\n            Statement::Variable(_) =\u003e \"Variable\",\n            Statement::Function(_) =\u003e \"Function\",\n            Statement::If(_) =\u003e \"If\",\n            Statement::While(_) =\u003e \"While\",\n            Statement::For(_) =\u003e \"For\",\n            Statement::Repeat(_) =\u003e \"Repeat\",\n            Statement::Return(_) =\u003e \"Return\",\n            Statement::Break(_) =\u003e \"Break\",\n            Statement::Continue(_) =\u003e \"Continue\",\n            Statement::Expression(_) =\u003e \"Expression\",\n            Statement::Block(_) =\u003e \"Block\",\n            Statement::Interface(_) =\u003e \"Interface\",\n            Statement::TypeAlias(_) =\u003e \"TypeAlias\",\n            Statement::Enum(_) =\u003e \"Enum\",\n            Statement::Class(_) =\u003e \"Class\",\n            Statement::Import(_) =\u003e \"Import\",\n            Statement::Export(_) =\u003e \"Export\",\n            Statement::Namespace(_) =\u003e \"Namespace\",\n            Statement::Label(_) =\u003e \"Label\",\n            Statement::Goto(_) =\u003e \"Goto\",\n            Statement::Throw(_) =\u003e \"Throw\",\n            Statement::Try(_) =\u003e \"Try\",\n            Statement::Rethrow(_) =\u003e \"Rethrow\",\n            Statement::DeclareFunction(_) =\u003e \"DeclareFunction\",\n            Statement::DeclareNamespace(_) =\u003e \"DeclareNamespace\",\n            Statement::DeclareType(_) =\u003e \"DeclareType\",\n            Statement::DeclareInterface(_) =\u003e \"DeclareInterface\",\n            Statement::DeclareConst(_) =\u003e \"DeclareConst\",\n        };\n\n        span!(Level::DEBUG, \"check_statement\", kind = stmt_type);\n\n        match stmt {\n            Statement::Variable(decl) =\u003e self.check_variable_declaration(decl),\n            Statement::Function(decl) =\u003e self.check_function_declaration(decl),\n            Statement::If(if_stmt) =\u003e self.check_if_statement(if_stmt),\n            Statement::While(while_stmt) =\u003e self.check_while_statement(while_stmt),\n            Statement::For(for_stmt) =\u003e self.check_for_statement(for_stmt),\n            Statement::Repeat(repeat_stmt) =\u003e self.check_repeat_statement(repeat_stmt),\n            Statement::Return(return_stmt) =\u003e self.check_return_statement(return_stmt),\n            Statement::Break(_) | Statement::Continue(_) =\u003e Ok(()),\n            Statement::Expression(expr) =\u003e {\n                self.infer_expression_type(expr)?;\n                Ok(())\n            }\n            Statement::Block(block) =\u003e self.check_block(block),\n            Statement::Interface(iface) =\u003e self.check_interface_declaration(iface),\n            Statement::TypeAlias(alias) =\u003e self.check_type_alias(alias),\n            Statement::Enum(enum_decl) =\u003e self.check_enum_declaration(enum_decl),\n            Statement::Class(class_decl) =\u003e self.check_class_declaration(class_decl),\n            Statement::Import(import) =\u003e self.check_import_statement(import),\n            Statement::Export(export) =\u003e self.check_export_statement(export),\n            // Declaration file statements - register them in the symbol table\n            Statement::DeclareFunction(func) =\u003e self.register_declare_function(func),\n            Statement::DeclareNamespace(ns) =\u003e self.register_declare_namespace(ns),\n            Statement::DeclareType(alias) =\u003e self.check_type_alias(alias), // Reuse existing logic\n            Statement::DeclareInterface(iface) =\u003e self.check_interface_declaration(iface), // Reuse existing logic\n            Statement::DeclareConst(const_decl) =\u003e self.register_declare_const(const_decl),\n            // Exception handling\n            Statement::Throw(throw_stmt) =\u003e self.check_throw_statement(throw_stmt),\n            Statement::Try(try_stmt) =\u003e self.check_try_statement(try_stmt),\n            Statement::Rethrow(span) =\u003e self.check_rethrow_statement(*span),\n            // File-based namespace declaration\n            Statement::Namespace(ns_decl) =\u003e self.check_namespace_declaration(ns_decl),\n            // Label and Goto (Lua compatibility)\n            Statement::Label(_) | Statement::Goto(_) =\u003e Ok(()),\n        }\n    }\n\n    /// Check variable declaration\n    fn check_variable_declaration(\n        \u0026mut self,\n        decl: \u0026mut VariableDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Infer the type of the initializer\n        let init_type = self.infer_expression_type(\u0026mut decl.initializer)?;\n\n        // Get the declared type or use inferred type\n        let var_type = if let Some(type_ann) = \u0026decl.type_annotation {\n            // Resolve the type annotation (handles type references)\n            let resolved_type_ann = self\n                .evaluate_type(type_ann)\n                .map_err(|e| TypeCheckError::new(e, decl.span))?;\n\n            // Deep-resolve both types so nested references (e.g., Address | nil in an\n            // interface property) are resolved before structural comparison\n            let deep_init = self.deep_resolve_type(\u0026init_type);\n            let deep_ann = self.deep_resolve_type(\u0026resolved_type_ann);\n\n            // Check that initializer is assignable to declared type\n            if !TypeCompatibility::is_assignable(\u0026deep_init, \u0026deep_ann) {\n                // Fallback: check if source class implements the target interface.\n                // Use original init_type and type_ann (pre-evaluation) since evaluate_type\n                // resolves interface references to ObjectType, losing the interface name.\n                if !self.check_implements_assignable(\u0026init_type, type_ann) {\n                    self.diagnostic_handler.error(\n                        decl.span,\n                        \u0026format!(\n                            \"Type mismatch in variable declaration: cannot assign type '{:?}' to type '{:?}'\",\n                            deep_init.kind, deep_ann.kind\n                        ),\n                    );\n                }\n            }\n            resolved_type_ann\n        } else {\n            // For const, use narrow type; for local, widen literals\n            if matches!(decl.kind, VariableKind::Const) {\n                init_type\n            } else {\n                self.widen_type(init_type)\n            }\n        };\n\n        // Declare the variable in the symbol table\n        let symbol_kind = match decl.kind {\n            VariableKind::Const =\u003e SymbolKind::Const,\n            VariableKind::Local =\u003e SymbolKind::Variable,\n        };\n\n        self.declare_pattern(\u0026decl.pattern, var_type, symbol_kind, decl.span)?;\n\n        Ok(())\n    }\n\n    /// Declare symbols from a pattern\n    fn declare_pattern(\n        \u0026mut self,\n        pattern: \u0026Pattern,\n        typ: Type,\n        kind: SymbolKind,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_phase\n        phases::declaration_phase::declare_pattern(\n            pattern,\n            typ,\n            kind,\n            span,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Check function declaration\n    fn check_function_declaration(\n        \u0026mut self,\n        decl: \u0026mut FunctionDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // NOTE: Function signature is already registered in the symbol table during pass 1\n        // (see register_function_signature method called from check_program)\n        // This method now only checks the function body\n\n        // Enter new scope for function body\n        self.symbol_table.enter_scope();\n\n        // If generic, declare type parameters as types in scope\n        phases::declaration_checking_phase::register_function_type_parameters(\n            decl.type_parameters.as_deref(),\n            \u0026mut self.type_env,\n            self.interner,\n        )?;\n\n        // Declare parameters\n        for (i, param) in decl.parameters.iter().enumerate() {\n            // Check if rest parameter is in the correct position\n            if param.is_rest \u0026\u0026 i != decl.parameters.len() - 1 {\n                return Err(TypeCheckError::new(\n                    \"Rest parameter must be the last parameter\",\n                    param.span,\n                ));\n            }\n\n            let param_type = if param.is_rest {\n                // Rest parameters are arrays\n                let elem_type = if let Some(type_ann) = \u0026param.type_annotation {\n                    // Evaluate to resolve type references\n                    let evaluated = self\n                        .evaluate_type(type_ann)\n                        .map_err(|e| TypeCheckError::new(e, param.span))\n                        .unwrap_or_else(|_| type_ann.clone());\n                    // Deep resolve to handle nested types\n                    self.deep_resolve_type(\u0026evaluated)\n                } else {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                };\n\n                // Wrap in array type\n                Type::new(TypeKind::Array(Box::new(elem_type)), param.span)\n            } else if let Some(type_ann) = \u0026param.type_annotation {\n                // Evaluate to resolve type references\n                let evaluated = self\n                    .evaluate_type(type_ann)\n                    .map_err(|e| TypeCheckError::new(e, param.span))\n                    .unwrap_or_else(|_| type_ann.clone());\n                // Deep resolve to handle nested types\n                self.deep_resolve_type(\u0026evaluated)\n            } else {\n                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n            };\n\n            self.declare_pattern(\n                \u0026param.pattern,\n                param_type,\n                SymbolKind::Parameter,\n                param.span,\n            )?;\n        }\n\n        // Set current function return type for return statement checking\n        let old_return_type = self.current_function_return_type.clone();\n        let resolved_return_type = decl.return_type.as_ref().map(|rt| {\n            let evaluated = self.evaluate_type(rt).unwrap_or_else(|_| rt.clone());\n            self.deep_resolve_type(\u0026evaluated)\n        });\n        self.current_function_return_type = resolved_return_type;\n\n        // Check function body (scope-safe: always exit scope even on error)\n        let body_result = self.check_block(\u0026mut decl.body);\n\n        // Check that non-void functions have a return statement on all code paths\n        if body_result.is_ok() {\n            if let Some(ref return_type) = decl.return_type {\n                // Only check if return type is not void/nil\n                let is_void = matches!(\n                    return_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Void)\n                        | TypeKind::Primitive(PrimitiveType::Nil)\n                );\n                if !is_void \u0026\u0026 !self.block_always_returns(\u0026decl.body) {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Function '{}' must return a value of type '{}' on all code paths\",\n                            self.interner.resolve(decl.name.node),\n                            self.type_to_string(return_type)\n                        ),\n                        decl.span,\n                    ));\n                }\n            }\n        }\n\n        // Restore previous return type\n        self.current_function_return_type = old_return_type;\n\n        // Clean up type parameter constraints and aliases\n        if let Some(type_params) = \u0026decl.type_parameters {\n            for type_param in type_params {\n                let param_name = self.interner.resolve(type_param.name.node).to_string();\n                self.type_env.remove_type_alias(\u0026param_name);\n                self.type_env.remove_type_param_constraint(\u0026param_name);\n            }\n        }\n\n        // Exit function scope (this will remove type parameter registrations)\n        self.symbol_table.exit_scope();\n\n        body_result\n    }\n\n    /// Check if statement\n    fn check_if_statement(\u0026mut self, if_stmt: \u0026mut IfStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check condition\n        self.infer_expression_type(\u0026mut if_stmt.condition)?;\n\n        // Collect current variable and function types for narrowing\n        // This includes both variables and functions so type predicates can be checked\n        let mut variable_types = FxHashMap::default();\n        for (name, symbol) in self.symbol_table.all_visible_symbols() {\n            let name_id = self.interner.intern(\u0026name);\n            variable_types.insert(name_id, symbol.typ.clone());\n        }\n\n        // Apply type narrowing based on the condition\n        let (then_context, else_context) = self.narrowing.narrow_from_condition(\n            \u0026if_stmt.condition,\n            self.narrowing.get_context(),\n            \u0026variable_types,\n            self.interner,\n        );\n\n        // Check then block with narrowed context\n        let saved_context = self.narrowing.get_context().clone();\n        *self.narrowing.get_context_mut() = then_context;\n        self.check_block(\u0026mut if_stmt.then_block)?;\n\n        // Restore context for else-if and else\n        *self.narrowing.get_context_mut() = else_context.clone();\n\n        // Check else-if clauses\n        for else_if in if_stmt.else_ifs.iter_mut() {\n            self.infer_expression_type(\u0026mut else_if.condition)?;\n\n            // Further narrow based on else-if condition\n            let (elseif_then, elseif_else) = self.narrowing.narrow_from_condition(\n                \u0026else_if.condition,\n                self.narrowing.get_context(),\n                \u0026variable_types,\n                self.interner,\n            );\n\n            *self.narrowing.get_context_mut() = elseif_then;\n            self.check_block(\u0026mut else_if.block)?;\n            *self.narrowing.get_context_mut() = elseif_else;\n        }\n\n        // Check else block\n        if let Some(else_block) = \u0026mut if_stmt.else_block {\n            self.check_block(else_block)?;\n        }\n\n        // Restore original context after if statement\n        *self.narrowing.get_context_mut() = saved_context;\n\n        Ok(())\n    }\n\n    /// Check while statement\n    fn check_while_statement(\n        \u0026mut self,\n        while_stmt: \u0026mut WhileStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.infer_expression_type(\u0026mut while_stmt.condition)?;\n        self.check_block(\u0026mut while_stmt.body)?;\n        Ok(())\n    }\n\n    /// Check for statement\n    fn check_for_statement(\u0026mut self, for_stmt: \u0026mut ForStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        match for_stmt {\n            ForStatement::Numeric(numeric) =\u003e {\n                self.symbol_table.enter_scope();\n\n                // Declare loop variable as number\n                let number_type =\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), numeric.span);\n                let symbol = Symbol::new(\n                    self.interner.resolve(numeric.variable.node).to_string(),\n                    SymbolKind::Variable,\n                    number_type,\n                    numeric.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, numeric.span))?;\n\n                // Check start, end, step expressions\n                self.infer_expression_type(\u0026mut numeric.start)?;\n                self.infer_expression_type(\u0026mut numeric.end)?;\n                if let Some(step) = \u0026mut numeric.step {\n                    self.infer_expression_type(step)?;\n                }\n\n                self.check_block(\u0026mut numeric.body)?;\n                self.symbol_table.exit_scope();\n            }\n            ForStatement::Generic(generic) =\u003e {\n                self.symbol_table.enter_scope();\n\n                // Declare loop variables with unknown type\n\n                let unknown_type =\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), generic.span);\n                for var in \u0026generic.variables {\n                    let symbol = Symbol::new(\n                        self.interner.resolve(var.node).to_string(),\n                        SymbolKind::Variable,\n                        unknown_type.clone(),\n                        generic.span,\n                    );\n                    self.symbol_table\n                        .declare(symbol)\n                        .map_err(|e| TypeCheckError::new(e, generic.span))?;\n                }\n\n                // Check iterators\n                for iter in \u0026mut generic.iterators {\n                    self.infer_expression_type(iter)?;\n                }\n\n                self.check_block(\u0026mut generic.body)?;\n                self.symbol_table.exit_scope();\n            }\n        }\n        Ok(())\n    }\n\n    /// Check repeat statement\n    fn check_repeat_statement(\n        \u0026mut self,\n        repeat_stmt: \u0026mut RepeatStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.symbol_table.enter_scope();\n        self.check_block(\u0026mut repeat_stmt.body)?;\n        self.infer_expression_type(\u0026mut repeat_stmt.until)?;\n        self.symbol_table.exit_scope();\n        Ok(())\n    }\n\n    /// Check return statement\n    fn check_return_statement(\n        \u0026mut self,\n        return_stmt: \u0026mut ReturnStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        if !return_stmt.values.is_empty() {\n            // Infer types for all return values\n            let return_types: Result\u003cVec\u003c_\u003e, _\u003e = return_stmt\n                .values\n                .iter_mut()\n                .map(|expr| self.infer_expression_type(expr))\n                .collect();\n            let return_types = return_types?;\n\n            // Create the actual return type (single value or tuple)\n            let actual_return_type = if return_types.len() == 1 {\n                return_types[0].clone()\n            } else {\n                Type::new(TypeKind::Tuple(return_types), return_stmt.span)\n            };\n\n            // Check against expected return type\n            if let Some(expected_type) = \u0026self.current_function_return_type {\n                // Type predicates have an implicit boolean return type\n                let effective_expected_type =\n                    if matches!(expected_type.kind, TypeKind::TypePredicate(_)) {\n                        Type::new(\n                            TypeKind::Primitive(PrimitiveType::Boolean),\n                            expected_type.span,\n                        )\n                    } else {\n                        expected_type.clone()\n                    };\n\n                if !TypeCompatibility::is_assignable(\u0026actual_return_type, \u0026effective_expected_type)\n                {\n                    return Err(TypeCheckError::new(\n                        \"Return type mismatch\",\n                        return_stmt.span,\n                    ));\n                }\n            }\n        } else {\n            // Check that void return is allowed\n            if let Some(expected_type) = \u0026self.current_function_return_type {\n                let void_type =\n                    Type::new(TypeKind::Primitive(PrimitiveType::Void), return_stmt.span);\n                if !TypeCompatibility::is_assignable(\u0026void_type, expected_type) {\n                    return Err(TypeCheckError::new(\n                        \"Function expects a return value\",\n                        return_stmt.span,\n                    ));\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Check block\n    fn check_block(\u0026mut self, block: \u0026mut Block) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.symbol_table.enter_scope();\n        let mut first_error: Option\u003cTypeCheckError\u003e = None;\n        for stmt in \u0026mut block.statements {\n            if let Err(e) = self.check_statement(stmt) {\n                if first_error.is_none() {\n                    first_error = Some(e);\n                }\n            }\n        }\n        self.symbol_table.exit_scope();\n        if let Some(err) = first_error {\n            Err(err)\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Check interface declaration\n    fn check_interface_declaration(\n        \u0026mut self,\n        iface: \u0026mut InterfaceDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_checking_phase for interface registration and validation\n        let (has_default_bodies, iface_type) =\n            phases::declaration_checking_phase::check_interface_declaration(\n                iface,\n                \u0026mut self.type_env,\n                \u0026mut self.symbol_table,\n                \u0026mut self.access_control,\n                self.interner,\n            )?;\n\n        // Type-check default method bodies if present\n        if has_default_bodies {\n            for member in iface.members.iter_mut() {\n                if let InterfaceMember::Method(method) = member {\n                    if let Some(body) = \u0026mut method.body {\n                        self.symbol_table.enter_scope();\n\n                        let self_symbol = Symbol::new(\n                            \"self\".to_string(),\n                            SymbolKind::Parameter,\n                            iface_type.clone(),\n                            method.span,\n                        );\n                        self.symbol_table\n                            .declare(self_symbol)\n                            .map_err(|e| TypeCheckError::new(e, method.span))?;\n\n                        let _ = self.check_block(body);\n\n                        self.symbol_table.exit_scope();\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Validate interface members for correctness\n    #[allow(dead_code)]\n    fn validate_interface_members(\n        \u0026self,\n        members: \u0026[ObjectTypeMember],\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::validate_interface_members(members, span)\n    }\n\n    /// Check type alias\n    fn check_type_alias(\u0026mut self, alias: \u0026TypeAliasDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // For non-generic aliases, evaluate the type before delegating\n        let evaluated_type = if alias.type_parameters.is_none() {\n            Some(\n                self.evaluate_type(\u0026alias.type_annotation)\n                    .map_err(|e| TypeCheckError::new(e, alias.span))?,\n            )\n        } else {\n            None\n        };\n\n        // Delegate to declaration_checking_phase\n        phases::declaration_checking_phase::check_type_alias(\n            alias,\n            \u0026mut self.type_env,\n            \u0026mut self.symbol_table,\n            self.interner,\n            evaluated_type,\n        )\n    }\n\n    /// Check export statement and register exported symbols\n    fn check_export_statement(\u0026mut self, export: \u0026ExportDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Extract export names and check for duplicates\n        match \u0026export.kind {\n            ExportKind::Declaration(decl) =\u003e {\n                // Extract the name being exported\n                let export_name = match \u0026**decl {\n                    Statement::Variable(var_decl) =\u003e {\n                        // Extract variable name from pattern\n                        match \u0026var_decl.pattern {\n                            typedlua_parser::ast::pattern::Pattern::Identifier(name) =\u003e {\n                                Some(self.interner.resolve(name.node).to_string())\n                            }\n                            _ =\u003e None, // Complex patterns - skip for now\n                        }\n                    }\n                    Statement::Function(func_decl) =\u003e {\n                        Some(self.interner.resolve(func_decl.name.node).to_string())\n                    }\n                    Statement::Class(class_decl) =\u003e {\n                        Some(self.interner.resolve(class_decl.name.node).to_string())\n                    }\n                    Statement::Interface(iface_decl) =\u003e {\n                        Some(self.interner.resolve(iface_decl.name.node).to_string())\n                    }\n                    Statement::TypeAlias(alias_decl) =\u003e {\n                        Some(self.interner.resolve(alias_decl.name.node).to_string())\n                    }\n                    Statement::Enum(enum_decl) =\u003e {\n                        Some(self.interner.resolve(enum_decl.name.node).to_string())\n                    }\n                    _ =\u003e None,\n                };\n\n                // Check for duplicate export\n                if let Some(name) = \u0026export_name {\n                    if !self.exported_names.insert(name.clone()) {\n                        return Err(TypeCheckError::new(\n                            format!(\"Duplicate export '{}'\", name),\n                            export.span,\n                        ));\n                    }\n                }\n            }\n            ExportKind::Named { specifiers, .. } =\u003e {\n                // Check each specifier for duplicates\n                for spec in specifiers {\n                    let export_name = if let Some(exported) = \u0026spec.exported {\n                        self.interner.resolve(exported.node).to_string()\n                    } else {\n                        self.interner.resolve(spec.local.node).to_string()\n                    };\n                    if !self.exported_names.insert(export_name.clone()) {\n                        return Err(TypeCheckError::new(\n                            format!(\"Duplicate export '{}'\", export_name),\n                            export.span,\n                        ));\n                    }\n                }\n            }\n            ExportKind::Default(_) =\u003e {\n                // Check for duplicate default export\n                if !self.exported_names.insert(\"default\".to_string()) {\n                    return Err(TypeCheckError::new(\n                        \"Duplicate default export\".to_string(),\n                        export.span,\n                    ));\n                }\n            }\n        }\n\n        // Now process the export declaration\n        match \u0026export.kind {\n            ExportKind::Declaration(decl) =\u003e {\n                // Process the declaration to register it in the symbol table\n                // Note: Most check functions require \u0026mut, but we only have \u0026 here\n                // For now, only handle TypeAlias which takes \u0026TypeAliasDeclaration\n                match \u0026**decl {\n                    Statement::TypeAlias(alias) =\u003e self.check_type_alias(alias),\n                    Statement::Interface(iface) =\u003e {\n                        // Register interface in both type_env and symbol_table\n                        // This is a subset of what check_interface_declaration does\n                        let iface_name = self.interner.resolve(iface.name.node).to_string();\n\n                        // Store type parameter names for generic interfaces\n                        if let Some(type_params) = \u0026iface.type_parameters {\n                            let param_names: Vec\u003cString\u003e = type_params\n                                .iter()\n                                .map(|tp| self.interner.resolve(tp.name.node).to_string())\n                                .collect();\n                            self.type_env\n                                .register_interface_type_params(iface_name.clone(), param_names);\n                        }\n\n                        // Create object type from interface members\n                        let obj_type = Type::new(\n                            TypeKind::Object(ObjectType {\n                                members: iface\n                                    .members\n                                    .iter()\n                                    .map(|member| match member {\n                                        InterfaceMember::Property(prop) =\u003e {\n                                            ObjectTypeMember::Property(prop.clone())\n                                        }\n                                        InterfaceMember::Method(method) =\u003e {\n                                            ObjectTypeMember::Method(method.clone())\n                                        }\n                                        InterfaceMember::Index(index) =\u003e {\n                                            ObjectTypeMember::Index(index.clone())\n                                        }\n                                    })\n                                    .collect(),\n                                span: iface.span,\n                            }),\n                            iface.span,\n                        );\n\n                        // Register in type_env\n                        self.type_env\n                            .register_interface(iface_name.clone(), obj_type.clone())\n                            .map_err(|e| TypeCheckError::new(e, iface.span))?;\n\n                        // Also register in symbol table for export extraction\n                        let symbol = Symbol {\n                            name: iface_name,\n                            typ: obj_type,\n                            kind: SymbolKind::Interface,\n                            span: iface.span,\n                            is_exported: true,\n                            references: Vec::new(),\n                        };\n                        let _ = self.symbol_table.declare(symbol);\n\n                        Ok(())\n                    }\n                    // TODO: Handle other declaration types (Function, Class, Variable, Enum)\n                    // These require mutable references and would need the ExportDeclaration to be mutable\n                    _ =\u003e Ok(()),\n                }\n            }\n            ExportKind::Named {\n                specifiers: _,\n                source,\n            } =\u003e {\n                // For re-exports, we don't need to register anything in the local symbol table\n                // The symbols will be resolved from the source module during extract_exports\n                // However, we should validate that the source module exists\n                if let Some(source_path) = source {\n                    if let (Some(resolver), Some(current_id)) =\n                        (\u0026self.module_resolver, \u0026self.current_module_id)\n                    {\n                        if let Err(e) = resolver.resolve(source_path, current_id.path()) {\n                            return Err(TypeCheckError::new(\n                                format!(\"Cannot resolve module '{}': {}\", source_path, e),\n                                export.span,\n                            ));\n                        }\n                    }\n                }\n                Ok(())\n            }\n            ExportKind::Default(expr) =\u003e {\n                // Type check the default export expression\n                let mut expr_clone = expr.clone();\n                self.infer_expression_type(\u0026mut expr_clone)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Check enum declaration\n    fn check_enum_declaration(\n        \u0026mut self,\n        enum_decl: \u0026mut EnumDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_checking_phase for simple enums\n        let is_rich_enum = phases::declaration_checking_phase::check_enum_declaration(\n            enum_decl,\n            \u0026mut self.type_env,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )?;\n\n        // If it's a rich enum, handle it here\n        if is_rich_enum {\n            self.check_rich_enum_declaration(enum_decl)?;\n        }\n\n        Ok(())\n    }\n\n    /// Check rich enum declaration with fields, constructor, and methods\n    fn check_rich_enum_declaration(\n        \u0026mut self,\n        enum_decl: \u0026mut EnumDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Register enum types and members with phase function\n        let enum_self_type = phases::declaration_checking_phase::check_rich_enum_declaration(\n            enum_decl,\n            \u0026mut self.type_env,\n            \u0026mut self.access_control,\n            self.interner,\n        )?;\n\n        // Check constructor body if present\n        if let Some(ref mut constructor) = enum_decl.constructor {\n            self.symbol_table.enter_scope();\n            let self_symbol = Symbol::new(\n                \"self\".to_string(),\n                SymbolKind::Parameter,\n                enum_self_type.clone(),\n                constructor.span,\n            );\n            let _ = self.symbol_table.declare(self_symbol);\n            let _ = self.check_block(\u0026mut constructor.body);\n            self.symbol_table.exit_scope();\n        }\n\n        // Check method bodies\n        for method in enum_decl.methods.iter_mut() {\n            self.symbol_table.enter_scope();\n            let self_symbol = Symbol::new(\n                \"self\".to_string(),\n                SymbolKind::Parameter,\n                enum_self_type.clone(),\n                method.span,\n            );\n            let _ = self.symbol_table.declare(self_symbol);\n            let _ = self.check_block(\u0026mut method.body);\n            self.symbol_table.exit_scope();\n        }\n\n        Ok(())\n    }\n\n    /// Resolve a type reference, handling utility types and generic type application\n    #[instrument(skip(self, type_ref), fields(type_name))]\n    fn resolve_type_reference(\u0026self, type_ref: \u0026TypeReference) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let name = self.interner.resolve(type_ref.name.node);\n        span!(Level::DEBUG, \"resolve_type_reference\", type_name = %name);\n\n        let span = type_ref.span;\n\n        // Check if it's a utility type\n        if let Some(type_args) = \u0026type_ref.type_arguments {\n            if TypeEnvironment::is_utility_type(\u0026name) {\n                // Resolve type arguments first (they might be type references)\n                let resolved_args: Result\u003cVec\u003cType\u003e, TypeCheckError\u003e = type_args\n                    .iter()\n                    .map(|arg| {\n                        self.evaluate_type(arg)\n                            .map_err(|e| TypeCheckError::new(e, arg.span))\n                    })\n                    .collect();\n                let resolved_args = resolved_args?;\n\n                return self\n                    .type_env\n                    .resolve_utility_type(\u0026name, \u0026resolved_args, span, self.interner, self.common)\n                    .map_err(|e| TypeCheckError::new(e, span));\n            }\n\n            // Check for generic type alias\n            if let Some(generic_alias) = self.type_env.get_generic_type_alias(\u0026name) {\n                use crate::types::generics::instantiate_type;\n                return instantiate_type(\n                    \u0026generic_alias.typ,\n                    \u0026generic_alias.type_parameters,\n                    type_args,\n                )\n                .map_err(|e| TypeCheckError::new(e, span));\n            }\n        }\n\n        // Regular type lookup\n        match self.type_env.lookup_type(\u0026name) {\n            Some(typ) =\u003e Ok(typ.clone()),\n            None =\u003e Err(TypeCheckError::new(\n                format!(\"Type '{}' not found\", name),\n                span,\n            )),\n        }\n    }\n\n    /// Check class declaration\n    #[instrument(skip(self, class_decl), fields(class_name))]\n    fn check_class_declaration(\n        \u0026mut self,\n        class_decl: \u0026mut ClassDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let class_name = self.interner.resolve(class_decl.name.node).to_string();\n        span!(Level::INFO, \"check_class_declaration\", class_name);\n\n        debug!(\n            members = class_decl.members.len(),\n            \"Checking class declaration\"\n        );\n\n        // Check decorators\n        self.check_decorators(\u0026mut class_decl.decorators)?;\n\n        debug!(\"Checking class {}\", class_name);\n\n        // Register class symbol (focused function - ~15 lines saved)\n        let _class_type = phases::declaration_checking_phase::register_class_symbol(\n            class_decl,\n            \u0026mut self.symbol_table,\n            \u0026mut self.type_env,\n            \u0026mut self.class_type_params,\n            self.interner,\n        )?;\n\n        // Enter a new scope for the class\n        self.symbol_table.enter_scope();\n\n        // Register type parameters if this is a generic class\n        // Register class type parameters in the type environment\n        phases::declaration_checking_phase::register_class_type_parameters(\n            class_decl.type_parameters.as_deref(),\n            \u0026mut self.type_env,\n            self.interner,\n        )?;\n\n        // Validate class inheritance (focused function - ~20 lines saved)\n        if let Some(extends_type) = \u0026class_decl.extends {\n            phases::validation_phase::validate_class_inheritance(\n                \u0026class_name,\n                extends_type,\n                \u0026self.access_control,\n                \u0026mut self.class_parents,\n                self.interner,\n                class_decl.span,\n            )?;\n        }\n\n        // Register class implements relationships before compliance checking,\n        // so covariant return type checks can look up the class hierarchy\n        phases::declaration_checking_phase::register_class_implements(\n            class_name.clone(),\n            class_decl.implements.clone(),\n            \u0026mut self.type_env,\n            \u0026mut self.access_control,\n            self.interner,\n        );\n\n        // Check interface implementation\n        for interface_type in \u0026class_decl.implements {\n            if let TypeKind::Reference(type_ref) = \u0026interface_type.kind {\n                let interface_name = self.interner.resolve(type_ref.name.node);\n                if let Some(interface) = self.type_env.get_interface(\u0026interface_name) {\n                    // If the interface has type arguments, instantiate it\n                    let instantiated = if let Some(type_args) = \u0026type_ref.type_arguments {\n                        declaration_checking_phase::instantiate_generic_interface(\n                            interface.clone(),\n                            type_args,\n                            \u0026interface_name,\n                            |typ, args, iface_name| {\n                                self.substitute_type_args_in_type(typ, args, iface_name)\n                            },\n                        )\n                    } else {\n                        interface.clone()\n                    };\n                    self.check_class_implements_interface(class_decl, \u0026instantiated)?;\n                } else {\n                    return Err(TypeCheckError::new(\n                        format!(\"Interface '{}' not found\", interface_name),\n                        class_decl.span,\n                    ));\n                }\n            } else {\n                return Err(TypeCheckError::new(\n                    \"Class can only implement interfaces (type references)\",\n                    class_decl.span,\n                ));\n            }\n        }\n\n        // Process primary constructor parameters - they become class properties\n        let mut primary_constructor_properties = Vec::new();\n        if let Some(primary_params) = \u0026class_decl.primary_constructor {\n            for param in primary_params {\n                // Validate: ensure no member with same name exists\n                let param_name = \u0026param.name.node;\n                if class_decl.members.iter().any(|m| match m {\n                    ClassMember::Property(p) =\u003e \u0026p.name.node == param_name,\n                    ClassMember::Method(m) =\u003e \u0026m.name.node == param_name,\n                    ClassMember::Getter(g) =\u003e \u0026g.name.node == param_name,\n                    ClassMember::Setter(s) =\u003e \u0026s.name.node == param_name,\n                    ClassMember::Constructor(_) =\u003e false,\n                    ClassMember::Operator(_) =\u003e false,\n                }) {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Primary constructor parameter '{}' conflicts with existing class member\",\n                            param_name\n                        ),\n                        param.span,\n                    ));\n                }\n\n                primary_constructor_properties.push(param);\n            }\n\n            // Register the class constructor for parent argument validation\n            self.type_env.register_class_constructor(\n                class_name.clone(),\n                class_decl.primary_constructor.clone().unwrap(),\n            );\n        }\n\n        // Validate parent constructor arguments if present\n        if let Some(parent_args) = \u0026mut class_decl.parent_constructor_args {\n            // Type check each parent constructor argument\n            for arg in parent_args.iter_mut() {\n                self.infer_expression_type(arg)?;\n            }\n\n            // Validate argument count and types match parent constructor\n            if let Some(extends_type) = \u0026class_decl.extends {\n                if let TypeKind::Reference(type_ref) = \u0026extends_type.kind {\n                    let parent_name = self.interner.resolve(type_ref.name.node);\n                    // Clone the constructor parameters to avoid borrow issues\n                    let parent_constructor =\n                        self.type_env.get_class_constructor(\u0026parent_name).cloned();\n\n                    if let Some(parent_constructor) = parent_constructor {\n                        // Check argument count\n                        if parent_args.len() != parent_constructor.len() {\n                            return Err(TypeCheckError::new(\n                                format!(\n                                    \"Parent constructor argument count mismatch: expected {}, found {}\",\n                                    parent_constructor.len(),\n                                    parent_args.len()\n                                ),\n                                class_decl.span,\n                            ));\n                        }\n\n                        // Check argument types\n                        for (i, (arg, param)) in parent_args\n                            .iter_mut()\n                            .zip(parent_constructor.iter())\n                            .enumerate()\n                        {\n                            let arg_type = self.infer_expression_type(arg)?;\n                            let param_type = \u0026param.type_annotation;\n                            if !TypeCompatibility::is_assignable(\u0026arg_type, param_type) {\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Parent constructor argument {} type mismatch: expected '{:?}', found '{:?}'\",\n                                        i + 1,\n                                        param_type.kind,\n                                        arg_type.kind\n                                    ),\n                                    arg.span,\n                                ));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Collect class members for access checking\n        let mut member_infos = Vec::new();\n\n        // Add primary constructor parameters as properties\n        for param in \u0026primary_constructor_properties {\n            member_infos.push(ClassMemberInfo {\n                name: self.interner.resolve(param.name.node).to_string(),\n                access: param.access.unwrap_or(AccessModifier::Public),\n                _is_static: false,\n                kind: ClassMemberKind::Property {\n                    type_annotation: param.type_annotation.clone(),\n                },\n                is_final: param.is_readonly, // readonly maps to final for properties\n            });\n        }\n\n        // Extract regular class member information\n        let mut class_member_infos = phases::declaration_checking_phase::extract_class_member_infos(\n            class_decl,\n            self.interner,\n        );\n        member_infos.append(\u0026mut class_member_infos);\n\n        // Extract parent class name first\n        let parent = class_decl.extends.as_ref().and_then(|ext| {\n            if let TypeKind::Reference(type_ref) = \u0026ext.kind {\n                Some(self.interner.resolve(type_ref.name.node).to_string())\n            } else {\n                None\n            }\n        });\n\n        // Register class and all its members with access control visitor\n        self.access_control\n            .register_class(\u0026class_name, parent.clone());\n        for member_info in member_infos {\n            self.access_control\n                .register_member(\u0026class_name, member_info);\n        }\n\n        // Mark class as final if needed\n        self.access_control\n            .mark_class_final(\u0026class_name, class_decl.is_final);\n\n        // Set current class context\n        let old_class = self.access_control.get_current_class().clone();\n        self.access_control.set_current_class(Some(ClassContext {\n            name: self.interner.resolve(class_decl.name.node).to_string(),\n            parent,\n            extends_type: class_decl.extends.clone(),\n        }));\n\n        // Check all class members\n        // Use soft error handling for member bodies so the class is still\n        // registered even if individual members have type errors. This prevents\n        // cascading \"undefined variable\" errors for code that uses the class.\n        let mut has_constructor = false;\n        let mut abstract_methods = Vec::new();\n        let mut first_member_error: Option\u003cTypeCheckError\u003e = None;\n\n        for member in class_decl.members.iter_mut() {\n            let result = match member {\n                ClassMember::Property(prop) =\u003e self.check_class_property(prop),\n                ClassMember::Constructor(ctor) =\u003e {\n                    if has_constructor {\n                        Err(TypeCheckError::new(\n                            \"Class can only have one constructor\",\n                            ctor.span,\n                        ))\n                    } else {\n                        has_constructor = true;\n                        self.check_constructor(ctor)\n                    }\n                }\n                ClassMember::Method(method) =\u003e {\n                    if method.is_abstract {\n                        if !class_decl.is_abstract {\n                            Err(TypeCheckError::new(\n                                format!(\n                                    \"Abstract method '{}' can only be in abstract class\",\n                                    method.name.node\n                                ),\n                                method.span,\n                            ))\n                        } else {\n                            abstract_methods\n                                .push(self.interner.resolve(method.name.node).to_string());\n                            self.check_class_method(method)\n                        }\n                    } else {\n                        self.check_class_method(method)\n                    }\n                }\n                ClassMember::Getter(getter) =\u003e self.check_class_getter(getter),\n                ClassMember::Setter(setter) =\u003e self.check_class_setter(setter),\n                ClassMember::Operator(op) =\u003e self.check_operator_declaration(op),\n            };\n\n            if let Err(e) = result {\n                if first_member_error.is_none() {\n                    first_member_error = Some(e);\n                }\n            }\n        }\n\n        // Restore previous class context\n        self.access_control.set_current_class(old_class);\n\n        // Exit class scope\n        self.symbol_table.exit_scope();\n\n        // Clean up type parameters from type environment after class scope\n        if let Some(type_params) = \u0026class_decl.type_parameters {\n            for type_param in type_params {\n                let param_name = self.interner.resolve(type_param.name.node).to_string();\n                self.type_env.remove_type_alias(\u0026param_name);\n            }\n        }\n\n        // Check that concrete classes implement all inherited abstract methods\n        if !class_decl.is_abstract {\n            if let Some(extends_type) = \u0026class_decl.extends {\n                if let TypeKind::Reference(type_ref) = \u0026extends_type.kind {\n                    let parent_name = self.interner.resolve(type_ref.name.node);\n                    // Check for abstract methods in parent class\n                    self.check_abstract_methods_implemented(\n                        \u0026class_name,\n                        \u0026parent_name,\n                        \u0026class_decl.members,\n                    )?;\n                }\n            }\n        }\n\n        // Handle member errors based on severity.\n        // Critical errors (abstract methods in non-abstract class, multiple constructors)\n        // should fail hard. Other errors become warnings to prevent cascading failures.\n        if let Some(err) = first_member_error {\n            if phases::declaration_checking_phase::is_critical_member_error(\u0026err.message) {\n                return Err(err);\n            } else {\n                // Non-critical errors become warnings\n                self.diagnostic_handler.warning(\n                    class_decl.span,\n                    \u0026format!(\"Error in class '{}' member: {}\", class_name, err.message),\n                );\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check that a class properly implements an interface\n    fn check_class_implements_interface(\n        \u0026self,\n        class_decl: \u0026ClassDeclaration,\n        interface: \u0026Type,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::check_class_implements_interface(\n            class_decl,\n            interface,\n            \u0026self.type_env,\n            self.interner,\n        )\n    }\n\n    /// Validate that all class properties are compatible with interface index signature\n    #[allow(dead_code)]\n    fn validate_index_signature(\n        \u0026self,\n        class_decl: \u0026ClassDeclaration,\n        index_sig: \u0026IndexSignature,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::validate_index_signature(class_decl, index_sig, self.interner)\n    }\n\n    /// Check that a class implements all abstract methods from its parent class\n    fn check_abstract_methods_implemented(\n        \u0026self,\n        class_name: \u0026str,\n        parent_name: \u0026str,\n        class_members: \u0026[ClassMember],\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::check_abstract_methods_implemented(\n            class_name,\n            parent_name,\n            class_members,\n            \u0026self.access_control,\n            self.interner,\n        )\n    }\n\n    /// Check decorators\n    fn check_decorators(\n        \u0026mut self,\n        decorators: \u0026mut [typedlua_parser::ast::statement::Decorator],\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check if decorators are enabled\n        if !decorators.is_empty() \u0026\u0026 !self.options.enable_decorators {\n            return Err(TypeCheckError::new(\n                \"Decorators require decorator features to be enabled. Enable 'enableDecorators' in your configuration.\".to_string(),\n                decorators[0].span,\n            ));\n        }\n\n        // Check for duplicate decorators\n        let mut seen_decorators = std::collections::HashSet::new();\n        for decorator in decorators.iter() {\n            // Get decorator name for comparison\n            let decorator_name = match \u0026decorator.expression {\n                typedlua_parser::ast::statement::DecoratorExpression::Identifier(name) =\u003e {\n                    self.interner.resolve(name.node).to_string()\n                }\n                typedlua_parser::ast::statement::DecoratorExpression::Call { callee, .. } =\u003e {\n                    // For calls, use the callee name\n                    if let typedlua_parser::ast::statement::DecoratorExpression::Identifier(name) =\n                        \u0026**callee\n                    {\n                        self.interner.resolve(name.node).to_string()\n                    } else {\n                        continue; // Skip complex expressions\n                    }\n                }\n                typedlua_parser::ast::statement::DecoratorExpression::Member { .. } =\u003e {\n                    continue; // Skip member expressions for duplicate checking\n                }\n            };\n\n            if !seen_decorators.insert(decorator_name.clone()) {\n                self.diagnostic_handler.warning(\n                    decorator.span,\n                    \u0026format!(\"Duplicate decorator '@{}'\", decorator_name),\n                );\n            }\n        }\n\n        // For now, we just validate that decorator expressions are valid\n        // Full decorator type checking would require:\n        // 1. Checking that decorator functions exist\n        // 2. Validating decorator function signatures match target type\n        // 3. Checking decorator arguments are type-compatible\n        // This is simplified for now - decorators are allowed but not deeply validated\n\n        for decorator in decorators.iter_mut() {\n            self.check_decorator_expression(\u0026mut decorator.expression)?;\n        }\n\n        Ok(())\n    }\n\n    /// Check a decorator expression\n    fn check_decorator_expression(\n        \u0026mut self,\n        expr: \u0026mut typedlua_parser::ast::statement::DecoratorExpression,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        use typedlua_parser::ast::statement::DecoratorExpression;\n\n        match expr {\n            DecoratorExpression::Identifier(name) =\u003e {\n                // Verify the decorator identifier exists (could be a function or imported decorator)\n                // For now, we allow any identifier - full validation would check it's a valid decorator function\n                let name_str = self.interner.resolve(name.node);\n                if self.symbol_table.lookup(\u0026name_str).is_none() {\n                    // It's okay if it doesn't exist - it might be a built-in decorator like @readonly, @sealed\n                    // We'll allow it through for now\n                }\n                Ok(())\n            }\n            DecoratorExpression::Call {\n                callee, arguments, ..\n            } =\u003e {\n                // Check the callee\n                self.check_decorator_expression(callee)?;\n\n                // Type check all arguments\n                for arg in arguments.iter_mut() {\n                    self.infer_expression_type(arg)?;\n                }\n\n                Ok(())\n            }\n            DecoratorExpression::Member { object, .. } =\u003e {\n                // Check the object part\n                self.check_decorator_expression(object)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Check class property\n    fn check_class_property(\n        \u0026mut self,\n        prop: \u0026mut PropertyDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut prop.decorators)?;\n\n        // Check initializer if present\n        if let Some(initializer) = \u0026mut prop.initializer {\n            let init_type = self.infer_expression_type(initializer)?;\n\n            // Verify initializer type is assignable to declared type\n            if !TypeCompatibility::is_assignable(\u0026init_type, \u0026prop.type_annotation) {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Property '{}' initializer type does not match declared type\",\n                        prop.name.node\n                    ),\n                    prop.span,\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check constructor\n    fn check_constructor(\n        \u0026mut self,\n        ctor: \u0026mut ConstructorDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Enter constructor scope\n        self.symbol_table.enter_scope();\n\n        // Inner function to do the actual checking, so we can ensure scope cleanup\n        let result = (|| -\u003e Result\u003c(), TypeCheckError\u003e {\n            // Declare 'self' parameter (implicit in constructors)\n            if let Some(class_ctx) = self.access_control.get_current_class() {\n                let self_type = Type::new(\n                    TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                        name: typedlua_parser::ast::Spanned::new(\n                            self.interner.intern(\u0026class_ctx.name),\n                            ctor.span,\n                        ),\n                        type_arguments: None,\n                        span: ctor.span,\n                    }),\n                    ctor.span,\n                );\n                let symbol = crate::utils::symbol_table::Symbol::new(\n                    \"self\".to_string(),\n                    crate::utils::symbol_table::SymbolKind::Parameter,\n                    self_type,\n                    ctor.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, ctor.span))?;\n            }\n\n            // Declare parameters\n            for param in \u0026ctor.parameters {\n                let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                    // Evaluate the type annotation to resolve any type references\n                    let evaluated = self\n                        .evaluate_type(type_ann)\n                        .map_err(|e| TypeCheckError::new(e, param.span))\n                        .unwrap_or_else(|_| type_ann.clone()); // Fall back to unevaluated if evaluation fails\n\n                    // Deep resolve to handle nested types in function types, arrays, etc.\n                    self.deep_resolve_type(\u0026evaluated)\n                } else {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                };\n\n                self.declare_pattern(\n                    \u0026param.pattern,\n                    param_type,\n                    SymbolKind::Parameter,\n                    param.span,\n                )?;\n            }\n\n            // Check constructor body\n            self.check_block(\u0026mut ctor.body)?;\n\n            Ok(())\n        })();\n\n        // Always exit scope, even on error\n        self.symbol_table.exit_scope();\n\n        result\n    }\n\n    /// Check class method\n    fn check_class_method(\u0026mut self, method: \u0026mut MethodDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut method.decorators)?;\n\n        // Check override keyword if present\n        if method.is_override {\n            self.check_method_override(method)?;\n        } else if let Some(class_context) = self.access_control.get_current_class() {\n            // Check if method shadows a parent method without override keyword\n            if let Some(parent_name) = \u0026class_context.parent {\n                if let Some(parent_members) = self.access_control.get_class_members(parent_name) {\n                    let method_name = self.interner.resolve(method.name.node);\n                    if parent_members.iter().any(|m| m.name == method_name) {\n                        self.diagnostic_handler.warning(\n                            method.span,\n                            \u0026format!(\n                                \"Method '{}' overrides a method from parent class '{}' but is missing the 'override' keyword\",\n                                method_name,\n                                parent_name\n                            ),\n                        );\n                    }\n                }\n            }\n        }\n\n        // Abstract methods don't have a body to check\n        if method.is_abstract {\n            if method.body.is_some() {\n                return Err(TypeCheckError::new(\n                    format!(\"Abstract method '{}' cannot have a body\", method.name.node),\n                    method.span,\n                ));\n            }\n            return Ok(());\n        }\n\n        // Non-abstract methods must have a body\n        if method.body.is_none() {\n            return Err(TypeCheckError::new(\n                format!(\n                    \"Non-abstract method '{}' must have a body\",\n                    method.name.node\n                ),\n                method.span,\n            ));\n        }\n\n        // Enter method scope\n        self.symbol_table.enter_scope();\n\n        // Do all method body work in a closure to ensure scope cleanup on error\n        let old_return_type = self.current_function_return_type.clone();\n        let result = (|| -\u003e Result\u003c(), TypeCheckError\u003e {\n            // Declare 'self' parameter for non-static methods\n            if !method.is_static {\n                if let Some(class_ctx) = self.access_control.get_current_class() {\n                    let self_type = Type::new(\n                        TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                            name: typedlua_parser::ast::Spanned::new(\n                                self.interner.intern(\u0026class_ctx.name),\n                                method.span,\n                            ),\n                            type_arguments: None,\n                            span: method.span,\n                        }),\n                        method.span,\n                    );\n                    let symbol = crate::utils::symbol_table::Symbol::new(\n                        \"self\".to_string(),\n                        crate::utils::symbol_table::SymbolKind::Parameter,\n                        self_type,\n                        method.span,\n                    );\n                    self.symbol_table\n                        .declare(symbol)\n                        .map_err(|e| TypeCheckError::new(e, method.span))?;\n                }\n            }\n\n            // Register type parameters if generic (with duplicate checking and constraint support)\n            phases::declaration_checking_phase::register_function_type_parameters(\n                method.type_parameters.as_deref(),\n                \u0026mut self.type_env,\n                self.interner,\n            )?;\n\n            // Declare parameters\n            for param in \u0026method.parameters {\n                let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                    // Evaluate the type annotation to resolve any type references (e.g., T, U in generic methods)\n                    let evaluated = self\n                        .evaluate_type(type_ann)\n                        .map_err(|e| TypeCheckError::new(e, param.span))\n                        .unwrap_or_else(|_| type_ann.clone()); // Fall back to unevaluated if evaluation fails\n\n                    // Deep resolve to handle nested types in function types, arrays, etc.\n                    self.deep_resolve_type(\u0026evaluated)\n                } else {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                };\n\n                self.declare_pattern(\n                    \u0026param.pattern,\n                    param_type,\n                    SymbolKind::Parameter,\n                    param.span,\n                )?;\n            }\n\n            // Set current function return type for return statement checking\n            self.current_function_return_type = method.return_type.clone();\n\n            // Check method body\n            if let Some(body) = \u0026mut method.body {\n                self.check_block(body)?;\n            }\n\n            Ok(())\n        })();\n\n        // Always restore return type and exit scope, even on error\n        self.current_function_return_type = old_return_type;\n        self.symbol_table.exit_scope();\n\n        // Clean up method type parameters from type environment\n        if let Some(type_params) = \u0026method.type_parameters {\n            for type_param in type_params {\n                let param_name = self.interner.resolve(type_param.name.node).to_string();\n                self.type_env.remove_type_alias(\u0026param_name);\n            }\n        }\n\n        result\n    }\n\n    /// Check class getter\n    fn check_class_getter(\u0026mut self, getter: \u0026mut GetterDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut getter.decorators)?;\n\n        // Enter getter scope\n        self.symbol_table.enter_scope();\n\n        // Declare 'self' parameter for non-static getters\n        if !getter.is_static {\n            if let Some(class_ctx) = self.access_control.get_current_class() {\n                let self_type = Type::new(\n                    TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                        name: typedlua_parser::ast::Spanned::new(\n                            self.interner.intern(\u0026class_ctx.name),\n                            getter.span,\n                        ),\n                        type_arguments: None,\n                        span: getter.span,\n                    }),\n                    getter.span,\n                );\n                let symbol = crate::utils::symbol_table::Symbol::new(\n                    \"self\".to_string(),\n                    crate::utils::symbol_table::SymbolKind::Parameter,\n                    self_type,\n                    getter.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, getter.span))?;\n            }\n        }\n\n        // Set current function return type\n        let old_return_type = self.current_function_return_type.clone();\n        self.current_function_return_type = Some(getter.return_type.clone());\n\n        // Check getter body\n        self.check_block(\u0026mut getter.body)?;\n\n        // Restore previous return type\n        self.current_function_return_type = old_return_type;\n\n        // Exit getter scope\n        self.symbol_table.exit_scope();\n\n        Ok(())\n    }\n\n    /// Check class setter\n    fn check_class_setter(\u0026mut self, setter: \u0026mut SetterDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut setter.decorators)?;\n\n        // Enter setter scope\n        self.symbol_table.enter_scope();\n\n        // Declare 'self' parameter for non-static setters\n        if !setter.is_static {\n            if let Some(class_ctx) = self.access_control.get_current_class() {\n                let self_type = Type::new(\n                    TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                        name: typedlua_parser::ast::Spanned::new(\n                            self.interner.intern(\u0026class_ctx.name),\n                            setter.span,\n                        ),\n                        type_arguments: None,\n                        span: setter.span,\n                    }),\n                    setter.span,\n                );\n                let symbol = crate::utils::symbol_table::Symbol::new(\n                    \"self\".to_string(),\n                    crate::utils::symbol_table::SymbolKind::Parameter,\n                    self_type,\n                    setter.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, setter.span))?;\n            }\n        }\n\n        // Declare the parameter\n        let param_type = if let Some(type_ann) = \u0026setter.parameter.type_annotation {\n            // Evaluate to resolve type references\n            let evaluated = self\n                .evaluate_type(type_ann)\n                .map_err(|e| TypeCheckError::new(e, setter.parameter.span))\n                .unwrap_or_else(|_| type_ann.clone());\n            // Deep resolve to handle nested types\n            self.deep_resolve_type(\u0026evaluated)\n        } else {\n            Type::new(\n                TypeKind::Primitive(PrimitiveType::Unknown),\n                setter.parameter.span,\n            )\n        };\n\n        self.declare_pattern(\n            \u0026setter.parameter.pattern,\n            param_type,\n            SymbolKind::Parameter,\n            setter.parameter.span,\n        )?;\n\n        // Check setter body\n        self.check_block(\u0026mut setter.body)?;\n\n        // Exit setter scope\n        self.symbol_table.exit_scope();\n\n        Ok(())\n    }\n\n    /// Check operator declaration\n    fn check_operator_declaration(\n        \u0026mut self,\n        op: \u0026mut OperatorDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        if op.operator == OperatorKind::NewIndex {\n            if op.parameters.len() != 2 {\n                return Err(TypeCheckError::new(\n                    \"operator []= must have exactly 2 parameters\",\n                    op.span,\n                ));\n            }\n        } else if op.parameters.is_empty() {\n            if !matches!(op.operator, OperatorKind::UnaryMinus | OperatorKind::Length) {\n                return Err(TypeCheckError::new(\n                    \"Only unary minus (-) and length (#) operators can have 0 parameters\",\n                    op.span,\n                ));\n            }\n        } else if op.parameters.len() == 1 {\n            if matches!(op.operator, OperatorKind::UnaryMinus | OperatorKind::Length) {\n                return Err(TypeCheckError::new(\n                    \"Binary operator must have exactly 1 parameter\",\n                    op.span,\n                ));\n            }\n        } else {\n            return Err(TypeCheckError::new(\n                \"Operator must have 0, 1, or 2 parameters\",\n                op.span,\n            ));\n        }\n\n        match op.operator {\n            OperatorKind::Equal | OperatorKind::NotEqual =\u003e {\n                if let Some(ref ret_type) = op.return_type {\n                    if !self.is_boolean_type(ret_type) {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Operator '{}' must return 'boolean'\",\n                                self.operator_kind_name(\u0026op.operator)\n                            ),\n                            ret_type.span,\n                        ));\n                    }\n                }\n            }\n            OperatorKind::LessThan\n            | OperatorKind::LessThanOrEqual\n            | OperatorKind::GreaterThan\n            | OperatorKind::GreaterThanOrEqual =\u003e {\n                if let Some(ref ret_type) = op.return_type {\n                    if !self.is_boolean_type(ret_type) {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Operator '{}' must return 'boolean'\",\n                                self.operator_kind_name(\u0026op.operator)\n                            ),\n                            ret_type.span,\n                        ));\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n\n        self.symbol_table.enter_scope();\n\n        if let Some(class_ctx) = self.access_control.get_current_class() {\n            let self_type = Type::new(\n                TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                    name: typedlua_parser::ast::Spanned::new(\n                        self.interner.intern(\u0026class_ctx.name),\n                        op.span,\n                    ),\n                    type_arguments: None,\n                    span: op.span,\n                }),\n                op.span,\n            );\n            let symbol = crate::utils::symbol_table::Symbol::new(\n                \"self\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Parameter,\n                self_type,\n                op.span,\n            );\n            self.symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, op.span))?;\n        }\n\n        for param in \u0026op.parameters {\n            let param_type = param.type_annotation.clone().unwrap_or_else(|| {\n                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n            });\n\n            self.declare_pattern(\n                \u0026param.pattern,\n                param_type,\n                SymbolKind::Parameter,\n                param.span,\n            )?;\n        }\n\n        let old_return_type = self.current_function_return_type.clone();\n        self.current_function_return_type = op.return_type.clone();\n\n        self.check_block(\u0026mut op.body)?;\n\n        self.current_function_return_type = old_return_type;\n\n        self.symbol_table.exit_scope();\n\n        Ok(())\n    }\n\n    fn is_boolean_type(\u0026self, typ: \u0026Type) -\u003e bool {\n        type_utilities::is_boolean_type(typ)\n    }\n\n    fn operator_kind_name(\u0026self, op: \u0026OperatorKind) -\u003e String {\n        type_utilities::operator_kind_name(op)\n    }\n\n    /// Check that an override method properly overrides a parent method\n    fn check_method_override(\u0026self, method: \u0026MethodDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Get current class context\n        let class_ctx = self\n            .access_control\n            .get_current_class()\n            .as_ref()\n            .ok_or_else(|| {\n                TypeCheckError::new(\n                    \"Override keyword used outside of class context\",\n                    method.span,\n                )\n            })?;\n\n        // Get extends clause type arguments for generic parent instantiation\n        let extends_type_args = class_ctx.extends_type.as_ref().and_then(|ext| {\n            if let TypeKind::Reference(type_ref) = \u0026ext.kind {\n                type_ref.type_arguments.as_ref()\n            } else {\n                None\n            }\n        });\n\n        // Get parent class type parameters (if the parent is generic)\n        let parent_type_params = class_ctx\n            .parent\n            .as_ref()\n            .and_then(|p| self.class_type_params.get(p));\n\n        phases::validation_phase::check_method_override(\n            method,\n            \u0026class_ctx.name,\n            class_ctx.parent.as_ref(),\n            parent_type_params,\n            extends_type_args,\n            \u0026self.access_control,\n            self.interner,\n            |typ| self.deep_resolve_type(typ),\n        )\n    }\n\n    /// Convert type to string for error messages\n    fn type_to_string(\u0026self, typ: \u0026Type) -\u003e String {\n        match \u0026typ.kind {\n            TypeKind::Primitive(prim) =\u003e format!(\"{:?}\", prim).to_lowercase(),\n            TypeKind::Reference(type_ref) =\u003e self.interner.resolve(type_ref.name.node).to_string(),\n            TypeKind::Array(elem) =\u003e format!(\"{}[]\", self.type_to_string(elem)),\n            TypeKind::Union(types) =\u003e {\n                let type_strings: Vec\u003cString\u003e =\n                    types.iter().map(|t| self.type_to_string(t)).collect();\n                type_strings.join(\" | \")\n            }\n            TypeKind::Function(_) =\u003e \"function\".to_string(),\n            TypeKind::Object(_) =\u003e \"object\".to_string(),\n            _ =\u003e format!(\"{:?}\", typ.kind),\n        }\n    }\n\n    /// Infer the type of an expression\n    /// Delegates to TypeInferrer visitor\n    fn infer_expression_type(\u0026mut self, expr: \u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let mut inferrer = TypeInferrer::new(\n            \u0026mut self.symbol_table,\n            \u0026mut self.type_env,\n            self.narrowing.get_context_mut(),\n            \u0026self.access_control,\n            self.interner,\n            \u0026self.diagnostic_handler,\n        );\n        inferrer.infer_expression(expr)\n    }\n\n    /// Evaluate special type constructs (keyof, mapped types, conditional types, etc.)\n    fn evaluate_type(\u0026self, typ: \u0026Type) -\u003e Result\u003cType, String\u003e {\n        match \u0026typ.kind {\n            TypeKind::KeyOf(operand) =\u003e {\n                // First evaluate the operand recursively\n                let evaluated_operand = self.evaluate_type(operand)?;\n                use crate::types::utility_types::evaluate_keyof;\n                evaluate_keyof(\u0026evaluated_operand, \u0026self.type_env, self.interner)\n            }\n            TypeKind::Mapped(mapped) =\u003e {\n                use crate::types::utility_types::evaluate_mapped_type;\n                evaluate_mapped_type(mapped, \u0026self.type_env, self.interner)\n            }\n            TypeKind::Conditional(conditional) =\u003e {\n                use crate::types::utility_types::evaluate_conditional_type;\n                evaluate_conditional_type(conditional, \u0026self.type_env)\n            }\n            TypeKind::TemplateLiteral(template) =\u003e {\n                use crate::types::utility_types::evaluate_template_literal_type;\n                evaluate_template_literal_type(template, \u0026self.type_env, self.interner)\n            }\n            TypeKind::TypeQuery(expr) =\u003e {\n                // typeof(expression) - Look up the type of the expression\n                // For identifiers, we can look them up directly in the type environment\n                use typedlua_parser::ast::expression::ExpressionKind;\n                match \u0026expr.kind {\n                    ExpressionKind::Identifier(name_id) =\u003e {\n                        let name = self.interner.resolve(*name_id);\n                        match self.type_env.lookup_type(\u0026name) {\n                            Some(t) =\u003e Ok(t.clone()),\n                            None =\u003e match self.symbol_table.lookup(\u0026name) {\n                                Some(symbol) =\u003e Ok(symbol.typ.clone()),\n                                None =\u003e {\n                                    Err(format!(\"Cannot resolve typeof for identifier '{}'\", name))\n                                }\n                            },\n                        }\n                    }\n                    ExpressionKind::Call(callee, _args, _type_args) =\u003e {\n                        // For function calls like typeof(getNumber()),\n                        // look up the return type of the function\n                        if let ExpressionKind::Identifier(name_id) = \u0026callee.kind {\n                            let name = self.interner.resolve(*name_id);\n                            match self.symbol_table.lookup(\u0026name) {\n                                Some(symbol) =\u003e {\n                                    if let TypeKind::Function(func) = \u0026symbol.typ.kind {\n                                        Ok((*func.return_type).clone())\n                                    } else {\n                                        Ok(Type::new(\n                                            TypeKind::Primitive(PrimitiveType::Unknown),\n                                            typ.span,\n                                        ))\n                                    }\n                                }\n                                None =\u003e Err(format!(\"Cannot resolve typeof for call '{}'\", name)),\n                            }\n                        } else {\n                            Ok(Type::new(\n                                TypeKind::Primitive(PrimitiveType::Unknown),\n                                typ.span,\n                            ))\n                        }\n                    }\n                    _ =\u003e Ok(Type::new(\n                        TypeKind::Primitive(PrimitiveType::Unknown),\n                        typ.span,\n                    )),\n                }\n            }\n            TypeKind::Reference(type_ref) =\u003e {\n                // Resolve type reference using the proper resolution logic\n                // This handles utility types, generic types, and regular type aliases\n                // If resolution fails (e.g., type parameter not found), return the reference as-is\n                match self.resolve_type_reference(type_ref) {\n                    Ok(resolved) =\u003e Ok(resolved),\n                    Err(_) =\u003e Ok(typ.clone()), // Return the reference unresolved (might be a type parameter)\n                }\n            }\n            _ =\u003e Ok(typ.clone()),\n        }\n    }\n\n    /// Deeply resolve all type references within a type tree.\n    /// Unlike evaluate_type which only resolves top-level references,\n    /// this recursively walks Object, Union, Nullable, Array, etc.\n    /// and resolves any nested TypeKind::Reference nodes.\n    fn deep_resolve_type(\u0026self, typ: \u0026Type) -\u003e Type {\n        match \u0026typ.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                match self.resolve_type_reference(type_ref) {\n                    Ok(resolved) =\u003e {\n                        // Avoid infinite recursion if resolution returns same reference\n                        if matches!(\u0026resolved.kind, TypeKind::Reference(r) if r.name.node == type_ref.name.node)\n                        {\n                            resolved\n                        } else {\n                            self.deep_resolve_type(\u0026resolved)\n                        }\n                    }\n                    Err(_) =\u003e typ.clone(),\n                }\n            }\n            TypeKind::Object(obj_type) =\u003e {\n                use typedlua_parser::ast::types::ObjectTypeMember;\n                let resolved_members: Vec\u003cObjectTypeMember\u003e = obj_type\n                    .members\n                    .iter()\n                    .map(|member| match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                type_annotation: self.deep_resolve_type(\u0026prop.type_annotation),\n                                ..prop.clone()\n                            })\n                        }\n                        other =\u003e other.clone(),\n                    })\n                    .collect();\n                Type::new(\n                    TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                        members: resolved_members,\n                        span: obj_type.span,\n                    }),\n                    typ.span,\n                )\n            }\n            TypeKind::Union(members) =\u003e {\n                let resolved: Vec\u003cType\u003e =\n                    members.iter().map(|m| self.deep_resolve_type(m)).collect();\n                Type::new(TypeKind::Union(resolved), typ.span)\n            }\n            TypeKind::Nullable(inner) =\u003e {\n                let resolved = self.deep_resolve_type(inner);\n                Type::new(TypeKind::Nullable(Box::new(resolved)), typ.span)\n            }\n            TypeKind::Array(elem) =\u003e {\n                let resolved = self.deep_resolve_type(elem);\n                Type::new(TypeKind::Array(Box::new(resolved)), typ.span)\n            }\n            TypeKind::Tuple(elems) =\u003e {\n                let resolved: Vec\u003cType\u003e = elems.iter().map(|e| self.deep_resolve_type(e)).collect();\n                Type::new(TypeKind::Tuple(resolved), typ.span)\n            }\n            TypeKind::Function(func_type) =\u003e {\n                // Recursively resolve parameter types and return type in function types\n                let resolved_params: Vec\u003ctypedlua_parser::ast::statement::Parameter\u003e = func_type\n                    .parameters\n                    .iter()\n                    .map(|param| typedlua_parser::ast::statement::Parameter {\n                        type_annotation: param\n                            .type_annotation\n                            .as_ref()\n                            .map(|t| self.deep_resolve_type(t)),\n                        ..param.clone()\n                    })\n                    .collect();\n\n                let resolved_return = self.deep_resolve_type(\u0026func_type.return_type);\n\n                Type::new(\n                    TypeKind::Function(typedlua_parser::ast::types::FunctionType {\n                        parameters: resolved_params,\n                        return_type: Box::new(resolved_return),\n                        ..func_type.clone()\n                    }),\n                    typ.span,\n                )\n            }\n            _ =\u003e typ.clone(),\n        }\n    }\n\n    /// Check if source type is assignable to target type via implements relationship.\n    /// For example, Box\u003cnumber\u003e is assignable to Storable\u003cnumber\u003e if Box implements Storable\u003cT\u003e.\n    fn check_implements_assignable(\u0026self, source: \u0026Type, target: \u0026Type) -\u003e bool {\n        phases::validation_phase::check_implements_assignable(\n            source,\n            target,\n            \u0026self.type_env,\n            self.interner,\n        )\n    }\n\n    /// Substitute type parameter references in a type with actual type arguments.\n    /// For a generic interface like Container\u003cT\u003e, given type_args [number],\n    /// replaces references to T with number.\n    fn substitute_type_args_in_type(\n        \u0026self,\n        typ: \u0026Type,\n        type_args: \u0026[Type],\n        interface_name: \u0026str,\n    ) -\u003e Type {\n        match \u0026typ.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                let ref_name = self.interner.resolve(type_ref.name.node).to_string();\n                // Check if this reference matches a type parameter of the interface.\n                // Look up the interface's declared type parameter names and find the\n                // positional index so we substitute with the correct type argument.\n                if let Some(param_names) = self.type_env.get_interface_type_params(interface_name) {\n                    if let Some(pos) = param_names.iter().position(|p| p == \u0026ref_name) {\n                        if pos \u003c type_args.len() {\n                            return type_args[pos].clone();\n                        }\n                    }\n                }\n                // Fallback: if no param names are registered, use heuristic\n                if self.type_env.get_interface(interface_name).is_some()\n                    \u0026\u0026 self.type_env.lookup_type(\u0026ref_name).is_none()\n                    \u0026\u0026 self.type_env.lookup_type_alias(\u0026ref_name).is_none()\n                    \u0026\u0026 !type_args.is_empty()\n                {\n                    return type_args[0].clone();\n                }\n                typ.clone()\n            }\n            TypeKind::Array(elem) =\u003e {\n                let subst = self.substitute_type_args_in_type(elem, type_args, interface_name);\n                Type::new(TypeKind::Array(Box::new(subst)), typ.span)\n            }\n            TypeKind::Nullable(inner) =\u003e {\n                let subst = self.substitute_type_args_in_type(inner, type_args, interface_name);\n                Type::new(TypeKind::Nullable(Box::new(subst)), typ.span)\n            }\n            TypeKind::Union(members) =\u003e {\n                let subst: Vec\u003cType\u003e = members\n                    .iter()\n                    .map(|m| self.substitute_type_args_in_type(m, type_args, interface_name))\n                    .collect();\n                Type::new(TypeKind::Union(subst), typ.span)\n            }\n            _ =\u003e typ.clone(),\n        }\n    }\n\n    /// Widen literal types to their base primitive types\n    fn widen_type(\u0026self, typ: Type) -\u003e Type {\n        type_utilities::widen_type(typ)\n    }\n\n    /// Register a declare function statement in the global scope\n    fn register_declare_function(\n        \u0026mut self,\n        func: \u0026DeclareFunctionStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::declaration_phase::register_declare_function(\n            func,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Register a declare const statement in the global scope\n    fn register_declare_const(\n        \u0026mut self,\n        const_decl: \u0026DeclareConstStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::declaration_phase::register_declare_const(\n            const_decl,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Register a declare namespace statement in the global scope\n    fn register_declare_namespace(\n        \u0026mut self,\n        ns: \u0026DeclareNamespaceStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::declaration_phase::register_declare_namespace(\n            ns,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Register minimal stdlib (fallback when full stdlib fails to parse)\n    pub fn register_minimal_stdlib(\u0026mut self) {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n        use typedlua_parser::ast::types::*;\n        use typedlua_parser::ast::Spanned;\n        use typedlua_parser::span::Span;\n\n        let span = Span::new(0, 0, 0, 0);\n\n        // Register string namespace\n        let string_members = vec![\n            ObjectTypeMember::Method(MethodSignature {\n                name: Spanned::new(self.interner.intern(\"upper\"), span),\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(self.interner.intern(\"s\"), span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Primitive(PrimitiveType::String),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Type::new(TypeKind::Primitive(PrimitiveType::String), span),\n                body: None,\n                span,\n            }),\n            ObjectTypeMember::Method(MethodSignature {\n                name: Spanned::new(self.interner.intern(\"lower\"), span),\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(self.interner.intern(\"s\"), span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Primitive(PrimitiveType::String),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Type::new(TypeKind::Primitive(PrimitiveType::String), span),\n                body: None,\n                span,\n            }),\n        ];\n\n        let string_type = Type::new(\n            TypeKind::Object(ObjectType {\n                members: string_members,\n                span,\n            }),\n            span,\n        );\n\n        let _ = self.symbol_table.declare(Symbol::new(\n            \"string\".to_string(),\n            SymbolKind::Const,\n            string_type,\n            span,\n        ));\n\n        // Register math namespace\n        let math_members = vec![\n            ObjectTypeMember::Property(PropertySignature {\n                is_readonly: true,\n                name: Spanned::new(self.interner.intern(\"pi\"), span),\n                is_optional: false,\n                type_annotation: Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n                span,\n            }),\n            ObjectTypeMember::Method(MethodSignature {\n                name: Spanned::new(self.interner.intern(\"abs\"), span),\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(self.interner.intern(\"x\"), span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n                body: None,\n                span,\n            }),\n        ];\n\n        let math_type = Type::new(\n            TypeKind::Object(ObjectType {\n                members: math_members,\n                span,\n            }),\n            span,\n        );\n\n        let _ = self.symbol_table.declare(Symbol::new(\n            \"math\".to_string(),\n            SymbolKind::Const,\n            math_type,\n            span,\n        ));\n    }\n\n    /// Get a reference to the symbol table for LSP queries\n    pub fn symbol_table(\u0026self) -\u003e \u0026SymbolTable {\n        \u0026self.symbol_table\n    }\n\n    /// Get a reference to the type environment for LSP queries\n    pub fn type_env(\u0026self) -\u003e \u0026TypeEnvironment {\n        \u0026self.type_env\n    }\n\n    /// Lookup a symbol by name in the current scope\n    pub fn lookup_symbol(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbol_table.lookup(name)\n    }\n\n    /// Lookup a type by name\n    pub fn lookup_type(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_env.lookup_type(name)\n    }\n\n    /// Extract exports from a program for module system\n    pub fn extract_exports(\u0026self, program: \u0026Program) -\u003e crate::module_resolver::ModuleExports {\n        // Delegate to module_phase for export extraction\n        phases::module_phase::extract_exports(\n            program,\n            \u0026self.symbol_table,\n            self.interner,\n            self.module_registry.as_ref(),\n            self.module_resolver.as_ref(),\n            self.current_module_id.as_ref(),\n        )\n    }\n\n    fn check_throw_statement(\u0026mut self, stmt: \u0026mut ThrowStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.infer_expression_type(\u0026mut stmt.expression)?;\n        Ok(())\n    }\n\n    fn check_rethrow_statement(\u0026self, span: Span) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::inference_phase::check_rethrow_statement(\u0026self.in_catch_block, span)\n    }\n\n    fn check_import_statement(\u0026mut self, import: \u0026ImportDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to module_phase for import processing\n        phases::module_phase::check_import_statement(\n            import,\n            \u0026mut self.symbol_table,\n            \u0026mut self.type_env,\n            \u0026mut self.access_control,\n            self.interner,\n            \u0026mut self.module_dependencies,\n            self.module_registry.as_ref(),\n            self.module_resolver.as_ref(),\n            self.current_module_id.as_ref(),\n            \u0026self.diagnostic_handler,\n        )\n    }\n\n    /// Get the list of module dependencies tracked during type checking\n    pub fn get_module_dependencies(\u0026self) -\u003e \u0026[std::path::PathBuf] {\n        \u0026self.module_dependencies\n    }\n\n    fn check_namespace_declaration(\n        \u0026mut self,\n        ns: \u0026NamespaceDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        if self.current_namespace.is_some() {\n            return Err(TypeCheckError::new(\n                \"Only one namespace declaration allowed per file\",\n                ns.span,\n            ));\n        }\n\n        let path: Vec\u003cString\u003e = ns\n            .path\n            .iter()\n            .map(|ident| self.interner.resolve(ident.node).to_string())\n            .collect();\n\n        self.current_namespace = Some(path.clone());\n\n        let namespace_type = Type::new(TypeKind::Namespace(path.clone()), ns.span);\n\n        let namespace_name = path\n            .first()\n            .ok_or_else(|| TypeCheckError::new(\"Namespace path cannot be empty\", ns.span))?;\n\n        let symbol = Symbol::new(\n            namespace_name.clone(),\n            SymbolKind::Namespace,\n            namespace_type,\n            ns.span,\n        );\n\n        self.symbol_table\n            .declare(symbol)\n            .map_err(|e| TypeCheckError::new(e, ns.span))?;\n\n        Ok(())\n    }\n\n    fn check_try_statement(\u0026mut self, stmt: \u0026mut TryStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.check_block(\u0026mut stmt.try_block)?;\n\n        for catch_clause in stmt.catch_clauses.iter_mut() {\n            self.check_catch_clause(catch_clause)?;\n        }\n\n        if let Some(finally_block) = \u0026mut stmt.finally_block {\n            self.check_block(finally_block)?;\n        }\n\n        Ok(())\n    }\n\n    fn check_catch_clause(\u0026mut self, clause: \u0026mut CatchClause) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.symbol_table.enter_scope();\n\n        let _catch_var_type = match \u0026clause.pattern {\n            CatchPattern::Untyped { variable, span } =\u003e {\n                let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), *span);\n                let symbol = Symbol::new(\n                    self.interner.resolve(variable.node).to_string(),\n                    SymbolKind::Variable,\n                    any_type.clone(),\n                    *span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, *span))?;\n                any_type\n            }\n            CatchPattern::Typed {\n                variable,\n                type_annotation,\n                span,\n            } =\u003e {\n                let symbol = Symbol::new(\n                    self.interner.resolve(variable.node).to_string(),\n                    SymbolKind::Variable,\n                    type_annotation.clone(),\n                    *span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, *span))?;\n                type_annotation.clone()\n            }\n            CatchPattern::MultiTyped {\n                variable,\n                type_annotations,\n                span,\n            } =\u003e {\n                let union_type = Type::new(TypeKind::Union(type_annotations.clone()), *span);\n                let symbol = Symbol::new(\n                    self.interner.resolve(variable.node).to_string(),\n                    SymbolKind::Variable,\n                    union_type.clone(),\n                    *span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, *span))?;\n                union_type\n            }\n        };\n\n        self.in_catch_block.push(true);\n        let result = self.check_block(\u0026mut clause.body);\n        self.in_catch_block.pop();\n\n        self.symbol_table.exit_scope();\n\n        result\n    }\n\n    /// Check if a class has circular inheritance by walking up the parent chain\n    #[allow(dead_code)]\n    fn has_circular_inheritance(\u0026self, class_name: \u0026str) -\u003e bool {\n        phases::validation_phase::has_circular_inheritance(class_name, \u0026self.class_parents)\n    }\n\n    /// Check if a block always returns (has a return statement on all code paths)\n    fn block_always_returns(\u0026self, block: \u0026Block) -\u003e bool {\n        control_flow::block_always_returns(block, self.interner)\n    }\n\n    /// Check if a statement always returns\n    #[allow(dead_code)]\n    fn statement_always_returns(\u0026self, stmt: \u0026Statement) -\u003e bool {\n        control_flow::statement_always_returns(stmt, self.interner)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::diagnostics::CollectingDiagnosticHandler;\n    use typedlua_parser::lexer::Lexer;\n    use typedlua_parser::parser::Parser;\n\n    fn type_check_source(source: \u0026str) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let (interner, common) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let mut lexer = Lexer::new(source, handler.clone(), \u0026interner);\n        let tokens = lexer.tokenize().expect(\"Lexing failed\");\n        let mut parser = Parser::new(tokens, handler.clone(), \u0026interner, \u0026common);\n        let mut program = parser.parse().expect(\"Parsing failed\");\n\n        let mut type_checker = TypeChecker::new(handler.clone(), \u0026interner, \u0026common);\n        let result = type_checker.check_program(\u0026mut program);\n\n        // Check if there are errors in the diagnostic handler\n        let has_errors = handler\n            .get_diagnostics()\n            .iter()\n            .any(|d| d.level == crate::cli::diagnostics::DiagnosticLevel::Error);\n\n        if has_errors {\n            Err(TypeCheckError::new(\n                \"Type checking failed with errors\",\n                Default::default(),\n            ))\n        } else {\n            result\n        }\n    }\n\n    /// Type check source code with stdlib loaded (for tests that need stdlib)\n    fn type_check_source_with_stdlib(source: \u0026str) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let (interner, common) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let mut lexer = Lexer::new(source, handler.clone(), \u0026interner);\n        let tokens = lexer.tokenize().expect(\"Lexing failed\");\n        let mut parser = Parser::new(tokens, handler.clone(), \u0026interner, \u0026common);\n        let mut program = parser.parse().expect(\"Parsing failed\");\n\n        let mut type_checker = TypeChecker::new_with_stdlib(handler.clone(), \u0026interner, \u0026common)\n            .expect(\"Failed to load stdlib\");\n        let result = type_checker.check_program(\u0026mut program);\n\n        // Check if there are errors in the diagnostic handler\n        let has_errors = handler\n            .get_diagnostics()\n            .iter()\n            .any(|d| d.level == crate::cli::diagnostics::DiagnosticLevel::Error);\n\n        if has_errors {\n            Err(TypeCheckError::new(\n                \"Type checking failed with errors\",\n                Default::default(),\n            ))\n        } else {\n            result\n        }\n    }\n\n    #[test]\n    fn test_simple_variable_declaration() {\n        let source = \"const x: number = 42\";\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_type_mismatch() {\n        let source = \"const x: string = 42\";\n        assert!(type_check_source(source).is_err());\n    }\n\n    #[test]\n    fn test_type_inference() {\n        let source = \"const x = 42\";\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_object_literal_inference() {\n        // First test: just declare the object\n        let source1 = \"const obj = {x: 10, y: 20}\\n\";\n        let result1 = type_check_source(source1);\n        if let Err(e) = \u0026result1 {\n            eprintln!(\" Error declaring object: {}\", e.message);\n        }\n        assert!(result1.is_ok(), \"Should be able to declare object literal\");\n\n        // Second test: declare and use\n        let source2 = \"const obj = {x: 10, y: 20}\\nconst a = obj.x\\n\";\n        let result2 = type_check_source(source2);\n        if let Err(e) = \u0026result2 {\n            eprintln!(\" Error using object: {}\", e.message);\n        }\n        assert!(result2.is_ok(), \"Should be able to use object properties\");\n    }\n\n    #[test]\n    fn test_function_type_checking() {\n        let source = r#\"\n            function add(a: number, b: number): number\n                return a + b\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_undefined_variable() {\n        let source = \"const x = y\";\n        assert!(type_check_source(source).is_err());\n    }\n\n    #[test]\n    fn test_narrowing_nil_check() {\n        // Test that nil checks narrow types correctly in if statements\n        let source = r#\"\n            function processValue(x: string | nil)\n                if x != nil then\n                    -- x should be narrowed to string here\n                    local y: string = x\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_narrowing_multiple_branches() {\n        // Test narrowing with multiple if branches\n        let source = r#\"\n            function processOptional(x: string | nil)\n                if x != nil then\n                    local s: string = x\n                end\n\n                local y: string | nil = \"test\"\n                if y != nil then\n                    local s2: string = y\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_narrowing_nested_if() {\n        // Test narrowing in nested if statements\n        let source = r#\"\n            function processNested(a: string | nil, b: number | nil)\n                if a != nil then\n                    local x: string = a\n                    if b != nil then\n                        local y: number = b\n                    end\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_narrowing_else_branch() {\n        // Test that else branch gets the complementary narrowing\n        let source = r#\"\n            function checkNil(x: string | nil)\n                if x == nil then\n                    -- In then branch, x is nil, just use it\n                    local temp = x\n                else\n                    -- In else branch, x is narrowed to string\n                    local s: string = x\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_type_predicate_valid_parameter() {\n        // Test that type predicates accept valid parameter names\n        let source = r#\"\n            function isString(x: string | number): x is string\n                return true\n            end\n        \"#;\n        let result = type_check_source(source);\n        if let Err(e) = \u0026result {\n            eprintln!(\"Unexpected error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_type_predicate_invalid_parameter() {\n        // Test that type predicates reject invalid parameter names\n        let source = r#\"\n            function isString(x: string | number): y is string\n                return true\n            end\n        \"#;\n        let result = type_check_source(source);\n        assert!(\n            result.is_err(),\n            \"Expected error for type predicate with invalid parameter name\"\n        );\n        if let Err(e) = result {\n            assert!(\n                e.message.contains(\"Type predicate parameter\"),\n                \"Expected error message about type predicate parameter, got: {}\",\n                e.message\n            );\n        }\n    }\n\n    #[test]\n    fn test_narrowing_double_nil_check() {\n        // Test nil narrowing with two variables\n        let source = r#\"\n            function process(a: string | nil, b: number | nil)\n                if a != nil then\n                    local x: string = a\n                end\n                if b != nil then\n                    local y: number = b\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_basic() {\n        let source = r#\"\n            class Animal\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_with_property() {\n        let source = r#\"\n            class Person\n                name: string\n                age: number = 25\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    // Property type checking is working but literal \"25\" vs number\n    // compatibility depends on the type compatibility implementation\n    // The test would pass with stricter type checking\n\n    #[test]\n    fn test_class_with_constructor() {\n        let source = r#\"\n            class Person\n                constructor(name: string, age: number)\n                    self.name = name\n                    self.age = age\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_multiple_constructors() {\n        let source = r#\"\n            class Person {\n                constructor(name: string) {\n                }\n\n                constructor(name: string, age: number) {\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(e.message.contains(\"one constructor\"));\n        }\n    }\n\n    #[test]\n    fn test_class_with_method() {\n        let source = r#\"\n            class Calculator {\n                add(a: number, b: number): number {\n                    return a + b\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_abstract_class() {\n        let source = r#\"\n            abstract class Animal {\n                abstract makeSound(): string;\n\n                move(): void {\n                    const x: number = 5\n                }\n            }\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_abstract_method_in_concrete_class() {\n        let source = r#\"\n            class Animal\n                abstract makeSound(): string;\n            end\n        \"#;\n        let result = type_check_source(source);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(e.message.contains(\"abstract class\"));\n        }\n    }\n\n    #[test]\n    fn test_abstract_method_with_body() {\n        // This test just verifies abstract methods work correctly\n        // The parser prevents abstract methods from having bodies by design\n        let source = r#\"\n            abstract class Animal {\n                abstract makeSound(): string;\n\n                concrete(): void {\n                    const x: number = 5\n                }\n            }\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_with_getter() {\n        let source = r#\"\n            class Person\n                get fullName(): string\n                    return \"John Doe\"\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_with_setter() {\n        let source = r#\"\n            class Person\n                set age(value: number)\n                    self._age = value\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    // Getter return type checking depends on literal vs primitive type compatibility\n\n    #[test]\n    fn test_generic_class() {\n        let source = r#\"\n            class Container\u003cT\u003e {\n                value: T\n\n                constructor(val: T) {\n                    const temp: T = val\n                }\n\n                getValue(defaultVal: T): T {\n                    return defaultVal\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_class_implements_interface() {\n        let source = r#\"\n            interface Walkable {\n                walk(): void\n            }\n\n            class Person implements Walkable {\n                walk(): void {\n                    const x: number = 5\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_class_missing_interface_method() {\n        let source = r#\"\n            interface Walkable {\n                walk(): void\n            }\n\n            class Person implements Walkable {\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(e.message.contains(\"does not implement\"));\n        }\n    }\n\n    #[test]\n    fn test_class_static_method() {\n        let source = r#\"\n            class Math\n                static abs(x: number): number\n                    if x \u003c 0 then\n                        return -x\n                    else\n                        return x\n                    end\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_stdlib_builtins_loaded() {\n        // Test that built-in functions are available\n        let source = r#\"\n            const x = print(\"Hello\")\n            const y = tonumber(\"42\")\n        \"#;\n        let result = type_check_source_with_stdlib(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(\n            result.is_ok(),\n            \"Built-in functions should be available from stdlib\"\n        );\n    }\n\n    #[test]\n    fn test_stdlib_string_library() {\n        // Test that string library functions are available\n        let source = r#\"\n            const upper = string.upper(\"hello\")\n            const lower = string.lower(\"WORLD\")\n        \"#;\n        let result = type_check_source_with_stdlib(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(\n            result.is_ok(),\n            \"String library should be available from stdlib\"\n        );\n    }\n\n    #[test]\n    fn test_stdlib_math_library() {\n        // Test that math library constants and functions are available\n        let source = r#\"\n            const p = math.pi\n            const result = math.abs(-5)\n        \"#;\n        let result = type_check_source_with_stdlib(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(\n            result.is_ok(),\n            \"Math library should be available from stdlib\"\n        );\n    }\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":284}},{"line":75,"address":[],"length":0,"stats":{"Line":568}},{"line":76,"address":[],"length":0,"stats":{"Line":568}},{"line":78,"address":[],"length":0,"stats":{"Line":568}},{"line":79,"address":[],"length":0,"stats":{"Line":568}},{"line":80,"address":[],"length":0,"stats":{"Line":568}},{"line":84,"address":[],"length":0,"stats":{"Line":568}},{"line":85,"address":[],"length":0,"stats":{"Line":568}},{"line":87,"address":[],"length":0,"stats":{"Line":568}},{"line":88,"address":[],"length":0,"stats":{"Line":568}},{"line":89,"address":[],"length":0,"stats":{"Line":568}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":15}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":12}},{"line":180,"address":[],"length":0,"stats":{"Line":21}},{"line":181,"address":[],"length":0,"stats":{"Line":423}},{"line":183,"address":[],"length":0,"stats":{"Line":276}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":284}},{"line":193,"address":[],"length":0,"stats":{"Line":568}},{"line":194,"address":[],"length":0,"stats":{"Line":284}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":852}},{"line":200,"address":[],"length":0,"stats":{"Line":284}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1029}},{"line":208,"address":[],"length":0,"stats":{"Line":499}},{"line":209,"address":[],"length":0,"stats":{"Line":115}},{"line":213,"address":[],"length":0,"stats":{"Line":283}},{"line":216,"address":[],"length":0,"stats":{"Line":849}},{"line":217,"address":[],"length":0,"stats":{"Line":566}},{"line":218,"address":[],"length":0,"stats":{"Line":1026}},{"line":219,"address":[],"length":0,"stats":{"Line":929}},{"line":220,"address":[],"length":0,"stats":{"Line":27}},{"line":221,"address":[],"length":0,"stats":{"Line":9}},{"line":224,"address":[],"length":0,"stats":{"Line":460}},{"line":227,"address":[],"length":0,"stats":{"Line":283}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":292}},{"line":233,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":9}},{"line":236,"address":[],"length":0,"stats":{"Line":274}},{"line":237,"address":[],"length":0,"stats":{"Line":274}},{"line":243,"address":[],"length":0,"stats":{"Line":38}},{"line":249,"address":[],"length":0,"stats":{"Line":38}},{"line":250,"address":[],"length":0,"stats":{"Line":38}},{"line":251,"address":[],"length":0,"stats":{"Line":38}},{"line":257,"address":[],"length":0,"stats":{"Line":705}},{"line":258,"address":[],"length":0,"stats":{"Line":1410}},{"line":259,"address":[],"length":0,"stats":{"Line":182}},{"line":260,"address":[],"length":0,"stats":{"Line":37}},{"line":261,"address":[],"length":0,"stats":{"Line":16}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":49}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":24}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":28}},{"line":271,"address":[],"length":0,"stats":{"Line":169}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":43}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":91}},{"line":283,"address":[],"length":0,"stats":{"Line":31}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":9}},{"line":286,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":1410}},{"line":291,"address":[],"length":0,"stats":{"Line":705}},{"line":292,"address":[],"length":0,"stats":{"Line":728}},{"line":293,"address":[],"length":0,"stats":{"Line":148}},{"line":294,"address":[],"length":0,"stats":{"Line":64}},{"line":295,"address":[],"length":0,"stats":{"Line":20}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":196}},{"line":299,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":24}},{"line":301,"address":[],"length":0,"stats":{"Line":72}},{"line":302,"address":[],"length":0,"stats":{"Line":24}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":112}},{"line":306,"address":[],"length":0,"stats":{"Line":676}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":172}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":16}},{"line":312,"address":[],"length":0,"stats":{"Line":364}},{"line":313,"address":[],"length":0,"stats":{"Line":124}},{"line":314,"address":[],"length":0,"stats":{"Line":16}},{"line":315,"address":[],"length":0,"stats":{"Line":36}},{"line":316,"address":[],"length":0,"stats":{"Line":24}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":329,"address":[],"length":0,"stats":{"Line":182}},{"line":334,"address":[],"length":0,"stats":{"Line":728}},{"line":337,"address":[],"length":0,"stats":{"Line":449}},{"line":339,"address":[],"length":0,"stats":{"Line":178}},{"line":340,"address":[],"length":0,"stats":{"Line":178}},{"line":341,"address":[],"length":0,"stats":{"Line":89}},{"line":345,"address":[],"length":0,"stats":{"Line":356}},{"line":346,"address":[],"length":0,"stats":{"Line":356}},{"line":349,"address":[],"length":0,"stats":{"Line":178}},{"line":353,"address":[],"length":0,"stats":{"Line":64}},{"line":354,"address":[],"length":0,"stats":{"Line":48}},{"line":355,"address":[],"length":0,"stats":{"Line":32}},{"line":356,"address":[],"length":0,"stats":{"Line":16}},{"line":357,"address":[],"length":0,"stats":{"Line":16}},{"line":358,"address":[],"length":0,"stats":{"Line":16}},{"line":363,"address":[],"length":0,"stats":{"Line":89}},{"line":366,"address":[],"length":0,"stats":{"Line":172}},{"line":367,"address":[],"length":0,"stats":{"Line":10}},{"line":369,"address":[],"length":0,"stats":{"Line":243}},{"line":374,"address":[],"length":0,"stats":{"Line":360}},{"line":375,"address":[],"length":0,"stats":{"Line":17}},{"line":376,"address":[],"length":0,"stats":{"Line":163}},{"line":379,"address":[],"length":0,"stats":{"Line":1081}},{"line":381,"address":[],"length":0,"stats":{"Line":179}},{"line":385,"address":[],"length":0,"stats":{"Line":252}},{"line":394,"address":[],"length":0,"stats":{"Line":252}},{"line":395,"address":[],"length":0,"stats":{"Line":252}},{"line":396,"address":[],"length":0,"stats":{"Line":252}},{"line":397,"address":[],"length":0,"stats":{"Line":252}},{"line":398,"address":[],"length":0,"stats":{"Line":252}},{"line":399,"address":[],"length":0,"stats":{"Line":252}},{"line":404,"address":[],"length":0,"stats":{"Line":37}},{"line":413,"address":[],"length":0,"stats":{"Line":74}},{"line":417,"address":[],"length":0,"stats":{"Line":74}},{"line":418,"address":[],"length":0,"stats":{"Line":37}},{"line":419,"address":[],"length":0,"stats":{"Line":37}},{"line":423,"address":[],"length":0,"stats":{"Line":172}},{"line":425,"address":[],"length":0,"stats":{"Line":51}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":98}},{"line":434,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":3}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":3}},{"line":448,"address":[],"length":0,"stats":{"Line":96}},{"line":450,"address":[],"length":0,"stats":{"Line":96}},{"line":451,"address":[],"length":0,"stats":{"Line":96}},{"line":452,"address":[],"length":0,"stats":{"Line":48}},{"line":453,"address":[],"length":0,"stats":{"Line":48}},{"line":455,"address":[],"length":0,"stats":{"Line":144}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":98}},{"line":461,"address":[],"length":0,"stats":{"Line":49}},{"line":462,"address":[],"length":0,"stats":{"Line":49}},{"line":463,"address":[],"length":0,"stats":{"Line":49}},{"line":464,"address":[],"length":0,"stats":{"Line":49}},{"line":469,"address":[],"length":0,"stats":{"Line":111}},{"line":470,"address":[],"length":0,"stats":{"Line":180}},{"line":471,"address":[],"length":0,"stats":{"Line":160}},{"line":472,"address":[],"length":0,"stats":{"Line":96}},{"line":474,"address":[],"length":0,"stats":{"Line":74}},{"line":477,"address":[],"length":0,"stats":{"Line":148}},{"line":480,"address":[],"length":0,"stats":{"Line":74}},{"line":481,"address":[],"length":0,"stats":{"Line":69}},{"line":483,"address":[],"length":0,"stats":{"Line":64}},{"line":484,"address":[],"length":0,"stats":{"Line":16}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":96}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":74}},{"line":505,"address":[],"length":0,"stats":{"Line":49}},{"line":506,"address":[],"length":0,"stats":{"Line":57}},{"line":507,"address":[],"length":0,"stats":{"Line":75}},{"line":508,"address":[],"length":0,"stats":{"Line":60}},{"line":509,"address":[],"length":0,"stats":{"Line":30}},{"line":514,"address":[],"length":0,"stats":{"Line":74}},{"line":516,"address":[],"length":0,"stats":{"Line":37}},{"line":520,"address":[],"length":0,"stats":{"Line":16}},{"line":522,"address":[],"length":0,"stats":{"Line":48}},{"line":526,"address":[],"length":0,"stats":{"Line":32}},{"line":527,"address":[],"length":0,"stats":{"Line":137}},{"line":528,"address":[],"length":0,"stats":{"Line":175}},{"line":529,"address":[],"length":0,"stats":{"Line":140}},{"line":533,"address":[],"length":0,"stats":{"Line":80}},{"line":534,"address":[],"length":0,"stats":{"Line":32}},{"line":535,"address":[],"length":0,"stats":{"Line":32}},{"line":536,"address":[],"length":0,"stats":{"Line":16}},{"line":537,"address":[],"length":0,"stats":{"Line":16}},{"line":541,"address":[],"length":0,"stats":{"Line":48}},{"line":542,"address":[],"length":0,"stats":{"Line":32}},{"line":543,"address":[],"length":0,"stats":{"Line":48}},{"line":546,"address":[],"length":0,"stats":{"Line":48}},{"line":549,"address":[],"length":0,"stats":{"Line":34}},{"line":550,"address":[],"length":0,"stats":{"Line":6}},{"line":553,"address":[],"length":0,"stats":{"Line":10}},{"line":554,"address":[],"length":0,"stats":{"Line":4}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":2}},{"line":560,"address":[],"length":0,"stats":{"Line":4}},{"line":561,"address":[],"length":0,"stats":{"Line":6}},{"line":562,"address":[],"length":0,"stats":{"Line":4}},{"line":566,"address":[],"length":0,"stats":{"Line":20}},{"line":567,"address":[],"length":0,"stats":{"Line":12}},{"line":571,"address":[],"length":0,"stats":{"Line":32}},{"line":573,"address":[],"length":0,"stats":{"Line":16}},{"line":577,"address":[],"length":0,"stats":{"Line":5}},{"line":581,"address":[],"length":0,"stats":{"Line":15}},{"line":582,"address":[],"length":0,"stats":{"Line":15}},{"line":583,"address":[],"length":0,"stats":{"Line":5}},{"line":587,"address":[],"length":0,"stats":{"Line":2}},{"line":588,"address":[],"length":0,"stats":{"Line":2}},{"line":589,"address":[],"length":0,"stats":{"Line":2}},{"line":590,"address":[],"length":0,"stats":{"Line":4}},{"line":593,"address":[],"length":0,"stats":{"Line":2}},{"line":594,"address":[],"length":0,"stats":{"Line":6}},{"line":596,"address":[],"length":0,"stats":{"Line":6}},{"line":597,"address":[],"length":0,"stats":{"Line":2}},{"line":598,"address":[],"length":0,"stats":{"Line":2}},{"line":599,"address":[],"length":0,"stats":{"Line":2}},{"line":601,"address":[],"length":0,"stats":{"Line":2}},{"line":602,"address":[],"length":0,"stats":{"Line":4}},{"line":603,"address":[],"length":0,"stats":{"Line":2}},{"line":606,"address":[],"length":0,"stats":{"Line":6}},{"line":607,"address":[],"length":0,"stats":{"Line":6}},{"line":608,"address":[],"length":0,"stats":{"Line":2}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":6}},{"line":613,"address":[],"length":0,"stats":{"Line":4}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":2}},{"line":647,"address":[],"length":0,"stats":{"Line":1}},{"line":651,"address":[],"length":0,"stats":{"Line":2}},{"line":652,"address":[],"length":0,"stats":{"Line":3}},{"line":653,"address":[],"length":0,"stats":{"Line":3}},{"line":654,"address":[],"length":0,"stats":{"Line":2}},{"line":655,"address":[],"length":0,"stats":{"Line":1}},{"line":659,"address":[],"length":0,"stats":{"Line":49}},{"line":663,"address":[],"length":0,"stats":{"Line":49}},{"line":665,"address":[],"length":0,"stats":{"Line":147}},{"line":666,"address":[],"length":0,"stats":{"Line":49}},{"line":668,"address":[],"length":0,"stats":{"Line":199}},{"line":670,"address":[],"length":0,"stats":{"Line":98}},{"line":673,"address":[],"length":0,"stats":{"Line":98}},{"line":674,"address":[],"length":0,"stats":{"Line":96}},{"line":676,"address":[],"length":0,"stats":{"Line":3}},{"line":680,"address":[],"length":0,"stats":{"Line":97}},{"line":682,"address":[],"length":0,"stats":{"Line":48}},{"line":683,"address":[],"length":0,"stats":{"Line":95}},{"line":685,"address":[],"length":0,"stats":{"Line":1}},{"line":686,"address":[],"length":0,"stats":{"Line":1}},{"line":689,"address":[],"length":0,"stats":{"Line":94}},{"line":692,"address":[],"length":0,"stats":{"Line":96}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":49}},{"line":717,"address":[],"length":0,"stats":{"Line":102}},{"line":718,"address":[],"length":0,"stats":{"Line":204}},{"line":719,"address":[],"length":0,"stats":{"Line":306}},{"line":720,"address":[],"length":0,"stats":{"Line":316}},{"line":721,"address":[],"length":0,"stats":{"Line":214}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":204}},{"line":728,"address":[],"length":0,"stats":{"Line":102}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":102}},{"line":736,"address":[],"length":0,"stats":{"Line":37}},{"line":741,"address":[],"length":0,"stats":{"Line":72}},{"line":743,"address":[],"length":0,"stats":{"Line":37}},{"line":744,"address":[],"length":0,"stats":{"Line":37}},{"line":745,"address":[],"length":0,"stats":{"Line":37}},{"line":746,"address":[],"length":0,"stats":{"Line":37}},{"line":747,"address":[],"length":0,"stats":{"Line":37}},{"line":751,"address":[],"length":0,"stats":{"Line":36}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":36}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":173}},{"line":791,"address":[],"length":0,"stats":{"Line":519}},{"line":793,"address":[],"length":0,"stats":{"Line":441}},{"line":794,"address":[],"length":0,"stats":{"Line":147}},{"line":797,"address":[],"length":0,"stats":{"Line":26}},{"line":802,"address":[],"length":0,"stats":{"Line":173}},{"line":803,"address":[],"length":0,"stats":{"Line":173}},{"line":804,"address":[],"length":0,"stats":{"Line":173}},{"line":805,"address":[],"length":0,"stats":{"Line":173}},{"line":806,"address":[],"length":0,"stats":{"Line":173}},{"line":811,"address":[],"length":0,"stats":{"Line":4}},{"line":813,"address":[],"length":0,"stats":{"Line":4}},{"line":814,"address":[],"length":0,"stats":{"Line":3}},{"line":816,"address":[],"length":0,"stats":{"Line":6}},{"line":817,"address":[],"length":0,"stats":{"Line":1}},{"line":819,"address":[],"length":0,"stats":{"Line":1}},{"line":820,"address":[],"length":0,"stats":{"Line":1}},{"line":821,"address":[],"length":0,"stats":{"Line":2}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":2}},{"line":827,"address":[],"length":0,"stats":{"Line":4}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":6}},{"line":846,"address":[],"length":0,"stats":{"Line":9}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":1}},{"line":856,"address":[],"length":0,"stats":{"Line":3}},{"line":857,"address":[],"length":0,"stats":{"Line":2}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":3}},{"line":862,"address":[],"length":0,"stats":{"Line":3}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":4}},{"line":883,"address":[],"length":0,"stats":{"Line":3}},{"line":887,"address":[],"length":0,"stats":{"Line":3}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":3}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":1}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":1}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":1}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":173}},{"line":1048,"address":[],"length":0,"stats":{"Line":692}},{"line":1049,"address":[],"length":0,"stats":{"Line":346}},{"line":1051,"address":[],"length":0,"stats":{"Line":346}},{"line":1054,"address":[],"length":0,"stats":{"Line":220}},{"line":1055,"address":[],"length":0,"stats":{"Line":94}},{"line":1057,"address":[],"length":0,"stats":{"Line":66}},{"line":1059,"address":[],"length":0,"stats":{"Line":55}},{"line":1060,"address":[],"length":0,"stats":{"Line":99}},{"line":1061,"address":[],"length":0,"stats":{"Line":33}},{"line":1064,"address":[],"length":0,"stats":{"Line":44}},{"line":1066,"address":[],"length":0,"stats":{"Line":22}},{"line":1067,"address":[],"length":0,"stats":{"Line":22}},{"line":1068,"address":[],"length":0,"stats":{"Line":132}},{"line":1069,"address":[],"length":0,"stats":{"Line":22}},{"line":1073,"address":[],"length":0,"stats":{"Line":66}},{"line":1075,"address":[],"length":0,"stats":{"Line":16}},{"line":1076,"address":[],"length":0,"stats":{"Line":16}},{"line":1077,"address":[],"length":0,"stats":{"Line":16}},{"line":1078,"address":[],"length":0,"stats":{"Line":16}},{"line":1080,"address":[],"length":0,"stats":{"Line":16}},{"line":1085,"address":[],"length":0,"stats":{"Line":270}},{"line":1086,"address":[],"length":0,"stats":{"Line":224}},{"line":1087,"address":[],"length":0,"stats":{"Line":46}},{"line":1088,"address":[],"length":0,"stats":{"Line":46}},{"line":1089,"address":[],"length":0,"stats":{"Line":23}},{"line":1096,"address":[],"length":0,"stats":{"Line":43}},{"line":1100,"address":[],"length":0,"stats":{"Line":172}},{"line":1101,"address":[],"length":0,"stats":{"Line":86}},{"line":1103,"address":[],"length":0,"stats":{"Line":43}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":129}},{"line":1111,"address":[],"length":0,"stats":{"Line":43}},{"line":1115,"address":[],"length":0,"stats":{"Line":43}},{"line":1116,"address":[],"length":0,"stats":{"Line":43}},{"line":1117,"address":[],"length":0,"stats":{"Line":43}},{"line":1118,"address":[],"length":0,"stats":{"Line":43}},{"line":1119,"address":[],"length":0,"stats":{"Line":43}},{"line":1123,"address":[],"length":0,"stats":{"Line":86}},{"line":1128,"address":[],"length":0,"stats":{"Line":86}},{"line":1129,"address":[],"length":0,"stats":{"Line":43}},{"line":1130,"address":[],"length":0,"stats":{"Line":43}},{"line":1134,"address":[],"length":0,"stats":{"Line":51}},{"line":1136,"address":[],"length":0,"stats":{"Line":8}},{"line":1137,"address":[],"length":0,"stats":{"Line":8}},{"line":1138,"address":[],"length":0,"stats":{"Line":8}},{"line":1139,"address":[],"length":0,"stats":{"Line":8}},{"line":1140,"address":[],"length":0,"stats":{"Line":8}},{"line":1141,"address":[],"length":0,"stats":{"Line":8}},{"line":1148,"address":[],"length":0,"stats":{"Line":84}},{"line":1149,"address":[],"length":0,"stats":{"Line":84}},{"line":1150,"address":[],"length":0,"stats":{"Line":42}},{"line":1151,"address":[],"length":0,"stats":{"Line":42}},{"line":1152,"address":[],"length":0,"stats":{"Line":42}},{"line":1156,"address":[],"length":0,"stats":{"Line":49}},{"line":1157,"address":[],"length":0,"stats":{"Line":8}},{"line":1158,"address":[],"length":0,"stats":{"Line":16}},{"line":1159,"address":[],"length":0,"stats":{"Line":12}},{"line":1161,"address":[],"length":0,"stats":{"Line":8}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":8}},{"line":1173,"address":[],"length":0,"stats":{"Line":17}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":82}},{"line":1190,"address":[],"length":0,"stats":{"Line":41}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[],"length":0,"stats":{"Line":41}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1251,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":82}},{"line":1278,"address":[],"length":0,"stats":{"Line":41}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1280,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1292,"address":[],"length":0,"stats":{"Line":41}},{"line":1293,"address":[],"length":0,"stats":{"Line":41}},{"line":1295,"address":[],"length":0,"stats":{"Line":123}},{"line":1298,"address":[],"length":0,"stats":{"Line":171}},{"line":1299,"address":[],"length":0,"stats":{"Line":14}},{"line":1300,"address":[],"length":0,"stats":{"Line":14}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":41}},{"line":1308,"address":[],"length":0,"stats":{"Line":164}},{"line":1309,"address":[],"length":0,"stats":{"Line":206}},{"line":1310,"address":[],"length":0,"stats":{"Line":110}},{"line":1311,"address":[],"length":0,"stats":{"Line":110}},{"line":1315,"address":[],"length":0,"stats":{"Line":41}},{"line":1316,"address":[],"length":0,"stats":{"Line":123}},{"line":1319,"address":[],"length":0,"stats":{"Line":123}},{"line":1320,"address":[],"length":0,"stats":{"Line":123}},{"line":1321,"address":[],"length":0,"stats":{"Line":164}},{"line":1322,"address":[],"length":0,"stats":{"Line":82}},{"line":1323,"address":[],"length":0,"stats":{"Line":41}},{"line":1330,"address":[],"length":0,"stats":{"Line":82}},{"line":1331,"address":[],"length":0,"stats":{"Line":82}},{"line":1332,"address":[],"length":0,"stats":{"Line":123}},{"line":1334,"address":[],"length":0,"stats":{"Line":146}},{"line":1335,"address":[],"length":0,"stats":{"Line":128}},{"line":1336,"address":[],"length":0,"stats":{"Line":92}},{"line":1337,"address":[],"length":0,"stats":{"Line":9}},{"line":1338,"address":[],"length":0,"stats":{"Line":9}},{"line":1339,"address":[],"length":0,"stats":{"Line":1}},{"line":1340,"address":[],"length":0,"stats":{"Line":1}},{"line":1341,"address":[],"length":0,"stats":{"Line":1}},{"line":1344,"address":[],"length":0,"stats":{"Line":8}},{"line":1345,"address":[],"length":0,"stats":{"Line":24}},{"line":1348,"address":[],"length":0,"stats":{"Line":28}},{"line":1349,"address":[],"length":0,"stats":{"Line":28}},{"line":1350,"address":[],"length":0,"stats":{"Line":5}},{"line":1351,"address":[],"length":0,"stats":{"Line":2}},{"line":1352,"address":[],"length":0,"stats":{"Line":2}},{"line":1353,"address":[],"length":0,"stats":{"Line":1}},{"line":1354,"address":[],"length":0,"stats":{"Line":1}},{"line":1356,"address":[],"length":0,"stats":{"Line":1}},{"line":1359,"address":[],"length":0,"stats":{"Line":4}},{"line":1360,"address":[],"length":0,"stats":{"Line":16}},{"line":1361,"address":[],"length":0,"stats":{"Line":12}},{"line":1364,"address":[],"length":0,"stats":{"Line":69}},{"line":1367,"address":[],"length":0,"stats":{"Line":8}},{"line":1368,"address":[],"length":0,"stats":{"Line":8}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":66}},{"line":1373,"address":[],"length":0,"stats":{"Line":6}},{"line":1374,"address":[],"length":0,"stats":{"Line":2}},{"line":1380,"address":[],"length":0,"stats":{"Line":123}},{"line":1383,"address":[],"length":0,"stats":{"Line":82}},{"line":1386,"address":[],"length":0,"stats":{"Line":47}},{"line":1387,"address":[],"length":0,"stats":{"Line":24}},{"line":1388,"address":[],"length":0,"stats":{"Line":30}},{"line":1389,"address":[],"length":0,"stats":{"Line":12}},{"line":1394,"address":[],"length":0,"stats":{"Line":41}},{"line":1395,"address":[],"length":0,"stats":{"Line":44}},{"line":1396,"address":[],"length":0,"stats":{"Line":14}},{"line":1397,"address":[],"length":0,"stats":{"Line":28}},{"line":1399,"address":[],"length":0,"stats":{"Line":14}},{"line":1400,"address":[],"length":0,"stats":{"Line":7}},{"line":1401,"address":[],"length":0,"stats":{"Line":7}},{"line":1402,"address":[],"length":0,"stats":{"Line":7}},{"line":1411,"address":[],"length":0,"stats":{"Line":43}},{"line":1412,"address":[],"length":0,"stats":{"Line":4}},{"line":1413,"address":[],"length":0,"stats":{"Line":2}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[],"length":0,"stats":{"Line":39}},{"line":1427,"address":[],"length":0,"stats":{"Line":4}},{"line":1433,"address":[],"length":0,"stats":{"Line":4}},{"line":1434,"address":[],"length":0,"stats":{"Line":4}},{"line":1435,"address":[],"length":0,"stats":{"Line":4}},{"line":1436,"address":[],"length":0,"stats":{"Line":4}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":7}},{"line":1458,"address":[],"length":0,"stats":{"Line":7}},{"line":1459,"address":[],"length":0,"stats":{"Line":7}},{"line":1460,"address":[],"length":0,"stats":{"Line":7}},{"line":1461,"address":[],"length":0,"stats":{"Line":7}},{"line":1462,"address":[],"length":0,"stats":{"Line":7}},{"line":1467,"address":[],"length":0,"stats":{"Line":97}},{"line":1472,"address":[],"length":0,"stats":{"Line":97}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":194}},{"line":1481,"address":[],"length":0,"stats":{"Line":194}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":194}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":97}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[],"length":0,"stats":{"Line":23}},{"line":1569,"address":[],"length":0,"stats":{"Line":69}},{"line":1572,"address":[],"length":0,"stats":{"Line":38}},{"line":1573,"address":[],"length":0,"stats":{"Line":60}},{"line":1576,"address":[],"length":0,"stats":{"Line":30}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":23}},{"line":1591,"address":[],"length":0,"stats":{"Line":8}},{"line":1596,"address":[],"length":0,"stats":{"Line":16}},{"line":1599,"address":[],"length":0,"stats":{"Line":16}},{"line":1601,"address":[],"length":0,"stats":{"Line":16}},{"line":1602,"address":[],"length":0,"stats":{"Line":16}},{"line":1603,"address":[],"length":0,"stats":{"Line":8}},{"line":1604,"address":[],"length":0,"stats":{"Line":16}},{"line":1605,"address":[],"length":0,"stats":{"Line":32}},{"line":1606,"address":[],"length":0,"stats":{"Line":16}},{"line":1608,"address":[],"length":0,"stats":{"Line":8}},{"line":1609,"address":[],"length":0,"stats":{"Line":8}},{"line":1611,"address":[],"length":0,"stats":{"Line":8}},{"line":1613,"address":[],"length":0,"stats":{"Line":16}},{"line":1614,"address":[],"length":0,"stats":{"Line":16}},{"line":1615,"address":[],"length":0,"stats":{"Line":8}},{"line":1616,"address":[],"length":0,"stats":{"Line":8}},{"line":1617,"address":[],"length":0,"stats":{"Line":8}},{"line":1619,"address":[],"length":0,"stats":{"Line":8}},{"line":1620,"address":[],"length":0,"stats":{"Line":16}},{"line":1621,"address":[],"length":0,"stats":{"Line":8}},{"line":1625,"address":[],"length":0,"stats":{"Line":28}},{"line":1626,"address":[],"length":0,"stats":{"Line":30}},{"line":1628,"address":[],"length":0,"stats":{"Line":20}},{"line":1629,"address":[],"length":0,"stats":{"Line":20}},{"line":1630,"address":[],"length":0,"stats":{"Line":10}},{"line":1631,"address":[],"length":0,"stats":{"Line":10}},{"line":1634,"address":[],"length":0,"stats":{"Line":30}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":20}},{"line":1640,"address":[],"length":0,"stats":{"Line":10}},{"line":1641,"address":[],"length":0,"stats":{"Line":10}},{"line":1642,"address":[],"length":0,"stats":{"Line":10}},{"line":1643,"address":[],"length":0,"stats":{"Line":10}},{"line":1648,"address":[],"length":0,"stats":{"Line":24}},{"line":1650,"address":[],"length":0,"stats":{"Line":8}},{"line":1654,"address":[],"length":0,"stats":{"Line":16}},{"line":1656,"address":[],"length":0,"stats":{"Line":8}},{"line":1660,"address":[],"length":0,"stats":{"Line":27}},{"line":1662,"address":[],"length":0,"stats":{"Line":81}},{"line":1665,"address":[],"length":0,"stats":{"Line":27}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":54}},{"line":1669,"address":[],"length":0,"stats":{"Line":31}},{"line":1670,"address":[],"length":0,"stats":{"Line":12}},{"line":1671,"address":[],"length":0,"stats":{"Line":16}},{"line":1672,"address":[],"length":0,"stats":{"Line":22}},{"line":1673,"address":[],"length":0,"stats":{"Line":12}},{"line":1674,"address":[],"length":0,"stats":{"Line":8}},{"line":1675,"address":[],"length":0,"stats":{"Line":4}},{"line":1676,"address":[],"length":0,"stats":{"Line":4}},{"line":1677,"address":[],"length":0,"stats":{"Line":4}},{"line":1678,"address":[],"length":0,"stats":{"Line":4}},{"line":1687,"address":[],"length":0,"stats":{"Line":27}},{"line":1688,"address":[],"length":0,"stats":{"Line":8}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":4}},{"line":1698,"address":[],"length":0,"stats":{"Line":46}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":46}},{"line":1712,"address":[],"length":0,"stats":{"Line":69}},{"line":1713,"address":[],"length":0,"stats":{"Line":46}},{"line":1715,"address":[],"length":0,"stats":{"Line":23}},{"line":1716,"address":[],"length":0,"stats":{"Line":42}},{"line":1717,"address":[],"length":0,"stats":{"Line":42}},{"line":1718,"address":[],"length":0,"stats":{"Line":21}},{"line":1719,"address":[],"length":0,"stats":{"Line":42}},{"line":1720,"address":[],"length":0,"stats":{"Line":84}},{"line":1721,"address":[],"length":0,"stats":{"Line":42}},{"line":1723,"address":[],"length":0,"stats":{"Line":21}},{"line":1724,"address":[],"length":0,"stats":{"Line":21}},{"line":1726,"address":[],"length":0,"stats":{"Line":21}},{"line":1728,"address":[],"length":0,"stats":{"Line":42}},{"line":1729,"address":[],"length":0,"stats":{"Line":42}},{"line":1730,"address":[],"length":0,"stats":{"Line":21}},{"line":1731,"address":[],"length":0,"stats":{"Line":21}},{"line":1732,"address":[],"length":0,"stats":{"Line":21}},{"line":1734,"address":[],"length":0,"stats":{"Line":21}},{"line":1735,"address":[],"length":0,"stats":{"Line":42}},{"line":1736,"address":[],"length":0,"stats":{"Line":21}},{"line":1741,"address":[],"length":0,"stats":{"Line":23}},{"line":1742,"address":[],"length":0,"stats":{"Line":46}},{"line":1743,"address":[],"length":0,"stats":{"Line":23}},{"line":1744,"address":[],"length":0,"stats":{"Line":23}},{"line":1748,"address":[],"length":0,"stats":{"Line":45}},{"line":1749,"address":[],"length":0,"stats":{"Line":33}},{"line":1751,"address":[],"length":0,"stats":{"Line":22}},{"line":1752,"address":[],"length":0,"stats":{"Line":22}},{"line":1753,"address":[],"length":0,"stats":{"Line":11}},{"line":1754,"address":[],"length":0,"stats":{"Line":11}},{"line":1757,"address":[],"length":0,"stats":{"Line":33}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1762,"address":[],"length":0,"stats":{"Line":22}},{"line":1763,"address":[],"length":0,"stats":{"Line":11}},{"line":1764,"address":[],"length":0,"stats":{"Line":11}},{"line":1765,"address":[],"length":0,"stats":{"Line":11}},{"line":1766,"address":[],"length":0,"stats":{"Line":11}},{"line":1771,"address":[],"length":0,"stats":{"Line":69}},{"line":1774,"address":[],"length":0,"stats":{"Line":46}},{"line":1775,"address":[],"length":0,"stats":{"Line":69}},{"line":1778,"address":[],"length":0,"stats":{"Line":23}},{"line":1782,"address":[],"length":0,"stats":{"Line":46}},{"line":1783,"address":[],"length":0,"stats":{"Line":46}},{"line":1786,"address":[],"length":0,"stats":{"Line":24}},{"line":1787,"address":[],"length":0,"stats":{"Line":4}},{"line":1788,"address":[],"length":0,"stats":{"Line":5}},{"line":1789,"address":[],"length":0,"stats":{"Line":2}},{"line":1793,"address":[],"length":0,"stats":{"Line":23}},{"line":1797,"address":[],"length":0,"stats":{"Line":2}},{"line":1799,"address":[],"length":0,"stats":{"Line":6}},{"line":1802,"address":[],"length":0,"stats":{"Line":4}},{"line":1805,"address":[],"length":0,"stats":{"Line":2}},{"line":1806,"address":[],"length":0,"stats":{"Line":4}},{"line":1808,"address":[],"length":0,"stats":{"Line":2}},{"line":1809,"address":[],"length":0,"stats":{"Line":4}},{"line":1810,"address":[],"length":0,"stats":{"Line":8}},{"line":1811,"address":[],"length":0,"stats":{"Line":4}},{"line":1813,"address":[],"length":0,"stats":{"Line":2}},{"line":1814,"address":[],"length":0,"stats":{"Line":2}},{"line":1816,"address":[],"length":0,"stats":{"Line":2}},{"line":1819,"address":[],"length":0,"stats":{"Line":4}},{"line":1820,"address":[],"length":0,"stats":{"Line":2}},{"line":1821,"address":[],"length":0,"stats":{"Line":2}},{"line":1822,"address":[],"length":0,"stats":{"Line":2}},{"line":1824,"address":[],"length":0,"stats":{"Line":2}},{"line":1825,"address":[],"length":0,"stats":{"Line":4}},{"line":1826,"address":[],"length":0,"stats":{"Line":2}},{"line":1831,"address":[],"length":0,"stats":{"Line":6}},{"line":1832,"address":[],"length":0,"stats":{"Line":4}},{"line":1835,"address":[],"length":0,"stats":{"Line":6}},{"line":1838,"address":[],"length":0,"stats":{"Line":4}},{"line":1841,"address":[],"length":0,"stats":{"Line":4}},{"line":1843,"address":[],"length":0,"stats":{"Line":2}},{"line":1847,"address":[],"length":0,"stats":{"Line":2}},{"line":1849,"address":[],"length":0,"stats":{"Line":6}},{"line":1852,"address":[],"length":0,"stats":{"Line":4}},{"line":1855,"address":[],"length":0,"stats":{"Line":2}},{"line":1856,"address":[],"length":0,"stats":{"Line":4}},{"line":1858,"address":[],"length":0,"stats":{"Line":2}},{"line":1859,"address":[],"length":0,"stats":{"Line":4}},{"line":1860,"address":[],"length":0,"stats":{"Line":8}},{"line":1861,"address":[],"length":0,"stats":{"Line":4}},{"line":1863,"address":[],"length":0,"stats":{"Line":2}},{"line":1864,"address":[],"length":0,"stats":{"Line":2}},{"line":1866,"address":[],"length":0,"stats":{"Line":2}},{"line":1869,"address":[],"length":0,"stats":{"Line":4}},{"line":1870,"address":[],"length":0,"stats":{"Line":2}},{"line":1871,"address":[],"length":0,"stats":{"Line":2}},{"line":1872,"address":[],"length":0,"stats":{"Line":2}},{"line":1874,"address":[],"length":0,"stats":{"Line":2}},{"line":1875,"address":[],"length":0,"stats":{"Line":4}},{"line":1876,"address":[],"length":0,"stats":{"Line":2}},{"line":1881,"address":[],"length":0,"stats":{"Line":6}},{"line":1883,"address":[],"length":0,"stats":{"Line":4}},{"line":1884,"address":[],"length":0,"stats":{"Line":4}},{"line":1885,"address":[],"length":0,"stats":{"Line":2}},{"line":1886,"address":[],"length":0,"stats":{"Line":2}},{"line":1888,"address":[],"length":0,"stats":{"Line":6}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1892,"address":[],"length":0,"stats":{"Line":0}},{"line":1896,"address":[],"length":0,"stats":{"Line":4}},{"line":1897,"address":[],"length":0,"stats":{"Line":2}},{"line":1898,"address":[],"length":0,"stats":{"Line":2}},{"line":1899,"address":[],"length":0,"stats":{"Line":2}},{"line":1900,"address":[],"length":0,"stats":{"Line":2}},{"line":1904,"address":[],"length":0,"stats":{"Line":6}},{"line":1907,"address":[],"length":0,"stats":{"Line":4}},{"line":1909,"address":[],"length":0,"stats":{"Line":2}},{"line":1913,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1924,"address":[],"length":0,"stats":{"Line":0}},{"line":1925,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1927,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1935,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":0}},{"line":1941,"address":[],"length":0,"stats":{"Line":0}},{"line":1945,"address":[],"length":0,"stats":{"Line":0}},{"line":1946,"address":[],"length":0,"stats":{"Line":0}},{"line":1947,"address":[],"length":0,"stats":{"Line":0}},{"line":1948,"address":[],"length":0,"stats":{"Line":0}},{"line":1949,"address":[],"length":0,"stats":{"Line":0}},{"line":1950,"address":[],"length":0,"stats":{"Line":0}},{"line":1951,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1959,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":0}},{"line":1961,"address":[],"length":0,"stats":{"Line":0}},{"line":1962,"address":[],"length":0,"stats":{"Line":0}},{"line":1963,"address":[],"length":0,"stats":{"Line":0}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1965,"address":[],"length":0,"stats":{"Line":0}},{"line":1966,"address":[],"length":0,"stats":{"Line":0}},{"line":1967,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[],"length":0,"stats":{"Line":0}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1978,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1983,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1988,"address":[],"length":0,"stats":{"Line":0}},{"line":1990,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1995,"address":[],"length":0,"stats":{"Line":0}},{"line":1996,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2000,"address":[],"length":0,"stats":{"Line":0}},{"line":2003,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2011,"address":[],"length":0,"stats":{"Line":0}},{"line":2012,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2023,"address":[],"length":0,"stats":{"Line":0}},{"line":2025,"address":[],"length":0,"stats":{"Line":0}},{"line":2028,"address":[],"length":0,"stats":{"Line":0}},{"line":2029,"address":[],"length":0,"stats":{"Line":0}},{"line":2032,"address":[],"length":0,"stats":{"Line":0}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2040,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2044,"address":[],"length":0,"stats":{"Line":0}},{"line":2045,"address":[],"length":0,"stats":{"Line":0}},{"line":2046,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2053,"address":[],"length":0,"stats":{"Line":0}},{"line":2055,"address":[],"length":0,"stats":{"Line":0}},{"line":2060,"address":[],"length":0,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2063,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2067,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2070,"address":[],"length":0,"stats":{"Line":0}},{"line":2071,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[],"length":0,"stats":{"Line":0}},{"line":2073,"address":[],"length":0,"stats":{"Line":0}},{"line":2078,"address":[],"length":0,"stats":{"Line":0}},{"line":2079,"address":[],"length":0,"stats":{"Line":0}},{"line":2080,"address":[],"length":0,"stats":{"Line":0}},{"line":2081,"address":[],"length":0,"stats":{"Line":0}},{"line":2082,"address":[],"length":0,"stats":{"Line":0}},{"line":2083,"address":[],"length":0,"stats":{"Line":0}},{"line":2084,"address":[],"length":0,"stats":{"Line":0}},{"line":2085,"address":[],"length":0,"stats":{"Line":0}},{"line":2086,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2096,"address":[],"length":0,"stats":{"Line":299}},{"line":2098,"address":[],"length":0,"stats":{"Line":299}},{"line":2099,"address":[],"length":0,"stats":{"Line":299}},{"line":2100,"address":[],"length":0,"stats":{"Line":299}},{"line":2101,"address":[],"length":0,"stats":{"Line":299}},{"line":2102,"address":[],"length":0,"stats":{"Line":299}},{"line":2103,"address":[],"length":0,"stats":{"Line":299}},{"line":2105,"address":[],"length":0,"stats":{"Line":897}},{"line":2109,"address":[],"length":0,"stats":{"Line":377}},{"line":2110,"address":[],"length":0,"stats":{"Line":377}},{"line":2111,"address":[],"length":0,"stats":{"Line":4}},{"line":2113,"address":[],"length":0,"stats":{"Line":16}},{"line":2115,"address":[],"length":0,"stats":{"Line":16}},{"line":2117,"address":[],"length":0,"stats":{"Line":13}},{"line":2119,"address":[],"length":0,"stats":{"Line":52}},{"line":2121,"address":[],"length":0,"stats":{"Line":2}},{"line":2123,"address":[],"length":0,"stats":{"Line":6}},{"line":2125,"address":[],"length":0,"stats":{"Line":11}},{"line":2127,"address":[],"length":0,"stats":{"Line":44}},{"line":2129,"address":[],"length":0,"stats":{"Line":0}},{"line":2133,"address":[],"length":0,"stats":{"Line":0}},{"line":2134,"address":[],"length":0,"stats":{"Line":0}},{"line":2135,"address":[],"length":0,"stats":{"Line":0}},{"line":2136,"address":[],"length":0,"stats":{"Line":0}},{"line":2137,"address":[],"length":0,"stats":{"Line":0}},{"line":2138,"address":[],"length":0,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2140,"address":[],"length":0,"stats":{"Line":0}},{"line":2141,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2150,"address":[],"length":0,"stats":{"Line":0}},{"line":2151,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[],"length":0,"stats":{"Line":0}},{"line":2154,"address":[],"length":0,"stats":{"Line":0}},{"line":2156,"address":[],"length":0,"stats":{"Line":0}},{"line":2157,"address":[],"length":0,"stats":{"Line":0}},{"line":2158,"address":[],"length":0,"stats":{"Line":0}},{"line":2162,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2167,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[],"length":0,"stats":{"Line":0}},{"line":2172,"address":[],"length":0,"stats":{"Line":0}},{"line":2173,"address":[],"length":0,"stats":{"Line":0}},{"line":2177,"address":[],"length":0,"stats":{"Line":123}},{"line":2181,"address":[],"length":0,"stats":{"Line":246}},{"line":2182,"address":[],"length":0,"stats":{"Line":216}},{"line":2183,"address":[],"length":0,"stats":{"Line":15}},{"line":2186,"address":[],"length":0,"stats":{"Line":224}},{"line":2194,"address":[],"length":0,"stats":{"Line":417}},{"line":2195,"address":[],"length":0,"stats":{"Line":417}},{"line":2196,"address":[],"length":0,"stats":{"Line":50}},{"line":2197,"address":[],"length":0,"stats":{"Line":100}},{"line":2198,"address":[],"length":0,"stats":{"Line":42}},{"line":2200,"address":[],"length":0,"stats":{"Line":195}},{"line":2202,"address":[],"length":0,"stats":{"Line":39}},{"line":2204,"address":[],"length":0,"stats":{"Line":9}},{"line":2207,"address":[],"length":0,"stats":{"Line":16}},{"line":2210,"address":[],"length":0,"stats":{"Line":26}},{"line":2212,"address":[],"length":0,"stats":{"Line":78}},{"line":2213,"address":[],"length":0,"stats":{"Line":26}},{"line":2215,"address":[],"length":0,"stats":{"Line":64}},{"line":2216,"address":[],"length":0,"stats":{"Line":38}},{"line":2217,"address":[],"length":0,"stats":{"Line":38}},{"line":2218,"address":[],"length":0,"stats":{"Line":152}},{"line":2219,"address":[],"length":0,"stats":{"Line":38}},{"line":2222,"address":[],"length":0,"stats":{"Line":0}},{"line":2226,"address":[],"length":0,"stats":{"Line":26}},{"line":2227,"address":[],"length":0,"stats":{"Line":26}},{"line":2228,"address":[],"length":0,"stats":{"Line":26}},{"line":2230,"address":[],"length":0,"stats":{"Line":26}},{"line":2233,"address":[],"length":0,"stats":{"Line":27}},{"line":2234,"address":[],"length":0,"stats":{"Line":54}},{"line":2235,"address":[],"length":0,"stats":{"Line":246}},{"line":2236,"address":[],"length":0,"stats":{"Line":81}},{"line":2238,"address":[],"length":0,"stats":{"Line":2}},{"line":2239,"address":[],"length":0,"stats":{"Line":8}},{"line":2240,"address":[],"length":0,"stats":{"Line":6}},{"line":2242,"address":[],"length":0,"stats":{"Line":6}},{"line":2243,"address":[],"length":0,"stats":{"Line":24}},{"line":2244,"address":[],"length":0,"stats":{"Line":18}},{"line":2246,"address":[],"length":0,"stats":{"Line":3}},{"line":2247,"address":[],"length":0,"stats":{"Line":33}},{"line":2248,"address":[],"length":0,"stats":{"Line":9}},{"line":2250,"address":[],"length":0,"stats":{"Line":17}},{"line":2252,"address":[],"length":0,"stats":{"Line":51}},{"line":2253,"address":[],"length":0,"stats":{"Line":17}},{"line":2255,"address":[],"length":0,"stats":{"Line":17}},{"line":2256,"address":[],"length":0,"stats":{"Line":9}},{"line":2257,"address":[],"length":0,"stats":{"Line":9}},{"line":2258,"address":[],"length":0,"stats":{"Line":9}},{"line":2259,"address":[],"length":0,"stats":{"Line":33}},{"line":2260,"address":[],"length":0,"stats":{"Line":18}},{"line":2264,"address":[],"length":0,"stats":{"Line":68}},{"line":2267,"address":[],"length":0,"stats":{"Line":17}},{"line":2268,"address":[],"length":0,"stats":{"Line":34}},{"line":2269,"address":[],"length":0,"stats":{"Line":51}},{"line":2270,"address":[],"length":0,"stats":{"Line":17}},{"line":2272,"address":[],"length":0,"stats":{"Line":17}},{"line":2275,"address":[],"length":0,"stats":{"Line":572}},{"line":2281,"address":[],"length":0,"stats":{"Line":16}},{"line":2283,"address":[],"length":0,"stats":{"Line":16}},{"line":2284,"address":[],"length":0,"stats":{"Line":16}},{"line":2285,"address":[],"length":0,"stats":{"Line":16}},{"line":2286,"address":[],"length":0,"stats":{"Line":16}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2299,"address":[],"length":0,"stats":{"Line":0}},{"line":2300,"address":[],"length":0,"stats":{"Line":0}},{"line":2301,"address":[],"length":0,"stats":{"Line":0}},{"line":2305,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2307,"address":[],"length":0,"stats":{"Line":0}},{"line":2308,"address":[],"length":0,"stats":{"Line":0}},{"line":2313,"address":[],"length":0,"stats":{"Line":0}},{"line":2314,"address":[],"length":0,"stats":{"Line":0}},{"line":2315,"address":[],"length":0,"stats":{"Line":0}},{"line":2316,"address":[],"length":0,"stats":{"Line":0}},{"line":2318,"address":[],"length":0,"stats":{"Line":0}},{"line":2320,"address":[],"length":0,"stats":{"Line":0}},{"line":2322,"address":[],"length":0,"stats":{"Line":0}},{"line":2323,"address":[],"length":0,"stats":{"Line":0}},{"line":2324,"address":[],"length":0,"stats":{"Line":0}},{"line":2326,"address":[],"length":0,"stats":{"Line":0}},{"line":2327,"address":[],"length":0,"stats":{"Line":0}},{"line":2328,"address":[],"length":0,"stats":{"Line":0}},{"line":2330,"address":[],"length":0,"stats":{"Line":0}},{"line":2331,"address":[],"length":0,"stats":{"Line":0}},{"line":2333,"address":[],"length":0,"stats":{"Line":0}},{"line":2335,"address":[],"length":0,"stats":{"Line":0}},{"line":2337,"address":[],"length":0,"stats":{"Line":0}},{"line":2342,"address":[],"length":0,"stats":{"Line":81}},{"line":2343,"address":[],"length":0,"stats":{"Line":162}},{"line":2347,"address":[],"length":0,"stats":{"Line":91}},{"line":2352,"address":[],"length":0,"stats":{"Line":91}},{"line":2353,"address":[],"length":0,"stats":{"Line":91}},{"line":2354,"address":[],"length":0,"stats":{"Line":91}},{"line":2359,"address":[],"length":0,"stats":{"Line":6}},{"line":2364,"address":[],"length":0,"stats":{"Line":6}},{"line":2365,"address":[],"length":0,"stats":{"Line":6}},{"line":2366,"address":[],"length":0,"stats":{"Line":6}},{"line":2371,"address":[],"length":0,"stats":{"Line":31}},{"line":2376,"address":[],"length":0,"stats":{"Line":31}},{"line":2377,"address":[],"length":0,"stats":{"Line":31}},{"line":2378,"address":[],"length":0,"stats":{"Line":31}},{"line":2383,"address":[],"length":0,"stats":{"Line":3}},{"line":2390,"address":[],"length":0,"stats":{"Line":6}},{"line":2393,"address":[],"length":0,"stats":{"Line":6}},{"line":2394,"address":[],"length":0,"stats":{"Line":3}},{"line":2395,"address":[],"length":0,"stats":{"Line":18}},{"line":2396,"address":[],"length":0,"stats":{"Line":6}},{"line":2397,"address":[],"length":0,"stats":{"Line":9}},{"line":2398,"address":[],"length":0,"stats":{"Line":18}},{"line":2399,"address":[],"length":0,"stats":{"Line":12}},{"line":2400,"address":[],"length":0,"stats":{"Line":9}},{"line":2401,"address":[],"length":0,"stats":{"Line":9}},{"line":2403,"address":[],"length":0,"stats":{"Line":6}},{"line":2404,"address":[],"length":0,"stats":{"Line":6}},{"line":2405,"address":[],"length":0,"stats":{"Line":6}},{"line":2406,"address":[],"length":0,"stats":{"Line":6}},{"line":2408,"address":[],"length":0,"stats":{"Line":12}},{"line":2409,"address":[],"length":0,"stats":{"Line":3}},{"line":2410,"address":[],"length":0,"stats":{"Line":3}},{"line":2412,"address":[],"length":0,"stats":{"Line":3}},{"line":2413,"address":[],"length":0,"stats":{"Line":18}},{"line":2414,"address":[],"length":0,"stats":{"Line":6}},{"line":2415,"address":[],"length":0,"stats":{"Line":9}},{"line":2416,"address":[],"length":0,"stats":{"Line":18}},{"line":2417,"address":[],"length":0,"stats":{"Line":12}},{"line":2418,"address":[],"length":0,"stats":{"Line":9}},{"line":2419,"address":[],"length":0,"stats":{"Line":9}},{"line":2421,"address":[],"length":0,"stats":{"Line":6}},{"line":2422,"address":[],"length":0,"stats":{"Line":6}},{"line":2423,"address":[],"length":0,"stats":{"Line":6}},{"line":2424,"address":[],"length":0,"stats":{"Line":6}},{"line":2426,"address":[],"length":0,"stats":{"Line":12}},{"line":2427,"address":[],"length":0,"stats":{"Line":3}},{"line":2428,"address":[],"length":0,"stats":{"Line":3}},{"line":2433,"address":[],"length":0,"stats":{"Line":3}},{"line":2434,"address":[],"length":0,"stats":{"Line":3}},{"line":2435,"address":[],"length":0,"stats":{"Line":3}},{"line":2437,"address":[],"length":0,"stats":{"Line":3}},{"line":2440,"address":[],"length":0,"stats":{"Line":12}},{"line":2441,"address":[],"length":0,"stats":{"Line":9}},{"line":2442,"address":[],"length":0,"stats":{"Line":6}},{"line":2443,"address":[],"length":0,"stats":{"Line":3}},{"line":2444,"address":[],"length":0,"stats":{"Line":3}},{"line":2448,"address":[],"length":0,"stats":{"Line":6}},{"line":2449,"address":[],"length":0,"stats":{"Line":3}},{"line":2450,"address":[],"length":0,"stats":{"Line":3}},{"line":2451,"address":[],"length":0,"stats":{"Line":18}},{"line":2452,"address":[],"length":0,"stats":{"Line":3}},{"line":2453,"address":[],"length":0,"stats":{"Line":9}},{"line":2454,"address":[],"length":0,"stats":{"Line":3}},{"line":2456,"address":[],"length":0,"stats":{"Line":3}},{"line":2457,"address":[],"length":0,"stats":{"Line":18}},{"line":2458,"address":[],"length":0,"stats":{"Line":6}},{"line":2459,"address":[],"length":0,"stats":{"Line":9}},{"line":2460,"address":[],"length":0,"stats":{"Line":18}},{"line":2461,"address":[],"length":0,"stats":{"Line":12}},{"line":2462,"address":[],"length":0,"stats":{"Line":9}},{"line":2463,"address":[],"length":0,"stats":{"Line":9}},{"line":2465,"address":[],"length":0,"stats":{"Line":6}},{"line":2466,"address":[],"length":0,"stats":{"Line":6}},{"line":2467,"address":[],"length":0,"stats":{"Line":6}},{"line":2468,"address":[],"length":0,"stats":{"Line":6}},{"line":2470,"address":[],"length":0,"stats":{"Line":12}},{"line":2471,"address":[],"length":0,"stats":{"Line":3}},{"line":2472,"address":[],"length":0,"stats":{"Line":3}},{"line":2477,"address":[],"length":0,"stats":{"Line":3}},{"line":2478,"address":[],"length":0,"stats":{"Line":3}},{"line":2479,"address":[],"length":0,"stats":{"Line":3}},{"line":2481,"address":[],"length":0,"stats":{"Line":3}},{"line":2484,"address":[],"length":0,"stats":{"Line":12}},{"line":2485,"address":[],"length":0,"stats":{"Line":9}},{"line":2486,"address":[],"length":0,"stats":{"Line":6}},{"line":2487,"address":[],"length":0,"stats":{"Line":3}},{"line":2488,"address":[],"length":0,"stats":{"Line":3}},{"line":2493,"address":[],"length":0,"stats":{"Line":0}},{"line":2494,"address":[],"length":0,"stats":{"Line":0}},{"line":2498,"address":[],"length":0,"stats":{"Line":0}},{"line":2499,"address":[],"length":0,"stats":{"Line":0}},{"line":2503,"address":[],"length":0,"stats":{"Line":0}},{"line":2504,"address":[],"length":0,"stats":{"Line":0}},{"line":2508,"address":[],"length":0,"stats":{"Line":0}},{"line":2509,"address":[],"length":0,"stats":{"Line":0}},{"line":2513,"address":[],"length":0,"stats":{"Line":0}},{"line":2516,"address":[],"length":0,"stats":{"Line":0}},{"line":2517,"address":[],"length":0,"stats":{"Line":0}},{"line":2518,"address":[],"length":0,"stats":{"Line":0}},{"line":2519,"address":[],"length":0,"stats":{"Line":0}},{"line":2520,"address":[],"length":0,"stats":{"Line":0}},{"line":2521,"address":[],"length":0,"stats":{"Line":0}},{"line":2525,"address":[],"length":0,"stats":{"Line":0}},{"line":2526,"address":[],"length":0,"stats":{"Line":0}},{"line":2527,"address":[],"length":0,"stats":{"Line":0}},{"line":2530,"address":[],"length":0,"stats":{"Line":0}},{"line":2531,"address":[],"length":0,"stats":{"Line":0}},{"line":2534,"address":[],"length":0,"stats":{"Line":0}},{"line":2537,"address":[],"length":0,"stats":{"Line":0}},{"line":2538,"address":[],"length":0,"stats":{"Line":0}},{"line":2539,"address":[],"length":0,"stats":{"Line":0}},{"line":2540,"address":[],"length":0,"stats":{"Line":0}},{"line":2541,"address":[],"length":0,"stats":{"Line":0}},{"line":2542,"address":[],"length":0,"stats":{"Line":0}},{"line":2543,"address":[],"length":0,"stats":{"Line":0}},{"line":2544,"address":[],"length":0,"stats":{"Line":0}},{"line":2545,"address":[],"length":0,"stats":{"Line":0}},{"line":2546,"address":[],"length":0,"stats":{"Line":0}},{"line":2551,"address":[],"length":0,"stats":{"Line":0}},{"line":2552,"address":[],"length":0,"stats":{"Line":0}},{"line":2555,"address":[],"length":0,"stats":{"Line":0}},{"line":2559,"address":[],"length":0,"stats":{"Line":0}},{"line":2560,"address":[],"length":0,"stats":{"Line":0}},{"line":2561,"address":[],"length":0,"stats":{"Line":0}},{"line":2562,"address":[],"length":0,"stats":{"Line":0}},{"line":2566,"address":[],"length":0,"stats":{"Line":0}},{"line":2567,"address":[],"length":0,"stats":{"Line":0}},{"line":2569,"address":[],"length":0,"stats":{"Line":0}},{"line":2572,"address":[],"length":0,"stats":{"Line":0}},{"line":2574,"address":[],"length":0,"stats":{"Line":0}},{"line":2576,"address":[],"length":0,"stats":{"Line":0}},{"line":2578,"address":[],"length":0,"stats":{"Line":0}},{"line":2581,"address":[],"length":0,"stats":{"Line":0}},{"line":2582,"address":[],"length":0,"stats":{"Line":0}},{"line":2583,"address":[],"length":0,"stats":{"Line":0}},{"line":2584,"address":[],"length":0,"stats":{"Line":0}},{"line":2587,"address":[],"length":0,"stats":{"Line":0}},{"line":2588,"address":[],"length":0,"stats":{"Line":0}},{"line":2589,"address":[],"length":0,"stats":{"Line":0}},{"line":2591,"address":[],"length":0,"stats":{"Line":0}},{"line":2594,"address":[],"length":0,"stats":{"Line":0}},{"line":2595,"address":[],"length":0,"stats":{"Line":0}},{"line":2597,"address":[],"length":0,"stats":{"Line":0}},{"line":2598,"address":[],"length":0,"stats":{"Line":0}},{"line":2601,"address":[],"length":0,"stats":{"Line":0}},{"line":2602,"address":[],"length":0,"stats":{"Line":0}},{"line":2605,"address":[],"length":0,"stats":{"Line":0}},{"line":2608,"address":[],"length":0,"stats":{"Line":0}},{"line":2609,"address":[],"length":0,"stats":{"Line":0}},{"line":2611,"address":[],"length":0,"stats":{"Line":0}},{"line":2612,"address":[],"length":0,"stats":{"Line":0}},{"line":2613,"address":[],"length":0,"stats":{"Line":0}},{"line":2615,"address":[],"length":0,"stats":{"Line":0}},{"line":2616,"address":[],"length":0,"stats":{"Line":0}},{"line":2617,"address":[],"length":0,"stats":{"Line":0}},{"line":2618,"address":[],"length":0,"stats":{"Line":0}},{"line":2620,"address":[],"length":0,"stats":{"Line":0}},{"line":2621,"address":[],"length":0,"stats":{"Line":0}},{"line":2622,"address":[],"length":0,"stats":{"Line":0}},{"line":2623,"address":[],"length":0,"stats":{"Line":0}},{"line":2625,"address":[],"length":0,"stats":{"Line":0}},{"line":2626,"address":[],"length":0,"stats":{"Line":0}},{"line":2627,"address":[],"length":0,"stats":{"Line":0}},{"line":2628,"address":[],"length":0,"stats":{"Line":0}},{"line":2629,"address":[],"length":0,"stats":{"Line":0}},{"line":2631,"address":[],"length":0,"stats":{"Line":0}},{"line":2632,"address":[],"length":0,"stats":{"Line":0}},{"line":2633,"address":[],"length":0,"stats":{"Line":0}},{"line":2634,"address":[],"length":0,"stats":{"Line":0}},{"line":2636,"address":[],"length":0,"stats":{"Line":0}},{"line":2637,"address":[],"length":0,"stats":{"Line":0}},{"line":2638,"address":[],"length":0,"stats":{"Line":0}},{"line":2639,"address":[],"length":0,"stats":{"Line":0}},{"line":2641,"address":[],"length":0,"stats":{"Line":0}},{"line":2642,"address":[],"length":0,"stats":{"Line":0}},{"line":2643,"address":[],"length":0,"stats":{"Line":0}},{"line":2644,"address":[],"length":0,"stats":{"Line":0}},{"line":2645,"address":[],"length":0,"stats":{"Line":0}},{"line":2646,"address":[],"length":0,"stats":{"Line":0}},{"line":2648,"address":[],"length":0,"stats":{"Line":0}},{"line":2649,"address":[],"length":0,"stats":{"Line":0}},{"line":2650,"address":[],"length":0,"stats":{"Line":0}},{"line":2651,"address":[],"length":0,"stats":{"Line":0}},{"line":2653,"address":[],"length":0,"stats":{"Line":0}},{"line":2654,"address":[],"length":0,"stats":{"Line":0}},{"line":2655,"address":[],"length":0,"stats":{"Line":0}},{"line":2656,"address":[],"length":0,"stats":{"Line":0}},{"line":2660,"address":[],"length":0,"stats":{"Line":0}},{"line":2661,"address":[],"length":0,"stats":{"Line":0}},{"line":2662,"address":[],"length":0,"stats":{"Line":0}},{"line":2664,"address":[],"length":0,"stats":{"Line":0}},{"line":2666,"address":[],"length":0,"stats":{"Line":0}},{"line":2671,"address":[],"length":0,"stats":{"Line":0}},{"line":2672,"address":[],"length":0,"stats":{"Line":0}},{"line":2676,"address":[],"length":0,"stats":{"Line":32}},{"line":2677,"address":[],"length":0,"stats":{"Line":96}},{"line":2682,"address":[],"length":0,"stats":{"Line":0}},{"line":2683,"address":[],"length":0,"stats":{"Line":0}}],"covered":779,"coverable":1370},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","type_compat.rs"],"content":"use std::collections::HashSet;\nuse typedlua_parser::ast::expression::Literal;\nuse typedlua_parser::ast::types::{\n    FunctionType, ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind,\n};\n\nfn type_ptr(ty: \u0026Type) -\u003e usize {\n    ty as *const Type as usize\n}\n\n/// Type compatibility checker\npub struct TypeCompatibility;\n\nimpl TypeCompatibility {\n    /// Check if `source` is assignable to `target`\n    pub fn is_assignable(source: \u0026Type, target: \u0026Type) -\u003e bool {\n        let mut visited: HashSet\u003c(usize, usize)\u003e = HashSet::new();\n        Self::is_assignable_recursive(source, target, \u0026mut visited)\n    }\n\n    fn is_assignable_recursive(\n        source: \u0026Type,\n        target: \u0026Type,\n        visited: \u0026mut HashSet\u003c(usize, usize)\u003e,\n    ) -\u003e bool {\n        let source_ptr = type_ptr(source);\n        let target_ptr = type_ptr(target);\n\n        if visited.contains(\u0026(source_ptr, target_ptr)) {\n            return true;\n        }\n        visited.insert((source_ptr, target_ptr));\n\n        // Unknown is assignable to/from anything\n        if matches!(source.kind, TypeKind::Primitive(PrimitiveType::Unknown))\n            || matches!(target.kind, TypeKind::Primitive(PrimitiveType::Unknown))\n        {\n            return true;\n        }\n\n        // Never is assignable to anything\n        if matches!(source.kind, TypeKind::Primitive(PrimitiveType::Never)) {\n            return true;\n        }\n\n        // Nothing is assignable to Never\n        if matches!(target.kind, TypeKind::Primitive(PrimitiveType::Never)) {\n            return false;\n        }\n\n        match (\u0026source.kind, \u0026target.kind) {\n            // Primitive types\n            (TypeKind::Primitive(s), TypeKind::Primitive(t)) =\u003e {\n                Self::is_primitive_assignable(*s, *t)\n            }\n\n            // Literal types\n            (TypeKind::Literal(s_lit), TypeKind::Literal(t_lit)) =\u003e s_lit == t_lit,\n\n            // Literal to primitive\n            (TypeKind::Literal(lit), TypeKind::Primitive(prim)) =\u003e {\n                Self::is_literal_assignable_to_primitive(lit, *prim)\n            }\n\n            // Primitive to literal (reverse direction - primitive nil can satisfy literal nil)\n            (TypeKind::Primitive(PrimitiveType::Nil), TypeKind::Literal(Literal::Nil)) =\u003e true,\n\n            // Also handle the case where source is a union containing nil and target expects literal nil\n            (TypeKind::Union(sources), TypeKind::Literal(Literal::Nil)) =\u003e {\n                // Check if any source member is nil\n                sources\n                    .iter()\n                    .any(|s| Self::is_assignable_recursive(s, target, visited))\n            }\n\n            // Union types\n            (_, TypeKind::Union(targets)) =\u003e {\n                // Source is assignable to union if assignable to any member\n                targets\n                    .iter()\n                    .any(|t| Self::is_assignable_recursive(source, t, visited))\n            }\n            (TypeKind::Union(sources), _) =\u003e {\n                // Union is assignable to target if all members are assignable\n                sources\n                    .iter()\n                    .all(|s| Self::is_assignable_recursive(s, target, visited))\n            }\n\n            // Intersection types\n            (TypeKind::Intersection(sources), _) =\u003e {\n                // Intersection is assignable to target if any member is assignable\n                sources\n                    .iter()\n                    .any(|s| Self::is_assignable_recursive(s, target, visited))\n            }\n            (_, TypeKind::Intersection(targets)) =\u003e {\n                // Source is assignable to intersection if assignable to all members\n                targets\n                    .iter()\n                    .all(|t| Self::is_assignable_recursive(source, t, visited))\n            }\n\n            // Array types\n            (TypeKind::Array(s_elem), TypeKind::Array(t_elem)) =\u003e {\n                Self::is_assignable_recursive(s_elem, t_elem, visited)\n            }\n\n            // Tuple types\n            (TypeKind::Tuple(s_elems), TypeKind::Tuple(t_elems)) =\u003e {\n                if s_elems.len() != t_elems.len() {\n                    return false;\n                }\n                s_elems\n                    .iter()\n                    .zip(t_elems.iter())\n                    .all(|(s, t)| Self::is_assignable_recursive(s, t, visited))\n            }\n\n            // Function types\n            (TypeKind::Function(s_func), TypeKind::Function(t_func)) =\u003e {\n                Self::is_function_assignable(s_func, t_func, visited)\n            }\n\n            // Object types\n            (TypeKind::Object(s_obj), TypeKind::Object(t_obj)) =\u003e {\n                Self::is_object_assignable(s_obj, t_obj, visited)\n            }\n\n            // Nullable types\n            (TypeKind::Nullable(s_inner), TypeKind::Nullable(t_inner)) =\u003e {\n                Self::is_assignable_recursive(s_inner, t_inner, visited)\n            }\n            (TypeKind::Primitive(PrimitiveType::Nil), TypeKind::Nullable(_)) =\u003e true,\n            (_, TypeKind::Nullable(t_inner)) =\u003e {\n                Self::is_assignable_recursive(source, t_inner, visited)\n            }\n\n            // Parenthesized types\n            (TypeKind::Parenthesized(s_inner), _) =\u003e {\n                Self::is_assignable_recursive(s_inner, target, visited)\n            }\n            (_, TypeKind::Parenthesized(t_inner)) =\u003e {\n                Self::is_assignable_recursive(source, t_inner, visited)\n            }\n\n            // Type references\n            // NOTE: Ideally we would resolve type aliases to their underlying types\n            // and check structural compatibility. For now, we use name-based matching.\n            // This means:\n            //   type A = number; type B = number;\n            //   A and B are NOT compatible (should be, but requires type resolution)\n            //\n            // Future enhancement: Pass TypeEnvironment to resolve_type_reference() and\n            // recursively check is_assignable on the resolved types.\n            (TypeKind::Reference(s_ref), TypeKind::Reference(t_ref)) =\u003e {\n                // Check if names match exactly\n                if s_ref.name.node == t_ref.name.node {\n                    // Same type reference name - check type arguments if present\n                    match (\u0026s_ref.type_arguments, \u0026t_ref.type_arguments) {\n                        (None, None) =\u003e true,\n                        (Some(s_args), Some(t_args)) if s_args.len() == t_args.len() =\u003e {\n                            // Check all type arguments are compatible\n                            s_args.iter().zip(t_args.iter()).all(|(s_arg, t_arg)| {\n                                Self::is_assignable_recursive(s_arg, t_arg, visited)\n                            })\n                        }\n                        _ =\u003e false,\n                    }\n                } else {\n                    // Different names - could still be compatible if they resolve to\n                    // the same underlying type, but we don't have type environment here\n                    false\n                }\n            }\n\n            // Type reference vs concrete type - would need type resolution\n            (TypeKind::Reference(_), _) =\u003e {\n                // We can't resolve the reference without a type environment\n                // Conservative: assume incompatible\n                false\n            }\n            (_, TypeKind::Reference(_)) =\u003e {\n                // We can't resolve the reference without a type environment\n                // Conservative: assume incompatible\n                false\n            }\n\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if primitive types are compatible\n    fn is_primitive_assignable(source: PrimitiveType, target: PrimitiveType) -\u003e bool {\n        if source == target {\n            return true;\n        }\n\n        match (source, target) {\n            // Integer is assignable to number\n            (PrimitiveType::Integer, PrimitiveType::Number) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if a literal is assignable to a primitive type\n    fn is_literal_assignable_to_primitive(lit: \u0026Literal, prim: PrimitiveType) -\u003e bool {\n        matches!(\n            (lit, prim),\n            (Literal::Number(_), PrimitiveType::Number)\n                | (Literal::String(_), PrimitiveType::String)\n                | (Literal::Boolean(_), PrimitiveType::Boolean)\n                | (Literal::Nil, PrimitiveType::Nil)\n        )\n    }\n\n    /// Check function type compatibility (contravariant parameters, covariant return)\n    fn is_function_assignable(\n        source: \u0026FunctionType,\n        target: \u0026FunctionType,\n        visited: \u0026mut HashSet\u003c(usize, usize)\u003e,\n    ) -\u003e bool {\n        // Check parameter count\n        if source.parameters.len() != target.parameters.len() {\n            return false;\n        }\n\n        // Parameters are contravariant: target params must be assignable to source params\n        for (s_param, t_param) in source.parameters.iter().zip(target.parameters.iter()) {\n            if let (Some(s_type), Some(t_type)) =\n                (\u0026s_param.type_annotation, \u0026t_param.type_annotation)\n            {\n                if !Self::is_assignable_recursive(t_type, s_type, visited) {\n                    return false;\n                }\n            }\n        }\n\n        // Return type is covariant: source return must be assignable to target return\n        Self::is_assignable_recursive(\u0026source.return_type, \u0026target.return_type, visited)\n    }\n\n    /// Check object type structural compatibility\n    fn is_object_assignable(\n        source: \u0026ObjectType,\n        target: \u0026ObjectType,\n        visited: \u0026mut HashSet\u003c(usize, usize)\u003e,\n    ) -\u003e bool {\n        // For each property in target, source must have a compatible property\n        for t_member in \u0026target.members {\n            match t_member {\n                ObjectTypeMember::Property(t_prop) =\u003e {\n                    // Find corresponding property in source\n                    let found = source.members.iter().any(|s_member| {\n                        if let ObjectTypeMember::Property(s_prop) = s_member {\n                            s_prop.name.node == t_prop.name.node\n                                \u0026\u0026 Self::is_assignable_recursive(\n                                    \u0026s_prop.type_annotation,\n                                    \u0026t_prop.type_annotation,\n                                    visited,\n                                )\n                        } else {\n                            false\n                        }\n                    });\n\n                    if !found \u0026\u0026 !t_prop.is_optional {\n                        return false;\n                    }\n                }\n                ObjectTypeMember::Method(t_method) =\u003e {\n                    // Find corresponding method in source\n                    let found = source.members.iter().any(|s_member| {\n                        if let ObjectTypeMember::Method(s_method) = s_member {\n                            s_method.name.node == t_method.name.node\n                        } else {\n                            false\n                        }\n                    });\n\n                    if !found {\n                        return false;\n                    }\n                }\n                ObjectTypeMember::Index(_) =\u003e {}\n            }\n        }\n\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    fn make_type(kind: TypeKind) -\u003e Type {\n        Type::new(kind, Span::new(0, 0, 0, 0))\n    }\n\n    #[test]\n    fn test_primitive_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let integer = make_type(TypeKind::Primitive(PrimitiveType::Integer));\n\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026number));\n        assert!(!TypeCompatibility::is_assignable(\u0026number, \u0026string));\n        assert!(TypeCompatibility::is_assignable(\u0026integer, \u0026number));\n        assert!(!TypeCompatibility::is_assignable(\u0026number, \u0026integer));\n    }\n\n    #[test]\n    fn test_literal_assignability() {\n        let num_lit = make_type(TypeKind::Literal(Literal::Number(42.0)));\n        let str_lit = make_type(TypeKind::Literal(Literal::String(\"hello\".to_string())));\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n\n        assert!(TypeCompatibility::is_assignable(\u0026num_lit, \u0026number));\n        assert!(!TypeCompatibility::is_assignable(\u0026num_lit, \u0026string));\n        assert!(TypeCompatibility::is_assignable(\u0026str_lit, \u0026string));\n        assert!(!TypeCompatibility::is_assignable(\u0026str_lit, \u0026number));\n    }\n\n    #[test]\n    fn test_union_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let number_or_string = make_type(TypeKind::Union(vec![number.clone(), string.clone()]));\n\n        // number is assignable to number | string\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026number_or_string));\n        // string is assignable to number | string\n        assert!(TypeCompatibility::is_assignable(\u0026string, \u0026number_or_string));\n    }\n\n    #[test]\n    fn test_array_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let number_array = make_type(TypeKind::Array(Box::new(number.clone())));\n        let string_array = make_type(TypeKind::Array(Box::new(string.clone())));\n\n        assert!(TypeCompatibility::is_assignable(\n            \u0026number_array,\n            \u0026number_array\n        ));\n        assert!(!TypeCompatibility::is_assignable(\n            \u0026number_array,\n            \u0026string_array\n        ));\n    }\n\n    #[test]\n    fn test_nullable_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let nullable_number = make_type(TypeKind::Nullable(Box::new(number.clone())));\n        let nil = make_type(TypeKind::Primitive(PrimitiveType::Nil));\n\n        // nil is assignable to number?\n        assert!(TypeCompatibility::is_assignable(\u0026nil, \u0026nullable_number));\n        // number is assignable to number?\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026nullable_number));\n    }\n\n    #[test]\n    fn test_unknown_assignability() {\n        let unknown = make_type(TypeKind::Primitive(PrimitiveType::Unknown));\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n\n        // unknown is assignable to/from anything\n        assert!(TypeCompatibility::is_assignable(\u0026unknown, \u0026number));\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026unknown));\n    }\n\n    #[test]\n    fn test_parenthesized_type() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let parenthesized = make_type(TypeKind::Parenthesized(Box::new(number.clone())));\n\n        // Parenthesized type should be same as inner type\n        assert!(TypeCompatibility::is_assignable(\u0026parenthesized, \u0026number));\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026parenthesized));\n    }\n\n    #[test]\n    fn test_literal_nil_to_nullable() {\n        let nil_type = make_type(TypeKind::Primitive(PrimitiveType::Nil));\n        let nullable_string = make_type(TypeKind::Nullable(Box::new(make_type(\n            TypeKind::Primitive(PrimitiveType::String),\n        ))));\n\n        // nil is assignable to nullable string\n        assert!(TypeCompatibility::is_assignable(\n            \u0026nil_type,\n            \u0026nullable_string\n        ));\n    }\n\n    #[test]\n    fn test_tuple_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n\n        let tuple1 = make_type(TypeKind::Tuple(vec![number.clone(), string.clone()]));\n        let tuple2 = make_type(TypeKind::Tuple(vec![number.clone(), string.clone()]));\n\n        // Same tuples should be assignable\n        assert!(TypeCompatibility::is_assignable(\u0026tuple1, \u0026tuple2));\n\n        let tuple_diff = make_type(TypeKind::Tuple(vec![number.clone(), number.clone()]));\n        assert!(!TypeCompatibility::is_assignable(\u0026tuple_diff, \u0026tuple1));\n    }\n\n    #[test]\n    fn test_function_with_throws() {\n        let func1 = make_type(TypeKind::Function(FunctionType {\n            parameters: vec![],\n            return_type: Box::new(make_type(TypeKind::Primitive(PrimitiveType::Number))),\n            throws: None,\n            span: Span::new(0, 0, 0, 0),\n            type_parameters: None,\n        }));\n        let func2 = make_type(TypeKind::Function(FunctionType {\n            parameters: vec![],\n            return_type: Box::new(make_type(TypeKind::Primitive(PrimitiveType::Number))),\n            throws: None,\n            span: Span::new(0, 0, 0, 0),\n            type_parameters: None,\n        }));\n\n        // Functions should be compatible\n        assert!(TypeCompatibility::is_assignable(\u0026func1, \u0026func2));\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":718}},{"line":8,"address":[],"length":0,"stats":{"Line":718}},{"line":16,"address":[],"length":0,"stats":{"Line":269}},{"line":17,"address":[],"length":0,"stats":{"Line":807}},{"line":18,"address":[],"length":0,"stats":{"Line":1076}},{"line":21,"address":[],"length":0,"stats":{"Line":359}},{"line":26,"address":[],"length":0,"stats":{"Line":1077}},{"line":27,"address":[],"length":0,"stats":{"Line":1077}},{"line":29,"address":[],"length":0,"stats":{"Line":1077}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1077}},{"line":35,"address":[],"length":0,"stats":{"Line":476}},{"line":36,"address":[],"length":0,"stats":{"Line":572}},{"line":38,"address":[],"length":0,"stats":{"Line":9}},{"line":42,"address":[],"length":0,"stats":{"Line":466}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":568}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":700}},{"line":53,"address":[],"length":0,"stats":{"Line":210}},{"line":54,"address":[],"length":0,"stats":{"Line":315}},{"line":58,"address":[],"length":0,"stats":{"Line":96}},{"line":61,"address":[],"length":0,"stats":{"Line":216}},{"line":62,"address":[],"length":0,"stats":{"Line":324}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":22}},{"line":79,"address":[],"length":0,"stats":{"Line":22}},{"line":81,"address":[],"length":0,"stats":{"Line":166}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":38}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":18}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":18}},{"line":121,"address":[],"length":0,"stats":{"Line":18}},{"line":122,"address":[],"length":0,"stats":{"Line":36}},{"line":126,"address":[],"length":0,"stats":{"Line":22}},{"line":127,"address":[],"length":0,"stats":{"Line":44}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":44}},{"line":158,"address":[],"length":0,"stats":{"Line":22}},{"line":160,"address":[],"length":0,"stats":{"Line":44}},{"line":161,"address":[],"length":0,"stats":{"Line":22}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":5}},{"line":194,"address":[],"length":0,"stats":{"Line":105}},{"line":195,"address":[],"length":0,"stats":{"Line":105}},{"line":196,"address":[],"length":0,"stats":{"Line":77}},{"line":199,"address":[],"length":0,"stats":{"Line":56}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":27}},{"line":207,"address":[],"length":0,"stats":{"Line":108}},{"line":208,"address":[],"length":0,"stats":{"Line":13}},{"line":209,"address":[],"length":0,"stats":{"Line":216}},{"line":218,"address":[],"length":0,"stats":{"Line":9}},{"line":224,"address":[],"length":0,"stats":{"Line":27}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":33}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":233,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":36}},{"line":244,"address":[],"length":0,"stats":{"Line":11}},{"line":250,"address":[],"length":0,"stats":{"Line":45}},{"line":251,"address":[],"length":0,"stats":{"Line":17}},{"line":252,"address":[],"length":0,"stats":{"Line":17}},{"line":254,"address":[],"length":0,"stats":{"Line":73}},{"line":255,"address":[],"length":0,"stats":{"Line":44}},{"line":256,"address":[],"length":0,"stats":{"Line":22}},{"line":257,"address":[],"length":0,"stats":{"Line":16}},{"line":258,"address":[],"length":0,"stats":{"Line":16}},{"line":259,"address":[],"length":0,"stats":{"Line":16}},{"line":260,"address":[],"length":0,"stats":{"Line":16}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":18}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":11}}],"covered":87,"coverable":114},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","type_environment.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::{ConstructorParameter, TypeParameter};\nuse typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\nuse typedlua_parser::span::Span;\n\n/// A generic type alias with type parameters\n#[derive(Debug, Clone)]\npub struct GenericTypeAlias {\n    pub type_parameters: Vec\u003cTypeParameter\u003e,\n    pub typ: Type,\n}\n\n/// Type environment managing type aliases and interfaces\n#[derive(Debug)]\npub struct TypeEnvironment {\n    /// Type aliases (type Foo = ...)\n    type_aliases: FxHashMap\u003cString, Type\u003e,\n    /// Generic type aliases (type Foo\u003cT\u003e = ...)\n    generic_type_aliases: FxHashMap\u003cString, GenericTypeAlias\u003e,\n    /// Interface types\n    interfaces: FxHashMap\u003cString, Type\u003e,\n    /// Built-in types\n    builtins: FxHashMap\u003cString, Type\u003e,\n    /// Currently resolving types (for cycle detection)\n    resolving: std::cell::RefCell\u003cstd::collections::HashSet\u003cString\u003e\u003e,\n    /// Type parameter constraints (T -\u003e constraint type)\n    type_param_constraints: FxHashMap\u003cString, Type\u003e,\n    /// Class implements relationships (class name -\u003e list of implemented interface types)\n    class_implements: FxHashMap\u003cString, Vec\u003cType\u003e\u003e,\n    /// Abstract classes (class name -\u003e is_abstract)\n    abstract_classes: FxHashMap\u003cString, bool\u003e,\n    /// Class primary constructors (class name -\u003e constructor parameters)\n    class_constructors: FxHashMap\u003cString, Vec\u003cConstructorParameter\u003e\u003e,\n    /// Interface type parameter names (interface name -\u003e ordered parameter names)\n    interface_type_params: FxHashMap\u003cString, Vec\u003cString\u003e\u003e,\n}\n\nimpl TypeEnvironment {\n    pub fn new() -\u003e Self {\n        let mut env = Self {\n            type_aliases: FxHashMap::default(),\n            generic_type_aliases: FxHashMap::default(),\n            interfaces: FxHashMap::default(),\n            builtins: FxHashMap::default(),\n            resolving: std::cell::RefCell::new(std::collections::HashSet::new()),\n            type_param_constraints: FxHashMap::default(),\n            class_implements: FxHashMap::default(),\n            abstract_classes: FxHashMap::default(),\n            class_constructors: FxHashMap::default(),\n            interface_type_params: FxHashMap::default(),\n        };\n\n        env.register_builtins();\n        env\n    }\n\n    /// Register built-in types\n    fn register_builtins(\u0026mut self) {\n        let span = Span::new(0, 0, 0, 0);\n\n        // Primitive types\n        self.builtins.insert(\n            \"nil\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Nil), span),\n        );\n        self.builtins.insert(\n            \"boolean\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span),\n        );\n        self.builtins.insert(\n            \"number\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n        );\n        self.builtins.insert(\n            \"integer\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Integer), span),\n        );\n        self.builtins.insert(\n            \"string\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::String), span),\n        );\n        self.builtins.insert(\n            \"unknown\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span),\n        );\n        self.builtins.insert(\n            \"never\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Never), span),\n        );\n        self.builtins.insert(\n            \"void\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Void), span),\n        );\n        self.builtins.insert(\n            \"table\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Table), span),\n        );\n        self.builtins.insert(\n            \"coroutine\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Coroutine), span),\n        );\n    }\n\n    /// Register a type alias\n    pub fn register_type_alias(\u0026mut self, name: String, typ: Type) -\u003e Result\u003c(), String\u003e {\n        if self.type_aliases.contains_key(\u0026name) {\n            return Err(format!(\"Type alias '{}' already defined\", name));\n        }\n        self.type_aliases.insert(name, typ);\n        Ok(())\n    }\n\n    /// Remove a type alias (used for cleaning up scoped type parameters)\n    pub fn remove_type_alias(\u0026mut self, name: \u0026str) {\n        self.type_aliases.remove(name);\n    }\n\n    /// Register a generic type alias\n    pub fn register_generic_type_alias(\n        \u0026mut self,\n        name: String,\n        type_parameters: Vec\u003cTypeParameter\u003e,\n        typ: Type,\n    ) -\u003e Result\u003c(), String\u003e {\n        if self.generic_type_aliases.contains_key(\u0026name) {\n            return Err(format!(\"Generic type alias '{}' already defined\", name));\n        }\n        self.generic_type_aliases.insert(\n            name,\n            GenericTypeAlias {\n                type_parameters,\n                typ,\n            },\n        );\n        Ok(())\n    }\n\n    /// Register an interface\n    pub fn register_interface(\u0026mut self, name: String, typ: Type) -\u003e Result\u003c(), String\u003e {\n        if self.interfaces.contains_key(\u0026name) {\n            return Err(format!(\"Interface '{}' already defined\", name));\n        }\n        self.interfaces.insert(name.clone(), typ);\n        Ok(())\n    }\n\n    /// Register the type parameter names for a generic interface.\n    pub fn register_interface_type_params(\u0026mut self, name: String, params: Vec\u003cString\u003e) {\n        self.interface_type_params.insert(name, params);\n    }\n\n    /// Get the type parameter names for a generic interface.\n    pub fn get_interface_type_params(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cString\u003e\u003e {\n        self.interface_type_params.get(name)\n    }\n\n    /// Look up a type by name (checks type aliases, interfaces, and builtins)\n    pub fn lookup_type(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_aliases\n            .get(name)\n            .or_else(|| self.interfaces.get(name))\n            .or_else(|| self.builtins.get(name))\n    }\n\n    /// Look up a type alias\n    pub fn lookup_type_alias(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_aliases.get(name)\n    }\n\n    /// Look up an interface\n    pub fn lookup_interface(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.interfaces.get(name)\n    }\n\n    /// Get an interface (alias for lookup_interface)\n    pub fn get_interface(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.lookup_interface(name)\n    }\n\n    /// Check if a type name is defined\n    pub fn is_type_defined(\u0026self, name: \u0026str) -\u003e bool {\n        self.lookup_type(name).is_some()\n    }\n\n    /// Register a type parameter constraint (e.g., T extends/implements Identifiable)\n    pub fn register_type_param_constraint(\u0026mut self, name: String, constraint: Type) {\n        self.type_param_constraints.insert(name, constraint);\n    }\n\n    /// Remove a type parameter constraint\n    pub fn remove_type_param_constraint(\u0026mut self, name: \u0026str) {\n        self.type_param_constraints.remove(name);\n    }\n\n    /// Get the constraint for a type parameter\n    pub fn get_type_param_constraint(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_param_constraints.get(name)\n    }\n\n    /// Register that a class implements one or more interfaces\n    pub fn register_class_implements(\u0026mut self, class_name: String, interfaces: Vec\u003cType\u003e) {\n        self.class_implements.insert(class_name, interfaces);\n    }\n\n    /// Get the interfaces a class implements\n    pub fn get_class_implements(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cType\u003e\u003e {\n        self.class_implements.get(class_name)\n    }\n\n    /// Register a class as abstract\n    pub fn register_abstract_class(\u0026mut self, class_name: String) {\n        self.abstract_classes.insert(class_name, true);\n    }\n\n    /// Check if a class is abstract\n    pub fn is_abstract_class(\u0026self, class_name: \u0026str) -\u003e bool {\n        self.abstract_classes\n            .get(class_name)\n            .copied()\n            .unwrap_or(false)\n    }\n\n    /// Register a class's primary constructor parameters\n    pub fn register_class_constructor(\n        \u0026mut self,\n        class_name: String,\n        params: Vec\u003cConstructorParameter\u003e,\n    ) {\n        self.class_constructors.insert(class_name, params);\n    }\n\n    /// Get a class's primary constructor parameters\n    pub fn get_class_constructor(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cConstructorParameter\u003e\u003e {\n        self.class_constructors.get(class_name)\n    }\n\n    /// Resolve a type reference, detecting cycles\n    pub fn resolve_type_reference(\u0026self, name: \u0026str) -\u003e Result\u003cOption\u003cType\u003e, String\u003e {\n        // Check if we're already resolving this type (cycle detection)\n        if self.resolving.borrow().contains(name) {\n            return Err(format!(\"Recursive type alias '{}' detected\", name));\n        }\n\n        // Mark as resolving\n        self.resolving.borrow_mut().insert(name.to_string());\n\n        // Look up the type\n        let result = self.lookup_type(name).cloned();\n\n        // Unmark\n        self.resolving.borrow_mut().remove(name);\n\n        Ok(result)\n    }\n\n    /// Get a generic type alias\n    pub fn get_generic_type_alias(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026GenericTypeAlias\u003e {\n        self.generic_type_aliases.get(name)\n    }\n\n    /// Check if a name is a built-in utility type\n    pub fn is_utility_type(name: \u0026str) -\u003e bool {\n        matches!(\n            name,\n            \"Partial\"\n                | \"Required\"\n                | \"Readonly\"\n                | \"Record\"\n                | \"Pick\"\n                | \"Omit\"\n                | \"Exclude\"\n                | \"Extract\"\n                | \"NonNilable\"\n                | \"Nilable\"\n                | \"ReturnType\"\n                | \"Parameters\"\n        )\n    }\n\n    /// Resolve a utility type with type arguments\n    pub fn resolve_utility_type(\n        \u0026self,\n        name: \u0026str,\n        type_args: \u0026[Type],\n        span: Span,\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n        common_ids: \u0026typedlua_parser::string_interner::CommonIdentifiers,\n    ) -\u003e Result\u003cType, String\u003e {\n        use crate::types::utility_types::apply_utility_type;\n        apply_utility_type(name, type_args, span, interner, common_ids)\n    }\n}\n\nimpl Default for TypeEnvironment {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_builtins_registered() {\n        let env = TypeEnvironment::new();\n\n        assert!(env.lookup_type(\"number\").is_some());\n        assert!(env.lookup_type(\"string\").is_some());\n        assert!(env.lookup_type(\"boolean\").is_some());\n        assert!(env.lookup_type(\"nil\").is_some());\n        assert!(env.lookup_type(\"unknown\").is_some());\n        assert!(env.lookup_type(\"never\").is_some());\n        assert!(env.lookup_type(\"void\").is_some());\n    }\n\n    #[test]\n    fn test_register_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_type_alias(\"MyNumber\".to_string(), typ)\n            .unwrap();\n\n        assert!(env.lookup_type(\"MyNumber\").is_some());\n        assert!(env.lookup_type_alias(\"MyNumber\").is_some());\n    }\n\n    #[test]\n    fn test_register_interface() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Table),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_interface(\"MyInterface\".to_string(), typ)\n            .unwrap();\n\n        assert!(env.lookup_type(\"MyInterface\").is_some());\n        assert!(env.lookup_interface(\"MyInterface\").is_some());\n    }\n\n    #[test]\n    fn test_duplicate_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_type_alias(\"Foo\".to_string(), typ.clone())\n            .unwrap();\n        assert!(env.register_type_alias(\"Foo\".to_string(), typ).is_err());\n    }\n\n    #[test]\n    fn test_all_builtins_registered() {\n        let env = TypeEnvironment::new();\n\n        let builtins = vec![\n            \"nil\",\n            \"boolean\",\n            \"number\",\n            \"integer\",\n            \"string\",\n            \"unknown\",\n            \"never\",\n            \"void\",\n            \"table\",\n            \"coroutine\",\n        ];\n\n        for builtin in \u0026builtins {\n            assert!(\n                env.lookup_type(builtin).is_some(),\n                \"Builtin type '{}' should be registered\",\n                builtin\n            );\n        }\n    }\n\n    #[test]\n    fn test_is_type_defined() {\n        let mut env = TypeEnvironment::new();\n\n        // Builtins should be defined\n        assert!(env.is_type_defined(\"number\"));\n        assert!(env.is_type_defined(\"string\"));\n\n        // Custom types should not be defined initially\n        assert!(!env.is_type_defined(\"MyType\"));\n\n        // Register custom type\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_type_alias(\"MyType\".to_string(), typ).unwrap();\n\n        // Now it should be defined\n        assert!(env.is_type_defined(\"MyType\"));\n    }\n\n    #[test]\n    fn test_lookup_type_alias_priority() {\n        let mut env = TypeEnvironment::new();\n\n        // Register interface with same name as type alias\n        let alias_type = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_type_alias(\"Foo\".to_string(), alias_type.clone())\n            .unwrap();\n\n        let interface_type = Type::new(\n            TypeKind::Primitive(PrimitiveType::String),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_interface(\"Foo\".to_string(), interface_type.clone())\n            .unwrap();\n\n        // Type aliases take priority over interfaces in lookup_type\n        let found = env.lookup_type(\"Foo\").unwrap();\n        match \u0026found.kind {\n            TypeKind::Primitive(PrimitiveType::Number) =\u003e (), // Type alias\n            TypeKind::Primitive(PrimitiveType::String) =\u003e {\n                panic!(\"Should have found type alias, not interface\")\n            }\n            _ =\u003e panic!(\"Unexpected type\"),\n        }\n    }\n\n    #[test]\n    fn test_register_generic_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        // Create a proper TypeParameter with StringId\n        use typedlua_parser::ast::Spanned;\n        use typedlua_parser::string_interner::StringInterner;\n\n        let interner = StringInterner::new();\n        let t_id = interner.get_or_intern(\"T\");\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, Span::new(0, 1, 1, 0)),\n            constraint: None,\n            default: None,\n            span: Span::new(0, 1, 1, 0),\n        };\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_generic_type_alias(\"Container\".to_string(), vec![type_param], typ)\n            .unwrap();\n\n        let generic_alias = env.get_generic_type_alias(\"Container\");\n        assert!(generic_alias.is_some());\n        assert_eq!(generic_alias.unwrap().type_parameters.len(), 1);\n    }\n\n    #[test]\n    fn test_duplicate_generic_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_generic_type_alias(\"Box\".to_string(), vec![], typ.clone())\n            .unwrap();\n        assert!(env\n            .register_generic_type_alias(\"Box\".to_string(), vec![], typ)\n            .is_err());\n    }\n\n    #[test]\n    fn test_duplicate_interface() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Table),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_interface(\"MyInterface\".to_string(), typ.clone())\n            .unwrap();\n        assert!(env\n            .register_interface(\"MyInterface\".to_string(), typ)\n            .is_err());\n    }\n\n    #[test]\n    fn test_resolve_type_reference_success() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_type_alias(\"MyNumber\".to_string(), typ)\n            .unwrap();\n\n        let resolved = env.resolve_type_reference(\"MyNumber\");\n        assert!(resolved.is_ok());\n        assert!(resolved.unwrap().is_some());\n    }\n\n    #[test]\n    fn test_resolve_type_reference_not_found() {\n        let env = TypeEnvironment::new();\n\n        let resolved = env.resolve_type_reference(\"NonExistent\");\n        assert!(resolved.is_ok());\n        assert!(resolved.unwrap().is_none());\n    }\n\n    #[test]\n    fn test_resolve_type_reference_cycle() {\n        let env = TypeEnvironment::new();\n\n        // Create a self-referencing type alias\n        // Note: This requires the type to reference itself, which is tricky\n        // with the current API. For now, we'll just test that the cycle\n        // detection mechanism works by manually marking a type as resolving.\n        env.resolving.borrow_mut().insert(\"Cycle\".to_string());\n\n        let result = env.resolve_type_reference(\"Cycle\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Recursive type alias\"));\n\n        // Clean up\n        env.resolving.borrow_mut().remove(\"Cycle\");\n    }\n\n    #[test]\n    fn test_is_utility_type() {\n        let utility_types = vec![\n            \"Partial\",\n            \"Required\",\n            \"Readonly\",\n            \"Record\",\n            \"Pick\",\n            \"Omit\",\n            \"Exclude\",\n            \"Extract\",\n            \"NonNilable\",\n            \"Nilable\",\n            \"ReturnType\",\n            \"Parameters\",\n        ];\n\n        for utility in \u0026utility_types {\n            assert!(\n                TypeEnvironment::is_utility_type(utility),\n                \"'{}' should be recognized as utility type\",\n                utility\n            );\n        }\n\n        let non_utility_types = vec![\"number\", \"string\", \"Array\", \"Map\", \"MyType\"];\n\n        for non_utility in \u0026non_utility_types {\n            assert!(\n                !TypeEnvironment::is_utility_type(non_utility),\n                \"'{}' should not be recognized as utility type\",\n                non_utility\n            );\n        }\n    }\n\n    #[test]\n    fn test_get_interface_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Table),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_interface(\"User\".to_string(), typ.clone())\n            .unwrap();\n\n        // get_interface should be an alias for lookup_interface\n        assert!(env.get_interface(\"User\").is_some());\n        assert!(env.get_interface(\"NonExistent\").is_none());\n    }\n\n    #[test]\n    fn test_default_impl() {\n        let env: TypeEnvironment = Default::default();\n        assert!(env.lookup_type(\"number\").is_some());\n    }\n\n    #[test]\n    fn test_multiple_type_aliases() {\n        let mut env = TypeEnvironment::new();\n\n        let types = vec![\n            (\"Int\", PrimitiveType::Integer),\n            (\"Float\", PrimitiveType::Number),\n            (\"Bool\", PrimitiveType::Boolean),\n            (\"Str\", PrimitiveType::String),\n        ];\n\n        for (name, prim) in \u0026types {\n            let typ = Type::new(TypeKind::Primitive(*prim), Span::new(0, 0, 0, 0));\n            env.register_type_alias(name.to_string(), typ).unwrap();\n        }\n\n        for (name, _) in \u0026types {\n            assert!(env.lookup_type(name).is_some());\n        }\n    }\n\n    #[test]\n    fn test_type_not_found_returns_none() {\n        let env = TypeEnvironment::new();\n\n        assert!(env.lookup_type(\"UnknownType\").is_none());\n        assert!(env.lookup_type_alias(\"UnknownType\").is_none());\n        assert!(env.lookup_interface(\"UnknownType\").is_none());\n        assert!(env.get_generic_type_alias(\"UnknownType\").is_none());\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":356}},{"line":41,"address":[],"length":0,"stats":{"Line":712}},{"line":42,"address":[],"length":0,"stats":{"Line":712}},{"line":43,"address":[],"length":0,"stats":{"Line":712}},{"line":44,"address":[],"length":0,"stats":{"Line":712}},{"line":45,"address":[],"length":0,"stats":{"Line":1068}},{"line":46,"address":[],"length":0,"stats":{"Line":712}},{"line":47,"address":[],"length":0,"stats":{"Line":712}},{"line":48,"address":[],"length":0,"stats":{"Line":712}},{"line":49,"address":[],"length":0,"stats":{"Line":356}},{"line":50,"address":[],"length":0,"stats":{"Line":356}},{"line":53,"address":[],"length":0,"stats":{"Line":712}},{"line":54,"address":[],"length":0,"stats":{"Line":356}},{"line":58,"address":[],"length":0,"stats":{"Line":356}},{"line":59,"address":[],"length":0,"stats":{"Line":712}},{"line":62,"address":[],"length":0,"stats":{"Line":712}},{"line":63,"address":[],"length":0,"stats":{"Line":712}},{"line":64,"address":[],"length":0,"stats":{"Line":1068}},{"line":66,"address":[],"length":0,"stats":{"Line":712}},{"line":67,"address":[],"length":0,"stats":{"Line":712}},{"line":68,"address":[],"length":0,"stats":{"Line":1068}},{"line":70,"address":[],"length":0,"stats":{"Line":712}},{"line":71,"address":[],"length":0,"stats":{"Line":712}},{"line":72,"address":[],"length":0,"stats":{"Line":1068}},{"line":74,"address":[],"length":0,"stats":{"Line":712}},{"line":75,"address":[],"length":0,"stats":{"Line":712}},{"line":76,"address":[],"length":0,"stats":{"Line":1068}},{"line":78,"address":[],"length":0,"stats":{"Line":712}},{"line":79,"address":[],"length":0,"stats":{"Line":712}},{"line":80,"address":[],"length":0,"stats":{"Line":1068}},{"line":82,"address":[],"length":0,"stats":{"Line":712}},{"line":83,"address":[],"length":0,"stats":{"Line":712}},{"line":84,"address":[],"length":0,"stats":{"Line":1068}},{"line":86,"address":[],"length":0,"stats":{"Line":712}},{"line":87,"address":[],"length":0,"stats":{"Line":712}},{"line":88,"address":[],"length":0,"stats":{"Line":1068}},{"line":90,"address":[],"length":0,"stats":{"Line":712}},{"line":91,"address":[],"length":0,"stats":{"Line":712}},{"line":92,"address":[],"length":0,"stats":{"Line":1068}},{"line":94,"address":[],"length":0,"stats":{"Line":712}},{"line":95,"address":[],"length":0,"stats":{"Line":712}},{"line":96,"address":[],"length":0,"stats":{"Line":1068}},{"line":98,"address":[],"length":0,"stats":{"Line":712}},{"line":99,"address":[],"length":0,"stats":{"Line":712}},{"line":100,"address":[],"length":0,"stats":{"Line":1068}},{"line":105,"address":[],"length":0,"stats":{"Line":179}},{"line":106,"address":[],"length":0,"stats":{"Line":537}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":708}},{"line":110,"address":[],"length":0,"stats":{"Line":177}},{"line":114,"address":[],"length":0,"stats":{"Line":44}},{"line":115,"address":[],"length":0,"stats":{"Line":132}},{"line":119,"address":[],"length":0,"stats":{"Line":29}},{"line":125,"address":[],"length":0,"stats":{"Line":87}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":56}},{"line":129,"address":[],"length":0,"stats":{"Line":28}},{"line":130,"address":[],"length":0,"stats":{"Line":28}},{"line":131,"address":[],"length":0,"stats":{"Line":28}},{"line":132,"address":[],"length":0,"stats":{"Line":28}},{"line":135,"address":[],"length":0,"stats":{"Line":28}},{"line":139,"address":[],"length":0,"stats":{"Line":42}},{"line":140,"address":[],"length":0,"stats":{"Line":126}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":200}},{"line":144,"address":[],"length":0,"stats":{"Line":40}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":197}},{"line":159,"address":[],"length":0,"stats":{"Line":197}},{"line":160,"address":[],"length":0,"stats":{"Line":394}},{"line":161,"address":[],"length":0,"stats":{"Line":401}},{"line":162,"address":[],"length":0,"stats":{"Line":359}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":9}},{"line":172,"address":[],"length":0,"stats":{"Line":27}},{"line":176,"address":[],"length":0,"stats":{"Line":7}},{"line":177,"address":[],"length":0,"stats":{"Line":21}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":15}},{"line":192,"address":[],"length":0,"stats":{"Line":45}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":197,"address":[],"length":0,"stats":{"Line":24}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":202,"address":[],"length":0,"stats":{"Line":16}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":12}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":6}},{"line":248,"address":[],"length":0,"stats":{"Line":10}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":27}},{"line":258,"address":[],"length":0,"stats":{"Line":81}},{"line":262,"address":[],"length":0,"stats":{"Line":64}},{"line":263,"address":[],"length":0,"stats":{"Line":34}},{"line":264,"address":[],"length":0,"stats":{"Line":64}},{"line":281,"address":[],"length":0,"stats":{"Line":22}},{"line":290,"address":[],"length":0,"stats":{"Line":132}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}}],"covered":107,"coverable":118},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","helpers","control_flow.rs"],"content":"//! Control flow analysis utilities\n//!\n//! This module provides utilities for analyzing control flow in TypedLua programs,\n//! including checking whether code paths always return or terminate.\n\nuse typedlua_parser::ast::expression::ExpressionKind;\nuse typedlua_parser::ast::statement::{Block, Statement};\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Check if a block always returns (has a return statement on all code paths).\n///\n/// This function recursively analyzes statements in a block to determine if\n/// every possible execution path ends with a return statement or other terminating\n/// statement (like throw).\n///\n/// # Parameters\n///\n/// - `block`: The block to analyze\n/// - `interner`: String interner for resolving function names\n///\n/// # Returns\n///\n/// Returns `true` if the block always returns on all code paths, `false` otherwise.\npub fn block_always_returns(block: \u0026Block, interner: \u0026StringInterner) -\u003e bool {\n    for stmt in \u0026block.statements {\n        if statement_always_returns(stmt, interner) {\n            return true;\n        }\n    }\n    false\n}\n\n/// Check if a statement always returns.\n///\n/// This function analyzes whether a statement will definitely result in a return\n/// or termination on all possible execution paths.\n///\n/// # Parameters\n///\n/// - `stmt`: The statement to analyze\n/// - `interner`: String interner for resolving function names\n///\n/// # Returns\n///\n/// Returns `true` if the statement always returns/terminates, `false` otherwise.\n///\n/// # Analyzed Statement Types\n///\n/// - **Return**: Always returns\n/// - **Throw**: Always terminates\n/// - **If**: Returns if both then and else branches return\n/// - **Try-catch**: Returns if finally returns, OR if try + all catches return\n/// - **Expression**: Returns if calling a known non-returning function (unreachable, error, throw)\npub fn statement_always_returns(stmt: \u0026Statement, interner: \u0026StringInterner) -\u003e bool {\n    match stmt {\n        Statement::Return(_) =\u003e true,\n        Statement::If(if_stmt) =\u003e {\n            // If statement always returns if both branches always return\n            let then_returns = block_always_returns(\u0026if_stmt.then_block, interner);\n            let else_returns = if_stmt\n                .else_block\n                .as_ref()\n                .map(|b| block_always_returns(b, interner))\n                .unwrap_or(false);\n            then_returns \u0026\u0026 else_returns\n        }\n        Statement::Try(try_stmt) =\u003e {\n            // Try-catch always returns if:\n            // 1. Finally block always returns (catches all paths), OR\n            // 2. Try block always returns AND all catch blocks always return\n            if let Some(ref finally) = try_stmt.finally_block {\n                if block_always_returns(finally, interner) {\n                    return true;\n                }\n            }\n\n            // Check try block and all catch blocks\n            let try_returns = block_always_returns(\u0026try_stmt.try_block, interner);\n            let all_catches_return = try_stmt\n                .catch_clauses\n                .iter()\n                .all(|catch| block_always_returns(\u0026catch.body, interner));\n\n            try_returns \u0026\u0026 all_catches_return \u0026\u0026 !try_stmt.catch_clauses.is_empty()\n        }\n        Statement::Throw(_) =\u003e true,\n        Statement::Expression(expr) =\u003e {\n            // Check if the expression is a call to a function that never returns\n            // (like unreachable(), error(), throw)\n            if let ExpressionKind::Call(callee, _, _) = \u0026expr.kind {\n                if let ExpressionKind::Identifier(string_id) = \u0026callee.kind {\n                    let name = interner.resolve(*string_id);\n                    name == \"unreachable\" || name == \"error\" || name == \"throw\"\n                } else {\n                    false\n                }\n            } else {\n                false\n            }\n        }\n        _ =\u003e false,\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":32}},{"line":25,"address":[],"length":0,"stats":{"Line":66}},{"line":26,"address":[],"length":0,"stats":{"Line":99}},{"line":27,"address":[],"length":0,"stats":{"Line":32}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":33}},{"line":55,"address":[],"length":0,"stats":{"Line":33}},{"line":56,"address":[],"length":0,"stats":{"Line":32}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":1}}],"covered":8,"coverable":32},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","helpers","mod.rs"],"content":"//! Helper modules for the type checker\n//!\n//! This module contains extracted utility functions and helpers that are reusable\n//! and have clear separation of concerns from the main type checker logic.\n\npub mod control_flow;\npub mod type_utilities;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","helpers","type_utilities.rs"],"content":"//! Pure type utility functions\n//!\n//! This module contains pure utility functions for working with types that\n//! don't require access to type checker state.\n//!\n//! These functions are meant to be used by the type checker and other modules\n//! as part of the refactoring effort to reduce cognitive load.\n\n#![allow(dead_code)] // Functions will be used during type_checker.rs refactoring\n\nuse typedlua_parser::ast::expression::*;\nuse typedlua_parser::ast::statement::*;\nuse typedlua_parser::ast::types::*;\n\n/// Widens literal types to their base primitive types.\n///\n/// Converts literal types (e.g., `42`, `\"hello\"`, `true`, `nil`) to their base\n/// primitive types (`number`, `string`, `boolean`, `nil`). Non-literal types are\n/// returned unchanged.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// // 42  number\n/// // \"hello\"  string\n/// // true  boolean\n/// // nil  nil\n/// // number  number (unchanged)\n/// ```\npub fn widen_type(typ: Type) -\u003e Type {\n    match typ.kind {\n        TypeKind::Literal(Literal::Number(_)) | TypeKind::Literal(Literal::Integer(_)) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), typ.span)\n        }\n        TypeKind::Literal(Literal::String(_)) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::String), typ.span)\n        }\n        TypeKind::Literal(Literal::Boolean(_)) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::Boolean), typ.span)\n        }\n        TypeKind::Literal(Literal::Nil) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::Nil), typ.span)\n        }\n        _ =\u003e typ,\n    }\n}\n\n/// Checks if a type is the boolean primitive type.\n///\n/// # Returns\n///\n/// `true` if the type is `boolean`, `false` otherwise.\npub fn is_boolean_type(typ: \u0026Type) -\u003e bool {\n    matches!(typ.kind, TypeKind::Primitive(PrimitiveType::Boolean))\n}\n\n/// Maps operator kinds to their Lua metamethod names.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// operator_kind_name(\u0026OperatorKind::Add) // \"__add\"\n/// operator_kind_name(\u0026OperatorKind::Subtract) // \"__sub\"\n/// operator_kind_name(\u0026OperatorKind::Index) // \"__index\"\n/// ```\npub fn operator_kind_name(op: \u0026OperatorKind) -\u003e String {\n    match op {\n        OperatorKind::Add =\u003e \"__add\",\n        OperatorKind::Subtract =\u003e \"__sub\",\n        OperatorKind::Multiply =\u003e \"__mul\",\n        OperatorKind::Divide =\u003e \"__div\",\n        OperatorKind::FloorDivide =\u003e \"__idiv\",\n        OperatorKind::Modulo =\u003e \"__mod\",\n        OperatorKind::Power =\u003e \"__pow\",\n        OperatorKind::Concatenate =\u003e \"__concat\",\n        OperatorKind::Equal =\u003e \"__eq\",\n        OperatorKind::NotEqual =\u003e \"__ne\",\n        OperatorKind::LessThan =\u003e \"__lt\",\n        OperatorKind::LessThanOrEqual =\u003e \"__le\",\n        OperatorKind::GreaterThan =\u003e \"__gt\",\n        OperatorKind::GreaterThanOrEqual =\u003e \"__ge\",\n        OperatorKind::Length =\u003e \"__len\",\n        OperatorKind::UnaryMinus =\u003e \"__unm\",\n        OperatorKind::BitwiseAnd =\u003e \"__band\",\n        OperatorKind::BitwiseOr =\u003e \"__bor\",\n        OperatorKind::BitwiseXor =\u003e \"__bxor\",\n        OperatorKind::ShiftLeft =\u003e \"__shl\",\n        OperatorKind::ShiftRight =\u003e \"__shr\",\n        OperatorKind::Index =\u003e \"__index\",\n        OperatorKind::NewIndex =\u003e \"__newindex\",\n        OperatorKind::Call =\u003e \"__call\",\n    }\n    .to_string()\n}\n\n/// Converts a type to a human-readable string representation for error messages.\n///\n/// This provides a simplified string representation of types for diagnostic output.\npub fn type_to_string(typ: \u0026Type) -\u003e String {\n    match \u0026typ.kind {\n        TypeKind::Primitive(prim) =\u003e format!(\"{:?}\", prim).to_lowercase(),\n        TypeKind::Literal(lit) =\u003e match lit {\n            Literal::String(s) =\u003e format!(\"\\\"{}\\\"\", s),\n            Literal::Number(n) =\u003e n.to_string(),\n            Literal::Integer(i) =\u003e i.to_string(),\n            Literal::Boolean(b) =\u003e b.to_string(),\n            Literal::Nil =\u003e \"nil\".to_string(),\n        },\n        TypeKind::Array(elem_type) =\u003e format!(\"{}[]\", type_to_string(elem_type)),\n        TypeKind::Tuple(types) =\u003e {\n            let type_strs: Vec\u003c_\u003e = types.iter().map(type_to_string).collect();\n            format!(\"[{}]\", type_strs.join(\", \"))\n        }\n        TypeKind::Union(types) =\u003e {\n            let type_strs: Vec\u003c_\u003e = types.iter().map(type_to_string).collect();\n            type_strs.join(\" | \")\n        }\n        TypeKind::Intersection(types) =\u003e {\n            let type_strs: Vec\u003c_\u003e = types.iter().map(type_to_string).collect();\n            type_strs.join(\" \u0026 \")\n        }\n        TypeKind::Nullable(inner) =\u003e format!(\"{}?\", type_to_string(inner)),\n        TypeKind::Function(_) =\u003e \"function\".to_string(),\n        TypeKind::Object(_) =\u003e \"object\".to_string(),\n        TypeKind::Reference(_) =\u003e \"type reference\".to_string(),\n        TypeKind::Infer(_) =\u003e \"infer type\".to_string(),\n        TypeKind::KeyOf(_) =\u003e \"keyof\".to_string(),\n        TypeKind::TypeQuery(_) =\u003e \"typeof\".to_string(),\n        TypeKind::IndexAccess(_, _) =\u003e \"indexed access type\".to_string(),\n        TypeKind::Conditional(_) =\u003e \"conditional type\".to_string(),\n        TypeKind::Mapped(_) =\u003e \"mapped type\".to_string(),\n        TypeKind::TemplateLiteral(_) =\u003e \"template literal type\".to_string(),\n        TypeKind::TypePredicate(_) =\u003e \"type predicate\".to_string(),\n        TypeKind::Parenthesized(inner) =\u003e type_to_string(inner),\n        TypeKind::Variadic(inner) =\u003e format!(\"...{}\", type_to_string(inner)),\n        TypeKind::Namespace(_) =\u003e \"namespace\".to_string(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    fn make_type(kind: TypeKind) -\u003e Type {\n        Type::new(kind, Span::default())\n    }\n\n    #[test]\n    fn test_widen_type_string_literal() {\n        let literal = make_type(TypeKind::Literal(Literal::String(\"hello\".to_string())));\n        let widened = widen_type(literal);\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_widen_type_number_literal() {\n        let literal = make_type(TypeKind::Literal(Literal::Number(42.0)));\n        let widened = widen_type(literal);\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_widen_type_boolean_literal() {\n        let literal = make_type(TypeKind::Literal(Literal::Boolean(true)));\n        let widened = widen_type(literal);\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_widen_type_non_literal_unchanged() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let widened = widen_type(number_type.clone());\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_is_boolean_type_true() {\n        let bool_type = make_type(TypeKind::Primitive(PrimitiveType::Boolean));\n        assert!(is_boolean_type(\u0026bool_type));\n    }\n\n    #[test]\n    fn test_is_boolean_type_false() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        assert!(!is_boolean_type(\u0026number_type));\n    }\n\n    #[test]\n    fn test_operator_kind_name() {\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Add), \"__add\");\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Subtract), \"__sub\");\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Index), \"__index\");\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Call), \"__call\");\n    }\n\n    #[test]\n    fn test_type_to_string_primitives() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        assert_eq!(type_to_string(\u0026number_type), \"number\");\n\n        let string_type = make_type(TypeKind::Primitive(PrimitiveType::String));\n        assert_eq!(type_to_string(\u0026string_type), \"string\");\n    }\n\n    #[test]\n    fn test_type_to_string_literals() {\n        let str_literal = make_type(TypeKind::Literal(Literal::String(\"hello\".to_string())));\n        assert_eq!(type_to_string(\u0026str_literal), \"\\\"hello\\\"\");\n\n        let num_literal = make_type(TypeKind::Literal(Literal::Number(42.0)));\n        assert_eq!(type_to_string(\u0026num_literal), \"42\");\n    }\n\n    #[test]\n    fn test_type_to_string_array() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let array_type = make_type(TypeKind::Array(Box::new(number_type)));\n        assert_eq!(type_to_string(\u0026array_type), \"number[]\");\n    }\n\n    #[test]\n    fn test_type_to_string_union() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string_type = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let union_type = make_type(TypeKind::Union(vec![number_type, string_type]));\n        assert_eq!(type_to_string(\u0026union_type), \"number | string\");\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":85}},{"line":31,"address":[],"length":0,"stats":{"Line":31}},{"line":33,"address":[],"length":0,"stats":{"Line":51}},{"line":36,"address":[],"length":0,"stats":{"Line":36}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":54}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":69},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","lib.rs"],"content":"pub mod cli;\npub mod core;\npub mod helpers;\npub mod module_resolver;\npub mod phases;\npub mod state;\npub mod stdlib;\npub mod types;\npub mod utils;\npub mod visitors;\n\npub use core::type_checker::TypeChecker;\npub use core::type_compat::TypeCompatibility;\npub use core::type_environment::TypeEnvironment;\npub use state::TypeCheckerState;\npub use types::generics::{\n    build_substitutions, check_type_constraints, infer_type_arguments,\n    instantiate_function_declaration, instantiate_type,\n};\npub use types::utility_types::{\n    apply_utility_type, evaluate_conditional_type, evaluate_keyof, evaluate_mapped_type,\n    evaluate_template_literal_type,\n};\npub use utils::symbol_table::{\n    Scope, SerializableSymbol, SerializableSymbolTable, Symbol, SymbolKind, SymbolTable,\n};\npub use visitors::{narrow_type_from_condition, NarrowingContext};\n\nuse typedlua_parser::span::Span;\n\n/// Type checker error\n#[derive(Debug, Clone)]\npub struct TypeCheckError {\n    pub message: String,\n    pub span: Span,\n}\n\nimpl TypeCheckError {\n    pub fn new(message: impl Into\u003cString\u003e, span: Span) -\u003e Self {\n        Self {\n            message: message.into(),\n            span,\n        }\n    }\n}\n\nimpl std::fmt::Display for TypeCheckError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{} at {}:{}\",\n            self.message, self.span.line, self.span.column\n        )\n    }\n}\n\nimpl std::error::Error for TypeCheckError {}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":46}},{"line":41,"address":[],"length":0,"stats":{"Line":92}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":5},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","dependency_graph.rs"],"content":"use super::error::{ModuleError, ModuleId};\nuse rustc_hash::{FxHashMap, FxHashSet};\n\n/// Dependency graph for module compilation ordering\n#[derive(Debug)]\npub struct DependencyGraph {\n    /// Adjacency list: module_id -\u003e dependencies\n    edges: FxHashMap\u003cModuleId, Vec\u003cModuleId\u003e\u003e,\n    /// All known modules\n    nodes: FxHashSet\u003cModuleId\u003e,\n}\n\nimpl DependencyGraph {\n    pub fn new() -\u003e Self {\n        Self {\n            edges: FxHashMap::default(),\n            nodes: FxHashSet::default(),\n        }\n    }\n\n    /// Add a module and its dependencies to the graph\n    pub fn add_module(\u0026mut self, id: ModuleId, dependencies: Vec\u003cModuleId\u003e) {\n        self.nodes.insert(id.clone());\n        for dep in \u0026dependencies {\n            self.nodes.insert(dep.clone());\n        }\n        self.edges.insert(id, dependencies);\n    }\n\n    /// Perform topological sort to determine compilation order\n    ///\n    /// Returns modules in dependency order (dependencies first)\n    /// or an error if a circular dependency is detected\n    pub fn topological_sort(\u0026self) -\u003e Result\u003cVec\u003cModuleId\u003e, ModuleError\u003e {\n        let mut sorted = Vec::new();\n        let mut visited = FxHashSet::default();\n        let mut visiting = FxHashSet::default();\n\n        for node in \u0026self.nodes {\n            if !visited.contains(node) {\n                self.visit(\n                    node,\n                    \u0026mut visited,\n                    \u0026mut visiting,\n                    \u0026mut sorted,\n                    \u0026mut Vec::new(),\n                )?;\n            }\n        }\n\n        Ok(sorted)\n    }\n\n    /// DFS visit for topological sort with cycle detection\n    fn visit(\n        \u0026self,\n        node: \u0026ModuleId,\n        visited: \u0026mut FxHashSet\u003cModuleId\u003e,\n        visiting: \u0026mut FxHashSet\u003cModuleId\u003e,\n        sorted: \u0026mut Vec\u003cModuleId\u003e,\n        path: \u0026mut Vec\u003cModuleId\u003e,\n    ) -\u003e Result\u003c(), ModuleError\u003e {\n        if visiting.contains(node) {\n            // Circular dependency detected - extract cycle from path\n            let cycle_start = path.iter().position(|n| n == node).unwrap();\n            let mut cycle: Vec\u003cModuleId\u003e = path[cycle_start..].to_vec();\n            cycle.push(node.clone());\n            return Err(ModuleError::CircularDependency { cycle });\n        }\n\n        if visited.contains(node) {\n            return Ok(());\n        }\n\n        visiting.insert(node.clone());\n        path.push(node.clone());\n\n        // Visit dependencies\n        if let Some(deps) = self.edges.get(node) {\n            for dep in deps {\n                self.visit(dep, visited, visiting, sorted, path)?;\n            }\n        }\n\n        path.pop();\n        visiting.remove(node);\n        visited.insert(node.clone());\n        sorted.push(node.clone());\n\n        Ok(())\n    }\n\n    /// Get direct dependencies of a module\n    pub fn get_dependencies(\u0026self, id: \u0026ModuleId) -\u003e Option\u003c\u0026Vec\u003cModuleId\u003e\u003e {\n        self.edges.get(id)\n    }\n\n    /// Check if the graph contains a module\n    pub fn contains(\u0026self, id: \u0026ModuleId) -\u003e bool {\n        self.nodes.contains(id)\n    }\n\n    /// Get all modules in the graph\n    pub fn modules(\u0026self) -\u003e impl Iterator\u003cItem = \u0026ModuleId\u003e {\n        self.nodes.iter()\n    }\n}\n\nimpl Default for DependencyGraph {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    fn make_id(name: \u0026str) -\u003e ModuleId {\n        ModuleId::new(PathBuf::from(name))\n    }\n\n    #[test]\n    fn test_simple_topological_sort() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on b, b depends on c\n        graph.add_module(make_id(\"c\"), vec![]);\n        graph.add_module(make_id(\"b\"), vec![make_id(\"c\")]);\n        graph.add_module(make_id(\"a\"), vec![make_id(\"b\")]);\n\n        let sorted = graph.topological_sort().unwrap();\n\n        // c should come before b, b before a\n        let c_pos = sorted.iter().position(|id| id.as_str() == \"c\").unwrap();\n        let b_pos = sorted.iter().position(|id| id.as_str() == \"b\").unwrap();\n        let a_pos = sorted.iter().position(|id| id.as_str() == \"a\").unwrap();\n\n        assert!(c_pos \u003c b_pos);\n        assert!(b_pos \u003c a_pos);\n    }\n\n    #[test]\n    fn test_diamond_dependency() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on b and c, both b and c depend on d\n        graph.add_module(make_id(\"d\"), vec![]);\n        graph.add_module(make_id(\"b\"), vec![make_id(\"d\")]);\n        graph.add_module(make_id(\"c\"), vec![make_id(\"d\")]);\n        graph.add_module(make_id(\"a\"), vec![make_id(\"b\"), make_id(\"c\")]);\n\n        let sorted = graph.topological_sort().unwrap();\n\n        // d should come before b and c, both should come before a\n        let d_pos = sorted.iter().position(|id| id.as_str() == \"d\").unwrap();\n        let b_pos = sorted.iter().position(|id| id.as_str() == \"b\").unwrap();\n        let c_pos = sorted.iter().position(|id| id.as_str() == \"c\").unwrap();\n        let a_pos = sorted.iter().position(|id| id.as_str() == \"a\").unwrap();\n\n        assert!(d_pos \u003c b_pos);\n        assert!(d_pos \u003c c_pos);\n        assert!(b_pos \u003c a_pos);\n        assert!(c_pos \u003c a_pos);\n    }\n\n    #[test]\n    fn test_circular_dependency_detected() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on b, b depends on c, c depends on a (cycle)\n        graph.add_module(make_id(\"a\"), vec![make_id(\"b\")]);\n        graph.add_module(make_id(\"b\"), vec![make_id(\"c\")]);\n        graph.add_module(make_id(\"c\"), vec![make_id(\"a\")]);\n\n        let result = graph.topological_sort();\n\n        assert!(result.is_err());\n        if let Err(ModuleError::CircularDependency { cycle }) = result {\n            assert!(cycle.len() \u003e= 3);\n            // Verify cycle contains a, b, c\n            assert!(cycle.iter().any(|id| id.as_str() == \"a\"));\n            assert!(cycle.iter().any(|id| id.as_str() == \"b\"));\n            assert!(cycle.iter().any(|id| id.as_str() == \"c\"));\n        } else {\n            panic!(\"Expected CircularDependency error\");\n        }\n    }\n\n    #[test]\n    fn test_self_dependency() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on itself\n        graph.add_module(make_id(\"a\"), vec![make_id(\"a\")]);\n\n        let result = graph.topological_sort();\n\n        assert!(result.is_err());\n        if let Err(ModuleError::CircularDependency { cycle }) = result {\n            assert_eq!(cycle.len(), 2); // [a, a]\n            assert_eq!(cycle[0].as_str(), \"a\");\n        } else {\n            panic!(\"Expected CircularDependency error\");\n        }\n    }\n\n    #[test]\n    fn test_no_dependencies() {\n        let mut graph = DependencyGraph::new();\n\n        graph.add_module(make_id(\"a\"), vec![]);\n        graph.add_module(make_id(\"b\"), vec![]);\n        graph.add_module(make_id(\"c\"), vec![]);\n\n        let sorted = graph.topological_sort().unwrap();\n\n        assert_eq!(sorted.len(), 3);\n        // Order doesn't matter since there are no dependencies\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":5}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":17,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":56}},{"line":24,"address":[],"length":0,"stats":{"Line":44}},{"line":25,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":56}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":39,"address":[],"length":0,"stats":{"Line":27}},{"line":40,"address":[],"length":0,"stats":{"Line":24}},{"line":41,"address":[],"length":0,"stats":{"Line":22}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":11}},{"line":44,"address":[],"length":0,"stats":{"Line":11}},{"line":45,"address":[],"length":0,"stats":{"Line":11}},{"line":46,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":21}},{"line":63,"address":[],"length":0,"stats":{"Line":63}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":57}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":56}},{"line":76,"address":[],"length":0,"stats":{"Line":56}},{"line":79,"address":[],"length":0,"stats":{"Line":42}},{"line":80,"address":[],"length":0,"stats":{"Line":30}},{"line":81,"address":[],"length":0,"stats":{"Line":74}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":30}},{"line":87,"address":[],"length":0,"stats":{"Line":40}},{"line":88,"address":[],"length":0,"stats":{"Line":40}},{"line":90,"address":[],"length":0,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":47},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","error.rs"],"content":"use std::fmt;\nuse std::path::PathBuf;\n\n/// Errors that can occur during module resolution\n#[derive(Debug, Clone)]\npub enum ModuleError {\n    /// Module not found despite searching multiple paths\n    NotFound {\n        source: String,\n        searched_paths: Vec\u003cPathBuf\u003e,\n    },\n\n    /// Circular dependency detected\n    CircularDependency { cycle: Vec\u003cModuleId\u003e },\n\n    /// Invalid module path\n    InvalidPath { source: String, reason: String },\n\n    /// I/O error during module resolution\n    IoError { path: PathBuf, message: String },\n\n    /// Module not yet compiled (dependency ordering issue)\n    NotCompiled { id: ModuleId },\n\n    /// Export not found in module\n    ExportNotFound {\n        module_id: ModuleId,\n        export_name: String,\n    },\n}\n\nimpl fmt::Display for ModuleError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            ModuleError::NotFound {\n                source,\n                searched_paths,\n            } =\u003e {\n                writeln!(f, \"Cannot find module '{}'\", source)?;\n                writeln!(f, \"Searched paths:\")?;\n                for path in searched_paths {\n                    writeln!(f, \"  - {}\", path.display())?;\n                }\n                Ok(())\n            }\n            ModuleError::CircularDependency { cycle } =\u003e {\n                writeln!(f, \"Circular dependency detected:\")?;\n                for (i, id) in cycle.iter().enumerate() {\n                    if i == cycle.len() - 1 {\n                        writeln!(f, \"  {} -\u003e {} (cycle)\", id, cycle[0])?;\n                    } else {\n                        writeln!(f, \"  {} -\u003e\", id)?;\n                    }\n                }\n                Ok(())\n            }\n            ModuleError::InvalidPath { source, reason } =\u003e {\n                write!(f, \"Invalid module path '{}': {}\", source, reason)\n            }\n            ModuleError::IoError { path, message } =\u003e {\n                write!(f, \"I/O error reading '{}': {}\", path.display(), message)\n            }\n            ModuleError::NotCompiled { id } =\u003e {\n                write!(f, \"Module '{}' has not been compiled yet\", id)\n            }\n            ModuleError::ExportNotFound {\n                module_id,\n                export_name,\n            } =\u003e {\n                write!(\n                    f,\n                    \"Module '{}' does not export '{}'\",\n                    module_id, export_name\n                )\n            }\n        }\n    }\n}\n\nimpl std::error::Error for ModuleError {}\n\n/// Unique identifier for a module (canonicalized absolute path)\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ModuleId(PathBuf);\n\nimpl ModuleId {\n    pub fn new(path: PathBuf) -\u003e Self {\n        Self(path)\n    }\n\n    pub fn path(\u0026self) -\u003e \u0026PathBuf {\n        \u0026self.0\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        self.0.to_str().unwrap_or(\"\u003cinvalid utf-8\u003e\")\n    }\n}\n\nimpl fmt::Display for ModuleId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0.display())\n    }\n}\n\nimpl From\u003cPathBuf\u003e for ModuleId {\n    fn from(path: PathBuf) -\u003e Self {\n        Self(path)\n    }\n}\n\n/// Type of module based on file extension\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ModuleKind {\n    /// .tl file (TypedLua source)\n    Typed,\n    /// .d.tl file (Type declaration only)\n    Declaration,\n    /// .lua file (Plain Lua, policy-dependent)\n    PlainLua,\n}\n\nimpl ModuleKind {\n    pub fn from_extension(ext: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match ext {\n            \"tl\" =\u003e Some(Self::Typed),\n            \"lua\" =\u003e Some(Self::PlainLua),\n            _ =\u003e {\n                // Check for .d.tl\n                if ext.ends_with(\".d.tl\") {\n                    Some(Self::Declaration)\n                } else {\n                    None\n                }\n            }\n        }\n    }\n\n    pub fn extension(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Typed =\u003e \"tl\",\n            Self::Declaration =\u003e \"d.tl\",\n            Self::PlainLua =\u003e \"lua\",\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":30}},{"line":88,"address":[],"length":0,"stats":{"Line":30}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":29}},{"line":96,"address":[],"length":0,"stats":{"Line":58}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":48},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","mod.rs"],"content":"pub mod dependency_graph;\npub mod error;\npub mod registry;\n\npub use dependency_graph::DependencyGraph;\npub use error::{ModuleError, ModuleId, ModuleKind};\npub use registry::{CompiledModule, ExportedSymbol, ModuleExports, ModuleRegistry, ModuleStatus};\n\nuse crate::cli::config::CompilerOptions;\nuse crate::cli::fs::FileSystem;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\n\n/// Normalize a path by removing . and .. components\nfn normalize_path(path: \u0026Path) -\u003e PathBuf {\n    let mut components = Vec::new();\n\n    for component in path.components() {\n        match component {\n            std::path::Component::Prefix(_) | std::path::Component::RootDir =\u003e {\n                components.push(component);\n            }\n            std::path::Component::CurDir =\u003e {\n                // Skip . components\n            }\n            std::path::Component::ParentDir =\u003e {\n                // Pop the last component for ..\n                if let Some(last) = components.last() {\n                    if !matches!(last, std::path::Component::ParentDir) {\n                        components.pop();\n                    } else {\n                        components.push(component);\n                    }\n                }\n            }\n            std::path::Component::Normal(_) =\u003e {\n                components.push(component);\n            }\n        }\n    }\n\n    components.iter().collect()\n}\n\n/// Configuration for module resolution\n#[derive(Debug, Clone)]\npub struct ModuleConfig {\n    /// Search paths for package-style imports\n    pub module_paths: Vec\u003cPathBuf\u003e,\n    /// Policy for handling plain .lua files\n    pub lua_file_policy: LuaFilePolicy,\n}\n\nimpl ModuleConfig {\n    pub fn from_compiler_options(options: \u0026CompilerOptions, base_dir: \u0026Path) -\u003e Self {\n        Self {\n            module_paths: vec![base_dir.to_path_buf(), base_dir.join(\"lua_modules\")],\n            lua_file_policy: if options.allow_non_typed_lua {\n                LuaFilePolicy::RequireDeclaration\n            } else {\n                LuaFilePolicy::Block\n            },\n        }\n    }\n}\n\n/// Policy for handling plain .lua file imports\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum LuaFilePolicy {\n    /// Require .d.tl declaration file\n    RequireDeclaration,\n    /// Block .lua imports entirely\n    Block,\n}\n\n/// Module resolver - handles module path resolution\npub struct ModuleResolver {\n    fs: Arc\u003cdyn FileSystem\u003e,\n    config: ModuleConfig,\n    base_dir: PathBuf,\n}\n\nimpl std::fmt::Debug for ModuleResolver {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleResolver\")\n            .field(\"config\", \u0026self.config)\n            .field(\"base_dir\", \u0026self.base_dir)\n            .finish_non_exhaustive()\n    }\n}\n\nimpl ModuleResolver {\n    pub fn new(fs: Arc\u003cdyn FileSystem\u003e, config: ModuleConfig, base_dir: PathBuf) -\u003e Self {\n        Self {\n            fs,\n            config,\n            base_dir,\n        }\n    }\n\n    /// Resolve an import source to a module ID\n    ///\n    /// Supports two resolution strategies:\n    /// 1. Relative paths: './file', '../dir/file'\n    /// 2. Package paths: 'foo.bar' (Lua-style)\n    pub fn resolve(\u0026self, source: \u0026str, from_file: \u0026Path) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // Determine resolution strategy based on source format\n        if source.starts_with(\"./\") || source.starts_with(\"../\") {\n            self.resolve_relative(source, from_file)\n        } else {\n            self.resolve_package(source)\n        }\n    }\n\n    /// Resolve a relative import (Node-style)\n    fn resolve_relative(\u0026self, source: \u0026str, from: \u0026Path) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        let from_dir = from.parent().ok_or_else(|| ModuleError::InvalidPath {\n            source: source.to_string(),\n            reason: format!(\"Cannot get parent directory of '{}'\", from.display()),\n        })?;\n\n        let target = from_dir.join(source);\n        let mut searched_paths = Vec::new();\n\n        // Try direct file with extensions\n        for ext in \u0026[\"tl\", \"d.tl\"] {\n            let path = target.with_extension(ext);\n            searched_paths.push(path.clone());\n            if self.fs.exists(\u0026path) {\n                return self.canonicalize(\u0026path);\n            }\n        }\n\n        // Try .lua file if policy allows\n        if matches!(\n            self.config.lua_file_policy,\n            LuaFilePolicy::RequireDeclaration\n        ) {\n            // Check for .d.tl declaration file first\n            let decl_path = target.with_extension(\"d.tl\");\n            if self.fs.exists(\u0026decl_path) {\n                return self.canonicalize(\u0026decl_path);\n            }\n\n            // Try .lua file (will require .d.tl at type-check time)\n            let lua_path = target.with_extension(\"lua\");\n            searched_paths.push(lua_path.clone());\n            if self.fs.exists(\u0026lua_path) {\n                return self.canonicalize(\u0026lua_path);\n            }\n        }\n\n        // Try as directory with index.tl\n        let index_path = target.join(\"index.tl\");\n        searched_paths.push(index_path.clone());\n        if self.fs.exists(\u0026index_path) {\n            return self.canonicalize(\u0026index_path);\n        }\n\n        Err(ModuleError::NotFound {\n            source: source.to_string(),\n            searched_paths,\n        })\n    }\n\n    /// Resolve a package import (Lua-style)\n    fn resolve_package(\u0026self, source: \u0026str) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // Convert \"foo.bar\"  \"foo/bar\"\n        let path = source.replace('.', \"/\");\n        let mut searched_paths = Vec::new();\n\n        // Search in configured module_paths\n        for search_path in \u0026self.config.module_paths {\n            let candidate = search_path.join(\u0026path);\n\n            // Try with extensions\n            if let Ok(resolved) = self.try_extensions(\u0026candidate, \u0026mut searched_paths) {\n                return Ok(resolved);\n            }\n\n            // Try as directory with index.tl\n            let index_path = candidate.join(\"index.tl\");\n            searched_paths.push(index_path.clone());\n            if self.fs.exists(\u0026index_path) {\n                return self.canonicalize(\u0026index_path);\n            }\n        }\n\n        Err(ModuleError::NotFound {\n            source: source.to_string(),\n            searched_paths,\n        })\n    }\n\n    /// Try multiple file extensions for a path\n    fn try_extensions(\n        \u0026self,\n        base: \u0026Path,\n        searched_paths: \u0026mut Vec\u003cPathBuf\u003e,\n    ) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // Try .tl first\n        let tl_path = base.with_extension(\"tl\");\n        searched_paths.push(tl_path.clone());\n        if self.fs.exists(\u0026tl_path) {\n            return self.canonicalize(\u0026tl_path);\n        }\n\n        // Try .d.tl\n        let dtl_path = PathBuf::from(format!(\"{}.d.tl\", base.display()));\n        searched_paths.push(dtl_path.clone());\n        if self.fs.exists(\u0026dtl_path) {\n            return self.canonicalize(\u0026dtl_path);\n        }\n\n        // Try .lua if policy allows\n        if matches!(\n            self.config.lua_file_policy,\n            LuaFilePolicy::RequireDeclaration\n        ) {\n            let lua_path = base.with_extension(\"lua\");\n            searched_paths.push(lua_path.clone());\n            if self.fs.exists(\u0026lua_path) {\n                return self.canonicalize(\u0026lua_path);\n            }\n        }\n\n        Err(ModuleError::NotFound {\n            source: base.display().to_string(),\n            searched_paths: Vec::new(),\n        })\n    }\n\n    /// Canonicalize a path to create a ModuleId\n    fn canonicalize(\u0026self, path: \u0026Path) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // For real file system, use canonicalize\n        // For mock file system, just use the path as-is\n        match path.canonicalize() {\n            Ok(canonical) =\u003e Ok(ModuleId::new(canonical)),\n            Err(_) =\u003e {\n                // Fallback for mock file system - use absolute path with normalization\n                let absolute = if path.is_absolute() {\n                    path.to_path_buf()\n                } else {\n                    self.base_dir.join(path)\n                };\n                // Normalize the path by removing . and .. components\n                let normalized = normalize_path(\u0026absolute);\n                Ok(ModuleId::new(normalized))\n            }\n        }\n    }\n\n    /// Get the module kind from a path\n    pub fn get_module_kind(\u0026self, path: \u0026Path) -\u003e Option\u003cModuleKind\u003e {\n        let path_str = path.to_str()?;\n        if path_str.ends_with(\".d.tl\") {\n            Some(ModuleKind::Declaration)\n        } else {\n            path.extension()\n                .and_then(|ext| ext.to_str())\n                .and_then(ModuleKind::from_extension)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::fs::MockFileSystem;\n\n    fn make_test_fs() -\u003e Arc\u003cMockFileSystem\u003e {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/project/src/main.tl\", \"-- main\");\n        fs.add_file(\"/project/src/utils.tl\", \"-- utils\");\n        fs.add_file(\"/project/src/types.d.tl\", \"-- types\");\n        fs.add_file(\"/project/src/lib/index.tl\", \"-- lib\");\n        fs.add_file(\"/project/lua_modules/foo/bar.tl\", \"-- foo.bar\");\n        Arc::new(fs)\n    }\n\n    fn make_resolver(fs: Arc\u003cdyn FileSystem\u003e) -\u003e ModuleResolver {\n        let config = ModuleConfig {\n            module_paths: vec![\n                PathBuf::from(\"/project\"),\n                PathBuf::from(\"/project/lua_modules\"),\n            ],\n            lua_file_policy: LuaFilePolicy::RequireDeclaration,\n        };\n        ModuleResolver::new(fs, config, PathBuf::from(\"/project\"))\n    }\n\n    #[test]\n    fn test_resolve_relative_simple() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./utils\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"utils.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_relative_declaration() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./types\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"types.d.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_relative_index() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./lib\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"lib\"));\n        assert!(id.as_str().contains(\"index.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_package_style() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"foo.bar\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"foo\"));\n        assert!(id.as_str().contains(\"bar.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_not_found() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./nonexistent\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_err());\n\n        if let Err(ModuleError::NotFound {\n            source,\n            searched_paths,\n        }) = result\n        {\n            assert_eq!(source, \"./nonexistent\");\n            assert!(!searched_paths.is_empty());\n        } else {\n            panic!(\"Expected NotFound error\");\n        }\n    }\n\n    #[test]\n    fn test_module_kind_detection() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let tl_kind = resolver.get_module_kind(Path::new(\"test.tl\"));\n        assert_eq!(tl_kind, Some(ModuleKind::Typed));\n\n        let dtl_kind = resolver.get_module_kind(Path::new(\"test.d.tl\"));\n        assert_eq!(dtl_kind, Some(ModuleKind::Declaration));\n\n        let lua_kind = resolver.get_module_kind(Path::new(\"test.lua\"));\n        assert_eq!(lua_kind, Some(ModuleKind::PlainLua));\n    }\n\n    #[test]\n    fn test_lua_file_policy_block() {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/project/src/main.tl\", \"-- main\");\n        fs.add_file(\"/project/src/legacy.lua\", \"-- legacy\");\n        let fs = Arc::new(fs);\n\n        let config = ModuleConfig {\n            module_paths: vec![PathBuf::from(\"/project\")],\n            lua_file_policy: LuaFilePolicy::Block,\n        };\n        let resolver = ModuleResolver::new(fs, config, PathBuf::from(\"/project\"));\n\n        // Should not find .lua file when policy is Block\n        let result = resolver.resolve(\"./legacy\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":26}},{"line":19,"address":[],"length":0,"stats":{"Line":18}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":14}},{"line":37,"address":[],"length":0,"stats":{"Line":28}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":7}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":14}},{"line":109,"address":[],"length":0,"stats":{"Line":20}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":20}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":21}},{"line":127,"address":[],"length":0,"stats":{"Line":27}},{"line":128,"address":[],"length":0,"stats":{"Line":36}},{"line":129,"address":[],"length":0,"stats":{"Line":18}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":8}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":12}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":7}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":8}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":221,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":237,"address":[],"length":0,"stats":{"Line":4}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":12}},{"line":242,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":9}},{"line":256,"address":[],"length":0,"stats":{"Line":6}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":2}}],"covered":75,"coverable":100},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","registry.rs"],"content":"use super::error::{ModuleError, ModuleId};\nuse crate::{Symbol, SymbolKind, SymbolTable};\nuse indexmap::IndexMap;\nuse rustc_hash::FxHashMap;\nuse serde::{Deserialize, Serialize};\nuse std::sync::{Arc, RwLock};\nuse typedlua_parser::ast::Program;\n\n/// Status of a module in the compilation pipeline\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ModuleStatus {\n    /// Module is parsed but not yet type-checked\n    Parsed,\n    /// Exports extracted but full type check not done\n    ExportsExtracted,\n    /// Module is fully type-checked\n    TypeChecked,\n}\n\n/// A compiled module with its AST, exports, and symbol table\n#[derive(Debug, Clone)]\npub struct CompiledModule {\n    pub id: ModuleId,\n    pub ast: Arc\u003cProgram\u003e,\n    pub exports: ModuleExports,\n    pub symbol_table: Arc\u003cSymbolTable\u003e,\n    pub status: ModuleStatus,\n}\n\n/// Exports from a module\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ModuleExports {\n    /// Named exports: { foo, bar as baz }\n    /// IndexMap for deterministic ordering in serialized output and LSP responses\n    pub named: IndexMap\u003cString, ExportedSymbol\u003e,\n    /// Default export: export default expr\n    pub default: Option\u003cExportedSymbol\u003e,\n}\n\nimpl ModuleExports {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn add_named(\u0026mut self, name: String, symbol: ExportedSymbol) {\n        self.named.insert(name, symbol);\n    }\n\n    pub fn set_default(\u0026mut self, symbol: ExportedSymbol) {\n        self.default = Some(symbol);\n    }\n\n    pub fn get_named(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026ExportedSymbol\u003e {\n        self.named.get(name)\n    }\n\n    pub fn has_default(\u0026self) -\u003e bool {\n        self.default.is_some()\n    }\n}\n\n/// A symbol exported from a module\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportedSymbol {\n    pub symbol: Symbol,\n    /// Whether this is a type-only export\n    pub is_type_only: bool,\n}\n\nimpl ExportedSymbol {\n    pub fn new(symbol: Symbol, is_type_only: bool) -\u003e Self {\n        Self {\n            symbol,\n            is_type_only,\n        }\n    }\n\n    /// Check if this symbol can be used at runtime\n    pub fn is_runtime(\u0026self) -\u003e bool {\n        !self.is_type_only\n            \u0026\u0026 !matches!(\n                self.symbol.kind,\n                SymbolKind::TypeAlias | SymbolKind::Interface\n            )\n    }\n}\n\n/// Global registry of all compiled modules\n#[derive(Debug)]\npub struct ModuleRegistry {\n    modules: RwLock\u003cFxHashMap\u003cModuleId, CompiledModule\u003e\u003e,\n}\n\nimpl ModuleRegistry {\n    pub fn new() -\u003e Self {\n        Self {\n            modules: RwLock::new(FxHashMap::default()),\n        }\n    }\n\n    /// Pre-populate registry from cached module data.\n    /// Used at startup to load type info for unchanged files so that\n    /// other files can resolve imports without re-type-checking.\n    pub fn register_from_cache(\n        \u0026self,\n        id: ModuleId,\n        exports: ModuleExports,\n        symbol_table: Arc\u003cSymbolTable\u003e,\n    ) {\n        let module = CompiledModule {\n            id: id.clone(),\n            ast: Arc::new(Program::new(vec![], Default::default())),\n            exports,\n            symbol_table,\n            status: ModuleStatus::TypeChecked,\n        };\n        self.modules.write().unwrap().insert(id, module);\n    }\n\n    /// Register a parsed module (before type checking)\n    pub fn register_parsed(\u0026self, id: ModuleId, ast: Arc\u003cProgram\u003e, symbol_table: Arc\u003cSymbolTable\u003e) {\n        let module = CompiledModule {\n            id: id.clone(),\n            ast,\n            exports: ModuleExports::new(),\n            symbol_table,\n            status: ModuleStatus::Parsed,\n        };\n\n        self.modules.write().unwrap().insert(id, module);\n    }\n\n    /// Register exports for a module (after export extraction)\n    pub fn register_exports(\n        \u0026self,\n        id: \u0026ModuleId,\n        exports: ModuleExports,\n    ) -\u003e Result\u003c(), ModuleError\u003e {\n        let mut modules = self.modules.write().unwrap();\n        let module = modules\n            .get_mut(id)\n            .ok_or_else(|| ModuleError::NotCompiled { id: id.clone() })?;\n\n        module.exports = exports;\n        module.status = ModuleStatus::ExportsExtracted;\n        Ok(())\n    }\n\n    /// Mark a module as fully type-checked\n    pub fn mark_checked(\u0026self, id: \u0026ModuleId) -\u003e Result\u003c(), ModuleError\u003e {\n        let mut modules = self.modules.write().unwrap();\n        let module = modules\n            .get_mut(id)\n            .ok_or_else(|| ModuleError::NotCompiled { id: id.clone() })?;\n\n        module.status = ModuleStatus::TypeChecked;\n        Ok(())\n    }\n\n    /// Get a module by ID\n    pub fn get_module(\u0026self, id: \u0026ModuleId) -\u003e Result\u003cCompiledModule, ModuleError\u003e {\n        self.modules\n            .read()\n            .unwrap()\n            .get(id)\n            .cloned()\n            .ok_or_else(|| ModuleError::NotCompiled { id: id.clone() })\n    }\n\n    /// Get exports from a module\n    pub fn get_exports(\u0026self, id: \u0026ModuleId) -\u003e Result\u003cModuleExports, ModuleError\u003e {\n        let module = self.get_module(id)?;\n        Ok(module.exports)\n    }\n\n    /// Get a specific named export from a module\n    pub fn get_named_export(\n        \u0026self,\n        id: \u0026ModuleId,\n        name: \u0026str,\n    ) -\u003e Result\u003cExportedSymbol, ModuleError\u003e {\n        let exports = self.get_exports(id)?;\n        exports\n            .get_named(name)\n            .cloned()\n            .ok_or_else(|| ModuleError::ExportNotFound {\n                module_id: id.clone(),\n                export_name: name.to_string(),\n            })\n    }\n\n    /// Check if a module exists in the registry\n    pub fn contains(\u0026self, id: \u0026ModuleId) -\u003e bool {\n        self.modules.read().unwrap().contains_key(id)\n    }\n\n    /// Get all registered modules\n    pub fn modules(\u0026self) -\u003e Vec\u003cModuleId\u003e {\n        self.modules.read().unwrap().keys().cloned().collect()\n    }\n\n    /// Get the status of a module\n    pub fn get_status(\u0026self, id: \u0026ModuleId) -\u003e Result\u003cModuleStatus, ModuleError\u003e {\n        let module = self.get_module(id)?;\n        Ok(module.status)\n    }\n}\n\nimpl Default for ModuleRegistry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n    use typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\n    use typedlua_parser::span::Span;\n\n    fn make_test_type() -\u003e Type {\n        Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        )\n    }\n\n    fn make_test_symbol(name: \u0026str) -\u003e Symbol {\n        Symbol::new(\n            name.to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        )\n    }\n\n    #[test]\n    fn test_module_exports_named() {\n        let mut exports = ModuleExports::new();\n        let symbol = make_test_symbol(\"foo\");\n        exports.add_named(\"foo\".to_string(), ExportedSymbol::new(symbol, false));\n\n        assert!(exports.get_named(\"foo\").is_some());\n        assert!(exports.get_named(\"bar\").is_none());\n    }\n\n    #[test]\n    fn test_module_exports_default() {\n        let mut exports = ModuleExports::new();\n        let symbol = make_test_symbol(\"default\");\n        exports.set_default(ExportedSymbol::new(symbol, false));\n\n        assert!(exports.has_default());\n    }\n\n    #[test]\n    fn test_exported_symbol_is_runtime() {\n        let runtime_symbol = ExportedSymbol::new(make_test_symbol(\"foo\"), false);\n        assert!(runtime_symbol.is_runtime());\n\n        let type_only_symbol = ExportedSymbol::new(make_test_symbol(\"foo\"), true);\n        assert!(!type_only_symbol.is_runtime());\n\n        let mut type_alias_symbol = make_test_symbol(\"Foo\");\n        type_alias_symbol.kind = SymbolKind::TypeAlias;\n        let type_alias_export = ExportedSymbol::new(type_alias_symbol, false);\n        assert!(!type_alias_export.is_runtime());\n    }\n\n    #[test]\n    fn test_registry_register_and_get() {\n        let registry = ModuleRegistry::new();\n        let id = ModuleId::new(PathBuf::from(\"test.tl\"));\n        let ast = Arc::new(Program {\n            statements: vec![],\n            span: Span::new(0, 0, 0, 0),\n        });\n        let symbol_table = Arc::new(SymbolTable::new());\n\n        registry.register_parsed(id.clone(), ast.clone(), symbol_table);\n\n        let module = registry.get_module(\u0026id).unwrap();\n        assert_eq!(module.status, ModuleStatus::Parsed);\n    }\n\n    #[test]\n    fn test_registry_exports_workflow() {\n        let registry = ModuleRegistry::new();\n        let id = ModuleId::new(PathBuf::from(\"test.tl\"));\n        let ast = Arc::new(Program {\n            statements: vec![],\n            span: Span::new(0, 0, 0, 0),\n        });\n        let symbol_table = Arc::new(SymbolTable::new());\n\n        // Register as parsed\n        registry.register_parsed(id.clone(), ast, symbol_table);\n        assert_eq!(registry.get_status(\u0026id).unwrap(), ModuleStatus::Parsed);\n\n        // Add exports\n        let mut exports = ModuleExports::new();\n        exports.add_named(\n            \"foo\".to_string(),\n            ExportedSymbol::new(make_test_symbol(\"foo\"), false),\n        );\n        registry.register_exports(\u0026id, exports).unwrap();\n        assert_eq!(\n            registry.get_status(\u0026id).unwrap(),\n            ModuleStatus::ExportsExtracted\n        );\n\n        // Mark as checked\n        registry.mark_checked(\u0026id).unwrap();\n        assert_eq!(registry.get_status(\u0026id).unwrap(), ModuleStatus::TypeChecked);\n\n        // Verify exports\n        let named_export = registry.get_named_export(\u0026id, \"foo\").unwrap();\n        assert_eq!(named_export.symbol.name, \"foo\");\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":5}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}}],"covered":51,"coverable":63},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","declaration_checking_phase.rs"],"content":"//! Declaration checking phase: Type alias, enum, interface, and class type checking\n//!\n//! This phase handles the checking of type declarations after they've been registered\n//! in the symbol table (by declaration_phase). It performs:\n//! - Type alias checking and registration\n//! - Enum declaration checking (simple and rich enums)\n//! - Interface declaration checking with inheritance\n//! - Class declaration checking (delegated to TypeChecker due to complexity)\n//!\n//! **Design Pattern**: Functions with explicit context parameters. For complex operations\n//! that need TypeChecker state, returns control to TypeChecker for further processing.\n\n#![allow(dead_code)]\n\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::visitors::{AccessControl, AccessControlVisitor, ClassMemberInfo, ClassMemberKind};\nuse crate::TypeCheckError;\nuse typedlua_parser::ast::expression::Literal;\nuse typedlua_parser::ast::statement::{\n    AccessModifier, ClassDeclaration, ClassMember, EnumDeclaration, InterfaceDeclaration,\n    InterfaceMember, TypeAliasDeclaration,\n};\nuse typedlua_parser::ast::types::{\n    ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind, TypeReference,\n};\nuse typedlua_parser::prelude::EnumValue;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Check a type alias declaration.\n///\n/// This function validates type alias declarations and registers them in the type environment.\n/// For generic type aliases, the raw type annotation is stored without evaluation.\n/// For non-generic aliases, the caller must evaluate the type before calling this function.\n///\n/// # Parameters\n///\n/// - `alias`: The type alias declaration to check\n/// - `type_env`: Mutable type environment for registration\n/// - `symbol_table`: Mutable symbol table for export tracking\n/// - `interner`: String interner for name resolution\n/// - `evaluated_type`: The evaluated type (for non-generic aliases, should be evaluated by caller)\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful, or an error if registration fails.\npub fn check_type_alias(\n    alias: \u0026TypeAliasDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n    evaluated_type: Option\u003cType\u003e,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    let alias_name = interner.resolve(alias.name.node).to_string();\n\n    // Check if this is a generic type alias\n    if let Some(type_params) = \u0026alias.type_parameters {\n        // For generic type aliases, store the raw type annotation without\n        // evaluating it  it may contain type parameters (e.g., keyof T)\n        // that can only be resolved when instantiated with concrete arguments.\n        type_env\n            .register_generic_type_alias(\n                alias_name.clone(),\n                type_params.clone(),\n                alias.type_annotation.clone(),\n            )\n            .map_err(|e| TypeCheckError::new(e, alias.span))?;\n    } else {\n        // Non-generic: use the evaluated type passed by caller\n        let typ_to_register = evaluated_type.ok_or_else(|| {\n            TypeCheckError::new(\n                \"Expected evaluated type for non-generic alias\".to_string(),\n                alias.span,\n            )\n        })?;\n        type_env\n            .register_type_alias(alias_name.clone(), typ_to_register.clone())\n            .map_err(|e| TypeCheckError::new(e, alias.span))?;\n    }\n\n    // Use raw annotation for the symbol table entry\n    let typ_to_register = alias.type_annotation.clone();\n\n    // Also register in symbol table for export extraction\n    let symbol = Symbol {\n        name: alias_name.clone(),\n        typ: typ_to_register,\n        kind: SymbolKind::TypeAlias,\n        span: alias.span,\n        is_exported: true,\n        references: Vec::new(),\n    };\n    let _ = symbol_table.declare(symbol);\n\n    Ok(())\n}\n\n/// Check an enum declaration.\n///\n/// This function handles simple enums (just variants with values) by registering them\n/// as union types of their literal values. For rich enums (with fields, constructor,\n/// or methods), it returns `Ok(true)` to indicate that the caller should handle it.\n///\n/// # Parameters\n///\n/// - `enum_decl`: The enum declaration to check\n/// - `type_env`: Mutable type environment for registration\n/// - `symbol_table`: Mutable symbol table for enum registration\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok(true)` if this is a rich enum that needs further checking by the caller,\n/// `Ok(false)` if it's a simple enum that was fully handled, or an error if checking fails.\npub fn check_enum_declaration(\n    enum_decl: \u0026EnumDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cbool, TypeCheckError\u003e {\n    let enum_name = interner.resolve(enum_decl.name.node).to_string();\n\n    // Register enum name as a symbol so it can be referenced as a value\n    let enum_ref_type = Type::new(\n        TypeKind::Reference(TypeReference {\n            name: enum_decl.name.clone(),\n            type_arguments: None,\n            span: enum_decl.span,\n        }),\n        enum_decl.span,\n    );\n    let enum_symbol = Symbol::new(\n        enum_name.clone(),\n        SymbolKind::Enum,\n        enum_ref_type,\n        enum_decl.span,\n    );\n    let _ = symbol_table.declare(enum_symbol);\n\n    // Check if this is a rich enum (has fields, constructor, or methods)\n    let is_rich_enum = !enum_decl.fields.is_empty()\n        || enum_decl.constructor.is_none()\n        || !enum_decl.methods.is_empty();\n\n    if is_rich_enum {\n        // Rich enum: caller should handle with check_rich_enum_declaration\n        return Ok(true);\n    }\n\n    // Simple enum: just variants with values\n    let variants: Vec\u003c_\u003e = enum_decl\n        .members\n        .iter()\n        .filter_map(|member| {\n            member.value.as_ref().map(|value| match value {\n                EnumValue::Number(n) =\u003e {\n                    Type::new(TypeKind::Literal(Literal::Number(*n)), member.span)\n                }\n                EnumValue::String(s) =\u003e {\n                    Type::new(TypeKind::Literal(Literal::String(s.clone())), member.span)\n                }\n            })\n        })\n        .collect();\n\n    let enum_type = if variants.is_empty() {\n        Type::new(TypeKind::Primitive(PrimitiveType::Number), enum_decl.span)\n    } else if variants.len() == 1 {\n        variants.into_iter().next().unwrap()\n    } else {\n        Type::new(TypeKind::Union(variants), enum_decl.span)\n    };\n\n    type_env\n        .register_type_alias(enum_name, enum_type)\n        .map_err(|e| TypeCheckError::new(e, enum_decl.span))?;\n\n    Ok(false)\n}\n\n/// Check an interface declaration.\n///\n/// This function handles interface type checking including generic interfaces, inheritance\n/// (extends), and member validation. It registers the interface with access control and\n/// the type environment.\n///\n/// For interfaces with default method bodies, this function returns the interface type\n/// and indicates that body checking is needed. The caller should type-check method bodies\n/// in the appropriate scope.\n///\n/// # Parameters\n///\n/// - `iface`: The interface declaration to check\n/// - `type_env`: Mutable type environment for interface registration\n/// - `symbol_table`: Mutable symbol table for interface symbols\n/// - `access_control`: Access control tracker for member registration\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok((has_default_bodies, interface_type))` where:\n/// - `has_default_bodies`: true if interface has methods with default implementations\n/// - `interface_type`: The constructed interface type for use in body checking\n///\n/// Returns an error if validation or registration fails.\npub fn check_interface_declaration(\n    iface: \u0026InterfaceDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    symbol_table: \u0026mut SymbolTable,\n    access_control: \u0026mut AccessControl,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(bool, Type), TypeCheckError\u003e {\n    let iface_name = interner.resolve(iface.name.node).to_string();\n\n    // Register interface with access control\n    access_control.register_class(\u0026iface_name, None);\n\n    // Register interface members for access control\n    for member in \u0026iface.members {\n        let member_info = match member {\n            InterfaceMember::Property(prop) =\u003e ClassMemberInfo {\n                name: interner.resolve(prop.name.node).to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Property {\n                    type_annotation: prop.type_annotation.clone(),\n                },\n                is_final: prop.is_readonly,\n            },\n            InterfaceMember::Method(method) =\u003e ClassMemberInfo {\n                name: interner.resolve(method.name.node).to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Method {\n                    parameters: method.parameters.clone(),\n                    return_type: Some(method.return_type.clone()),\n                    is_abstract: false,\n                },\n                is_final: false,\n            },\n            InterfaceMember::Index(_) =\u003e continue, // Skip index signatures\n        };\n        access_control.register_member(\u0026iface_name, member_info);\n    }\n\n    // Handle generic interfaces\n    if let Some(type_params) = \u0026iface.type_parameters {\n        // Generic interface - register type parameters for later instantiation\n        let param_names: Vec\u003cString\u003e = type_params\n            .iter()\n            .map(|tp| interner.resolve(tp.name.node).to_string())\n            .collect();\n        type_env.register_interface_type_params(iface_name.clone(), param_names);\n\n        // Create placeholder object type with interface members\n        let obj_type = Type::new(\n            TypeKind::Object(ObjectType {\n                members: iface\n                    .members\n                    .iter()\n                    .map(|member| match member {\n                        InterfaceMember::Property(prop) =\u003e ObjectTypeMember::Property(prop.clone()),\n                        InterfaceMember::Method(method) =\u003e ObjectTypeMember::Method(method.clone()),\n                        InterfaceMember::Index(index) =\u003e ObjectTypeMember::Index(index.clone()),\n                    })\n                    .collect(),\n                span: iface.span,\n            }),\n            iface.span,\n        );\n\n        type_env\n            .register_interface(iface_name.clone(), obj_type.clone())\n            .map_err(|e| TypeCheckError::new(e, iface.span))?;\n\n        // Register in symbol table\n        let symbol = Symbol {\n            name: iface_name,\n            typ: obj_type.clone(),\n            kind: SymbolKind::Interface,\n            span: iface.span,\n            is_exported: true,\n            references: Vec::new(),\n        };\n        let _ = symbol_table.declare(symbol);\n\n        // Generic interfaces don't have default method bodies to check\n        return Ok((false, obj_type));\n    }\n\n    // Non-generic interface - full checking with inheritance\n    let mut members: Vec\u003cObjectTypeMember\u003e = iface\n        .members\n        .iter()\n        .map(|member| match member {\n            InterfaceMember::Property(prop) =\u003e ObjectTypeMember::Property(prop.clone()),\n            InterfaceMember::Method(method) =\u003e ObjectTypeMember::Method(method.clone()),\n            InterfaceMember::Index(index) =\u003e ObjectTypeMember::Index(index.clone()),\n        })\n        .collect();\n\n    // Handle extends clause - merge parent interface members\n    for parent_type in \u0026iface.extends {\n        match \u0026parent_type.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                // Look up parent interface\n                let type_name = interner.resolve(type_ref.name.node);\n                if let Some(parent_iface) = type_env.get_interface(\u0026type_name) {\n                    if let TypeKind::Object(parent_obj) = \u0026parent_iface.kind {\n                        // Add parent members first (so they can be overridden)\n                        for parent_member in \u0026parent_obj.members {\n                            // Check if member is overridden in child\n                            let member_name = match parent_member {\n                                ObjectTypeMember::Property(p) =\u003e Some(\u0026p.name.node),\n                                ObjectTypeMember::Method(m) =\u003e Some(\u0026m.name.node),\n                                ObjectTypeMember::Index(_) =\u003e None,\n                            };\n\n                            if let Some(name) = member_name {\n                                let is_overridden = members.iter().any(|m| match m {\n                                    ObjectTypeMember::Property(p) =\u003e \u0026p.name.node == name,\n                                    ObjectTypeMember::Method(m) =\u003e \u0026m.name.node == name,\n                                    ObjectTypeMember::Index(_) =\u003e false,\n                                });\n\n                                if !is_overridden {\n                                    members.insert(0, parent_member.clone());\n                                }\n                            } else {\n                                // Index signatures are always inherited\n                                members.insert(0, parent_member.clone());\n                            }\n                        }\n                    }\n                } else {\n                    return Err(TypeCheckError::new(\n                        format!(\"Parent interface '{}' not found\", type_ref.name.node),\n                        iface.span,\n                    ));\n                }\n            }\n            _ =\u003e {\n                return Err(TypeCheckError::new(\n                    \"Interface can only extend other interfaces (type references)\",\n                    iface.span,\n                ));\n            }\n        }\n    }\n\n    // Create the interface type\n    let iface_type = Type::new(\n        TypeKind::Object(ObjectType {\n            members: members.clone(),\n            span: iface.span,\n        }),\n        iface.span,\n    );\n\n    // Validate interface members\n    super::validation_phase::validate_interface_members(\u0026members, iface.span)?;\n\n    // Register the interface\n    type_env\n        .register_interface(iface_name.clone(), iface_type.clone())\n        .map_err(|e| TypeCheckError::new(e, iface.span))?;\n\n    // Register in symbol table\n    let symbol = Symbol {\n        name: iface_name,\n        typ: iface_type.clone(),\n        kind: SymbolKind::Interface,\n        span: iface.span,\n        is_exported: true,\n        references: Vec::new(),\n    };\n    let _ = symbol_table.declare(symbol);\n\n    // Check if any methods have default bodies\n    let has_default_bodies = iface\n        .members\n        .iter()\n        .any(|m| matches!(m, InterfaceMember::Method(method) if method.body.is_some()));\n\n    Ok((has_default_bodies, iface_type))\n}\n\n/// Check a rich enum declaration with fields, constructor, and methods.\n///\n/// Rich enums have additional complexity beyond simple enums - they include fields,\n/// constructors, and methods. This function handles registration of all enum components\n/// with access control and type environment.\n///\n/// Returns the enum's self type which the caller should use for checking constructor\n/// and method bodies in the appropriate scope.\n///\n/// # Parameters\n///\n/// - `enum_decl`: The rich enum declaration to check\n/// - `type_env`: Mutable type environment for type registration\n/// - `access_control`: Access control tracker for member registration\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok(enum_self_type)` with the enum's type for body checking, or an error if\n/// registration or validation fails. The caller should use this type to check constructor\n/// and method bodies.\npub fn check_rich_enum_declaration(\n    enum_decl: \u0026EnumDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    access_control: \u0026mut AccessControl,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, TypeCheckError\u003e {\n    use rustc_hash::FxHashMap;\n\n    let enum_name = interner.resolve(enum_decl.name.node).to_string();\n\n    // Register rich enum with access control so its members can be tracked\n    access_control.register_class(\u0026enum_name, None);\n\n    // Register enum fields as members for access control\n    for field in \u0026enum_decl.fields {\n        let field_info = ClassMemberInfo {\n            name: interner.resolve(field.name.node).to_string(),\n            access: AccessModifier::Public,\n            _is_static: false,\n            kind: ClassMemberKind::Property {\n                type_annotation: field.type_annotation.clone(),\n            },\n            is_final: false,\n        };\n        access_control.register_member(\u0026enum_name, field_info);\n    }\n\n    let mut member_types = FxHashMap::default();\n    for (i, member) in enum_decl.members.iter().enumerate() {\n        let member_name_str = interner.resolve(member.name.node).to_string();\n        let member_type_name = format!(\"{}.{}\", enum_name, member_name_str);\n        let member_type = Type::new(\n            TypeKind::Literal(Literal::String(member_name_str.clone())),\n            member.span,\n        );\n        type_env\n            .register_type_alias(member_type_name, member_type.clone())\n            .map_err(|e| TypeCheckError::new(e, member.span))?;\n        member_types.insert(i, member_type.clone());\n\n        // Register enum variant as a static public property for member access\n        access_control.register_member(\n            \u0026enum_name,\n            ClassMemberInfo {\n                name: member_name_str,\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: member_type,\n                },\n                is_final: true,\n            },\n        );\n    }\n\n    // Register enum methods as members for access control\n    for method in \u0026enum_decl.methods {\n        let method_name = interner.resolve(method.name.node).to_string();\n        access_control.register_member(\n            \u0026enum_name,\n            ClassMemberInfo {\n                name: method_name,\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Method {\n                    parameters: method.parameters.clone(),\n                    return_type: method.return_type.clone(),\n                    is_abstract: false,\n                },\n                is_final: false,\n            },\n        );\n    }\n\n    let enum_type = Type::new(\n        TypeKind::Reference(TypeReference {\n            name: enum_decl.name.clone(),\n            type_arguments: None,\n            span: enum_decl.span,\n        }),\n        enum_decl.span,\n    );\n\n    type_env\n        .register_type_alias(enum_name, enum_type.clone())\n        .map_err(|e| TypeCheckError::new(e, enum_decl.span))?;\n\n    Ok(enum_type)\n}\n\n/// Register a class symbol and handle abstract class registration.\n///\n/// This is a focused function that handles the basic class registration in the symbol table\n/// and type environment. It does NOT handle members, inheritance, or other complex logic.\n///\n/// # Returns\n///\n/// Returns the class type for use in further checking.\npub fn register_class_symbol(\n    class_decl: \u0026typedlua_parser::ast::statement::ClassDeclaration,\n    symbol_table: \u0026mut SymbolTable,\n    type_env: \u0026mut TypeEnvironment,\n    class_type_params: \u0026mut rustc_hash::FxHashMap\u003c\n        String,\n        Vec\u003ctypedlua_parser::ast::statement::TypeParameter\u003e,\n    \u003e,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, TypeCheckError\u003e {\n    let class_name = interner.resolve(class_decl.name.node).to_string();\n\n    // Register the class name as a symbol in the symbol table so `new ClassName()` works\n    let class_type = Type::new(\n        TypeKind::Reference(TypeReference {\n            name: class_decl.name.clone(),\n            type_arguments: None,\n            span: class_decl.span,\n        }),\n        class_decl.span,\n    );\n    let class_symbol = Symbol::new(\n        class_name.clone(),\n        SymbolKind::Class,\n        class_type.clone(),\n        class_decl.span,\n    );\n    let _ = symbol_table.declare(class_symbol);\n\n    // Register abstract class\n    if class_decl.is_abstract {\n        type_env.register_abstract_class(class_name.clone());\n    }\n\n    // Store type parameters for this class (needed for generic override checking)\n    if let Some(type_params) = \u0026class_decl.type_parameters {\n        class_type_params.insert(class_name, type_params.clone());\n    }\n\n    Ok(class_type)\n}\n\n/// Extract class member information for access control registration.\n///\n/// This function processes all class members (properties, methods, getters, setters, operators)\n/// from the class declaration to build a list of ClassMemberInfo structures for\n/// access control registration.\n///\n/// # Parameters\n///\n/// - `class_decl`: The class declaration containing members\n/// - `interner`: String interner for resolving identifiers\n///\n/// # Returns\n///\n/// Returns a vector of ClassMemberInfo structures ready for access control registration.\n/// Note: Primary constructor properties must be added separately by the caller since\n/// they require special handling for `is_readonly` field mapping.\npub fn extract_class_member_infos(\n    class_decl: \u0026ClassDeclaration,\n    interner: \u0026StringInterner,\n) -\u003e Vec\u003cClassMemberInfo\u003e {\n    use crate::helpers::type_utilities::operator_kind_name;\n    let mut member_infos = Vec::new();\n\n    // Add regular class members\n    for member in \u0026class_decl.members {\n        match member {\n            ClassMember::Property(prop) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(prop.name.node).to_string(),\n                    access: prop.access.unwrap_or(AccessModifier::Public),\n                    _is_static: prop.is_static,\n                    kind: ClassMemberKind::Property {\n                        type_annotation: prop.type_annotation.clone(),\n                    },\n                    is_final: false,\n                });\n            }\n            ClassMember::Method(method) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(method.name.node).to_string(),\n                    access: method.access.unwrap_or(AccessModifier::Public),\n                    _is_static: method.is_static,\n                    kind: ClassMemberKind::Method {\n                        parameters: method.parameters.clone(),\n                        return_type: method.return_type.clone(),\n                        is_abstract: method.is_abstract,\n                    },\n                    is_final: method.is_final,\n                });\n            }\n            ClassMember::Getter(getter) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(getter.name.node).to_string(),\n                    access: getter.access.unwrap_or(AccessModifier::Public),\n                    _is_static: getter.is_static,\n                    kind: ClassMemberKind::Getter {\n                        return_type: getter.return_type.clone(),\n                    },\n                    is_final: false,\n                });\n            }\n            ClassMember::Setter(setter) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(setter.name.node).to_string(),\n                    access: setter.access.unwrap_or(AccessModifier::Public),\n                    _is_static: setter.is_static,\n                    kind: ClassMemberKind::Setter {\n                        parameter_type: setter.parameter.type_annotation.clone().unwrap_or_else(\n                            || Type::new(TypeKind::Primitive(PrimitiveType::Unknown), setter.span),\n                        ),\n                    },\n                    is_final: false,\n                });\n            }\n            ClassMember::Constructor(_) =\u003e {\n                // Constructor doesn't have access modifiers for member access\n            }\n            ClassMember::Operator(op) =\u003e {\n                let op_name = operator_kind_name(\u0026op.operator);\n                member_infos.push(ClassMemberInfo {\n                    name: op_name,\n                    access: op.access.unwrap_or(AccessModifier::Public),\n                    _is_static: false,\n                    kind: ClassMemberKind::Operator {\n                        operator: op.operator,\n                        parameters: op.parameters.clone(),\n                        return_type: op.return_type.clone(),\n                    },\n                    is_final: false,\n                });\n            }\n        }\n    }\n\n    member_infos\n}\n\n/// Classify a class member error as critical or non-critical.\n///\n/// Critical errors should fail compilation immediately, while non-critical errors\n/// can be converted to warnings to prevent cascading failures.\n///\n/// # Parameters\n///\n/// - `error_message`: The error message to classify\n///\n/// # Returns\n///\n/// Returns `true` if the error is critical and should fail compilation, `false` otherwise.\npub fn is_critical_member_error(error_message: \u0026str) -\u003e bool {\n    (error_message.contains(\"Abstract method\") \u0026\u0026 error_message.contains(\"abstract class\"))\n        || error_message.contains(\"one constructor\")\n        || error_message.contains(\"Decorators require decorator features\")\n        || error_message.contains(\"Cannot override final method\")\n        || error_message.contains(\"is incompatible with parent\")\n        || error_message.contains(\"must implement abstract method\")\n        || error_message.contains(\"uses override but class\")\n        || error_message.contains(\"marked as override but parent class does not have this method\")\n        || error_message.contains(\"Return type mismatch\")\n        || error_message.contains(\"is private and only accessible\")\n        || error_message.contains(\"is protected and only accessible\")\n        || error_message.contains(\"operators can have 0 parameters\")\n        || error_message.contains(\"Binary operator must have exactly\")\n        || error_message.contains(\"Operator must have 0, 1, or 2\")\n        || error_message.contains(\"must have exactly 2 parameters\")\n        || error_message.contains(\"must return 'boolean'\")\n}\n\n/// Register class type parameters in the type environment.\n///\n/// Type parameters from a generic class declaration are registered as type aliases\n/// in the type environment, scoped to the class body. Any existing type aliases\n/// with the same name are removed first.\n///\n/// # Parameters\n///\n/// - `type_params`: Optional slice of type parameters from the class declaration\n/// - `type_env`: Mutable type environment for registration\n/// - `interner`: String interner for resolving parameter names\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful, or an error if registration fails.\npub fn register_class_type_parameters(\n    type_params: Option\u003c\u0026[typedlua_parser::ast::statement::TypeParameter]\u003e,\n    type_env: \u0026mut crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), crate::TypeCheckError\u003e {\n    if let Some(type_params) = type_params {\n        for type_param in type_params {\n            let param_name = interner.resolve(type_param.name.node).to_string();\n            let param_type = Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: type_param.name.clone(),\n                    type_arguments: None,\n                    span: type_param.span,\n                }),\n                type_param.span,\n            );\n\n            // Remove any existing type alias with this name (from a previous generic class)\n            // then register fresh. Type params are scoped to the class body.\n            type_env.remove_type_alias(\u0026param_name);\n            type_env\n                .register_type_alias(param_name, param_type)\n                .map_err(|e| crate::TypeCheckError::new(e, type_param.span))?;\n        }\n    }\n    Ok(())\n}\n\n/// Register class-implements relationships in type environment and access control.\n///\n/// This function extracts interface names from the class's implements clause and\n/// registers them with both the type environment (for type checking) and access\n/// control (for member lookup).\n///\n/// # Parameters\n///\n/// - `class_name`: Name of the class\n/// - `implements`: Vector of interface types that the class implements\n/// - `type_env`: Mutable type environment for registration\n/// - `access_control`: Mutable access control for member lookup\n/// - `interner`: String interner for resolving interface names\npub fn register_class_implements(\n    class_name: String,\n    implements: Vec\u003cType\u003e,\n    type_env: \u0026mut crate::core::type_environment::TypeEnvironment,\n    access_control: \u0026mut crate::visitors::AccessControl,\n    interner: \u0026StringInterner,\n) {\n    if implements.is_empty() {\n        return;\n    }\n\n    // Register with type environment for type checking\n    type_env.register_class_implements(class_name.clone(), implements.clone());\n\n    // Extract interface names and register with access control for member lookup\n    let interface_names: Vec\u003cString\u003e = implements\n        .iter()\n        .map(|t| {\n            // Extract the interface name from the type\n            match \u0026t.kind {\n                TypeKind::Reference(ref_type) =\u003e interner.resolve(ref_type.name.node).to_string(),\n                _ =\u003e format!(\"{:?}\", t),\n            }\n        })\n        .collect();\n    access_control.register_class_implements(\u0026class_name, interface_names);\n}\n\n/// Register function type parameters with duplicate checking.\n///\n/// This function validates that type parameters are unique and registers them\n/// in the type environment along with any constraints.\n///\n/// # Parameters\n///\n/// - `type_params`: Optional slice of type parameters from the function declaration\n/// - `type_env`: Mutable type environment for registration\n/// - `interner`: String interner for resolving parameter names\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful, or an error if duplicate parameters are found\n/// or registration fails.\npub fn register_function_type_parameters(\n    type_params: Option\u003c\u0026[typedlua_parser::ast::statement::TypeParameter]\u003e,\n    type_env: \u0026mut crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), crate::TypeCheckError\u003e {\n    let Some(type_params) = type_params else {\n        return Ok(());\n    };\n\n    // Check for duplicate type parameters\n    let mut seen_params = std::collections::HashSet::new();\n    for type_param in type_params {\n        let param_name = interner.resolve(type_param.name.node).to_string();\n        if !seen_params.insert(param_name.clone()) {\n            return Err(crate::TypeCheckError::new(\n                format!(\"Duplicate type parameter '{}'\", param_name),\n                type_param.span,\n            ));\n        }\n    }\n\n    // Register type parameters in type environment\n    for type_param in type_params {\n        let param_name = interner.resolve(type_param.name.node).to_string();\n        let param_type = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: type_param.name.clone(),\n                type_arguments: None,\n                span: type_param.span,\n            }),\n            type_param.span,\n        );\n\n        // Type parameters are treated as local types in the function scope\n        type_env.remove_type_alias(\u0026param_name);\n        type_env\n            .register_type_alias(param_name.clone(), param_type)\n            .map_err(|e| crate::TypeCheckError::new(e, type_param.span))?;\n\n        // Register constraint if present (e.g., T implements Identifiable)\n        if let Some(constraint) = \u0026type_param.constraint {\n            type_env.register_type_param_constraint(param_name, (**constraint).clone());\n        }\n    }\n\n    Ok(())\n}\n\n/// Instantiate a generic interface with type arguments.\n///\n/// For generic interfaces like `Comparable\u003cT\u003e`, this function takes the interface type\n/// and substitutes all type parameters with concrete type arguments, producing an\n/// instantiated interface like `Comparable\u003cnumber\u003e`.\n///\n/// This handles the complex nested type substitution required for generic interface\n/// implementation checking.\n///\n/// # Parameters\n///\n/// - `interface`: The generic interface type to instantiate\n/// - `type_args`: The type arguments to substitute\n/// - `interface_name`: Name of the interface for substitution context\n/// - `substitute_fn`: Callback to perform type argument substitution\n///\n/// # Returns\n///\n/// Returns the instantiated interface type with all type parameters replaced.\npub fn instantiate_generic_interface\u003cF\u003e(\n    interface: Type,\n    type_args: \u0026Vec\u003cType\u003e,\n    interface_name: \u0026str,\n    substitute_fn: F,\n) -\u003e Type\nwhere\n    F: Fn(\u0026Type, \u0026Vec\u003cType\u003e, \u0026str) -\u003e Type,\n{\n    let mut instantiated_iface = interface.clone();\n    if let TypeKind::Object(ref mut obj) = instantiated_iface.kind {\n        // Build substitution map from interface type params\n        // For generic interfaces, we stored the raw type with references to T\n        // We need to substitute T -\u003e type_arg for each type param\n        for member in \u0026mut obj.members {\n            match member {\n                ObjectTypeMember::Method(method) =\u003e {\n                    // Substitute return type\n                    method.return_type =\n                        substitute_fn(\u0026method.return_type, type_args, interface_name);\n                    // Substitute parameter types\n                    for param in \u0026mut method.parameters {\n                        if let Some(ref type_ann) = param.type_annotation {\n                            param.type_annotation =\n                                Some(substitute_fn(type_ann, type_args, interface_name));\n                        }\n                    }\n                }\n                ObjectTypeMember::Property(prop) =\u003e {\n                    prop.type_annotation =\n                        substitute_fn(\u0026prop.type_annotation, type_args, interface_name);\n                }\n                ObjectTypeMember::Index(_) =\u003e {}\n            }\n        }\n    }\n    instantiated_iface\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":173}},{"line":54,"address":[],"length":0,"stats":{"Line":692}},{"line":57,"address":[],"length":0,"stats":{"Line":199}},{"line":61,"address":[],"length":0,"stats":{"Line":26}},{"line":63,"address":[],"length":0,"stats":{"Line":52}},{"line":64,"address":[],"length":0,"stats":{"Line":52}},{"line":65,"address":[],"length":0,"stats":{"Line":52}},{"line":67,"address":[],"length":0,"stats":{"Line":26}},{"line":70,"address":[],"length":0,"stats":{"Line":441}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":147}},{"line":77,"address":[],"length":0,"stats":{"Line":735}},{"line":78,"address":[],"length":0,"stats":{"Line":151}},{"line":82,"address":[],"length":0,"stats":{"Line":516}},{"line":86,"address":[],"length":0,"stats":{"Line":516}},{"line":89,"address":[],"length":0,"stats":{"Line":172}},{"line":91,"address":[],"length":0,"stats":{"Line":172}},{"line":93,"address":[],"length":0,"stats":{"Line":344}},{"line":95,"address":[],"length":0,"stats":{"Line":172}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":37}},{"line":213,"address":[],"length":0,"stats":{"Line":148}},{"line":216,"address":[],"length":0,"stats":{"Line":148}},{"line":219,"address":[],"length":0,"stats":{"Line":323}},{"line":220,"address":[],"length":0,"stats":{"Line":285}},{"line":222,"address":[],"length":0,"stats":{"Line":460}},{"line":225,"address":[],"length":0,"stats":{"Line":115}},{"line":228,"address":[],"length":0,"stats":{"Line":115}},{"line":231,"address":[],"length":0,"stats":{"Line":108}},{"line":234,"address":[],"length":0,"stats":{"Line":27}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":568}},{"line":247,"address":[],"length":0,"stats":{"Line":39}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":262,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":10}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":6}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":292,"address":[],"length":0,"stats":{"Line":105}},{"line":293,"address":[],"length":0,"stats":{"Line":35}},{"line":295,"address":[],"length":0,"stats":{"Line":174}},{"line":296,"address":[],"length":0,"stats":{"Line":224}},{"line":297,"address":[],"length":0,"stats":{"Line":52}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":37}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":3}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":4}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":35}},{"line":354,"address":[],"length":0,"stats":{"Line":70}},{"line":355,"address":[],"length":0,"stats":{"Line":35}},{"line":357,"address":[],"length":0,"stats":{"Line":35}},{"line":361,"address":[],"length":0,"stats":{"Line":105}},{"line":364,"address":[],"length":0,"stats":{"Line":35}},{"line":365,"address":[],"length":0,"stats":{"Line":175}},{"line":366,"address":[],"length":0,"stats":{"Line":39}},{"line":371,"address":[],"length":0,"stats":{"Line":102}},{"line":373,"address":[],"length":0,"stats":{"Line":34}},{"line":375,"address":[],"length":0,"stats":{"Line":34}},{"line":377,"address":[],"length":0,"stats":{"Line":68}},{"line":380,"address":[],"length":0,"stats":{"Line":68}},{"line":381,"address":[],"length":0,"stats":{"Line":34}},{"line":383,"address":[],"length":0,"stats":{"Line":138}},{"line":385,"address":[],"length":0,"stats":{"Line":34}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":43}},{"line":517,"address":[],"length":0,"stats":{"Line":172}},{"line":521,"address":[],"length":0,"stats":{"Line":43}},{"line":522,"address":[],"length":0,"stats":{"Line":129}},{"line":523,"address":[],"length":0,"stats":{"Line":43}},{"line":524,"address":[],"length":0,"stats":{"Line":43}},{"line":526,"address":[],"length":0,"stats":{"Line":43}},{"line":529,"address":[],"length":0,"stats":{"Line":86}},{"line":530,"address":[],"length":0,"stats":{"Line":43}},{"line":531,"address":[],"length":0,"stats":{"Line":86}},{"line":532,"address":[],"length":0,"stats":{"Line":43}},{"line":534,"address":[],"length":0,"stats":{"Line":86}},{"line":537,"address":[],"length":0,"stats":{"Line":47}},{"line":538,"address":[],"length":0,"stats":{"Line":12}},{"line":542,"address":[],"length":0,"stats":{"Line":55}},{"line":543,"address":[],"length":0,"stats":{"Line":24}},{"line":546,"address":[],"length":0,"stats":{"Line":43}},{"line":565,"address":[],"length":0,"stats":{"Line":41}},{"line":570,"address":[],"length":0,"stats":{"Line":82}},{"line":573,"address":[],"length":0,"stats":{"Line":169}},{"line":574,"address":[],"length":0,"stats":{"Line":64}},{"line":575,"address":[],"length":0,"stats":{"Line":46}},{"line":576,"address":[],"length":0,"stats":{"Line":69}},{"line":577,"address":[],"length":0,"stats":{"Line":92}},{"line":578,"address":[],"length":0,"stats":{"Line":92}},{"line":579,"address":[],"length":0,"stats":{"Line":46}},{"line":580,"address":[],"length":0,"stats":{"Line":23}},{"line":581,"address":[],"length":0,"stats":{"Line":23}},{"line":583,"address":[],"length":0,"stats":{"Line":23}},{"line":586,"address":[],"length":0,"stats":{"Line":56}},{"line":587,"address":[],"length":0,"stats":{"Line":84}},{"line":588,"address":[],"length":0,"stats":{"Line":112}},{"line":589,"address":[],"length":0,"stats":{"Line":112}},{"line":590,"address":[],"length":0,"stats":{"Line":56}},{"line":591,"address":[],"length":0,"stats":{"Line":28}},{"line":592,"address":[],"length":0,"stats":{"Line":84}},{"line":593,"address":[],"length":0,"stats":{"Line":56}},{"line":594,"address":[],"length":0,"stats":{"Line":28}},{"line":596,"address":[],"length":0,"stats":{"Line":28}},{"line":599,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":6}},{"line":601,"address":[],"length":0,"stats":{"Line":8}},{"line":602,"address":[],"length":0,"stats":{"Line":8}},{"line":603,"address":[],"length":0,"stats":{"Line":4}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":605,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":2}},{"line":610,"address":[],"length":0,"stats":{"Line":2}},{"line":611,"address":[],"length":0,"stats":{"Line":4}},{"line":612,"address":[],"length":0,"stats":{"Line":6}},{"line":613,"address":[],"length":0,"stats":{"Line":6}},{"line":614,"address":[],"length":0,"stats":{"Line":2}},{"line":616,"address":[],"length":0,"stats":{"Line":6}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":9}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":41}},{"line":658,"address":[],"length":0,"stats":{"Line":2}},{"line":659,"address":[],"length":0,"stats":{"Line":6}},{"line":660,"address":[],"length":0,"stats":{"Line":2}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":43}},{"line":697,"address":[],"length":0,"stats":{"Line":49}},{"line":698,"address":[],"length":0,"stats":{"Line":18}},{"line":699,"address":[],"length":0,"stats":{"Line":24}},{"line":701,"address":[],"length":0,"stats":{"Line":6}},{"line":702,"address":[],"length":0,"stats":{"Line":18}},{"line":703,"address":[],"length":0,"stats":{"Line":6}},{"line":704,"address":[],"length":0,"stats":{"Line":6}},{"line":706,"address":[],"length":0,"stats":{"Line":6}},{"line":711,"address":[],"length":0,"stats":{"Line":18}},{"line":712,"address":[],"length":0,"stats":{"Line":6}},{"line":713,"address":[],"length":0,"stats":{"Line":18}},{"line":714,"address":[],"length":0,"stats":{"Line":6}},{"line":717,"address":[],"length":0,"stats":{"Line":43}},{"line":733,"address":[],"length":0,"stats":{"Line":42}},{"line":740,"address":[],"length":0,"stats":{"Line":84}},{"line":741,"address":[],"length":0,"stats":{"Line":38}},{"line":745,"address":[],"length":0,"stats":{"Line":24}},{"line":748,"address":[],"length":0,"stats":{"Line":12}},{"line":750,"address":[],"length":0,"stats":{"Line":8}},{"line":752,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":16}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":16}},{"line":776,"address":[],"length":0,"stats":{"Line":60}},{"line":781,"address":[],"length":0,"stats":{"Line":73}},{"line":782,"address":[],"length":0,"stats":{"Line":47}},{"line":786,"address":[],"length":0,"stats":{"Line":26}},{"line":787,"address":[],"length":0,"stats":{"Line":45}},{"line":788,"address":[],"length":0,"stats":{"Line":64}},{"line":789,"address":[],"length":0,"stats":{"Line":48}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":45}},{"line":799,"address":[],"length":0,"stats":{"Line":64}},{"line":801,"address":[],"length":0,"stats":{"Line":16}},{"line":802,"address":[],"length":0,"stats":{"Line":48}},{"line":803,"address":[],"length":0,"stats":{"Line":16}},{"line":804,"address":[],"length":0,"stats":{"Line":16}},{"line":806,"address":[],"length":0,"stats":{"Line":16}},{"line":810,"address":[],"length":0,"stats":{"Line":48}},{"line":811,"address":[],"length":0,"stats":{"Line":16}},{"line":812,"address":[],"length":0,"stats":{"Line":64}},{"line":813,"address":[],"length":0,"stats":{"Line":16}},{"line":816,"address":[],"length":0,"stats":{"Line":18}},{"line":817,"address":[],"length":0,"stats":{"Line":4}},{"line":821,"address":[],"length":0,"stats":{"Line":13}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}}],"covered":189,"coverable":333},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","declaration_phase.rs"],"content":"//! Declaration phase: Symbol registration and declaration handling\n//!\n//! This phase handles:\n//! - Registering function signatures in the symbol table\n//! - Declaring variables, constants, and type aliases\n//! - Declaring classes, interfaces, and enums\n//! - Tracking declarations for forward references\n//!\n//! **Design Pattern**: Stateless phase functions that take explicit context parameters.\n//! The phase focuses on DECLARING symbols (adding them to the symbol table) before\n//! full type checking occurs. This enables forward references and proper scope resolution.\n\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::TypeCheckError;\nuse typedlua_parser::ast::pattern::{ArrayPatternElement, Pattern};\nuse typedlua_parser::ast::statement::{\n    DeclareConstStatement, DeclareFunctionStatement, DeclareNamespaceStatement,\n    FunctionDeclaration, MethodSignature, PropertySignature, Statement,\n};\nuse typedlua_parser::ast::types::{\n    FunctionType, ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind,\n};\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Register a function signature in the symbol table.\n///\n/// This function creates a symbol for a function declaration based on its signature\n/// (name, parameters, return type, type parameters) and adds it to the symbol table.\n/// This allows the function to be referenced before its body is type-checked.\n///\n/// This is called during the declaration phase (PASS 1), before checking the function body.\n///\n/// # Validation\n///\n/// - Type predicate return types: Validates that the parameter name in a type predicate\n///   actually matches one of the function's parameters\n/// - Return type: Defaults to `void` if no return type is specified\n///\n/// # Parameters\n///\n/// - `decl`: The function declaration to register\n/// - `symbol_table`: Mutable symbol table to add the function symbol\n/// - `interner`: String interner for resolving the function name\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the function was successfully registered, or an error if\n/// validation fails or a symbol with the same name already exists in the current scope.\npub fn register_function_signature(\n    decl: \u0026FunctionDeclaration,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Validate type predicate return types\n    if let Some(return_type) = \u0026decl.return_type {\n        if let TypeKind::TypePredicate(predicate) = \u0026return_type.kind {\n            // Validate that the parameter name in the predicate matches one of the function parameters\n            let param_exists = decl.parameters.iter().any(|param| {\n                if let Pattern::Identifier(ident) = \u0026param.pattern {\n                    ident.node == predicate.parameter_name.node\n                } else {\n                    false\n                }\n            });\n\n            if !param_exists {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Type predicate parameter '{}' does not match any function parameter\",\n                        predicate.parameter_name.node\n                    ),\n                    predicate.span,\n                ));\n            }\n        }\n    }\n\n    // Create function type\n    let func_type =\n        Type::new(\n            TypeKind::Function(FunctionType {\n                type_parameters: decl.type_parameters.clone(),\n                parameters: decl.parameters.clone(),\n                return_type: Box::new(decl.return_type.clone().unwrap_or_else(|| {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Void), decl.span)\n                })),\n                throws: decl.throws.clone(),\n                span: decl.span,\n            }),\n            decl.span,\n        );\n\n    // Declare function in symbol table\n    let symbol = Symbol::new(\n        interner.resolve(decl.name.node).to_string(),\n        SymbolKind::Function,\n        func_type,\n        decl.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, decl.span))\n}\n\n/// Declare symbols from a destructuring pattern.\n///\n/// This function recursively traverses a pattern (identifier, array destructuring,\n/// object destructuring, or-patterns) and declares each binding in the symbol table.\n///\n/// # Pattern Types\n///\n/// - **Identifier**: `let x: number` - declares `x`\n/// - **Array**: `let [a, b, ...rest] = array` - declares `a`, `b`, `rest`\n/// - **Object**: `let {x, y: z} = obj` - declares `x`, `z`\n/// - **Or-pattern**: `let (a | b) = value` - declares from first alternative\n/// - **Literals/Wildcards**: No declarations\n///\n/// # Parameters\n///\n/// - `pattern`: The pattern to extract bindings from\n/// - `typ`: The type to assign to the bindings\n/// - `kind`: Symbol kind (Variable, Const, etc.)\n/// - `span`: Source location for error reporting\n/// - `symbol_table`: Mutable symbol table\n/// - `interner`: String interner for resolving names\npub fn declare_pattern(\n    pattern: \u0026Pattern,\n    typ: Type,\n    kind: SymbolKind,\n    span: Span,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    match pattern {\n        Pattern::Identifier(ident) =\u003e {\n            let symbol = Symbol::new(interner.resolve(ident.node).to_string(), kind, typ, span);\n            symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, span))?;\n            Ok(())\n        }\n        Pattern::Array(array_pattern) =\u003e {\n            // Extract element type from array type\n            if let TypeKind::Array(elem_type) = \u0026typ.kind {\n                for elem in \u0026array_pattern.elements {\n                    match elem {\n                        ArrayPatternElement::Pattern(pat) =\u003e {\n                            declare_pattern(\n                                pat,\n                                (**elem_type).clone(),\n                                kind,\n                                span,\n                                symbol_table,\n                                interner,\n                            )?;\n                        }\n                        ArrayPatternElement::Rest(ident) =\u003e {\n                            // Rest gets array type\n                            let array_type = Type::new(TypeKind::Array(elem_type.clone()), span);\n                            let symbol = Symbol::new(\n                                interner.resolve(ident.node).to_string(),\n                                kind,\n                                array_type,\n                                span,\n                            );\n                            symbol_table\n                                .declare(symbol)\n                                .map_err(|e| TypeCheckError::new(e, span))?;\n                        }\n                        ArrayPatternElement::Hole =\u003e {\n                            // Holes don't declare symbols\n                        }\n                    }\n                }\n            } else {\n                return Err(TypeCheckError::new(\n                    \"Cannot destructure non-array type\",\n                    span,\n                ));\n            }\n            Ok(())\n        }\n        Pattern::Object(obj_pattern) =\u003e {\n            // Extract properties from object type\n            if let TypeKind::Object(obj_type) = \u0026typ.kind {\n                for prop_pattern in \u0026obj_pattern.properties {\n                    // Find matching property in type\n                    let prop_type = obj_type.members.iter().find_map(|member| {\n                        if let ObjectTypeMember::Property(prop) = member {\n                            if prop.name.node == prop_pattern.key.node {\n                                return Some(prop.type_annotation.clone());\n                            }\n                        }\n                        None\n                    });\n\n                    let prop_type = match prop_type {\n                        Some(t) =\u003e t,\n                        None =\u003e {\n                            return Err(TypeCheckError::new(\n                                format!(\n                                    \"Property '{}' does not exist on type\",\n                                    prop_pattern.key.node\n                                ),\n                                span,\n                            ));\n                        }\n                    };\n\n                    if let Some(value_pattern) = \u0026prop_pattern.value {\n                        declare_pattern(\n                            value_pattern,\n                            prop_type,\n                            kind,\n                            span,\n                            symbol_table,\n                            interner,\n                        )?;\n                    } else {\n                        // Shorthand: { x } means { x: x }\n                        let symbol = Symbol::new(\n                            interner.resolve(prop_pattern.key.node).to_string(),\n                            kind,\n                            prop_type,\n                            span,\n                        );\n                        symbol_table\n                            .declare(symbol)\n                            .map_err(|e| TypeCheckError::new(e, span))?;\n                    }\n                }\n            } else {\n                return Err(TypeCheckError::new(\n                    \"Cannot destructure non-object type\",\n                    span,\n                ));\n            }\n            Ok(())\n        }\n        Pattern::Literal(_, _) | Pattern::Wildcard(_) =\u003e {\n            // Literals and wildcards don't declare symbols\n            Ok(())\n        }\n        Pattern::Or(or_pattern) =\u003e {\n            // For or-patterns, all alternatives bind the same variables\n            // Declare from the first alternative\n            if let Some(first) = or_pattern.alternatives.first() {\n                declare_pattern(first, typ, kind, span, symbol_table, interner)?;\n            }\n            Ok(())\n        }\n    }\n}\n\n/// Register a `declare function` statement in the symbol table.\n///\n/// Ambient function declarations (using `declare function`) don't have bodies.\n/// They just register the function signature for type checking purposes.\npub fn register_declare_function(\n    func: \u0026DeclareFunctionStatement,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    let func_type = Type::new(\n        TypeKind::Function(FunctionType {\n            type_parameters: func.type_parameters.clone(),\n            parameters: func.parameters.clone(),\n            return_type: Box::new(func.return_type.clone()),\n            throws: func.throws.clone(),\n            span: func.span,\n        }),\n        func.span,\n    );\n\n    let symbol = Symbol::new(\n        interner.resolve(func.name.node).to_string(),\n        SymbolKind::Function,\n        func_type,\n        func.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, func.span))\n}\n\n/// Register a `declare const` statement in the symbol table.\n///\n/// Ambient constant declarations don't have initializers.\n/// They just register the constant name and type.\npub fn register_declare_const(\n    const_decl: \u0026DeclareConstStatement,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    let symbol = Symbol::new(\n        interner.resolve(const_decl.name.node).to_string(),\n        SymbolKind::Const,\n        const_decl.type_annotation.clone(),\n        const_decl.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, const_decl.span))\n}\n\n/// Register a `declare namespace` statement in the symbol table.\n///\n/// Namespace declarations create an object type containing all exported members.\n/// This allows `Namespace.member` access patterns.\npub fn register_declare_namespace(\n    ns: \u0026DeclareNamespaceStatement,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Create object type from namespace members\n    let members: Vec\u003c_\u003e = ns\n        .members\n        .iter()\n        .filter_map(|member| match member {\n            Statement::DeclareFunction(func) if func.is_export =\u003e {\n                Some(ObjectTypeMember::Method(MethodSignature {\n                    name: func.name.clone(),\n                    type_parameters: func.type_parameters.clone(),\n                    parameters: func.parameters.clone(),\n                    return_type: func.return_type.clone(),\n                    body: None,\n                    span: func.span,\n                }))\n            }\n            Statement::DeclareConst(const_decl) if const_decl.is_export =\u003e {\n                Some(ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: true, // Constants are readonly\n                    name: const_decl.name.clone(),\n                    is_optional: false,\n                    type_annotation: const_decl.type_annotation.clone(),\n                    span: const_decl.span,\n                }))\n            }\n            _ =\u003e None,\n        })\n        .collect();\n\n    let namespace_type = Type::new(\n        TypeKind::Object(ObjectType {\n            members,\n            span: ns.span,\n        }),\n        ns.span,\n    );\n\n    let symbol = Symbol::new(\n        interner.resolve(ns.name.node).to_string(),\n        SymbolKind::Const,\n        namespace_type,\n        ns.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, ns.span))\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":38}},{"line":56,"address":[],"length":0,"stats":{"Line":71}},{"line":57,"address":[],"length":0,"stats":{"Line":35}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":37}},{"line":83,"address":[],"length":0,"stats":{"Line":74}},{"line":84,"address":[],"length":0,"stats":{"Line":74}},{"line":85,"address":[],"length":0,"stats":{"Line":153}},{"line":86,"address":[],"length":0,"stats":{"Line":15}},{"line":88,"address":[],"length":0,"stats":{"Line":74}},{"line":89,"address":[],"length":0,"stats":{"Line":37}},{"line":91,"address":[],"length":0,"stats":{"Line":37}},{"line":96,"address":[],"length":0,"stats":{"Line":111}},{"line":97,"address":[],"length":0,"stats":{"Line":37}},{"line":98,"address":[],"length":0,"stats":{"Line":37}},{"line":99,"address":[],"length":0,"stats":{"Line":37}},{"line":102,"address":[],"length":0,"stats":{"Line":37}},{"line":103,"address":[],"length":0,"stats":{"Line":74}},{"line":104,"address":[],"length":0,"stats":{"Line":37}},{"line":128,"address":[],"length":0,"stats":{"Line":252}},{"line":136,"address":[],"length":0,"stats":{"Line":252}},{"line":137,"address":[],"length":0,"stats":{"Line":252}},{"line":138,"address":[],"length":0,"stats":{"Line":2016}},{"line":139,"address":[],"length":0,"stats":{"Line":252}},{"line":140,"address":[],"length":0,"stats":{"Line":504}},{"line":141,"address":[],"length":0,"stats":{"Line":256}},{"line":142,"address":[],"length":0,"stats":{"Line":251}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":91}},{"line":267,"address":[],"length":0,"stats":{"Line":91}},{"line":268,"address":[],"length":0,"stats":{"Line":273}},{"line":269,"address":[],"length":0,"stats":{"Line":273}},{"line":270,"address":[],"length":0,"stats":{"Line":364}},{"line":271,"address":[],"length":0,"stats":{"Line":182}},{"line":272,"address":[],"length":0,"stats":{"Line":91}},{"line":274,"address":[],"length":0,"stats":{"Line":91}},{"line":278,"address":[],"length":0,"stats":{"Line":273}},{"line":279,"address":[],"length":0,"stats":{"Line":91}},{"line":280,"address":[],"length":0,"stats":{"Line":91}},{"line":281,"address":[],"length":0,"stats":{"Line":91}},{"line":284,"address":[],"length":0,"stats":{"Line":91}},{"line":285,"address":[],"length":0,"stats":{"Line":182}},{"line":286,"address":[],"length":0,"stats":{"Line":91}},{"line":293,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":18}},{"line":300,"address":[],"length":0,"stats":{"Line":6}},{"line":301,"address":[],"length":0,"stats":{"Line":12}},{"line":302,"address":[],"length":0,"stats":{"Line":6}},{"line":305,"address":[],"length":0,"stats":{"Line":6}},{"line":306,"address":[],"length":0,"stats":{"Line":12}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":31}},{"line":320,"address":[],"length":0,"stats":{"Line":93}},{"line":321,"address":[],"length":0,"stats":{"Line":31}},{"line":323,"address":[],"length":0,"stats":{"Line":383}},{"line":324,"address":[],"length":0,"stats":{"Line":703}},{"line":325,"address":[],"length":0,"stats":{"Line":351}},{"line":326,"address":[],"length":0,"stats":{"Line":1053}},{"line":327,"address":[],"length":0,"stats":{"Line":1053}},{"line":328,"address":[],"length":0,"stats":{"Line":1053}},{"line":329,"address":[],"length":0,"stats":{"Line":1053}},{"line":330,"address":[],"length":0,"stats":{"Line":351}},{"line":331,"address":[],"length":0,"stats":{"Line":351}},{"line":334,"address":[],"length":0,"stats":{"Line":84}},{"line":335,"address":[],"length":0,"stats":{"Line":42}},{"line":336,"address":[],"length":0,"stats":{"Line":42}},{"line":337,"address":[],"length":0,"stats":{"Line":126}},{"line":338,"address":[],"length":0,"stats":{"Line":42}},{"line":339,"address":[],"length":0,"stats":{"Line":84}},{"line":340,"address":[],"length":0,"stats":{"Line":42}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":31}},{"line":349,"address":[],"length":0,"stats":{"Line":31}},{"line":350,"address":[],"length":0,"stats":{"Line":31}},{"line":352,"address":[],"length":0,"stats":{"Line":31}},{"line":356,"address":[],"length":0,"stats":{"Line":93}},{"line":357,"address":[],"length":0,"stats":{"Line":31}},{"line":358,"address":[],"length":0,"stats":{"Line":31}},{"line":359,"address":[],"length":0,"stats":{"Line":31}},{"line":362,"address":[],"length":0,"stats":{"Line":31}},{"line":363,"address":[],"length":0,"stats":{"Line":62}},{"line":364,"address":[],"length":0,"stats":{"Line":31}}],"covered":89,"coverable":153},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","inference_phase.rs"],"content":"//! Inference phase: Statement and expression type checking\n\nuse crate::TypeCheckError;\nuse typedlua_parser::ast::statement::{\n    ForStatement, IfStatement, RepeatStatement, ReturnStatement, WhileStatement,\n};\nuse typedlua_parser::span::Span;\n\n/// Check that a rethrow statement appears in a valid context (inside a catch block).\n///\n/// Rethrow can only be used within a catch clause to re-raise the caught exception.\n///\n/// # Parameters\n///\n/// - `in_catch_block`: Stack of catch block contexts (true if currently in a catch block)\n/// - `span`: Source span for error reporting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if valid (in a catch block), or an error if outside a catch block.\npub fn check_rethrow_statement(in_catch_block: \u0026[bool], span: Span) -\u003e Result\u003c(), TypeCheckError\u003e {\n    if in_catch_block.last() != Some(\u0026true) {\n        return Err(TypeCheckError::new(\n            \"rethrow can only be used outside of a catch block\",\n            span,\n        ));\n    }\n    Ok(())\n}\n\n/// Check an if statement structure.\n///\n/// This function validates the if statement structure and returns information\n/// about blocks that need type checking. The caller should check expressions\n/// and blocks with access to full TypeChecker state.\n///\n/// # Parameters\n///\n/// - `if_stmt`: The if statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the structure is valid. The caller should then:\n/// 1. Infer the condition expression type\n/// 2. Check the then block\n/// 3. Check else-if conditions and blocks\n/// 4. Check the else block if present\npub fn check_if_statement(_if_stmt: \u0026IfStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation only - caller handles expression/block checking\n    // If statement structure is already validated by parser\n    Ok(())\n}\n\n/// Check a while statement structure.\n///\n/// # Parameters\n///\n/// - `while_stmt`: The while statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())`. The caller should check the condition expression and body block.\npub fn check_while_statement(_while_stmt: \u0026WhileStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation only - caller handles expression/block checking\n    Ok(())\n}\n\n/// Check a for statement structure.\n///\n/// This validates for loop patterns (numeric and generic).\n///\n/// # Parameters\n///\n/// - `for_stmt`: The for statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())`. The caller should:\n/// 1. Enter new scope for loop variable\n/// 2. Infer iterator expression types\n/// 3. Declare loop variable(s)\n/// 4. Check the loop body\n/// 5. Exit scope\npub fn check_for_statement(_for_stmt: \u0026ForStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation - caller handles variable declaration and body checking\n    Ok(())\n}\n\n/// Check a repeat statement structure.\n///\n/// # Parameters\n///\n/// - `repeat_stmt`: The repeat statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())`. The caller should check the body block and condition expression.\npub fn check_repeat_statement(_repeat_stmt: \u0026RepeatStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation only\n    Ok(())\n}\n\n/// Check a return statement structure and validate context.\n///\n/// This function validates that the return statement appears in a valid context\n/// (inside a function). The caller should handle type checking the return expression\n/// against the expected return type.\n///\n/// # Parameters\n///\n/// - `return_stmt`: The return statement to check\n/// - `current_function_return_type`: The expected return type of the enclosing function\n/// - `span`: Span for error reporting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if valid, or an error if the return statement is outside a function.\n/// The caller should then check the return expression type matches the function return type.\npub fn check_return_statement(\n    _return_stmt: \u0026ReturnStatement,\n    current_function_return_type: Option\u003c\u0026typedlua_parser::ast::types::Type\u003e,\n    span: Span,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Validate we're inside a function\n    if current_function_return_type.is_none() {\n        return Err(TypeCheckError::new(\n            \"Return statement outside function\",\n            span,\n        ));\n    }\n\n    // Caller should check the expression type against current_function_return_type\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    #[test]\n    fn test_check_rethrow_inside_catch() {\n        let span = Span::new(0, 10, 0, 10);\n        let in_catch = vec![true];\n        let result = check_rethrow_statement(\u0026in_catch, span);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_rethrow_outside_catch() {\n        let span = Span::new(0, 10, 0, 10);\n        let in_catch: Vec\u003cbool\u003e = vec![];\n        let result = check_rethrow_statement(\u0026in_catch, span);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_check_return_inside_function() {\n        let span = Span::new(0, 10, 0, 10);\n        let return_type = typedlua_parser::ast::types::Type::new(\n            typedlua_parser::ast::types::TypeKind::Primitive(\n                typedlua_parser::ast::types::PrimitiveType::Number,\n            ),\n            span,\n        );\n        let result = check_return_statement(\n            \u0026typedlua_parser::ast::statement::ReturnStatement {\n                values: Vec::new(),\n                span,\n            },\n            Some(\u0026return_type),\n            span,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_return_outside_function() {\n        let span = Span::new(0, 10, 0, 10);\n        let result = check_return_statement(\n            \u0026typedlua_parser::ast::statement::ReturnStatement {\n                values: Vec::new(),\n                span,\n            },\n            None,\n            span,\n        );\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_check_if_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let if_stmt = typedlua_parser::ast::statement::IfStatement {\n            condition: typedlua_parser::ast::expression::Expression {\n                kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                    typedlua_parser::ast::expression::Literal::Boolean(true),\n                ),\n                span,\n                annotated_type: None,\n                receiver_class: None,\n            },\n            then_block: typedlua_parser::ast::statement::Block {\n                statements: Vec::new(),\n                span,\n            },\n            else_ifs: Vec::new(),\n            else_block: None,\n            span,\n        };\n        let result = check_if_statement(\u0026if_stmt);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_while_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let while_stmt = typedlua_parser::ast::statement::WhileStatement {\n            condition: typedlua_parser::ast::expression::Expression {\n                kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                    typedlua_parser::ast::expression::Literal::Boolean(true),\n                ),\n                span,\n                annotated_type: None,\n                receiver_class: None,\n            },\n            body: typedlua_parser::ast::statement::Block {\n                statements: Vec::new(),\n                span,\n            },\n            span,\n        };\n        let result = check_while_statement(\u0026while_stmt);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_for_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let for_stmt = typedlua_parser::ast::statement::ForStatement::Numeric(Box::new(\n            typedlua_parser::ast::statement::ForNumeric {\n                variable: typedlua_parser::ast::Spanned::new(\n                    typedlua_parser::string_interner::StringId::from_u32(0),\n                    span,\n                ),\n                start: typedlua_parser::ast::expression::Expression {\n                    kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                        typedlua_parser::ast::expression::Literal::Number(1.0),\n                    ),\n                    span,\n                    annotated_type: None,\n                    receiver_class: None,\n                },\n                end: typedlua_parser::ast::expression::Expression {\n                    kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                        typedlua_parser::ast::expression::Literal::Number(10.0),\n                    ),\n                    span,\n                    annotated_type: None,\n                    receiver_class: None,\n                },\n                step: None,\n                body: typedlua_parser::ast::statement::Block {\n                    statements: Vec::new(),\n                    span,\n                },\n                span,\n            },\n        ));\n        let result = check_for_statement(\u0026for_stmt);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_repeat_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let repeat_stmt = typedlua_parser::ast::statement::RepeatStatement {\n            body: typedlua_parser::ast::statement::Block {\n                statements: Vec::new(),\n                span,\n            },\n            until: typedlua_parser::ast::expression::Expression {\n                kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                    typedlua_parser::ast::expression::Literal::Boolean(true),\n                ),\n                span,\n                annotated_type: None,\n                receiver_class: None,\n            },\n            span,\n        };\n        let result = check_repeat_statement(\u0026repeat_stmt);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","mod.rs"],"content":"//! Type checker phase modules\n//!\n//! This module contains the decomposed phases of type checking, extracted from\n//! the monolithic type_checker.rs to improve maintainability and reduce cognitive load.\n//!\n//! Each phase handles a specific aspect of type checking:\n//! - `module_phase`: Import/export resolution and module dependency tracking\n//! - `declaration_phase`: Symbol declaration and registration (PASS 1)\n//! - `declaration_checking_phase`: Type alias, enum, interface checking (PASS 2)\n//! - `validation_phase`: Type compatibility and validation checks\n//! - `inference_phase`: Statement and expression type inference\n\npub mod declaration_checking_phase;\npub mod declaration_phase;\npub mod inference_phase;\npub mod module_phase;\npub mod validation_phase;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","module_phase.rs"],"content":"//! Module phase: Import/export resolution and module dependency tracking\n//!\n//! This phase handles:\n//! - Extracting exports from a program (export declarations, export specifiers)\n//! - Resolving import statements and registering imported symbols\n//! - Tracking module dependencies for multi-module compilation\n//!\n//! **Design Pattern**: Stateless phase functions that take explicit context parameters\n//! rather than encapsulating state. This allows flexibility in how the type checker\n//! orchestrates phase execution.\n\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::module_resolver::{\n    ExportedSymbol, ModuleExports, ModuleId, ModuleRegistry, ModuleResolver,\n};\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::visitors::{AccessControl, AccessControlVisitor, ClassMemberInfo, ClassMemberKind};\nuse crate::TypeCheckError;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse typedlua_parser::ast::pattern::Pattern;\nuse typedlua_parser::ast::statement::{ExportKind, ImportClause, ImportDeclaration, Statement};\nuse typedlua_parser::ast::types::{ObjectTypeMember, PrimitiveType, Type, TypeKind};\nuse typedlua_parser::ast::Program;\nuse typedlua_parser::prelude::AccessModifier;\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Extract all exported symbols from a program.\n///\n/// This function analyzes export statements in the AST and builds a `ModuleExports`\n/// structure containing all named and default exports. It handles:\n///\n/// - `export { foo, bar }` - Named exports of existing symbols\n/// - `export const x = 1` - Inline export declarations\n/// - `export default expr` - Default exports\n/// - `export { foo } from './other'` - Re-exports from other modules\n///\n/// # Parameters\n///\n/// - `program`: The AST program to extract exports from\n/// - `symbol_table`: Symbol table for looking up exported symbols\n/// - `interner`: String interner for resolving identifier names\n/// - `module_registry`: Optional registry for resolving re-exports (None if not using modules)\n/// - `module_resolver`: Optional resolver for finding source modules (None if not using modules)\n/// - `current_module_id`: Optional ID of the current module (None if not using modules)\n///\n/// # Returns\n///\n/// A `ModuleExports` structure containing all exports found in the program.\npub fn extract_exports(\n    program: \u0026Program,\n    symbol_table: \u0026SymbolTable,\n    interner: \u0026StringInterner,\n    module_registry: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026crate::module_resolver::ModuleId\u003e,\n) -\u003e ModuleExports {\n    let mut exports = ModuleExports::new();\n\n    for stmt in program.statements.iter() {\n        if let Statement::Export(export_decl) = stmt {\n            match \u0026export_decl.kind {\n                ExportKind::Declaration(decl) =\u003e {\n                    extract_declaration_export(decl, symbol_table, interner, \u0026mut exports);\n                }\n                ExportKind::Named { specifiers, source } =\u003e {\n                    for spec in specifiers {\n                        let local_name = interner.resolve(spec.local.node);\n                        let export_name = spec\n                            .exported\n                            .as_ref()\n                            .map(|e| interner.resolve(e.node))\n                            .unwrap_or_else(|| local_name.clone());\n\n                        // Check if this is a re-export from another module\n                        if let Some(source_path) = source {\n                            handle_reexport(\n                                \u0026local_name,\n                                \u0026export_name,\n                                source_path,\n                                module_registry,\n                                module_resolver,\n                                current_module_id,\n                                \u0026mut exports,\n                            );\n                        } else {\n                            // Local export - look up in symbol table\n                            if let Some(symbol) = symbol_table.lookup(\u0026local_name) {\n                                let is_type_only = matches!(\n                                    symbol.kind,\n                                    SymbolKind::TypeAlias | SymbolKind::Interface\n                                );\n                                exports.add_named(\n                                    export_name,\n                                    ExportedSymbol::new(symbol.clone(), is_type_only),\n                                );\n                            }\n                        }\n                    }\n                }\n                ExportKind::Default(_expr) =\u003e {\n                    // For default exports, create a synthetic symbol\n                    // Future: infer the type of the expression\n                    let default_symbol = Symbol {\n                        name: \"default\".to_string(),\n                        typ: Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            export_decl.span,\n                        ),\n                        kind: SymbolKind::Variable,\n                        span: export_decl.span,\n                        is_exported: true,\n                        references: Vec::new(),\n                    };\n                    exports.set_default(ExportedSymbol::new(default_symbol, false));\n                }\n            }\n        }\n    }\n\n    exports\n}\n\n/// Helper: Extract exports from an inline export declaration\nfn extract_declaration_export(\n    decl: \u0026Statement,\n    symbol_table: \u0026SymbolTable,\n    interner: \u0026StringInterner,\n    exports: \u0026mut ModuleExports,\n) {\n    match decl {\n        Statement::Variable(var_decl) =\u003e {\n            if let Pattern::Identifier(ident) = \u0026var_decl.pattern {\n                let ident_name = interner.resolve(ident.node);\n                if let Some(symbol) = symbol_table.lookup(\u0026ident_name) {\n                    exports.add_named(ident_name, ExportedSymbol::new(symbol.clone(), false));\n                }\n            }\n        }\n        Statement::Function(func_decl) =\u003e {\n            let func_name = interner.resolve(func_decl.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026func_name) {\n                exports.add_named(func_name, ExportedSymbol::new(symbol.clone(), false));\n            }\n        }\n        Statement::Class(class_decl) =\u003e {\n            let class_name = interner.resolve(class_decl.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026class_name) {\n                exports.add_named(class_name, ExportedSymbol::new(symbol.clone(), false));\n            }\n        }\n        Statement::TypeAlias(type_alias) =\u003e {\n            let alias_name = interner.resolve(type_alias.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026alias_name) {\n                exports.add_named(alias_name, ExportedSymbol::new(symbol.clone(), true));\n            }\n        }\n        Statement::Interface(interface_decl) =\u003e {\n            let interface_name = interner.resolve(interface_decl.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026interface_name) {\n                exports.add_named(interface_name, ExportedSymbol::new(symbol.clone(), true));\n            }\n        }\n        _ =\u003e {}\n    }\n}\n\n/// Helper: Handle re-exports from another module\n#[allow(clippy::too_many_arguments)]\nfn handle_reexport(\n    local_name: \u0026str,\n    export_name: \u0026str,\n    source_path: \u0026str,\n    module_registry: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026crate::module_resolver::ModuleId\u003e,\n    exports: \u0026mut ModuleExports,\n) {\n    if let (Some(registry), Some(resolver), Some(current_id)) =\n        (module_registry, module_resolver, current_module_id)\n    {\n        if let Ok(source_module_id) = resolver.resolve(source_path, current_id.path()) {\n            if let Ok(source_exports) = registry.get_exports(\u0026source_module_id) {\n                if let Some(exported_sym) = source_exports.get_named(local_name) {\n                    exports.add_named(export_name.to_string(), exported_sym.clone());\n                }\n            }\n        }\n    }\n}\n\n/// Process an import statement and register imported symbols.\n///\n/// This function handles all import clause types:\n/// - Default imports: `import foo from './module'`\n/// - Named imports: `import { foo, bar } from './module'`\n/// - Type-only imports: `import type { Foo } from './module'`\n/// - Namespace imports: `import * as foo from './module'`\n/// - Mixed imports: `import foo, { bar } from './module'`\n///\n/// For type-only imports, symbols are registered in both the symbol table and type environment,\n/// and if the imported type is an interface/object, its members are registered in access control.\n///\n/// # Parameters\n///\n/// - `import`: The import declaration AST node\n/// - `symbol_table`: Mutable symbol table for declaring imported symbols\n/// - `type_env`: Mutable type environment for type-only imports\n/// - `access_control`: Mutable access control for interface/object member registration\n/// - `interner`: String interner for resolving names\n/// - `module_dependencies`: Vector to track import dependencies\n/// - `module_registry`, `module_resolver`, `current_module_id`: Optional module resolution components\n/// - `diagnostic_handler`: For reporting import resolution errors\n#[allow(clippy::too_many_arguments)]\npub fn check_import_statement(\n    import: \u0026ImportDeclaration,\n    symbol_table: \u0026mut SymbolTable,\n    type_env: \u0026mut TypeEnvironment,\n    access_control: \u0026mut AccessControl,\n    interner: \u0026StringInterner,\n    module_dependencies: \u0026mut Vec\u003cPathBuf\u003e,\n    module_registry: Option\u003c\u0026Arc\u003cModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026Arc\u003cModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026ModuleId\u003e,\n    diagnostic_handler: \u0026Arc\u003cdyn DiagnosticHandler\u003e,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    match \u0026import.clause {\n        ImportClause::Default(name) =\u003e {\n            let name_str = interner.resolve(name.node);\n            let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), import.span);\n            let symbol = Symbol::new(\n                name_str.to_string(),\n                SymbolKind::Variable,\n                any_type,\n                import.span,\n            );\n            symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, import.span))?;\n        }\n        ImportClause::Named(specifiers) =\u003e {\n            for spec in specifiers {\n                let name_str = interner.resolve(spec.imported.node);\n                let import_type = resolve_import_type(\n                    \u0026import.source,\n                    \u0026name_str,\n                    import.span,\n                    module_dependencies,\n                    module_registry,\n                    module_resolver,\n                    current_module_id,\n                    diagnostic_handler,\n                )?;\n\n                let symbol = Symbol::new(\n                    name_str.to_string(),\n                    SymbolKind::Variable,\n                    import_type,\n                    spec.span,\n                );\n                symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n            }\n        }\n        ImportClause::TypeOnly(specifiers) =\u003e {\n            for spec in specifiers {\n                let name_str = interner.resolve(spec.imported.node);\n                let import_type = resolve_import_type(\n                    \u0026import.source,\n                    \u0026name_str,\n                    import.span,\n                    module_dependencies,\n                    module_registry,\n                    module_resolver,\n                    current_module_id,\n                    diagnostic_handler,\n                )?;\n\n                // Register in symbol table\n                let symbol = Symbol::new(\n                    name_str.to_string(),\n                    SymbolKind::TypeAlias,\n                    import_type.clone(),\n                    spec.span,\n                );\n                symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n\n                // Also register in type_env\n                type_env\n                    .register_type_alias(name_str.to_string(), import_type.clone())\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n\n                // Register in access control if it's an object type\n                if let TypeKind::Object(obj_type) = \u0026import_type.kind {\n                    access_control.register_class(\u0026name_str, None);\n                    for member in \u0026obj_type.members {\n                        let member_info = match member {\n                            ObjectTypeMember::Property(prop) =\u003e ClassMemberInfo {\n                                name: interner.resolve(prop.name.node).to_string(),\n                                access: AccessModifier::Public,\n                                _is_static: false,\n                                kind: ClassMemberKind::Property {\n                                    type_annotation: prop.type_annotation.clone(),\n                                },\n                                is_final: prop.is_readonly,\n                            },\n                            ObjectTypeMember::Method(method) =\u003e ClassMemberInfo {\n                                name: interner.resolve(method.name.node).to_string(),\n                                access: AccessModifier::Public,\n                                _is_static: false,\n                                kind: ClassMemberKind::Method {\n                                    parameters: method.parameters.clone(),\n                                    return_type: Some(method.return_type.clone()),\n                                    is_abstract: false,\n                                },\n                                is_final: false,\n                            },\n                            ObjectTypeMember::Index(_) =\u003e continue,\n                        };\n                        access_control.register_member(\u0026name_str, member_info);\n                    }\n                }\n            }\n        }\n        ImportClause::Namespace(name) =\u003e {\n            let name_str = interner.resolve(name.node);\n            let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), import.span);\n            let symbol = Symbol::new(\n                name_str.to_string(),\n                SymbolKind::Variable,\n                any_type,\n                import.span,\n            );\n            symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, import.span))?;\n        }\n        ImportClause::Mixed { default, named } =\u003e {\n            // Handle default import\n            let default_name_str = interner.resolve(default.node);\n            let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), import.span);\n            let default_symbol = Symbol::new(\n                default_name_str.to_string(),\n                SymbolKind::Variable,\n                any_type,\n                default.span,\n            );\n            symbol_table\n                .declare(default_symbol)\n                .map_err(|e| TypeCheckError::new(e, default.span))?;\n\n            // Handle named imports\n            for spec in named {\n                let name_str = interner.resolve(spec.imported.node);\n                let import_type = resolve_import_type(\n                    \u0026import.source,\n                    \u0026name_str,\n                    import.span,\n                    module_dependencies,\n                    module_registry,\n                    module_resolver,\n                    current_module_id,\n                    diagnostic_handler,\n                )?;\n\n                let symbol = Symbol::new(\n                    name_str.to_string(),\n                    SymbolKind::Variable,\n                    import_type,\n                    spec.span,\n                );\n                symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Resolve the type of an imported symbol from a source module.\n///\n/// This function attempts to resolve the type of a symbol being imported from another module.\n/// If module resolution is configured and the source module is found, it looks up the symbol\n/// in the module's exports and returns its type. If resolution fails, it reports an error\n/// via the diagnostic handler and returns an Unknown type as a fallback.\n///\n/// Module dependencies are tracked by adding the resolved source module path to the dependencies vector.\n#[allow(clippy::too_many_arguments)]\nfn resolve_import_type(\n    source: \u0026str,\n    symbol_name: \u0026str,\n    span: Span,\n    module_dependencies: \u0026mut Vec\u003cPathBuf\u003e,\n    module_registry: Option\u003c\u0026Arc\u003cModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026Arc\u003cModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026ModuleId\u003e,\n    diagnostic_handler: \u0026Arc\u003cdyn DiagnosticHandler\u003e,\n) -\u003e Result\u003cType, TypeCheckError\u003e {\n    if let (Some(registry), Some(resolver), Some(current_id)) =\n        (module_registry, module_resolver, current_module_id)\n    {\n        match resolver.resolve(source, current_id.path()) {\n            Ok(source_module_id) =\u003e {\n                // Track dependency\n                module_dependencies.push(source_module_id.path().to_path_buf());\n\n                match registry.get_exports(\u0026source_module_id) {\n                    Ok(source_exports) =\u003e {\n                        if let Some(exported_sym) = source_exports.get_named(symbol_name) {\n                            return Ok(exported_sym.symbol.typ.clone());\n                        }\n                    }\n                    Err(_) =\u003e {\n                        // Module exists but exports not available yet\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                diagnostic_handler.error(\n                    span,\n                    \u0026format!(\"Failed to resolve module '{}': {}\", source, e),\n                );\n            }\n        }\n    } else {\n        diagnostic_handler.error(\n            span,\n            \u0026format!(\n                \"Module '{}' not found (module resolution not configured)\",\n                source\n            ),\n        );\n    }\n\n    // Fallback: return Unknown type\n    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::diagnostics::CollectingDiagnosticHandler;\n    use std::sync::Arc;\n\n    #[test]\n    fn test_extract_exports_empty() {\n        let program = typedlua_parser::ast::Program {\n            statements: Vec::new(),\n            span: Span::new(0, 0, 0, 0),\n        };\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let result = extract_exports(\u0026program, \u0026symbol_table, \u0026interner, None, None, None);\n        assert!(result.named.is_empty());\n        assert!(result.default.is_none());\n    }\n\n    #[test]\n    fn test_extract_exports_with_variable() {\n        let span = Span::new(0, 10, 0, 10);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n\n        let name_id = interner.intern(\"myVar\");\n        let symbol = crate::utils::symbol_table::Symbol::new(\n            \"myVar\".to_string(),\n            crate::utils::symbol_table::SymbolKind::Variable,\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n            span,\n        );\n        symbol_table.declare(symbol).unwrap();\n\n        let program = typedlua_parser::ast::Program {\n            statements: Vec::new(),\n            span,\n        };\n\n        let result = extract_exports(\u0026program, \u0026symbol_table, \u0026interner, None, None, None);\n        assert!(result.named.is_empty());\n    }\n\n    #[test]\n    fn test_check_import_statement_default() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let mut type_env = crate::core::type_environment::TypeEnvironment::new();\n        let mut access_control = crate::visitors::AccessControl::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let name_id = interner.intern(\"MyModule\");\n        let import = typedlua_parser::ast::statement::ImportDeclaration {\n            clause: typedlua_parser::ast::statement::ImportClause::Default(\n                typedlua_parser::ast::Spanned::new(name_id, span),\n            ),\n            source: \"./my_module.lua\".to_string(),\n            span,\n        };\n\n        let result = check_import_statement(\n            \u0026import,\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut access_control,\n            \u0026interner,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_resolve_import_type_no_resolver() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let result = resolve_import_type(\n            \"./unknown.lua\",\n            \"SomeType\",\n            span,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        // Should return Unknown type when no resolver configured\n        assert!(result.is_ok());\n        let resolved_type = result.unwrap();\n        assert!(matches!(\n            resolved_type.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_check_import_statement_named() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let mut type_env = crate::core::type_environment::TypeEnvironment::new();\n        let mut access_control = crate::visitors::AccessControl::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let import = typedlua_parser::ast::statement::ImportDeclaration {\n            clause: typedlua_parser::ast::statement::ImportClause::Named(vec![\n                typedlua_parser::ast::statement::ImportSpecifier {\n                    imported: typedlua_parser::ast::Spanned::new(interner.intern(\"foo\"), span),\n                    local: Some(typedlua_parser::ast::Spanned::new(\n                        interner.intern(\"foo\"),\n                        span,\n                    )),\n                    span,\n                },\n            ]),\n            source: \"./my_module.lua\".to_string(),\n            span,\n        };\n\n        let result = check_import_statement(\n            \u0026import,\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut access_control,\n            \u0026interner,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_import_statement_namespace() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let mut type_env = crate::core::type_environment::TypeEnvironment::new();\n        let mut access_control = crate::visitors::AccessControl::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let import = typedlua_parser::ast::statement::ImportDeclaration {\n            clause: typedlua_parser::ast::statement::ImportClause::Namespace(\n                typedlua_parser::ast::Spanned::new(interner.intern(\"mylib\"), span),\n            ),\n            source: \"./my_module.lua\".to_string(),\n            span,\n        };\n\n        let result = check_import_statement(\n            \u0026import,\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut access_control,\n            \u0026interner,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_extract_declaration_export_function() {\n        let span = Span::new(0, 10, 0, 10);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n\n        let func_name_id = interner.intern(\"myFunc\");\n        let symbol = crate::utils::symbol_table::Symbol::new(\n            \"myFunc\".to_string(),\n            crate::utils::symbol_table::SymbolKind::Function,\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n            span,\n        );\n        symbol_table.declare(symbol).unwrap();\n\n        let program = typedlua_parser::ast::Program {\n            statements: Vec::new(),\n            span,\n        };\n\n        let result = extract_exports(\u0026program, \u0026symbol_table, \u0026interner, None, None, None);\n        assert!(result.named.is_empty());\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":4}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":6}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":6}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":434,"address":[],"length":0,"stats":{"Line":2}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":4}}],"covered":53,"coverable":187},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","validation_phase.rs"],"content":"//! Validation phase: Type compatibility and validation checks\n//!\n//! This phase handles:\n//! - Interface member validation (duplicate checking)\n//! - Index signature validation\n//! - Abstract method implementation verification\n//! - Method override validation (parameter/return type compatibility)\n//! - Decorator validation\n//!\n//! **Design Pattern**: Stateless phase functions that take explicit context parameters.\n\n#![allow(dead_code)]\n\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_compat::TypeCompatibility;\nuse crate::types::generics;\nuse crate::utils::symbol_table::SymbolTable;\nuse crate::visitors::{AccessControl, AccessControlVisitor, ClassMemberKind};\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse typedlua_parser::ast::expression::Expression;\nuse typedlua_parser::ast::statement::{\n    ClassMember, Decorator, DecoratorExpression, IndexSignature, MethodDeclaration, TypeParameter,\n};\nuse typedlua_parser::ast::types::{ObjectTypeMember, Type};\nuse typedlua_parser::prelude::ClassDeclaration;\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Validate interface members for duplicate property names.\n///\n/// Interfaces cannot have duplicate property or method names.\n/// This function checks all members and returns an error if duplicates are found.\n///\n/// # Parameters\n///\n/// - `members`: The interface members to validate\n/// - `span`: Source span for error reporting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if validation passes, or an error if duplicates are found.\npub fn validate_interface_members(\n    members: \u0026[ObjectTypeMember],\n    span: Span,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Check for duplicate property names\n    let mut seen_names = HashSet::new();\n\n    for member in members {\n        let name = match member {\n            ObjectTypeMember::Property(prop) =\u003e Some(\u0026prop.name.node),\n            ObjectTypeMember::Method(method) =\u003e Some(\u0026method.name.node),\n            ObjectTypeMember::Index(_) =\u003e None,\n        };\n\n        if let Some(name) = name {\n            if !seen_names.insert(*name) {\n                return Err(TypeCheckError::new(\n                    format!(\"Duplicate property '{}' in interface\", name),\n                    span,\n                ));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Validate that class properties conform to index signature constraints.\n///\n/// When a class has an index signature, all properties must have types that are\n/// assignable to the index signature's value type.\n///\n/// # Parameters\n///\n/// - `class_decl`: The class declaration to validate\n/// - `index_sig`: The index signature to check against\n/// - `interner`: String interner for resolving property names\n///\n/// # Returns\n///\n/// Returns `Ok(())` if validation passes, or an error if any property violates the constraint.\npub fn validate_index_signature(\n    class_decl: \u0026ClassDeclaration,\n    index_sig: \u0026IndexSignature,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    for member in \u0026class_decl.members {\n        if let ClassMember::Property(prop) = member {\n            // Check if property type is assignable to index signature value type\n            if !TypeCompatibility::is_assignable(\u0026prop.type_annotation, \u0026index_sig.value_type) {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Property '{}' is not assignable to index signature value type\",\n                        interner.resolve(prop.name.node)\n                    ),\n                    prop.span,\n                ));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check that a class implements all abstract methods from its parent class.\n///\n/// When a class extends a parent class with abstract methods, it must provide\n/// concrete implementations for all abstract methods. This function walks the\n/// inheritance chain to verify all abstract methods are implemented.\n///\n/// # Parameters\n///\n/// - `class_name`: The name of the class being validated\n/// - `parent_name`: The name of the parent class\n/// - `class_members`: The members of the child class\n/// - `access_control`: Access control visitor for checking parent members\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok(())` if all abstract methods are implemented, or an error otherwise.\npub fn check_abstract_methods_implemented(\n    class_name: \u0026str,\n    parent_name: \u0026str,\n    class_members: \u0026[ClassMember],\n    access_control: \u0026AccessControl,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Get the parent class members\n    if let Some(parent_members) = access_control.get_class_members(parent_name) {\n        for member in parent_members {\n            if let ClassMemberKind::Method {\n                is_abstract: true, ..\n            } = \u0026member.kind\n            {\n                // Check if this class implements the abstract method\n                let method_name = \u0026member.name;\n                let implemented = class_members.iter().any(|m| {\n                    if let ClassMember::Method(method) = m {\n                        method.name.node.as_u32() == interner.get_or_intern(method_name).as_u32()\n                    } else {\n                        false\n                    }\n                });\n\n                if !implemented {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Class '{}' must implement abstract method '{}' from parent class '{}'\",\n                            class_name, method_name, parent_name\n                        ),\n                        Span::dummy(),\n                    ));\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Validate decorators on a declaration.\n///\n/// This function checks:\n/// - Decorators are enabled in configuration\n/// - No duplicate decorators\n/// - Decorator expressions are valid\n///\n/// # Parameters\n///\n/// - `decorators`: The decorators to validate\n/// - `enable_decorators`: Whether decorators are enabled in configuration\n/// - `interner`: String interner for name resolution\n/// - `symbol_table`: Symbol table for checking decorator existence\n/// - `diagnostic_handler`: For reporting warnings\n/// - `infer_expression_type`: Callback to infer decorator argument types\n///\n/// # Returns\n///\n/// Returns `Ok(())` if validation passes, or an error if decorators are disabled\n/// or expressions are invalid.\npub fn check_decorators\u003cF\u003e(\n    decorators: \u0026mut [Decorator],\n    enable_decorators: bool,\n    interner: \u0026StringInterner,\n    symbol_table: \u0026SymbolTable,\n    diagnostic_handler: \u0026Arc\u003cdyn DiagnosticHandler\u003e,\n    mut infer_expression_type: F,\n) -\u003e Result\u003c(), TypeCheckError\u003e\nwhere\n    F: FnMut(\u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e,\n{\n    // Check if decorators are enabled\n    if !decorators.is_empty() \u0026\u0026 !enable_decorators {\n        return Err(TypeCheckError::new(\n            \"Decorators require decorator features to be enabled. Enable 'enableDecorators' in your configuration.\".to_string(),\n            decorators[0].span,\n        ));\n    }\n\n    // Check for duplicate decorators\n    let mut seen_decorators = HashSet::new();\n    for decorator in decorators.iter() {\n        // Get decorator name for comparison\n        let decorator_name = match \u0026decorator.expression {\n            DecoratorExpression::Identifier(name) =\u003e interner.resolve(name.node).to_string(),\n            DecoratorExpression::Call { callee, .. } =\u003e {\n                // For calls, use the callee name\n                if let DecoratorExpression::Identifier(name) = \u0026**callee {\n                    interner.resolve(name.node).to_string()\n                } else {\n                    continue; // Skip complex expressions\n                }\n            }\n            DecoratorExpression::Member { .. } =\u003e {\n                continue; // Skip member expressions for duplicate checking\n            }\n        };\n\n        if !seen_decorators.insert(decorator_name.clone()) {\n            diagnostic_handler.warning(\n                decorator.span,\n                \u0026format!(\"Duplicate decorator '@{}'\", decorator_name),\n            );\n        }\n    }\n\n    // Validate decorator expressions\n    for decorator in decorators.iter_mut() {\n        check_decorator_expression(\n            \u0026mut decorator.expression,\n            interner,\n            symbol_table,\n            \u0026mut infer_expression_type,\n        )?;\n    }\n\n    Ok(())\n}\n\n/// Check a decorator expression.\n///\n/// Validates that decorator identifiers, calls, and member expressions are well-formed.\n/// For decorator calls, type-checks all arguments.\n///\n/// # Parameters\n///\n/// - `expr`: The decorator expression to check\n/// - `interner`: String interner for name resolution\n/// - `symbol_table`: Symbol table for checking identifier existence\n/// - `infer_expression_type`: Callback to infer argument types\nfn check_decorator_expression\u003cF\u003e(\n    expr: \u0026mut DecoratorExpression,\n    interner: \u0026StringInterner,\n    symbol_table: \u0026SymbolTable,\n    infer_expression_type: \u0026mut F,\n) -\u003e Result\u003c(), TypeCheckError\u003e\nwhere\n    F: FnMut(\u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e,\n{\n    match expr {\n        DecoratorExpression::Identifier(name) =\u003e {\n            // Verify the decorator identifier exists (could be a function or imported decorator)\n            // For now, we allow any identifier - full validation would check it's a valid decorator function\n            let name_str = interner.resolve(name.node);\n            if symbol_table.lookup(\u0026name_str).is_none() {\n                // It's okay if it doesn't exist - it might be a built-in decorator like @readonly, @sealed\n                // We'll allow it through for now\n            }\n            Ok(())\n        }\n        DecoratorExpression::Call {\n            callee, arguments, ..\n        } =\u003e {\n            // Check the callee\n            check_decorator_expression(callee, interner, symbol_table, infer_expression_type)?;\n\n            // Type check all arguments\n            for arg in arguments.iter_mut() {\n                infer_expression_type(arg)?;\n            }\n\n            Ok(())\n        }\n        DecoratorExpression::Member { object, .. } =\u003e {\n            // Check the object part\n            check_decorator_expression(object, interner, symbol_table, infer_expression_type)?;\n            Ok(())\n        }\n    }\n}\n\n/// Check method override compatibility.\n///\n/// When a method is marked with the `override` keyword, this function validates:\n/// - The class has a parent class\n/// - The parent class has a method with the same name\n/// - The parent method is not marked `final`\n/// - Parameter types are compatible (contravariant)\n/// - Return types are compatible (covariant)\n/// - Generic parent types are properly instantiated\n///\n/// # Parameters\n///\n/// - `method`: The method declaration to check\n/// - `class_name`: Name of the class containing the method\n/// - `parent_name`: Name of the parent class\n/// - `parent_type_params`: Type parameters of the parent class (if generic)\n/// - `extends_type_args`: Type arguments in the extends clause\n/// - `access_control`: Access control visitor for checking parent members\n/// - `interner`: String interner for name resolution\n/// - `deep_resolve_type`: Callback to resolve type aliases\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the override is valid, or an error if validation fails.\n#[allow(clippy::too_many_arguments)]\npub fn check_method_override\u003cF\u003e(\n    method: \u0026MethodDeclaration,\n    class_name: \u0026str,\n    parent_name: Option\u003c\u0026String\u003e,\n    parent_type_params: Option\u003c\u0026Vec\u003cTypeParameter\u003e\u003e,\n    extends_type_args: Option\u003c\u0026Vec\u003cType\u003e\u003e,\n    access_control: \u0026AccessControl,\n    interner: \u0026StringInterner,\n    mut deep_resolve_type: F,\n) -\u003e Result\u003c(), TypeCheckError\u003e\nwhere\n    F: FnMut(\u0026Type) -\u003e Type,\n{\n    // Check if class has a parent\n    let parent_name = parent_name.ok_or_else(|| {\n        TypeCheckError::new(\n            format!(\n                \"Method '{}' uses override but class '{}' has no parent class\",\n                method.name.node, class_name\n            ),\n            method.span,\n        )\n    })?;\n\n    // Walk the inheritance chain to find the method and check if it's final\n    let method_name = interner.resolve(method.name.node);\n    let mut current_class = parent_name.clone();\n    let mut found_method = None;\n    let mut found_in_class = None;\n\n    loop {\n        if let Some(parent_members) = access_control.get_class_members(\u0026current_class) {\n            if let Some(parent_method) = parent_members.iter().find(|m| m.name == method_name) {\n                found_method = Some(parent_method);\n                found_in_class = Some(current_class.clone());\n                break;\n            }\n        }\n\n        // Get parent from access_control's hierarchy\n        let parent_name_opt = access_control.get_parent_class(\u0026current_class);\n        match parent_name_opt {\n            Some(next_parent) =\u003e current_class = next_parent,\n            None =\u003e break,\n        }\n    }\n\n    let parent_method = found_method.ok_or_else(|| {\n        TypeCheckError::new(\n            format!(\n                \"Method '{}' marked as override but parent class does not have this method\",\n                method_name\n            ),\n            method.span,\n        )\n    })?;\n\n    // Check if parent method is final anywhere in the inheritance chain\n    if parent_method.is_final {\n        return Err(TypeCheckError::new(\n            format!(\n                \"Cannot override final method {} from ancestor class {}\",\n                method.name.node,\n                found_in_class.unwrap()\n            ),\n            method.span,\n        ));\n    }\n\n    match \u0026parent_method.kind {\n        ClassMemberKind::Method {\n            parameters: parent_params,\n            return_type: parent_return,\n            ..\n        } =\u003e {\n            // Check parameter count\n            if method.parameters.len() != parent_params.len() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Method '{}' has {} parameters but overridden method has {} parameters\",\n                        method.name.node,\n                        method.parameters.len(),\n                        parent_params.len()\n                    ),\n                    method.span,\n                ));\n            }\n\n            // Check parameter types (contravariance)\n            for (i, (child_param, parent_param)) in method\n                .parameters\n                .iter()\n                .zip(parent_params.iter())\n                .enumerate()\n            {\n                let child_type = child_param.type_annotation.as_ref().ok_or_else(|| {\n                    TypeCheckError::new(\n                        format!(\n                            \"Override method '{}' parameter {} must have explicit type annotation\",\n                            method.name.node,\n                            i + 1\n                        ),\n                        child_param.span,\n                    )\n                })?;\n\n                let raw_parent_type = parent_param.type_annotation.as_ref().ok_or_else(|| {\n                    TypeCheckError::new(\n                        format!(\n                            \"Parent method '{}' parameter {} has no type annotation\",\n                            method.name.node,\n                            i + 1\n                        ),\n                        parent_param.span,\n                    )\n                })?;\n\n                // Instantiate parent type if the parent class is generic\n                let parent_type = if let (Some(type_params), Some(type_args)) =\n                    (parent_type_params, extends_type_args)\n                {\n                    generics::instantiate_type(raw_parent_type, type_params, type_args)\n                        .unwrap_or_else(|_| raw_parent_type.clone())\n                } else {\n                    raw_parent_type.clone()\n                };\n\n                // Deep-resolve both types for comparison\n                let resolved_child = deep_resolve_type(child_type);\n                let resolved_parent = deep_resolve_type(\u0026parent_type);\n\n                // Parameters are contravariant: parent type must be assignable to child type\n                // (child can accept a more specific type than parent)\n                if !TypeCompatibility::is_assignable(\u0026resolved_parent, \u0026resolved_child) {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Method '{}' parameter {} type is incompatible with parent parameter type\",\n                            method.name.node,\n                            i + 1\n                        ),\n                        child_param.span,\n                    ));\n                }\n            }\n\n            // Check return type (covariance)\n            if let Some(child_return) = \u0026method.return_type {\n                if let Some(raw_parent_ret) = parent_return {\n                    // Instantiate parent return type if generic\n                    let parent_ret = if let (Some(type_params), Some(type_args)) =\n                        (parent_type_params, extends_type_args)\n                    {\n                        generics::instantiate_type(raw_parent_ret, type_params, type_args)\n                            .unwrap_or_else(|_| raw_parent_ret.clone())\n                    } else {\n                        raw_parent_ret.clone()\n                    };\n\n                    let resolved_child_ret = deep_resolve_type(child_return);\n                    let resolved_parent_ret = deep_resolve_type(\u0026parent_ret);\n\n                    // Child return type must be assignable to parent return type\n                    if !TypeCompatibility::is_assignable(\u0026resolved_parent_ret, \u0026resolved_child_ret)\n                    {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Method '{}' return type is incompatible with parent return type\",\n                                method.name.node\n                            ),\n                            method.span,\n                        ));\n                    }\n                }\n            } else if parent_return.is_some() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Method '{}' must have return type to match parent method\",\n                        method.name.node\n                    ),\n                    method.span,\n                ));\n            }\n\n            Ok(())\n        }\n        _ =\u003e Err(TypeCheckError::new(\n            format!(\n                \"Cannot override '{}' - parent member is not a method\",\n                method.name.node\n            ),\n            method.span,\n        )),\n    }\n}\n\n/// Check if a class has circular inheritance.\n///\n/// Detects inheritance cycles like: A extends B, B extends C, C extends A.\n///\n/// # Parameters\n///\n/// - `class_name`: The class name to check for circular inheritance\n/// - `class_parents`: Map from class name to parent class name\n///\n/// # Returns\n///\n/// Returns `true` if a circular inheritance is detected, `false` otherwise.\npub fn has_circular_inheritance(\n    class_name: \u0026str,\n    class_parents: \u0026FxHashMap\u003cString, String\u003e,\n) -\u003e bool {\n    let mut visited = std::collections::HashSet::new();\n    let mut current = class_name.to_string();\n\n    visited.insert(current.clone());\n\n    while let Some(parent) = class_parents.get(\u0026current) {\n        if visited.contains(parent) {\n            return true; // Found a cycle\n        }\n        visited.insert(parent.clone());\n        current = parent.clone();\n    }\n\n    false\n}\n\n/// Check that a class properly implements an interface.\n///\n/// Validates that:\n/// - All required interface properties are present in the class\n/// - All required interface methods are implemented with compatible signatures\n/// - Index signatures are properly implemented\n///\n/// # Parameters\n///\n/// - `class_decl`: The class declaration to validate\n/// - `interface`: The interface type that the class claims to implement\n/// - `type_env`: Type environment for checking class implements relationships\n/// - `interner`: String interner for resolving names in error messages\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the class properly implements the interface, or an error if validation fails.\npub fn check_class_implements_interface(\n    class_decl: \u0026ClassDeclaration,\n    interface: \u0026Type,\n    type_env: \u0026crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    use typedlua_parser::ast::statement::ClassMember;\n    use typedlua_parser::ast::types::{ObjectTypeMember, TypeKind};\n\n    if let TypeKind::Object(obj_type) = \u0026interface.kind {\n        for required_member in \u0026obj_type.members {\n            match required_member {\n                ObjectTypeMember::Property(req_prop) =\u003e {\n                    // Find matching property in class\n                    let found = class_decl.members.iter().any(|member| {\n                        if let ClassMember::Property(class_prop) = member {\n                            class_prop.name.node == req_prop.name.node\n                        } else {\n                            false\n                        }\n                    });\n\n                    if !found \u0026\u0026 !req_prop.is_optional {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Class '{}' does not implement required property '{}' from interface\",\n                                interner.resolve(class_decl.name.node),\n                                interner.resolve(req_prop.name.node)\n                            ),\n                            class_decl.span,\n                        ));\n                    }\n                }\n                ObjectTypeMember::Method(req_method) =\u003e {\n                    // Find matching method in class and validate signature\n                    let matching_method = class_decl.members.iter().find_map(|member| {\n                        if let ClassMember::Method(class_method) = member {\n                            if class_method.name.node == req_method.name.node {\n                                return Some(class_method);\n                            }\n                        }\n                        None\n                    });\n\n                    match matching_method {\n                        None =\u003e {\n                            if req_method.body.is_none() {\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Class '{}' does not implement required method '{}' from interface\",\n                                        interner.resolve(class_decl.name.node),\n                                        interner.resolve(req_method.name.node)\n                                    ),\n                                    class_decl.span,\n                                ));\n                            }\n                            // Method has default implementation in interface, okay\n                        }\n                        Some(class_method) =\u003e {\n                            // Check parameter count\n                            if class_method.parameters.len() != req_method.parameters.len() {\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Method '{}' has {} parameters but interface requires {}\",\n                                        interner.resolve(req_method.name.node),\n                                        class_method.parameters.len(),\n                                        req_method.parameters.len()\n                                    ),\n                                    class_method.span,\n                                ));\n                            }\n\n                            // Check parameter types\n                            for (i, (class_param, req_param)) in class_method\n                                .parameters\n                                .iter()\n                                .zip(req_method.parameters.iter())\n                                .enumerate()\n                            {\n                                if let (Some(class_type), Some(req_type)) =\n                                    (\u0026class_param.type_annotation, \u0026req_param.type_annotation)\n                                {\n                                    if !TypeCompatibility::is_assignable(class_type, req_type) {\n                                        return Err(TypeCheckError::new(\n                                            format!(\n                                                \"Method '{}' parameter {} has incompatible type\",\n                                                interner.resolve(req_method.name.node),\n                                                i\n                                            ),\n                                            class_method.span,\n                                        ));\n                                    }\n                                }\n                            }\n\n                            // Check return type (covariant: class return must be assignable to interface return)\n                            // MethodSignature has return_type: Type (not Option)\n                            // MethodDeclaration has return_type: Option\u003cType\u003e\n                            if let Some(class_return) = \u0026class_method.return_type {\n                                if !TypeCompatibility::is_assignable(\n                                    class_return,\n                                    \u0026req_method.return_type,\n                                ) \u0026\u0026 !check_implements_assignable(\n                                    class_return,\n                                    \u0026req_method.return_type,\n                                    type_env,\n                                    interner,\n                                ) {\n                                    return Err(TypeCheckError::new(\n                                        format!(\n                                            \"Method '{}' has incompatible return type\",\n                                            interner.resolve(req_method.name.node)\n                                        ),\n                                        class_method.span,\n                                    ));\n                                }\n                            } else {\n                                // Method has no return type annotation, but interface requires one\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Method '{}' must have a return type annotation to match interface\",\n                                        interner.resolve(req_method.name.node)\n                                    ),\n                                    class_method.span,\n                                ));\n                            }\n                        }\n                    }\n                }\n                ObjectTypeMember::Index(index_sig) =\u003e {\n                    // Validate that all class properties are compatible with index signature\n                    validate_index_signature(class_decl, index_sig, interner)?;\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if source type is assignable to target type via implements relationship.\n///\n/// This handles covariance in interface implementation. For example, Box\u003cnumber\u003e is\n/// assignable to Storable\u003cnumber\u003e if Box implements Storable\u003cT\u003e.\n///\n/// # Parameters\n///\n/// - `source`: The source type to check\n/// - `target`: The target type to check against\n/// - `type_env`: Type environment for looking up class implements relationships\n/// - `interner`: String interner for resolving type names\n///\n/// # Returns\n///\n/// Returns `true` if source type implements target interface, `false` otherwise.\npub fn check_implements_assignable(\n    source: \u0026Type,\n    target: \u0026Type,\n    type_env: \u0026crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e bool {\n    use typedlua_parser::ast::types::TypeKind;\n\n    if let (TypeKind::Reference(s_ref), TypeKind::Reference(t_ref)) = (\u0026source.kind, \u0026target.kind) {\n        let source_name = interner.resolve(s_ref.name.node);\n        let target_name = interner.resolve(t_ref.name.node);\n\n        // Check if source class implements the target interface\n        if let Some(implements) = type_env.get_class_implements(\u0026source_name) {\n            for iface_type in implements {\n                if let TypeKind::Reference(iface_ref) = \u0026iface_type.kind {\n                    let iface_name = interner.resolve(iface_ref.name.node);\n                    if iface_name == target_name {\n                        // Interface name matches. For generic interfaces, check type arg\n                        // compatibility. The common case is pass-through type params:\n                        // class Box\u003cT\u003e implements Storable\u003cT\u003e means Box\u003cnumber\u003e -\u003e Storable\u003cnumber\u003e\n                        match (\u0026s_ref.type_arguments, \u0026t_ref.type_arguments) {\n                            (None, None) =\u003e return true,\n                            (Some(s_args), Some(t_args)) if s_args.len() == t_args.len() =\u003e {\n                                if s_args\n                                    .iter()\n                                    .zip(t_args.iter())\n                                    .all(|(s, t)| TypeCompatibility::is_assignable(s, t))\n                                {\n                                    return true;\n                                }\n                            }\n                            _ =\u003e {\n                                // Arity mismatch or partial generics - still allow if names match\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    false\n}\n\n/// Validate class inheritance - checks for final parent and circular inheritance.\n///\n/// This focused function validates that a class's inheritance is valid:\n/// - Parent class is not marked as final\n/// - No circular inheritance exists\n///\n/// # Returns\n///\n/// Returns Ok(parent_name) if inheritance is valid, or an error if validation fails.\npub fn validate_class_inheritance(\n    class_name: \u0026str,\n    extends_type: \u0026typedlua_parser::ast::types::Type,\n    access_control: \u0026crate::visitors::AccessControl,\n    class_parents: \u0026mut rustc_hash::FxHashMap\u003cString, String\u003e,\n    interner: \u0026typedlua_parser::string_interner::StringInterner,\n    span: typedlua_parser::span::Span,\n) -\u003e Result\u003cString, crate::TypeCheckError\u003e {\n    use typedlua_parser::ast::types::TypeKind;\n\n    if let TypeKind::Reference(type_ref) = \u0026extends_type.kind {\n        let parent_name = interner.resolve(type_ref.name.node).to_string();\n\n        // Check if parent class is final\n        if access_control.is_class_final(\u0026parent_name) {\n            return Err(crate::TypeCheckError::new(\n                format!(\"Cannot extend final class {}\", parent_name),\n                span,\n            ));\n        }\n\n        // Check for circular inheritance\n        class_parents.insert(class_name.to_string(), parent_name.clone());\n        if has_circular_inheritance(class_name, class_parents) {\n            return Err(crate::TypeCheckError::new(\n                format!(\n                    \"Circular inheritance detected: class '{}' inherits from itself through the inheritance chain\",\n                    class_name\n                ),\n                span,\n            ));\n        }\n\n        Ok(parent_name)\n    } else {\n        Err(crate::TypeCheckError::new(\n            \"Class can only extend another class (type reference)\",\n            span,\n        ))\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":35}},{"line":50,"address":[],"length":0,"stats":{"Line":70}},{"line":52,"address":[],"length":0,"stats":{"Line":315}},{"line":53,"address":[],"length":0,"stats":{"Line":280}},{"line":54,"address":[],"length":0,"stats":{"Line":226}},{"line":55,"address":[],"length":0,"stats":{"Line":52}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":279}},{"line":60,"address":[],"length":0,"stats":{"Line":278}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":35}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":7}},{"line":134,"address":[],"length":0,"stats":{"Line":21}},{"line":135,"address":[],"length":0,"stats":{"Line":21}},{"line":138,"address":[],"length":0,"stats":{"Line":7}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":11}},{"line":143,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":7}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":7}},{"line":533,"address":[],"length":0,"stats":{"Line":14}},{"line":534,"address":[],"length":0,"stats":{"Line":21}},{"line":536,"address":[],"length":0,"stats":{"Line":28}},{"line":538,"address":[],"length":0,"stats":{"Line":38}},{"line":539,"address":[],"length":0,"stats":{"Line":24}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":32}},{"line":543,"address":[],"length":0,"stats":{"Line":24}},{"line":546,"address":[],"length":0,"stats":{"Line":7}},{"line":566,"address":[],"length":0,"stats":{"Line":4}},{"line":575,"address":[],"length":0,"stats":{"Line":8}},{"line":576,"address":[],"length":0,"stats":{"Line":11}},{"line":577,"address":[],"length":0,"stats":{"Line":4}},{"line":578,"address":[],"length":0,"stats":{"Line":1}},{"line":580,"address":[],"length":0,"stats":{"Line":4}},{"line":581,"address":[],"length":0,"stats":{"Line":2}},{"line":582,"address":[],"length":0,"stats":{"Line":1}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":1}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":3}},{"line":601,"address":[],"length":0,"stats":{"Line":11}},{"line":602,"address":[],"length":0,"stats":{"Line":4}},{"line":603,"address":[],"length":0,"stats":{"Line":2}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":3}},{"line":612,"address":[],"length":0,"stats":{"Line":2}},{"line":613,"address":[],"length":0,"stats":{"Line":2}},{"line":614,"address":[],"length":0,"stats":{"Line":2}},{"line":615,"address":[],"length":0,"stats":{"Line":2}},{"line":616,"address":[],"length":0,"stats":{"Line":4}},{"line":617,"address":[],"length":0,"stats":{"Line":3}},{"line":619,"address":[],"length":0,"stats":{"Line":1}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":626,"address":[],"length":0,"stats":{"Line":6}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":8}},{"line":640,"address":[],"length":0,"stats":{"Line":2}},{"line":641,"address":[],"length":0,"stats":{"Line":2}},{"line":642,"address":[],"length":0,"stats":{"Line":4}},{"line":643,"address":[],"length":0,"stats":{"Line":2}},{"line":645,"address":[],"length":0,"stats":{"Line":4}},{"line":646,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":4}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":4}},{"line":665,"address":[],"length":0,"stats":{"Line":4}},{"line":666,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":668,"address":[],"length":0,"stats":{"Line":2}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":3}},{"line":721,"address":[],"length":0,"stats":{"Line":16}},{"line":729,"address":[],"length":0,"stats":{"Line":32}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":16}},{"line":775,"address":[],"length":0,"stats":{"Line":8}},{"line":785,"address":[],"length":0,"stats":{"Line":16}},{"line":786,"address":[],"length":0,"stats":{"Line":32}},{"line":789,"address":[],"length":0,"stats":{"Line":24}},{"line":790,"address":[],"length":0,"stats":{"Line":2}},{"line":791,"address":[],"length":0,"stats":{"Line":2}},{"line":792,"address":[],"length":0,"stats":{"Line":1}},{"line":797,"address":[],"length":0,"stats":{"Line":42}},{"line":798,"address":[],"length":0,"stats":{"Line":21}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":7}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}}],"covered":81,"coverable":309},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","state","mod.rs"],"content":"//! Type checker state management\n//!\n//! This module provides the shared state structure for the type checker,\n//! enabling better modularity and testability.\n\npub mod stdlib_loader;\npub mod type_checker_state;\n\npub use type_checker_state::TypeCheckerState;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","state","stdlib_loader.rs"],"content":"//! Standard library parsing for the type checker\n//!\n//! This module provides functionality to parse TypedLua standard library\n//! definition files into AST programs. The caller is responsible for\n//! processing the statements (e.g., type checking, populating symbol tables).\n\nuse crate::cli::config::LuaVersion;\nuse crate::cli::diagnostics::CollectingDiagnosticHandler;\nuse std::sync::Arc;\nuse typedlua_parser::ast::Program;\nuse typedlua_parser::lexer::Lexer;\nuse typedlua_parser::parser::Parser;\nuse typedlua_parser::string_interner::{CommonIdentifiers, StringInterner};\n\n/// Parses the standard library definition files for the specified Lua version.\n///\n/// This function reads and parses all stdlib files for the given Lua version,\n/// returning the parsed AST programs. The caller is responsible for processing\n/// these programs (e.g., type checking statements, populating symbol tables).\n///\n/// # Separation of Concerns\n///\n/// This function focuses solely on parsing stdlib files into AST. It does not:\n/// - Perform type checking\n/// - Populate symbol tables\n/// - Register types or symbols\n///\n/// This separation allows the stdlib parser to be:\n/// - Independently testable\n/// - Reusable in different contexts (e.g., LSP, static analysis tools)\n/// - Free from coupling to type checker internals\n///\n/// # Arguments\n///\n/// * `target_version` - The Lua version to parse stdlib for (5.1, 5.2, 5.3, or 5.4)\n/// * `interner` - String interner for parsing identifiers\n/// * `common` - Common identifiers for parsing\n///\n/// # Returns\n///\n/// Returns `Ok(Vec\u003cProgram\u003e)` containing the parsed stdlib programs, or an error\n/// message if parsing failed.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use typedlua_typechecker::state::stdlib_loader;\n/// use typedlua_typechecker::config::LuaVersion;\n///\n/// let (interner, common) = StringInterner::new_with_common_identifiers();\n/// let programs = stdlib_loader::parse_stdlib_files(\n///     LuaVersion::Lua54,\n///     \u0026interner,\n///     \u0026common\n/// )?;\n///\n/// // Process the programs as needed\n/// for mut program in programs {\n///     for statement in \u0026mut program.statements {\n///         // Check statement, register types, etc.\n///     }\n/// }\n/// ```\npub fn parse_stdlib_files(\n    target_version: LuaVersion,\n    interner: \u0026StringInterner,\n    common: \u0026CommonIdentifiers,\n) -\u003e Result\u003cVec\u003cProgram\u003e, String\u003e {\n    use crate::stdlib;\n\n    let stdlib_files = stdlib::get_all_stdlib(target_version);\n    let mut programs = Vec::with_capacity(stdlib_files.len());\n\n    for (filename, source) in stdlib_files {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let mut lexer = Lexer::new(source, handler.clone(), interner);\n        let tokens = lexer\n            .tokenize()\n            .map_err(|e| format!(\"Failed to lex {}: {:?}\", filename, e))?;\n\n        let mut parser = Parser::new(tokens, handler.clone(), interner, common);\n        let program = parser\n            .parse()\n            .map_err(|e| format!(\"Failed to parse {}: {:?}\", filename, e))?;\n\n        programs.push(program);\n    }\n\n    Ok(programs)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::config::LuaVersion;\n    use typedlua_parser::string_interner::StringInterner;\n\n    #[test]\n    fn test_parse_stdlib_lua51() {\n        let (interner, common) = StringInterner::new_with_common_identifiers();\n\n        let result = parse_stdlib_files(LuaVersion::Lua51, \u0026interner, \u0026common);\n\n        assert!(result.is_ok());\n        let programs = result.unwrap();\n        assert!(\n            !programs.is_empty(),\n            \"Should parse at least one stdlib file\"\n        );\n\n        // Verify programs have statements\n        let total_statements: usize = programs.iter().map(|p| p.statements.len()).sum();\n        assert!(\n            total_statements \u003e 0,\n            \"Stdlib should contain type definitions\"\n        );\n    }\n\n    #[test]\n    fn test_parse_stdlib_all_versions() {\n        let versions = vec![\n            LuaVersion::Lua51,\n            LuaVersion::Lua52,\n            LuaVersion::Lua53,\n            LuaVersion::Lua54,\n        ];\n\n        for version in versions {\n            let (interner, common) = StringInterner::new_with_common_identifiers();\n\n            let result = parse_stdlib_files(version, \u0026interner, \u0026common);\n\n            assert!(\n                result.is_ok(),\n                \"Failed to parse stdlib for version {:?}\",\n                version\n            );\n\n            let programs = result.unwrap();\n            assert!(\n                !programs.is_empty(),\n                \"Should parse at least one stdlib file for {:?}\",\n                version\n            );\n        }\n    }\n\n    #[test]\n    fn test_parse_stdlib_returns_valid_programs() {\n        let (interner, common) = StringInterner::new_with_common_identifiers();\n        let programs = parse_stdlib_files(LuaVersion::Lua54, \u0026interner, \u0026common).unwrap();\n\n        // Verify each program is valid\n        for program in programs {\n            // Programs should have statements (stdlib definitions)\n            assert!(\n                !program.statements.is_empty(),\n                \"Each stdlib file should have declarations\"\n            );\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":27}},{"line":72,"address":[],"length":0,"stats":{"Line":36}},{"line":74,"address":[],"length":0,"stats":{"Line":90}},{"line":75,"address":[],"length":0,"stats":{"Line":81}},{"line":76,"address":[],"length":0,"stats":{"Line":135}},{"line":77,"address":[],"length":0,"stats":{"Line":54}},{"line":79,"address":[],"length":0,"stats":{"Line":27}},{"line":81,"address":[],"length":0,"stats":{"Line":162}},{"line":82,"address":[],"length":0,"stats":{"Line":54}},{"line":84,"address":[],"length":0,"stats":{"Line":27}},{"line":86,"address":[],"length":0,"stats":{"Line":81}},{"line":89,"address":[],"length":0,"stats":{"Line":9}}],"covered":13,"coverable":13},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","state","type_checker_state.rs"],"content":"//! Type checker state module\n//!\n//! This module contains the shared state structure for the type checker,\n//! extracted from the monolithic TypeChecker to enable better modularity\n//! and testability.\n\nuse std::collections::HashSet;\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\nuse rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::TypeParameter;\nuse typedlua_parser::string_interner::{CommonIdentifiers, StringInterner};\n\nuse crate::cli::config::CompilerOptions;\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::module_resolver::{ModuleId, ModuleRegistry, ModuleResolver};\nuse crate::utils::symbol_table::SymbolTable;\nuse crate::visitors::{AccessControl, TypeNarrower};\nuse typedlua_parser::ast::types::Type;\n\n/// Shared state for the type checker\n///\n/// This struct contains all the mutable state that was previously embedded\n/// directly in TypeChecker. Extracting it enables:\n/// - Better testability (state can be created independently)\n/// - Phase-based decomposition (different phases can share state)\n/// - Reduced cognitive load (state is separated from logic)\npub struct TypeCheckerState\u003c'a\u003e {\n    /// Symbol table for tracking variable and type declarations\n    pub symbol_table: SymbolTable,\n    /// Type environment for type checking and inference\n    pub type_env: TypeEnvironment,\n    /// Current function's return type (for return statement validation)\n    pub current_function_return_type: Option\u003cType\u003e,\n    /// Type narrowing state for control flow analysis\n    pub narrowing: TypeNarrower,\n    /// Access control for class inheritance and visibility\n    pub access_control: AccessControl,\n    /// Compiler options (target version, optimization level, etc.)\n    pub options: CompilerOptions,\n    /// Diagnostic handler for reporting errors and warnings\n    pub diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n    /// String interner for efficient string handling\n    pub interner: \u0026'a StringInterner,\n    /// Common identifiers (keywords, built-in types, etc.)\n    pub common: \u0026'a CommonIdentifiers,\n    /// Module registry for multi-module compilation\n    pub module_registry: Option\u003cArc\u003cModuleRegistry\u003e\u003e,\n    /// Current module ID\n    pub current_module_id: Option\u003cModuleId\u003e,\n    /// Module resolver for import path resolution\n    pub module_resolver: Option\u003cArc\u003cModuleResolver\u003e\u003e,\n    /// Track module dependencies for cache invalidation\n    pub module_dependencies: Vec\u003cPathBuf\u003e,\n    /// Stack tracking whether we're inside a catch block (for rethrow validation)\n    pub in_catch_block: Vec\u003cbool\u003e,\n    /// Current namespace path for this module\n    pub current_namespace: Option\u003cVec\u003cString\u003e\u003e,\n    /// Type parameters for each generic class (needed for override checking)\n    pub class_type_params: FxHashMap\u003cString, Vec\u003cTypeParameter\u003e\u003e,\n    /// Track class inheritance for circular dependency detection\n    pub class_parents: FxHashMap\u003cString, String\u003e,\n    /// Track exported names to detect duplicates\n    pub exported_names: HashSet\u003cString\u003e,\n}\n\nimpl\u003c'a\u003e TypeCheckerState\u003c'a\u003e {\n    /// Create a new type checker state with default values\n    pub fn new(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a StringInterner,\n        common: \u0026'a CommonIdentifiers,\n    ) -\u003e Self {\n        Self {\n            symbol_table: SymbolTable::new(),\n            type_env: TypeEnvironment::new(),\n            current_function_return_type: None,\n            narrowing: TypeNarrower::new(),\n            access_control: AccessControl::new(),\n            options: CompilerOptions::default(),\n            diagnostic_handler,\n            interner,\n            common,\n            module_registry: None,\n            current_module_id: None,\n            module_resolver: None,\n            module_dependencies: Vec::new(),\n            in_catch_block: Vec::new(),\n            current_namespace: None,\n            class_type_params: FxHashMap::default(),\n            class_parents: FxHashMap::default(),\n            exported_names: HashSet::new(),\n        }\n    }\n\n    /// Create a new type checker state with module support\n    pub fn new_with_module_support(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a StringInterner,\n        common: \u0026'a CommonIdentifiers,\n        module_registry: Arc\u003cModuleRegistry\u003e,\n        current_module_id: ModuleId,\n        module_resolver: Arc\u003cModuleResolver\u003e,\n    ) -\u003e Self {\n        let mut state = Self::new(diagnostic_handler, interner, common);\n        state.module_registry = Some(module_registry);\n        state.current_module_id = Some(current_module_id);\n        state.module_resolver = Some(module_resolver);\n        state\n    }\n\n    /// Get the current module ID as a string reference\n    pub fn current_module_id_str(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.current_module_id.as_ref().map(|id| id.as_str())\n    }\n\n    /// Check if we're currently inside a catch block\n    pub fn is_in_catch_block(\u0026self) -\u003e bool {\n        self.in_catch_block.last().copied().unwrap_or(false)\n    }\n\n    /// Push a new catch block context\n    pub fn push_catch_block(\u0026mut self, in_catch: bool) {\n        self.in_catch_block.push(in_catch);\n    }\n\n    /// Pop the current catch block context\n    pub fn pop_catch_block(\u0026mut self) {\n        self.in_catch_block.pop();\n    }\n\n    /// Get the full namespace path as a string\n    pub fn namespace_path(\u0026self) -\u003e String {\n        match \u0026self.current_namespace {\n            Some(parts) =\u003e parts.join(\".\"),\n            None =\u003e String::new(),\n        }\n    }\n\n    /// Check if a class is already registered\n    pub fn has_class(\u0026self, name: \u0026str) -\u003e bool {\n        self.class_parents.contains_key(name) || self.class_type_params.contains_key(name)\n    }\n\n    /// Get the parent class for a given class\n    pub fn get_parent_class(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026str\u003e {\n        self.class_parents.get(class_name).map(|s| s.as_str())\n    }\n\n    /// Register a class with its parent\n    pub fn register_class(\u0026mut self, name: String, parent: Option\u003cString\u003e) {\n        if let Some(parent_name) = parent {\n            self.class_parents.insert(name, parent_name);\n        }\n    }\n\n    /// Check if a name is already exported\n    pub fn is_exported(\u0026self, name: \u0026str) -\u003e bool {\n        self.exported_names.contains(name)\n    }\n\n    /// Mark a name as exported\n    pub fn mark_exported(\u0026mut self, name: String) -\u003e bool {\n        self.exported_names.insert(name)\n    }\n\n    /// Add a module dependency\n    pub fn add_dependency(\u0026mut self, path: PathBuf) {\n        if !self.module_dependencies.contains(\u0026path) {\n            self.module_dependencies.push(path);\n        }\n    }\n\n    /// Get all module dependencies\n    pub fn get_dependencies(\u0026self) -\u003e \u0026[PathBuf] {\n        \u0026self.module_dependencies\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::diagnostics::CollectingDiagnosticHandler;\n    use std::sync::Arc;\n    use typedlua_parser::string_interner::StringInterner;\n\n    fn create_test_state() -\u003e TypeCheckerState\u003c'static\u003e {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let (interner, common) = StringInterner::new_with_common_identifiers();\n        // Leak the interner to get a 'static reference for tests\n        let interner = Box::leak(Box::new(interner));\n        let common = Box::leak(Box::new(common));\n        TypeCheckerState::new(handler, interner, common)\n    }\n\n    #[test]\n    fn test_state_creation() {\n        let state = create_test_state();\n        assert!(state.current_function_return_type.is_none());\n        assert!(state.module_registry.is_none());\n        assert!(state.current_module_id.is_none());\n    }\n\n    #[test]\n    fn test_catch_block_tracking() {\n        let mut state = create_test_state();\n        assert!(!state.is_in_catch_block());\n\n        state.push_catch_block(true);\n        assert!(state.is_in_catch_block());\n\n        state.push_catch_block(false);\n        assert!(!state.is_in_catch_block());\n\n        state.pop_catch_block();\n        assert!(state.is_in_catch_block());\n\n        state.pop_catch_block();\n        assert!(!state.is_in_catch_block());\n    }\n\n    #[test]\n    fn test_class_registration() {\n        let mut state = create_test_state();\n        assert!(!state.has_class(\"MyClass\"));\n\n        state.register_class(\"MyClass\".to_string(), Some(\"ParentClass\".to_string()));\n        assert!(state.has_class(\"MyClass\"));\n        assert_eq!(state.get_parent_class(\"MyClass\"), Some(\"ParentClass\"));\n    }\n\n    #[test]\n    fn test_export_tracking() {\n        let mut state = create_test_state();\n        assert!(!state.is_exported(\"foo\"));\n\n        assert!(state.mark_exported(\"foo\".to_string()));\n        assert!(state.is_exported(\"foo\"));\n\n        // Second insert should return false (already exists)\n        assert!(!state.mark_exported(\"foo\".to_string()));\n    }\n\n    #[test]\n    fn test_dependencies() {\n        let mut state = create_test_state();\n        assert!(state.get_dependencies().is_empty());\n\n        state.add_dependency(PathBuf::from(\"/path/to/module.lua\"));\n        assert_eq!(state.get_dependencies().len(), 1);\n\n        // Duplicate should not be added\n        state.add_dependency(PathBuf::from(\"/path/to/module.lua\"));\n        assert_eq!(state.get_dependencies().len(), 1);\n    }\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":90,"address":[],"length":0,"stats":{"Line":10}},{"line":92,"address":[],"length":0,"stats":{"Line":10}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":15}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":9}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":6}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":3}}],"covered":33,"coverable":45},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","stdlib","mod.rs"],"content":"// Standard library type definitions embedded at compile time\n\nuse crate::cli::config::LuaVersion;\n\n/// Builtin global functions (available in all Lua versions)\npub const BUILTINS: \u0026str = include_str!(\"builtins.d.tl\");\n\n/// Lua 5.1 standard library\npub const LUA51: \u0026str = include_str!(\"lua51.d.tl\");\n\n/// Lua 5.2 standard library\npub const LUA52: \u0026str = include_str!(\"lua52.d.tl\");\n\n/// Lua 5.3 standard library\npub const LUA53: \u0026str = include_str!(\"lua53.d.tl\");\n\n/// Lua 5.4 standard library\npub const LUA54: \u0026str = include_str!(\"lua54.d.tl\");\n\n/// Reflection runtime module (available in all Lua versions)\npub const REFLECTION: \u0026str = include_str!(\"reflection.d.tl\");\n\n/// Get the appropriate stdlib content based on Lua version\npub fn get_stdlib(version: LuaVersion) -\u003e \u0026'static str {\n    match version {\n        LuaVersion::Lua51 =\u003e LUA51,\n        LuaVersion::Lua52 =\u003e LUA52,\n        LuaVersion::Lua53 =\u003e LUA53,\n        LuaVersion::Lua54 =\u003e LUA54,\n    }\n}\n\n/// Get all stdlib sources (builtins + version-specific + reflection)\npub fn get_all_stdlib(version: LuaVersion) -\u003e Vec\u003c(\u0026'static str, \u0026'static str)\u003e {\n    vec![\n        (\"builtins.d.tl\", BUILTINS),\n        (\n            match version {\n                LuaVersion::Lua51 =\u003e \"lua51.d.tl\",\n                LuaVersion::Lua52 =\u003e \"lua52.d.tl\",\n                LuaVersion::Lua53 =\u003e \"lua53.d.tl\",\n                LuaVersion::Lua54 =\u003e \"lua54.d.tl\",\n            },\n            get_stdlib(version),\n        ),\n        (\"reflection.d.tl\", REFLECTION),\n    ]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_builtins_embedded() {\n        assert!(!BUILTINS.is_empty());\n        assert!(BUILTINS.contains(\"declare function print\"));\n        assert!(BUILTINS.contains(\"declare function type\"));\n    }\n\n    #[test]\n    fn test_lua51_embedded() {\n        assert!(!LUA51.is_empty());\n        assert!(LUA51.contains(\"declare namespace string\"));\n        assert!(LUA51.contains(\"declare namespace table\"));\n    }\n\n    #[test]\n    fn test_lua52_embedded() {\n        assert!(!LUA52.is_empty());\n        assert!(LUA52.contains(\"declare namespace bit32\"));\n        assert!(!LUA52.contains(\"table.maxn\")); // Removed in 5.2\n    }\n\n    #[test]\n    fn test_lua53_embedded() {\n        assert!(!LUA53.is_empty());\n        assert!(LUA53.contains(\"declare namespace utf8\"));\n        assert!(!LUA53.contains(\"declare namespace bit32\")); // Removed in 5.3\n    }\n\n    #[test]\n    fn test_lua54_embedded() {\n        assert!(!LUA54.is_empty());\n        assert!(LUA54.contains(\"declare function warn\"));\n        assert!(LUA54.contains(\"declare namespace coroutine\"));\n        assert!(LUA54.contains(\"export function close\")); // coroutine.close\n    }\n\n    #[test]\n    fn test_get_stdlib() {\n        assert_eq!(get_stdlib(LuaVersion::Lua51), LUA51);\n        assert_eq!(get_stdlib(LuaVersion::Lua52), LUA52);\n        assert_eq!(get_stdlib(LuaVersion::Lua53), LUA53);\n        assert_eq!(get_stdlib(LuaVersion::Lua54), LUA54);\n    }\n\n    #[test]\n    fn test_get_all_stdlib() {\n        let stdlib = get_all_stdlib(LuaVersion::Lua54);\n        assert_eq!(stdlib.len(), 3);\n        assert_eq!(stdlib[0].0, \"builtins.d.tl\");\n        assert_eq!(stdlib[1].0, \"lua54.d.tl\");\n        assert_eq!(stdlib[2].0, \"reflection.d.tl\");\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":14}},{"line":25,"address":[],"length":0,"stats":{"Line":14}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":10}}],"covered":16,"coverable":16},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","types","generics.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::TypeParameter;\nuse typedlua_parser::ast::types::{Type, TypeKind, TypeReference};\nuse typedlua_parser::string_interner::StringId;\n\n#[cfg(test)]\nuse typedlua_parser::span::Span;\n\n/// Substitutes type parameters with concrete types in a type\npub fn instantiate_type(\n    typ: \u0026Type,\n    type_params: \u0026[TypeParameter],\n    type_args: \u0026[Type],\n) -\u003e Result\u003cType, String\u003e {\n    if type_params.len() != type_args.len() {\n        return Err(format!(\n            \"Expected {} type arguments, but got {}\",\n            type_params.len(),\n            type_args.len()\n        ));\n    }\n\n    // Build substitution map\n    let mut substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n    for (param, arg) in type_params.iter().zip(type_args.iter()) {\n        substitutions.insert(param.name.node, arg.clone());\n    }\n\n    substitute_type(typ, \u0026substitutions)\n}\n\n/// Recursively substitute type parameters in a type\nfn substitute_type(typ: \u0026Type, substitutions: \u0026FxHashMap\u003cStringId, Type\u003e) -\u003e Result\u003cType, String\u003e {\n    match \u0026typ.kind {\n        // If this is a type reference that matches a type parameter, substitute it\n        TypeKind::Reference(type_ref) =\u003e {\n            let name = type_ref.name.node;\n\n            // Check if this is a type parameter\n            if let Some(substituted) = substitutions.get(\u0026name) {\n                // Apply type arguments if present (e.g., for higher-kinded types)\n                if let Some(ref args) = type_ref.type_arguments {\n                    // This would be a higher-kinded type - not common, but we should handle it\n                    // For now, just return an error\n                    if !args.is_empty() {\n                        return Err(format!(\n                            \"Type parameter {:?} cannot have type arguments\",\n                            name\n                        ));\n                    }\n                }\n                Ok(substituted.clone())\n            } else {\n                // Not a type parameter - recursively substitute in type arguments\n                if let Some(ref args) = type_ref.type_arguments {\n                    let substituted_args: Result\u003cVec\u003c_\u003e, _\u003e = args\n                        .iter()\n                        .map(|arg| substitute_type(arg, substitutions))\n                        .collect();\n\n                    Ok(Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: type_ref.name.clone(),\n                            type_arguments: Some(substituted_args?),\n                            span: type_ref.span,\n                        }),\n                        typ.span,\n                    ))\n                } else {\n                    Ok(typ.clone())\n                }\n            }\n        }\n\n        // Array type: substitute element type\n        TypeKind::Array(elem) =\u003e {\n            let substituted_elem = substitute_type(elem, substitutions)?;\n            Ok(Type::new(\n                TypeKind::Array(Box::new(substituted_elem)),\n                typ.span,\n            ))\n        }\n\n        // Tuple type: substitute each element\n        TypeKind::Tuple(elems) =\u003e {\n            let substituted_elems: Result\u003cVec\u003c_\u003e, _\u003e = elems\n                .iter()\n                .map(|elem| substitute_type(elem, substitutions))\n                .collect();\n\n            Ok(Type::new(TypeKind::Tuple(substituted_elems?), typ.span))\n        }\n\n        // Union type: substitute each member\n        TypeKind::Union(members) =\u003e {\n            let substituted_members: Result\u003cVec\u003c_\u003e, _\u003e = members\n                .iter()\n                .map(|member| substitute_type(member, substitutions))\n                .collect();\n\n            Ok(Type::new(TypeKind::Union(substituted_members?), typ.span))\n        }\n\n        // Intersection type: substitute each member\n        TypeKind::Intersection(members) =\u003e {\n            let substituted_members: Result\u003cVec\u003c_\u003e, _\u003e = members\n                .iter()\n                .map(|member| substitute_type(member, substitutions))\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Intersection(substituted_members?),\n                typ.span,\n            ))\n        }\n\n        // Function type: substitute parameter and return types\n        TypeKind::Function(func_type) =\u003e {\n            use typedlua_parser::ast::statement::Parameter;\n\n            let substituted_params: Result\u003cVec\u003cParameter\u003e, String\u003e = func_type\n                .parameters\n                .iter()\n                .map(|param| {\n                    if let Some(ref type_ann) = param.type_annotation {\n                        let substituted = substitute_type(type_ann, substitutions)?;\n                        Ok(Parameter {\n                            pattern: param.pattern.clone(),\n                            type_annotation: Some(substituted),\n                            default: param.default.clone(),\n                            is_rest: param.is_rest,\n                            is_optional: param.is_optional,\n                            span: param.span,\n                        })\n                    } else {\n                        Ok(param.clone())\n                    }\n                })\n                .collect();\n\n            let substituted_return = substitute_type(\u0026func_type.return_type, substitutions)?;\n\n            Ok(Type::new(\n                TypeKind::Function(typedlua_parser::ast::types::FunctionType {\n                    type_parameters: None, // Type parameters are gone after substitution\n                    parameters: substituted_params?,\n                    return_type: Box::new(substituted_return),\n                    throws: func_type.throws.clone(),\n                    span: func_type.span,\n                }),\n                typ.span,\n            ))\n        }\n\n        // Nullable type: substitute inner type\n        TypeKind::Nullable(inner) =\u003e {\n            let substituted_inner = substitute_type(inner, substitutions)?;\n            Ok(Type::new(\n                TypeKind::Nullable(Box::new(substituted_inner)),\n                typ.span,\n            ))\n        }\n\n        // Parenthesized type: substitute inner type\n        TypeKind::Parenthesized(inner) =\u003e {\n            let substituted_inner = substitute_type(inner, substitutions)?;\n            Ok(Type::new(\n                TypeKind::Parenthesized(Box::new(substituted_inner)),\n                typ.span,\n            ))\n        }\n\n        // Object type: substitute property type annotations\n        TypeKind::Object(obj_type) =\u003e {\n            use typedlua_parser::ast::statement::{MethodSignature, PropertySignature};\n            use typedlua_parser::ast::types::ObjectTypeMember;\n\n            let mut substituted_members: Vec\u003cObjectTypeMember\u003e = Vec::new();\n            for member in \u0026obj_type.members {\n                let substituted = match member {\n                    ObjectTypeMember::Property(prop) =\u003e {\n                        let substituted_type =\n                            substitute_type(\u0026prop.type_annotation, substitutions)?;\n                        ObjectTypeMember::Property(PropertySignature {\n                            type_annotation: substituted_type,\n                            ..prop.clone()\n                        })\n                    }\n                    ObjectTypeMember::Method(method) =\u003e {\n                        // For methods, substitute the return type\n                        // Note: method parameters are handled separately during function type checking\n                        let substituted_return =\n                            substitute_type(\u0026method.return_type, substitutions)?;\n\n                        ObjectTypeMember::Method(MethodSignature {\n                            return_type: substituted_return,\n                            ..method.clone()\n                        })\n                    }\n                    ObjectTypeMember::Index(index) =\u003e {\n                        // Index signatures have key_type and value_type\n                        // key_type is IndexKeyType (String or Number), not Type\n                        let substituted_value = substitute_type(\u0026index.value_type, substitutions)?;\n\n                        ObjectTypeMember::Index(typedlua_parser::ast::statement::IndexSignature {\n                            value_type: substituted_value,\n                            ..index.clone()\n                        })\n                    }\n                };\n                substituted_members.push(substituted);\n            }\n\n            Ok(Type::new(\n                TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                    members: substituted_members,\n                    ..obj_type.clone()\n                }),\n                typ.span,\n            ))\n        }\n\n        // Conditional types, mapped types, etc. would need similar handling\n        // For now, just clone types that don't contain type parameters\n        _ =\u003e Ok(typ.clone()),\n    }\n}\n\n/// Check if type arguments satisfy type parameter constraints\npub fn check_type_constraints(\n    type_params: \u0026[TypeParameter],\n    type_args: \u0026[Type],\n) -\u003e Result\u003c(), String\u003e {\n    if type_params.len() != type_args.len() {\n        return Err(format!(\n            \"Expected {} type arguments, but got {}\",\n            type_params.len(),\n            type_args.len()\n        ));\n    }\n\n    for (param, arg) in type_params.iter().zip(type_args.iter()) {\n        if let Some(ref constraint) = param.constraint {\n            // Check if arg is assignable to constraint\n            // This is a simplified check - a real implementation would use TypeCompatibility\n            // For now, we'll just do a basic check\n            if !is_type_compatible(arg, constraint) {\n                return Err(format!(\n                    \"Type argument does not satisfy constraint for parameter '{}'\",\n                    param.name.node\n                ));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if a type is compatible with a constraint\n/// Uses the TypeCompatibility module for proper checking\nfn is_type_compatible(arg: \u0026Type, constraint: \u0026Type) -\u003e bool {\n    use crate::core::type_compat::TypeCompatibility;\n    TypeCompatibility::is_assignable(arg, constraint)\n}\n\n/// Infer type arguments for a generic function from argument types\n/// Returns a map from type parameter name to inferred type\npub fn infer_type_arguments(\n    type_params: \u0026[TypeParameter],\n    function_params: \u0026[typedlua_parser::ast::statement::Parameter],\n    arg_types: \u0026[Type],\n) -\u003e Result\u003cVec\u003cType\u003e, String\u003e {\n    if function_params.len() != arg_types.len() {\n        return Err(format!(\n            \"Expected {} arguments, got {}\",\n            function_params.len(),\n            arg_types.len()\n        ));\n    }\n\n    let mut inferred: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n\n    // For each parameter-argument pair, try to infer type arguments\n    for (param, arg_type) in function_params.iter().zip(arg_types.iter()) {\n        if let Some(param_type) = \u0026param.type_annotation {\n            infer_from_types(param_type, arg_type, \u0026mut inferred)?;\n        }\n    }\n\n    // Build result vector in the same order as type parameters\n    type_params\n        .iter()\n        .map(|type_param| {\n            inferred\n                .get(\u0026type_param.name.node)\n                .cloned()\n                .or_else(|| type_param.default.as_ref().map(|d| (**d).clone()))\n                .ok_or_else(|| {\n                    format!(\n                        \"Could not infer type argument for parameter '{:?}'\",\n                        type_param.name.node\n                    )\n                })\n        })\n        .collect()\n}\n\n/// Helper to infer type arguments by matching param_type pattern against arg_type\nfn infer_from_types(\n    param_type: \u0026Type,\n    arg_type: \u0026Type,\n    inferred: \u0026mut FxHashMap\u003cStringId, Type\u003e,\n) -\u003e Result\u003c(), String\u003e {\n    match \u0026param_type.kind {\n        // If parameter is a type reference (e.g., T), and it's a type parameter\n        TypeKind::Reference(type_ref) if type_ref.type_arguments.is_none() =\u003e {\n            // This might be a type parameter - record the inference\n            let param_name = type_ref.name.node;\n\n            // Check if we already inferred this type parameter\n            if let Some(existing) = inferred.get(\u0026param_name) {\n                // Verify they match (simplified - should use proper type equality)\n                if !types_equal(existing, arg_type) {\n                    return Err(format!(\n                        \"Conflicting type inference for parameter '{:?}'\",\n                        param_name\n                    ));\n                }\n            } else {\n                inferred.insert(param_name, arg_type.clone());\n            }\n            Ok(())\n        }\n\n        // If parameter is Array\u003cT\u003e, and argument is Array\u003cU\u003e, infer T = U\n        TypeKind::Array(elem_param) =\u003e {\n            if let TypeKind::Array(elem_arg) = \u0026arg_type.kind {\n                infer_from_types(elem_param, elem_arg, inferred)\n            } else {\n                Ok(()) // Type mismatch, but don't error during inference\n            }\n        }\n\n        // If parameter is a generic type application like Map\u003cK, V\u003e\n        TypeKind::Reference(type_ref) if type_ref.type_arguments.is_some() =\u003e {\n            if let TypeKind::Reference(arg_ref) = \u0026arg_type.kind {\n                // Names should match\n                if type_ref.name.node == arg_ref.name.node {\n                    if let (Some(param_args), Some(arg_args)) =\n                        (\u0026type_ref.type_arguments, \u0026arg_ref.type_arguments)\n                    {\n                        // Infer from each type argument pair\n                        for (p, a) in param_args.iter().zip(arg_args.iter()) {\n                            infer_from_types(p, a, inferred)?;\n                        }\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        // For other types, no inference needed\n        _ =\u003e Ok(()),\n    }\n}\n\n/// Simple type equality check (simplified)\nfn types_equal(t1: \u0026Type, t2: \u0026Type) -\u003e bool {\n    // Simplified - just check if both are the same primitive\n    match (\u0026t1.kind, \u0026t2.kind) {\n        (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) =\u003e p1 == p2,\n        (TypeKind::Reference(r1), TypeKind::Reference(r2)) =\u003e r1.name.node == r2.name.node,\n        _ =\u003e false, // For now, consider other types as not equal\n    }\n}\n\n// =============================================================================\n// Body Instantiation Functions for Generic Specialization\n// =============================================================================\n\n/// Build a substitution map from type parameters and type arguments\npub fn build_substitutions(\n    type_params: \u0026[TypeParameter],\n    type_args: \u0026[Type],\n) -\u003e Result\u003cFxHashMap\u003cStringId, Type\u003e, String\u003e {\n    if type_params.len() != type_args.len() {\n        return Err(format!(\n            \"Expected {} type arguments, but got {}\",\n            type_params.len(),\n            type_args.len()\n        ));\n    }\n\n    let mut substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n    for (param, arg) in type_params.iter().zip(type_args.iter()) {\n        substitutions.insert(param.name.node, arg.clone());\n    }\n    Ok(substitutions)\n}\n\n/// Instantiate a block with type substitutions\n/// Clones the block and substitutes type annotations in all statements\npub fn instantiate_block(\n    block: \u0026typedlua_parser::ast::statement::Block,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::Block {\n    use typedlua_parser::ast::statement::Block;\n\n    Block {\n        statements: block\n            .statements\n            .iter()\n            .map(|stmt| instantiate_statement(stmt, substitutions))\n            .collect(),\n        span: block.span,\n    }\n}\n\n/// Instantiate a statement with type substitutions\npub fn instantiate_statement(\n    stmt: \u0026typedlua_parser::ast::statement::Statement,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::Statement {\n    use typedlua_parser::ast::statement::{\n        ElseIf, ForGeneric, ForNumeric, ForStatement, IfStatement, RepeatStatement,\n        ReturnStatement, Statement, ThrowStatement, VariableDeclaration, WhileStatement,\n    };\n\n    match stmt {\n        Statement::Variable(var_decl) =\u003e Statement::Variable(VariableDeclaration {\n            kind: var_decl.kind,\n            pattern: var_decl.pattern.clone(),\n            type_annotation: var_decl\n                .type_annotation\n                .as_ref()\n                .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n            initializer: instantiate_expression(\u0026var_decl.initializer, substitutions),\n            span: var_decl.span,\n        }),\n\n        Statement::Function(func_decl) =\u003e {\n            Statement::Function(instantiate_function_declaration(func_decl, substitutions))\n        }\n\n        Statement::Expression(expr) =\u003e {\n            Statement::Expression(instantiate_expression(expr, substitutions))\n        }\n\n        Statement::Return(ret) =\u003e Statement::Return(ReturnStatement {\n            values: ret\n                .values\n                .iter()\n                .map(|e| instantiate_expression(e, substitutions))\n                .collect(),\n            span: ret.span,\n        }),\n\n        Statement::If(if_stmt) =\u003e Statement::If(IfStatement {\n            condition: instantiate_expression(\u0026if_stmt.condition, substitutions),\n            then_block: instantiate_block(\u0026if_stmt.then_block, substitutions),\n            else_ifs: if_stmt\n                .else_ifs\n                .iter()\n                .map(|elif| ElseIf {\n                    condition: instantiate_expression(\u0026elif.condition, substitutions),\n                    block: instantiate_block(\u0026elif.block, substitutions),\n                    span: elif.span,\n                })\n                .collect(),\n            else_block: if_stmt\n                .else_block\n                .as_ref()\n                .map(|b| instantiate_block(b, substitutions)),\n            span: if_stmt.span,\n        }),\n\n        Statement::While(while_stmt) =\u003e Statement::While(WhileStatement {\n            condition: instantiate_expression(\u0026while_stmt.condition, substitutions),\n            body: instantiate_block(\u0026while_stmt.body, substitutions),\n            span: while_stmt.span,\n        }),\n\n        Statement::For(for_stmt) =\u003e Statement::For(Box::new(match for_stmt.as_ref() {\n            ForStatement::Numeric(num) =\u003e ForStatement::Numeric(Box::new(ForNumeric {\n                variable: num.variable.clone(),\n                start: instantiate_expression(\u0026num.start, substitutions),\n                end: instantiate_expression(\u0026num.end, substitutions),\n                step: num\n                    .step\n                    .as_ref()\n                    .map(|e| instantiate_expression(e, substitutions)),\n                body: instantiate_block(\u0026num.body, substitutions),\n                span: num.span,\n            })),\n            ForStatement::Generic(gen) =\u003e ForStatement::Generic(ForGeneric {\n                variables: gen.variables.clone(),\n                iterators: gen\n                    .iterators\n                    .iter()\n                    .map(|e| instantiate_expression(e, substitutions))\n                    .collect(),\n                body: instantiate_block(\u0026gen.body, substitutions),\n                span: gen.span,\n            }),\n        })),\n\n        Statement::Repeat(repeat) =\u003e Statement::Repeat(RepeatStatement {\n            body: instantiate_block(\u0026repeat.body, substitutions),\n            until: instantiate_expression(\u0026repeat.until, substitutions),\n            span: repeat.span,\n        }),\n\n        Statement::Block(block) =\u003e Statement::Block(instantiate_block(block, substitutions)),\n\n        Statement::Throw(throw) =\u003e Statement::Throw(ThrowStatement {\n            expression: instantiate_expression(\u0026throw.expression, substitutions),\n            span: throw.span,\n        }),\n\n        // Statements that don't contain type parameters or are complex - clone as-is\n        Statement::Break(span) =\u003e Statement::Break(*span),\n        Statement::Continue(span) =\u003e Statement::Continue(*span),\n        Statement::Rethrow(span) =\u003e Statement::Rethrow(*span),\n        Statement::Class(class_decl) =\u003e Statement::Class(class_decl.clone()),\n        Statement::Interface(iface) =\u003e Statement::Interface(iface.clone()),\n        Statement::TypeAlias(alias) =\u003e Statement::TypeAlias(alias.clone()),\n        Statement::Enum(enum_decl) =\u003e Statement::Enum(enum_decl.clone()),\n        Statement::Import(import) =\u003e Statement::Import(import.clone()),\n        Statement::Export(export) =\u003e Statement::Export(export.clone()),\n        Statement::Try(try_stmt) =\u003e Statement::Try(try_stmt.clone()),\n        Statement::Namespace(ns) =\u003e Statement::Namespace(ns.clone()),\n        Statement::DeclareFunction(df) =\u003e Statement::DeclareFunction(df.clone()),\n        Statement::DeclareNamespace(dn) =\u003e Statement::DeclareNamespace(dn.clone()),\n        Statement::DeclareType(dt) =\u003e Statement::DeclareType(dt.clone()),\n        Statement::DeclareInterface(di) =\u003e Statement::DeclareInterface(di.clone()),\n        Statement::DeclareConst(dc) =\u003e Statement::DeclareConst(dc.clone()),\n        Statement::Label(l) =\u003e Statement::Label(l.clone()),\n        Statement::Goto(g) =\u003e Statement::Goto(g.clone()),\n    }\n}\n\n/// Instantiate a function declaration with type substitutions\npub fn instantiate_function_declaration(\n    func: \u0026typedlua_parser::ast::statement::FunctionDeclaration,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::FunctionDeclaration {\n    typedlua_parser::ast::statement::FunctionDeclaration {\n        name: func.name.clone(),\n        type_parameters: None, // Remove type parameters after specialization\n        parameters: func\n            .parameters\n            .iter()\n            .map(|p| instantiate_parameter(p, substitutions))\n            .collect(),\n        return_type: func\n            .return_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        body: instantiate_block(\u0026func.body, substitutions),\n        throws: func.throws.clone(),\n        span: func.span,\n    }\n}\n\n/// Instantiate a parameter with type substitutions\npub fn instantiate_parameter(\n    param: \u0026typedlua_parser::ast::statement::Parameter,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::Parameter {\n    typedlua_parser::ast::statement::Parameter {\n        pattern: param.pattern.clone(),\n        type_annotation: param\n            .type_annotation\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        default: param\n            .default\n            .as_ref()\n            .map(|e| instantiate_expression(e, substitutions)),\n        is_rest: param.is_rest,\n        is_optional: param.is_optional,\n        span: param.span,\n    }\n}\n\n/// Instantiate an expression with type substitutions\npub fn instantiate_expression(\n    expr: \u0026typedlua_parser::ast::expression::Expression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::Expression {\n    use typedlua_parser::ast::expression::{Expression, ExpressionKind};\n\n    let new_kind = match \u0026expr.kind {\n        ExpressionKind::Literal(lit) =\u003e ExpressionKind::Literal(lit.clone()),\n        ExpressionKind::Identifier(id) =\u003e ExpressionKind::Identifier(*id),\n\n        ExpressionKind::Binary(op, left, right) =\u003e ExpressionKind::Binary(\n            *op,\n            Box::new(instantiate_expression(left, substitutions)),\n            Box::new(instantiate_expression(right, substitutions)),\n        ),\n\n        ExpressionKind::Unary(op, operand) =\u003e ExpressionKind::Unary(\n            *op,\n            Box::new(instantiate_expression(operand, substitutions)),\n        ),\n\n        ExpressionKind::Assignment(target, op, value) =\u003e ExpressionKind::Assignment(\n            Box::new(instantiate_expression(target, substitutions)),\n            *op,\n            Box::new(instantiate_expression(value, substitutions)),\n        ),\n\n        ExpressionKind::Call(callee, args, type_args) =\u003e ExpressionKind::Call(\n            Box::new(instantiate_expression(callee, substitutions)),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::MethodCall(obj, method, args, type_args) =\u003e ExpressionKind::MethodCall(\n            Box::new(instantiate_expression(obj, substitutions)),\n            method.clone(),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::Member(obj, member) =\u003e ExpressionKind::Member(\n            Box::new(instantiate_expression(obj, substitutions)),\n            member.clone(),\n        ),\n\n        ExpressionKind::Index(obj, index) =\u003e ExpressionKind::Index(\n            Box::new(instantiate_expression(obj, substitutions)),\n            Box::new(instantiate_expression(index, substitutions)),\n        ),\n\n        ExpressionKind::Array(elements) =\u003e ExpressionKind::Array(\n            elements\n                .iter()\n                .map(|elem| instantiate_array_element(elem, substitutions))\n                .collect(),\n        ),\n\n        ExpressionKind::Object(props) =\u003e ExpressionKind::Object(\n            props\n                .iter()\n                .map(|prop| instantiate_object_property(prop, substitutions))\n                .collect(),\n        ),\n\n        ExpressionKind::Function(func) =\u003e {\n            ExpressionKind::Function(instantiate_function_expression(func, substitutions))\n        }\n\n        ExpressionKind::Arrow(arrow) =\u003e {\n            ExpressionKind::Arrow(instantiate_arrow_function(arrow, substitutions))\n        }\n\n        ExpressionKind::Conditional(cond, then_expr, else_expr) =\u003e ExpressionKind::Conditional(\n            Box::new(instantiate_expression(cond, substitutions)),\n            Box::new(instantiate_expression(then_expr, substitutions)),\n            Box::new(instantiate_expression(else_expr, substitutions)),\n        ),\n\n        ExpressionKind::Pipe(left, right) =\u003e ExpressionKind::Pipe(\n            Box::new(instantiate_expression(left, substitutions)),\n            Box::new(instantiate_expression(right, substitutions)),\n        ),\n\n        ExpressionKind::Match(match_expr) =\u003e {\n            ExpressionKind::Match(instantiate_match_expression(match_expr, substitutions))\n        }\n\n        ExpressionKind::Parenthesized(inner) =\u003e {\n            ExpressionKind::Parenthesized(Box::new(instantiate_expression(inner, substitutions)))\n        }\n\n        ExpressionKind::TypeAssertion(expr_inner, typ) =\u003e ExpressionKind::TypeAssertion(\n            Box::new(instantiate_expression(expr_inner, substitutions)),\n            substitute_type(typ, substitutions).unwrap_or_else(|_| typ.clone()),\n        ),\n\n        ExpressionKind::OptionalMember(obj, member) =\u003e ExpressionKind::OptionalMember(\n            Box::new(instantiate_expression(obj, substitutions)),\n            member.clone(),\n        ),\n\n        ExpressionKind::OptionalIndex(obj, index) =\u003e ExpressionKind::OptionalIndex(\n            Box::new(instantiate_expression(obj, substitutions)),\n            Box::new(instantiate_expression(index, substitutions)),\n        ),\n\n        ExpressionKind::OptionalCall(callee, args, type_args) =\u003e ExpressionKind::OptionalCall(\n            Box::new(instantiate_expression(callee, substitutions)),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::OptionalMethodCall(obj, method, args, type_args) =\u003e {\n            ExpressionKind::OptionalMethodCall(\n                Box::new(instantiate_expression(obj, substitutions)),\n                method.clone(),\n                args.iter()\n                    .map(|a| instantiate_argument(a, substitutions))\n                    .collect(),\n                type_args.as_ref().map(|tas| {\n                    tas.iter()\n                        .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                        .collect()\n                }),\n            )\n        }\n\n        ExpressionKind::Template(template) =\u003e {\n            ExpressionKind::Template(instantiate_template_literal(template, substitutions))\n        }\n\n        ExpressionKind::New(callee, args, type_args) =\u003e ExpressionKind::New(\n            Box::new(instantiate_expression(callee, substitutions)),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::Try(try_expr) =\u003e {\n            ExpressionKind::Try(instantiate_try_expression(try_expr, substitutions))\n        }\n\n        ExpressionKind::ErrorChain(left, right) =\u003e ExpressionKind::ErrorChain(\n            Box::new(instantiate_expression(left, substitutions)),\n            Box::new(instantiate_expression(right, substitutions)),\n        ),\n\n        // Simple expression kinds - clone as-is\n        ExpressionKind::SelfKeyword =\u003e ExpressionKind::SelfKeyword,\n        ExpressionKind::SuperKeyword =\u003e ExpressionKind::SuperKeyword,\n    };\n\n    Expression {\n        kind: new_kind,\n        span: expr.span,\n        annotated_type: expr\n            .annotated_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        receiver_class: expr.receiver_class.clone(),\n    }\n}\n\n/// Helper to instantiate an argument\nfn instantiate_argument(\n    arg: \u0026typedlua_parser::ast::expression::Argument,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::Argument {\n    typedlua_parser::ast::expression::Argument {\n        value: instantiate_expression(\u0026arg.value, substitutions),\n        is_spread: arg.is_spread,\n        span: arg.span,\n    }\n}\n\n/// Helper to instantiate an array element\nfn instantiate_array_element(\n    elem: \u0026typedlua_parser::ast::expression::ArrayElement,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::ArrayElement {\n    use typedlua_parser::ast::expression::ArrayElement;\n    match elem {\n        ArrayElement::Expression(e) =\u003e {\n            ArrayElement::Expression(instantiate_expression(e, substitutions))\n        }\n        ArrayElement::Spread(e) =\u003e ArrayElement::Spread(instantiate_expression(e, substitutions)),\n    }\n}\n\n/// Helper to instantiate an object property\nfn instantiate_object_property(\n    prop: \u0026typedlua_parser::ast::expression::ObjectProperty,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::ObjectProperty {\n    use typedlua_parser::ast::expression::ObjectProperty;\n    match prop {\n        ObjectProperty::Property { key, value, span } =\u003e ObjectProperty::Property {\n            key: key.clone(),\n            value: Box::new(instantiate_expression(value, substitutions)),\n            span: *span,\n        },\n        ObjectProperty::Computed { key, value, span } =\u003e ObjectProperty::Computed {\n            key: Box::new(instantiate_expression(key, substitutions)),\n            value: Box::new(instantiate_expression(value, substitutions)),\n            span: *span,\n        },\n        ObjectProperty::Spread { value, span } =\u003e ObjectProperty::Spread {\n            value: Box::new(instantiate_expression(value, substitutions)),\n            span: *span,\n        },\n    }\n}\n\n/// Helper to instantiate a function expression\nfn instantiate_function_expression(\n    func: \u0026typedlua_parser::ast::expression::FunctionExpression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::FunctionExpression {\n    typedlua_parser::ast::expression::FunctionExpression {\n        type_parameters: None, // Remove type parameters after specialization\n        parameters: func\n            .parameters\n            .iter()\n            .map(|p| instantiate_parameter(p, substitutions))\n            .collect(),\n        return_type: func\n            .return_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        body: instantiate_block(\u0026func.body, substitutions),\n        span: func.span,\n    }\n}\n\n/// Helper to instantiate an arrow function\nfn instantiate_arrow_function(\n    arrow: \u0026typedlua_parser::ast::expression::ArrowFunction,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::ArrowFunction {\n    use typedlua_parser::ast::expression::{ArrowBody, ArrowFunction};\n    ArrowFunction {\n        parameters: arrow\n            .parameters\n            .iter()\n            .map(|p| instantiate_parameter(p, substitutions))\n            .collect(),\n        return_type: arrow\n            .return_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        body: match \u0026arrow.body {\n            ArrowBody::Expression(e) =\u003e {\n                ArrowBody::Expression(Box::new(instantiate_expression(e.as_ref(), substitutions)))\n            }\n            ArrowBody::Block(b) =\u003e ArrowBody::Block(instantiate_block(b, substitutions)),\n        },\n        span: arrow.span,\n    }\n}\n\n/// Helper to instantiate a template literal\nfn instantiate_template_literal(\n    template: \u0026typedlua_parser::ast::expression::TemplateLiteral,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::TemplateLiteral {\n    use typedlua_parser::ast::expression::{TemplateLiteral, TemplatePart};\n    TemplateLiteral {\n        parts: template\n            .parts\n            .iter()\n            .map(|part| match part {\n                TemplatePart::String(s) =\u003e TemplatePart::String(s.clone()),\n                TemplatePart::Expression(e) =\u003e {\n                    TemplatePart::Expression(Box::new(instantiate_expression(e, substitutions)))\n                }\n            })\n            .collect(),\n        span: template.span,\n    }\n}\n\n/// Helper to instantiate a match expression\nfn instantiate_match_expression(\n    match_expr: \u0026typedlua_parser::ast::expression::MatchExpression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::MatchExpression {\n    use typedlua_parser::ast::expression::{MatchArm, MatchArmBody, MatchExpression};\n    MatchExpression {\n        value: Box::new(instantiate_expression(\u0026match_expr.value, substitutions)),\n        arms: match_expr\n            .arms\n            .iter()\n            .map(|arm| MatchArm {\n                pattern: arm.pattern.clone(),\n                guard: arm\n                    .guard\n                    .as_ref()\n                    .map(|e| instantiate_expression(e, substitutions)),\n                body: match \u0026arm.body {\n                    MatchArmBody::Expression(e) =\u003e {\n                        MatchArmBody::Expression(Box::new(instantiate_expression(e, substitutions)))\n                    }\n                    MatchArmBody::Block(b) =\u003e {\n                        MatchArmBody::Block(instantiate_block(b, substitutions))\n                    }\n                },\n                span: arm.span,\n            })\n            .collect(),\n        span: match_expr.span,\n    }\n}\n\n/// Helper to instantiate a try expression\nfn instantiate_try_expression(\n    try_expr: \u0026typedlua_parser::ast::expression::TryExpression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::TryExpression {\n    typedlua_parser::ast::expression::TryExpression {\n        expression: Box::new(instantiate_expression(\u0026try_expr.expression, substitutions)),\n        catch_variable: try_expr.catch_variable.clone(),\n        catch_expression: Box::new(instantiate_expression(\n            \u0026try_expr.catch_expression,\n            substitutions,\n        )),\n        span: try_expr.span,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::types::{PrimitiveType, TypeKind};\n    use typedlua_parser::ast::Spanned;\n\n    #[test]\n    fn test_instantiate_simple_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Type reference T\n        let type_ref_t = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n\n        // Type argument: number\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Instantiate T with number\n        let result = instantiate_type(\n            \u0026type_ref_t,\n            \u0026[type_param],\n            std::slice::from_ref(\u0026number_type),\n        )\n        .unwrap();\n\n        // Result should be number\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_array_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Array\u003cT\u003e\n        let array_t = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            ))),\n            span,\n        );\n\n        // Type argument: string\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        // Instantiate Array\u003cT\u003e with string\n        let result = instantiate_type(\u0026array_t, \u0026[type_param], \u0026[string_type]).unwrap();\n\n        // Result should be Array\u003cstring\u003e\n        match \u0026result.kind {\n            TypeKind::Array(elem) =\u003e {\n                assert!(matches!(\n                    elem.kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected array type\"),\n        }\n    }\n\n    #[test]\n    fn test_wrong_number_of_type_args() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_ref_t = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        // Try to instantiate with wrong number of type arguments\n        let result = instantiate_type(\u0026type_ref_t, \u0026[type_param], \u0026[number_type, string_type]);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_infer_type_arguments_simple() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let _x_id = interner.intern(\"x\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Function parameter: (value: T)\n        let value_id = interner.intern(\"value\");\n        let func_param = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(value_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        // Argument type: number\n        let arg_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Infer type arguments\n        let result = infer_type_arguments(\u0026[type_param], \u0026[func_param], \u0026[arg_type]);\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 1);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_array() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let values_id = interner.intern(\"values\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Function parameter: (values: Array\u003cT\u003e)\n        let func_param = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(values_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Array(Box::new(Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ))),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        // Argument type: Array\u003cstring\u003e\n        let arg_type = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            span,\n        );\n\n        // Infer type arguments\n        let result = infer_type_arguments(\u0026[type_param], \u0026[func_param], \u0026[arg_type]);\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 1);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_check_constraints_pass() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T extends number\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        // Type argument: number (should satisfy constraint)\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = check_type_constraints(\u0026[type_param], \u0026[number_type]);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_constraints_fail() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T extends number\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        // Type argument: string (should NOT satisfy constraint)\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = check_type_constraints(\u0026[type_param], \u0026[string_type]);\n        assert!(result.is_err());\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Tests\n    // ========================================================================\n\n    #[test]\n    fn test_build_substitutions_success() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result =\n            build_substitutions(\u0026[type_param_t, type_param_u], \u0026[number_type, string_type]);\n        assert!(result.is_ok());\n\n        let substitutions = result.unwrap();\n        assert_eq!(substitutions.len(), 2);\n        assert!(substitutions.contains_key(\u0026t_id));\n        assert!(substitutions.contains_key(\u0026u_id));\n    }\n\n    #[test]\n    fn test_build_substitutions_wrong_count() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Provide wrong number of type arguments\n        let result = build_substitutions(std::slice::from_ref(\u0026type_param), \u0026[]);\n        assert!(result.is_err());\n\n        let result = build_substitutions(\u0026[type_param], \u0026[number_type.clone(), number_type]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_instantiate_tuple_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Tuple\u003cT, U\u003e\n        let tuple_type = Type::new(\n            TypeKind::Tuple(vec![\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(u_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n            ]),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\n            \u0026tuple_type,\n            \u0026[type_param_t, type_param_u],\n            \u0026[number_type, string_type],\n        )\n        .unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Tuple(elems) =\u003e {\n                assert_eq!(elems.len(), 2);\n                assert!(matches!(\n                    elems[0].kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n                assert!(matches!(\n                    elems[1].kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected tuple type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_union_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Union\u003cT, nil\u003e\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), span),\n            ]),\n            span,\n        );\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\u0026union_type, \u0026[type_param], \u0026[string_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Union(members) =\u003e {\n                assert_eq!(members.len(), 2);\n                assert!(matches!(\n                    members[0].kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n                assert!(matches!(\n                    members[1].kind,\n                    TypeKind::Primitive(PrimitiveType::Nil)\n                ));\n            }\n            _ =\u003e panic!(\"Expected union type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_function_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let param_id = interner.intern(\"x\");\n        let func_type = Type::new(\n            TypeKind::Function(typedlua_parser::ast::types::FunctionType {\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(param_id, span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: Spanned::new(t_id, span),\n                            type_arguments: None,\n                            span,\n                        }),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Box::new(Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                )),\n                throws: None,\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026func_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Function(func) =\u003e {\n                assert_eq!(func.parameters.len(), 1);\n                assert!(func.type_parameters.is_none());\n                // Parameter type should be number\n                assert!(func.parameters[0].type_annotation.is_some());\n                assert!(matches!(\n                    func.parameters[0].type_annotation.as_ref().unwrap().kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n                // Return type should be number\n                assert!(matches!(\n                    func.return_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n            }\n            _ =\u003e panic!(\"Expected function type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_nullable_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Nullable\u003cT\u003e\n        let nullable_type = Type::new(\n            TypeKind::Nullable(Box::new(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            ))),\n            span,\n        );\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\u0026nullable_type, \u0026[type_param], \u0026[string_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Nullable(inner) =\u003e {\n                assert!(matches!(\n                    inner.kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected nullable type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_nested_generic() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Array\u003cArray\u003cT\u003e\u003e\n        let nested_array = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Array(Box::new(Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ))),\n                span,\n            ))),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026nested_array, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Array(outer) =\u003e match \u0026outer.kind {\n                TypeKind::Array(inner) =\u003e {\n                    assert!(matches!(\n                        inner.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                }\n                _ =\u003e panic!(\"Expected nested array\"),\n            },\n            _ =\u003e panic!(\"Expected array type\"),\n        }\n    }\n\n    #[test]\n    fn test_infer_type_arguments_multiple_params() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Function parameters: (a: T, b: U)\n        let a_id = interner.intern(\"a\");\n        let b_id = interner.intern(\"b\");\n\n        let param_a = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(a_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let param_b = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(b_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(u_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = infer_type_arguments(\n            \u0026[type_param_t, type_param_u],\n            \u0026[param_a, param_b],\n            \u0026[number_type, string_type],\n        );\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 2);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n        assert!(matches!(\n            inferred[1].kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_with_default() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Type parameter U with default: string\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            span,\n        };\n\n        // Only one function parameter using T\n        let a_id = interner.intern(\"a\");\n        let param_a = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(a_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Infer with only one argument - U should use default\n        let result =\n            infer_type_arguments(\u0026[type_param_t, type_param_u], \u0026[param_a], \u0026[number_type]);\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 2);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n        assert!(matches!(\n            inferred[1].kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_wrong_arg_count() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let a_id = interner.intern(\"a\");\n        let param_a = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(a_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Wrong number of arguments\n        let result = infer_type_arguments(\n            std::slice::from_ref(\u0026type_param),\n            std::slice::from_ref(\u0026param_a),\n            \u0026[],\n        );\n        assert!(result.is_err());\n\n        let result = infer_type_arguments(\n            \u0026[type_param],\n            \u0026[param_a],\n            \u0026[number_type.clone(), number_type],\n        );\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_instantiate_block_empty() {\n        let span = Span::new(0, 0, 0, 0);\n        let block = typedlua_parser::ast::statement::Block {\n            statements: vec![],\n            span,\n        };\n\n        let substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        let result = instantiate_block(\u0026block, \u0026substitutions);\n\n        assert!(result.statements.is_empty());\n    }\n\n    #[test]\n    fn test_instantiate_expression_literal() {\n        let span = Span::new(0, 0, 0, 0);\n        let expr = typedlua_parser::ast::expression::Expression {\n            kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                typedlua_parser::ast::expression::Literal::Number(42.0),\n            ),\n            span,\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        let result = instantiate_expression(\u0026expr, \u0026substitutions);\n\n        assert!(matches!(\n            result.kind,\n            typedlua_parser::ast::expression::ExpressionKind::Literal(\n                typedlua_parser::ast::expression::Literal::Number(42.0)\n            )\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_parameter_with_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        use typedlua_parser::ast::pattern::Pattern;\n\n        let x_id = interner.intern(\"x\");\n        let param = typedlua_parser::ast::statement::Parameter {\n            pattern: Pattern::Identifier(Spanned::new(x_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let mut substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        substitutions.insert(t_id, number_type);\n\n        let result = instantiate_parameter(\u0026param, \u0026substitutions);\n\n        assert!(result.type_annotation.is_some());\n        assert!(matches!(\n            result.type_annotation.unwrap().kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_parenthesized_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Parenthesized\u003cT\u003e\n        let parenthesized_type = Type::new(\n            TypeKind::Parenthesized(Box::new(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            ))),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026parenthesized_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Parenthesized(inner) =\u003e {\n                assert!(matches!(\n                    inner.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n            }\n            _ =\u003e panic!(\"Expected parenthesized type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_intersection_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Intersection\u003cT, U\u003e\n        let intersection_type = Type::new(\n            TypeKind::Intersection(vec![\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(u_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n            ]),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\n            \u0026intersection_type,\n            \u0026[type_param_t, type_param_u],\n            \u0026[number_type, string_type],\n        )\n        .unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Intersection(members) =\u003e {\n                assert_eq!(members.len(), 2);\n                assert!(matches!(\n                    members[0].kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n                assert!(matches!(\n                    members[1].kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected intersection type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_object_type_with_property() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let value_id = interner.intern(\"value\");\n\n        let obj_type = Type::new(\n            TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                members: vec![typedlua_parser::ast::types::ObjectTypeMember::Property(\n                    typedlua_parser::ast::statement::PropertySignature {\n                        name: Spanned::new(value_id, span),\n                        type_annotation: Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: Spanned::new(t_id, span),\n                                type_arguments: None,\n                                span,\n                            }),\n                            span,\n                        ),\n                        is_readonly: false,\n                        is_optional: false,\n                        span,\n                    },\n                )],\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026obj_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Object(obj) =\u003e {\n                assert_eq!(obj.members.len(), 1);\n                if let typedlua_parser::ast::types::ObjectTypeMember::Property(prop) =\n                    \u0026obj.members[0]\n                {\n                    assert!(matches!(\n                        prop.type_annotation.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                } else {\n                    panic!(\"Expected property member\");\n                }\n            }\n            _ =\u003e panic!(\"Expected object type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_object_type_with_method() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let method_id = interner.intern(\"getValue\");\n\n        let obj_type = Type::new(\n            TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                members: vec![typedlua_parser::ast::types::ObjectTypeMember::Method(\n                    typedlua_parser::ast::statement::MethodSignature {\n                        name: Spanned::new(method_id, span),\n                        type_parameters: None,\n                        parameters: vec![],\n                        return_type: Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: Spanned::new(t_id, span),\n                                type_arguments: None,\n                                span,\n                            }),\n                            span,\n                        ),\n                        body: None,\n                        span,\n                    },\n                )],\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026obj_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Object(obj) =\u003e {\n                assert_eq!(obj.members.len(), 1);\n                if let typedlua_parser::ast::types::ObjectTypeMember::Method(method) =\n                    \u0026obj.members[0]\n                {\n                    assert!(matches!(\n                        method.return_type.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                } else {\n                    panic!(\"Expected method member\");\n                }\n            }\n            _ =\u003e panic!(\"Expected object type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_object_type_with_index_signature() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let key_id = interner.intern(\"key\");\n\n        let obj_type = Type::new(\n            TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                members: vec![typedlua_parser::ast::types::ObjectTypeMember::Index(\n                    typedlua_parser::ast::statement::IndexSignature {\n                        key_name: Spanned::new(key_id, span),\n                        key_type: typedlua_parser::ast::statement::IndexKeyType::String,\n                        value_type: Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: Spanned::new(t_id, span),\n                                type_arguments: None,\n                                span,\n                            }),\n                            span,\n                        ),\n                        span,\n                    },\n                )],\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026obj_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Object(obj) =\u003e {\n                assert_eq!(obj.members.len(), 1);\n                if let typedlua_parser::ast::types::ObjectTypeMember::Index(idx) = \u0026obj.members[0] {\n                    assert!(matches!(\n                        idx.value_type.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                } else {\n                    panic!(\"Expected index member\");\n                }\n            }\n            _ =\u003e panic!(\"Expected object type\"),\n        }\n    }\n\n    #[test]\n    fn test_substitute_type_with_type_args_error() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Type reference T with type arguments (should error)\n        let type_ref_with_args = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: Some(vec![Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    span,\n                )]),\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026type_ref_with_args, \u0026[type_param], \u0026[number_type]);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_instantiate_type_primitive() {\n        let span = Span::new(0, 0, 0, 0);\n\n        let primitive_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026primitive_type, \u0026[], \u0026[]);\n\n        assert!(result.is_ok());\n        assert!(matches!(\n            result.unwrap().kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_check_type_constraints_with_multiple_params() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result =\n            check_type_constraints(\u0026[type_param_t, type_param_u], \u0026[number_type, string_type]);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_type_constraints_second_param_fails() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let boolean_type = Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span);\n\n        let result =\n            check_type_constraints(\u0026[type_param_t, type_param_u], \u0026[number_type, boolean_type]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_infer_from_types_array_mismatch() {\n        let span = Span::new(0, 0, 0, 0);\n\n        let param_type = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            span,\n        );\n\n        let arg_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let mut inferred: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        let result = infer_from_types(\u0026param_type, \u0026arg_type, \u0026mut inferred);\n\n        assert!(result.is_ok());\n        assert!(inferred.is_empty());\n    }\n\n    #[test]\n    fn test_types_equal_primitives() {\n        let span = Span::new(0, 0, 0, 0);\n\n        let num1 = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let num2 = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let str_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        assert!(types_equal(\u0026num1, \u0026num2));\n        assert!(!types_equal(\u0026num1, \u0026str_type));\n    }\n\n    #[test]\n    fn test_types_equal_references() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let ref1 = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n        let ref2 = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n\n        assert!(types_equal(\u0026ref1, \u0026ref2));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_conflict() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let x_id = interner.intern(\"x\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let param = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(x_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = infer_type_arguments(\u0026[type_param], \u0026[param], \u0026[number_type, string_type]);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":31}},{"line":15,"address":[],"length":0,"stats":{"Line":93}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":90}},{"line":25,"address":[],"length":0,"stats":{"Line":258}},{"line":26,"address":[],"length":0,"stats":{"Line":144}},{"line":29,"address":[],"length":0,"stats":{"Line":90}},{"line":33,"address":[],"length":0,"stats":{"Line":66}},{"line":34,"address":[],"length":0,"stats":{"Line":66}},{"line":36,"address":[],"length":0,"stats":{"Line":34}},{"line":37,"address":[],"length":0,"stats":{"Line":68}},{"line":40,"address":[],"length":0,"stats":{"Line":101}},{"line":42,"address":[],"length":0,"stats":{"Line":34}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":16}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":14}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":14}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":7}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":11}},{"line":178,"address":[],"length":0,"stats":{"Line":33}},{"line":179,"address":[],"length":0,"stats":{"Line":39}},{"line":180,"address":[],"length":0,"stats":{"Line":28}},{"line":181,"address":[],"length":0,"stats":{"Line":12}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":36}},{"line":184,"address":[],"length":0,"stats":{"Line":12}},{"line":185,"address":[],"length":0,"stats":{"Line":24}},{"line":186,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":42}},{"line":214,"address":[],"length":0,"stats":{"Line":22}},{"line":215,"address":[],"length":0,"stats":{"Line":11}},{"line":216,"address":[],"length":0,"stats":{"Line":22}},{"line":217,"address":[],"length":0,"stats":{"Line":11}},{"line":219,"address":[],"length":0,"stats":{"Line":11}},{"line":225,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":32}},{"line":243,"address":[],"length":0,"stats":{"Line":12}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":18}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":273,"address":[],"length":0,"stats":{"Line":36}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":276,"address":[],"length":0,"stats":{"Line":9}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":27}},{"line":284,"address":[],"length":0,"stats":{"Line":67}},{"line":285,"address":[],"length":0,"stats":{"Line":22}},{"line":286,"address":[],"length":0,"stats":{"Line":44}},{"line":291,"address":[],"length":0,"stats":{"Line":9}},{"line":293,"address":[],"length":0,"stats":{"Line":21}},{"line":294,"address":[],"length":0,"stats":{"Line":12}},{"line":295,"address":[],"length":0,"stats":{"Line":24}},{"line":296,"address":[],"length":0,"stats":{"Line":12}},{"line":297,"address":[],"length":0,"stats":{"Line":17}},{"line":298,"address":[],"length":0,"stats":{"Line":12}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":13}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":44}},{"line":318,"address":[],"length":0,"stats":{"Line":22}},{"line":321,"address":[],"length":0,"stats":{"Line":22}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":44}},{"line":332,"address":[],"length":0,"stats":{"Line":11}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":3}},{"line":386,"address":[],"length":0,"stats":{"Line":9}},{"line":387,"address":[],"length":0,"stats":{"Line":4}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":390,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":11}},{"line":396,"address":[],"length":0,"stats":{"Line":8}},{"line":398,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":1}},{"line":571,"address":[],"length":0,"stats":{"Line":2}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}},{"line":580,"address":[],"length":0,"stats":{"Line":1}},{"line":581,"address":[],"length":0,"stats":{"Line":1}},{"line":582,"address":[],"length":0,"stats":{"Line":1}},{"line":587,"address":[],"length":0,"stats":{"Line":1}},{"line":593,"address":[],"length":0,"stats":{"Line":2}},{"line":594,"address":[],"length":0,"stats":{"Line":2}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":1}},{"line":765,"address":[],"length":0,"stats":{"Line":1}},{"line":769,"address":[],"length":0,"stats":{"Line":2}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}}],"covered":175,"coverable":425},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","types","mod.rs"],"content":"pub mod generics;\npub mod utility_types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","types","utility_types.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::expression::Literal;\nuse typedlua_parser::ast::statement::{IndexKeyType, PropertySignature};\nuse typedlua_parser::ast::types::{\n    MappedType, MappedTypeModifier, ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind,\n};\nuse typedlua_parser::ast::Ident;\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\nuse crate::core::type_environment::TypeEnvironment;\n\n/// Apply a utility type transformation\npub fn apply_utility_type(\n    name: \u0026str,\n    type_args: \u0026[Type],\n    span: Span,\n    interner: \u0026StringInterner,\n    common_ids: \u0026typedlua_parser::string_interner::CommonIdentifiers,\n) -\u003e Result\u003cType, String\u003e {\n    match name {\n        \"Partial\" =\u003e partial(type_args, span),\n        \"Required\" =\u003e required(type_args, span),\n        \"Readonly\" =\u003e readonly(type_args, span),\n        \"Record\" =\u003e record(type_args, span, interner, common_ids),\n        \"Pick\" =\u003e pick(type_args, span, interner),\n        \"Omit\" =\u003e omit(type_args, span, interner),\n        \"Exclude\" =\u003e exclude(type_args, span),\n        \"Extract\" =\u003e extract(type_args, span),\n        \"NonNilable\" =\u003e non_nilable(type_args, span),\n        \"Nilable\" =\u003e nilable(type_args, span),\n        \"ReturnType\" =\u003e return_type(type_args, span),\n        \"Parameters\" =\u003e parameters(type_args, span),\n        _ =\u003e Err(format!(\"Unknown utility type: {}\", name)),\n    }\n}\n\n/// Partial\u003cT\u003e - Makes all properties in T optional\nfn partial(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Partial\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            let new_members = obj\n                .members\n                .iter()\n                .map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                is_readonly: prop.is_readonly,\n                                name: prop.name.clone(),\n                                is_optional: true, // Make optional\n                                type_annotation: prop.type_annotation.clone(),\n                                span: prop.span,\n                            })\n                        }\n                        // Methods and index signatures remain unchanged\n                        other =\u003e other.clone(),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Partial\u003cT\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Required\u003cT\u003e - Makes all properties in T required (non-optional)\nfn required(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Required\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            let new_members = obj\n                .members\n                .iter()\n                .map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                is_readonly: prop.is_readonly,\n                                name: prop.name.clone(),\n                                is_optional: false, // Make required\n                                type_annotation: prop.type_annotation.clone(),\n                                span: prop.span,\n                            })\n                        }\n                        other =\u003e other.clone(),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Required\u003cT\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Readonly\u003cT\u003e - Makes all properties in T readonly\nfn readonly(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Readonly\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            let new_members = obj\n                .members\n                .iter()\n                .map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                is_readonly: true, // Make readonly\n                                name: prop.name.clone(),\n                                is_optional: prop.is_optional,\n                                type_annotation: prop.type_annotation.clone(),\n                                span: prop.span,\n                            })\n                        }\n                        other =\u003e other.clone(),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        TypeKind::Array(_) =\u003e {\n            // For arrays, we can wrap in a readonly wrapper\n            // but for now, just return the same array (Lua doesn't enforce readonly)\n            Ok(typ.clone())\n        }\n        _ =\u003e Err(\"Readonly\u003cT\u003e requires T to be an object or array type\".to_string()),\n    }\n}\n\n/// Record\u003cK, V\u003e - Constructs an object type with keys of type K and values of type V\nfn record(\n    type_args: \u0026[Type],\n    span: Span,\n    _interner: \u0026StringInterner,\n    common_ids: \u0026typedlua_parser::string_interner::CommonIdentifiers,\n) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Record\u003cK, V\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let key_type = \u0026type_args[0];\n    let value_type = \u0026type_args[1];\n\n    // Validate key type is string or number and determine IndexKeyType\n    let index_key_type = match \u0026key_type.kind {\n        TypeKind::Primitive(PrimitiveType::String) | TypeKind::Literal(Literal::String(_)) =\u003e {\n            IndexKeyType::String\n        }\n        TypeKind::Primitive(PrimitiveType::Number)\n        | TypeKind::Primitive(PrimitiveType::Integer)\n        | TypeKind::Literal(Literal::Number(_)) =\u003e IndexKeyType::Number,\n        TypeKind::Union(types) =\u003e {\n            // Check if all union members are string literals\n            if types\n                .iter()\n                .all(|t| matches!(t.kind, TypeKind::Literal(Literal::String(_))))\n            {\n                IndexKeyType::String\n            } else {\n                return Err(\n                    \"Record\u003cK, V\u003e requires K to be string, number, or a union of string literals\"\n                        .to_string(),\n                );\n            }\n        }\n        _ =\u003e {\n            return Err(\n                \"Record\u003cK, V\u003e requires K to be string, number, or a union of string literals\"\n                    .to_string(),\n            )\n        }\n    };\n\n    // Create an object type with an index signature\n    use typedlua_parser::ast::statement::IndexSignature;\n    use typedlua_parser::ast::Ident;\n\n    let key_id = common_ids.key;\n    let index_sig = IndexSignature {\n        key_name: Ident::new(key_id, span),\n        key_type: index_key_type,\n        value_type: value_type.clone(),\n        span,\n    };\n\n    Ok(Type::new(\n        TypeKind::Object(ObjectType {\n            members: vec![ObjectTypeMember::Index(index_sig)],\n            span,\n        }),\n        span,\n    ))\n}\n\n/// Pick\u003cT, K\u003e - Picks a subset of properties from T\nfn pick(type_args: \u0026[Type], span: Span, interner: \u0026StringInterner) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Pick\u003cT, K\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let keys = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            // Extract the property names to pick\n            let keys_to_pick = extract_string_literal_keys(keys)?;\n\n            let new_members: Vec\u003cObjectTypeMember\u003e = obj\n                .members\n                .iter()\n                .filter_map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            // Use interner to resolve StringId to actual string value\n                            let prop_name = interner.resolve(prop.name.node);\n                            if keys_to_pick.contains(\u0026prop_name) {\n                                Some(member.clone())\n                            } else {\n                                None\n                            }\n                        }\n                        // Don't pick methods or index signatures\n                        _ =\u003e None,\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Pick\u003cT, K\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Omit\u003cT, K\u003e - Omits properties from T\nfn omit(type_args: \u0026[Type], span: Span, interner: \u0026StringInterner) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Omit\u003cT, K\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let keys = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            // Extract the property names to omit\n            let keys_to_omit = extract_string_literal_keys(keys)?;\n\n            let new_members: Vec\u003cObjectTypeMember\u003e = obj\n                .members\n                .iter()\n                .filter_map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            // Use interner to resolve StringId to actual string value\n                            let prop_name = interner.resolve(prop.name.node);\n                            if !keys_to_omit.contains(\u0026prop_name) {\n                                Some(member.clone())\n                            } else {\n                                None\n                            }\n                        }\n                        // Keep methods and index signatures\n                        other =\u003e Some(other.clone()),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Omit\u003cT, K\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Exclude\u003cT, U\u003e - Excludes types from a union T that are assignable to U\nfn exclude(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Exclude\u003cT, U\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let exclude_type = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let remaining: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !is_assignable_to(t, exclude_type))\n                .cloned()\n                .collect();\n\n            if remaining.is_empty() {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else if remaining.len() == 1 {\n                Ok(remaining[0].clone())\n            } else {\n                Ok(Type::new(TypeKind::Union(remaining), span))\n            }\n        }\n        _ =\u003e {\n            // If T is not a union, check if it's assignable to U\n            if is_assignable_to(typ, exclude_type) {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else {\n                Ok(typ.clone())\n            }\n        }\n    }\n}\n\n/// Extract\u003cT, U\u003e - Extracts types from a union T that are assignable to U\nfn extract(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Extract\u003cT, U\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let extract_type = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let extracted: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| is_assignable_to(t, extract_type))\n                .cloned()\n                .collect();\n\n            if extracted.is_empty() {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else if extracted.len() == 1 {\n                Ok(extracted[0].clone())\n            } else {\n                Ok(Type::new(TypeKind::Union(extracted), span))\n            }\n        }\n        _ =\u003e {\n            // If T is not a union, check if it's assignable to U\n            if is_assignable_to(typ, extract_type) {\n                Ok(typ.clone())\n            } else {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            }\n        }\n    }\n}\n\n/// NonNilable\u003cT\u003e - Removes nil and void from a type\nfn non_nilable(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"NonNilable\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let non_nil: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !is_nil_or_void(t))\n                .cloned()\n                .collect();\n\n            if non_nil.is_empty() {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else if non_nil.len() == 1 {\n                Ok(non_nil[0].clone())\n            } else {\n                Ok(Type::new(TypeKind::Union(non_nil), span))\n            }\n        }\n        TypeKind::Nullable(inner) =\u003e Ok((**inner).clone()),\n        _ =\u003e {\n            if is_nil_or_void(typ) {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else {\n                Ok(typ.clone())\n            }\n        }\n    }\n}\n\n/// Nilable\u003cT\u003e - Adds nil to a type (equivalent to T | nil)\nfn nilable(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Nilable\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    // Check if it's already nilable\n    if is_nil_or_void(typ) {\n        return Ok(typ.clone());\n    }\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            // Check if nil is already in the union\n            if types.iter().any(is_nil_or_void) {\n                Ok(typ.clone())\n            } else {\n                let mut new_types = types.clone();\n                new_types.push(Type::new(TypeKind::Primitive(PrimitiveType::Nil), span));\n                Ok(Type::new(TypeKind::Union(new_types), span))\n            }\n        }\n        TypeKind::Nullable(_) =\u003e {\n            // Already nullable\n            Ok(typ.clone())\n        }\n        _ =\u003e Ok(Type::new(\n            TypeKind::Union(vec![\n                typ.clone(),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), span),\n            ]),\n            span,\n        )),\n    }\n}\n\n/// ReturnType\u003cF\u003e - Extracts the return type from a function type\nfn return_type(type_args: \u0026[Type], _span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"ReturnType\u003cF\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    match \u0026typ.kind {\n        TypeKind::Function(ref func) =\u003e Ok((*func.return_type).clone()),\n        _ =\u003e Err(\"ReturnType\u003cF\u003e requires F to be a function type\".to_string()),\n    }\n}\n\n/// Parameters\u003cF\u003e - Extracts parameter types from a function as a tuple\nfn parameters(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Parameters\u003cF\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    match \u0026typ.kind {\n        TypeKind::Function(ref func) =\u003e {\n            let param_types: Vec\u003cType\u003e = func\n                .parameters\n                .iter()\n                .filter_map(|p| p.type_annotation.clone())\n                .collect();\n\n            Ok(Type::new(TypeKind::Tuple(param_types), span))\n        }\n        _ =\u003e Err(\"Parameters\u003cF\u003e requires F to be a function type\".to_string()),\n    }\n}\n\n/// Evaluate a mapped type: { [K in T]: V }\n/// Transforms the mapped type into a concrete object type\npub fn evaluate_mapped_type(\n    mapped: \u0026MappedType,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, String\u003e {\n    // Resolve the 'in' type if it's a KeyOf expression\n    let in_type_resolved = match \u0026mapped.in_type.kind {\n        TypeKind::KeyOf(operand) =\u003e {\n            // Evaluate keyof to get the union of string literals\n            evaluate_keyof(operand, type_env, interner)?\n        }\n        _ =\u003e (*mapped.in_type).clone(),\n    };\n\n    // Extract the keys from the resolved 'in' clause\n    let keys = extract_keys_from_type(\u0026in_type_resolved, type_env, interner)?;\n\n    let members: Vec\u003c_\u003e = keys\n        .iter()\n        .map(|key| {\n            let key_id = interner.intern(key);\n\n            // Determine readonly status based on modifier\n            let is_readonly = match mapped.readonly_modifier {\n                MappedTypeModifier::Add =\u003e true,\n                MappedTypeModifier::Remove =\u003e false,\n                MappedTypeModifier::None =\u003e false,\n            };\n\n            // Determine optional status based on modifier\n            let is_optional = match mapped.optional_modifier {\n                MappedTypeModifier::Add =\u003e true,\n                MappedTypeModifier::Remove =\u003e false,\n                MappedTypeModifier::None =\u003e false,\n            };\n\n            ObjectTypeMember::Property(PropertySignature {\n                is_readonly,\n                name: Ident::new(key_id, mapped.span),\n                is_optional,\n                type_annotation: (*mapped.value_type).clone(),\n                span: mapped.span,\n            })\n        })\n        .collect();\n\n    Ok(Type::new(\n        TypeKind::Object(ObjectType {\n            members,\n            span: mapped.span,\n        }),\n        mapped.span,\n    ))\n}\n\n/// Evaluate keyof operator - extracts property names from an object type\npub fn evaluate_keyof(\n    typ: \u0026Type,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, String\u003e {\n    // Resolve type reference first\n    let resolved_type = match \u0026typ.kind {\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = interner.resolve(type_ref.name.node);\n            match type_env.lookup_type(\u0026type_name) {\n                Some(t) =\u003e t.clone(),\n                None =\u003e return Err(format!(\"Type '{}' not found\", type_name)),\n            }\n        }\n        _ =\u003e typ.clone(),\n    };\n\n    match \u0026resolved_type.kind {\n        TypeKind::Object(obj) =\u003e {\n            let keys: Vec\u003c_\u003e = obj\n                .members\n                .iter()\n                .filter_map(|member| match member {\n                    ObjectTypeMember::Property(prop) =\u003e Some(Type::new(\n                        TypeKind::Literal(Literal::String(prop.name.node.to_string())),\n                        prop.span,\n                    )),\n                    ObjectTypeMember::Method(method) =\u003e Some(Type::new(\n                        TypeKind::Literal(Literal::String(method.name.node.to_string())),\n                        method.span,\n                    )),\n                    // Index signatures don't contribute to keyof\n                    ObjectTypeMember::Index(_) =\u003e None,\n                })\n                .collect();\n\n            if keys.is_empty() {\n                Ok(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if keys.len() == 1 {\n                Ok(keys.into_iter().next().unwrap())\n            } else {\n                Ok(Type::new(TypeKind::Union(keys), resolved_type.span))\n            }\n        }\n        _ =\u003e Err(format!(\n            \"keyof requires an object type, got {:?}\",\n            resolved_type.kind\n        )),\n    }\n}\n\n/// Evaluate a conditional type: T extends U ? X : Y\n/// Also handles infer keyword: T extends Array\u003cinfer U\u003e ? U : never\npub fn evaluate_conditional_type(\n    conditional: \u0026typedlua_parser::ast::types::ConditionalType,\n    type_env: \u0026TypeEnvironment,\n) -\u003e Result\u003cType, String\u003e {\n    use crate::core::type_compat::TypeCompatibility;\n    use rustc_hash::FxHashMap;\n\n    // Check if check_type extends extends_type\n    let check_type = \u0026conditional.check_type;\n    let extends_type = \u0026conditional.extends_type;\n\n    // Check if extends_type contains infer - if so, we need pattern matching\n    let mut inferred_types: FxHashMap\u003cString, Type\u003e = FxHashMap::default();\n    let has_infer = contains_infer(extends_type);\n\n    if has_infer {\n        // Try to match check_type against extends_type pattern and extract inferred types\n        if try_match_and_infer(check_type, extends_type, \u0026mut inferred_types, type_env) {\n            // Match succeeded - evaluate true branch with inferred types\n            return substitute_inferred_types(\u0026conditional.true_type, \u0026inferred_types);\n        } else {\n            // Match failed - return false branch\n            return Ok((*conditional.false_type).clone());\n        }\n    }\n\n    // Handle distributive conditional types\n    // If check_type is a union, distribute the conditional over each member\n    if let TypeKind::Union(union_types) = \u0026check_type.kind {\n        let result_types: Vec\u003c_\u003e = union_types\n            .iter()\n            .map(|member_type| {\n                // Create a new conditional for each union member\n                let member_conditional = typedlua_parser::ast::types::ConditionalType {\n                    check_type: Box::new(member_type.clone()),\n                    extends_type: conditional.extends_type.clone(),\n                    true_type: conditional.true_type.clone(),\n                    false_type: conditional.false_type.clone(),\n                    span: conditional.span,\n                };\n\n                evaluate_conditional_type(\u0026member_conditional, type_env)\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        // If all results are the same, return just one\n        // Otherwise, return a union\n        if result_types.len() == 1 {\n            return Ok(result_types.into_iter().next().unwrap());\n        }\n\n        // Check if all types are the same (simplified check)\n        let all_same = result_types\n            .windows(2)\n            .all(|w| types_structurally_equal(\u0026w[0], \u0026w[1]));\n\n        if all_same {\n            return Ok(result_types.into_iter().next().unwrap());\n        }\n\n        return Ok(Type::new(TypeKind::Union(result_types), conditional.span));\n    }\n\n    // Resolve type references for comparison\n    let resolved_check = resolve_type_reference(check_type, type_env);\n    let resolved_extends = resolve_type_reference(extends_type, type_env);\n\n    // Check assignability: does check_type extend extends_type?\n    if TypeCompatibility::is_assignable(\u0026resolved_check, \u0026resolved_extends) {\n        Ok((*conditional.true_type).clone())\n    } else {\n        Ok((*conditional.false_type).clone())\n    }\n}\n\n/// Helper to resolve type references\nfn resolve_type_reference(typ: \u0026Type, type_env: \u0026TypeEnvironment) -\u003e Type {\n    match \u0026typ.kind {\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = type_ref.name.node.to_string();\n            match type_env.lookup_type(\u0026type_name) {\n                Some(t) =\u003e t.clone(),\n                None =\u003e typ.clone(), // Can't resolve, use as-is\n            }\n        }\n        _ =\u003e typ.clone(),\n    }\n}\n\n/// Helper to check if two types are structurally equal (simplified)\nfn types_structurally_equal(t1: \u0026Type, t2: \u0026Type) -\u003e bool {\n    match (\u0026t1.kind, \u0026t2.kind) {\n        (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) =\u003e p1 == p2,\n        (TypeKind::Literal(l1), TypeKind::Literal(l2)) =\u003e l1 == l2,\n        (TypeKind::Reference(r1), TypeKind::Reference(r2)) =\u003e r1.name.node == r2.name.node,\n        (TypeKind::Array(a1), TypeKind::Array(a2)) =\u003e types_structurally_equal(a1, a2),\n        _ =\u003e false,\n    }\n}\n\n/// Check if a type contains an infer keyword\nfn contains_infer(typ: \u0026Type) -\u003e bool {\n    match \u0026typ.kind {\n        TypeKind::Infer(_) =\u003e true,\n        TypeKind::Array(elem) =\u003e contains_infer(elem),\n        TypeKind::Union(types) | TypeKind::Intersection(types) | TypeKind::Tuple(types) =\u003e {\n            types.iter().any(contains_infer)\n        }\n        TypeKind::Function(func) =\u003e {\n            func.parameters\n                .iter()\n                .any(|p| p.type_annotation.as_ref().is_some_and(contains_infer))\n                || contains_infer(\u0026func.return_type)\n        }\n        TypeKind::Reference(type_ref) =\u003e type_ref\n            .type_arguments\n            .as_ref()\n            .is_some_and(|args| args.iter().any(contains_infer)),\n        _ =\u003e false,\n    }\n}\n\n/// Try to match a check_type against a pattern (extends_type) and extract inferred types\nfn try_match_and_infer(\n    check_type: \u0026Type,\n    pattern: \u0026Type,\n    inferred: \u0026mut FxHashMap\u003cString, Type\u003e,\n    type_env: \u0026TypeEnvironment,\n) -\u003e bool {\n    match \u0026pattern.kind {\n        // If pattern is `infer R`, capture the check_type as R\n        TypeKind::Infer(name) =\u003e {\n            inferred.insert(name.node.to_string(), check_type.clone());\n            true\n        }\n\n        // Array pattern: T[] matches against Array\u003cU\u003e\n        TypeKind::Array(pattern_elem) =\u003e {\n            if let TypeKind::Array(check_elem) = \u0026check_type.kind {\n                try_match_and_infer(check_elem, pattern_elem, inferred, type_env)\n            } else {\n                false\n            }\n        }\n\n        // Type reference with type arguments: Foo\u003cinfer R\u003e\n        TypeKind::Reference(pattern_ref) =\u003e {\n            // Resolve check_type if it's a reference\n            let resolved_check = resolve_type_reference(check_type, type_env);\n\n            if let TypeKind::Reference(check_ref) = \u0026resolved_check.kind {\n                // Names must match\n                if pattern_ref.name.node != check_ref.name.node {\n                    return false;\n                }\n\n                // Match type arguments\n                match (\u0026pattern_ref.type_arguments, \u0026check_ref.type_arguments) {\n                    (Some(pattern_args), Some(check_args)) =\u003e {\n                        if pattern_args.len() != check_args.len() {\n                            return false;\n                        }\n                        pattern_args\n                            .iter()\n                            .zip(check_args.iter())\n                            .all(|(p, c)| try_match_and_infer(c, p, inferred, type_env))\n                    }\n                    (None, None) =\u003e true,\n                    _ =\u003e false,\n                }\n            } else {\n                false\n            }\n        }\n\n        // Function type pattern\n        TypeKind::Function(pattern_func) =\u003e {\n            if let TypeKind::Function(check_func) = \u0026check_type.kind {\n                // Match parameters\n                if pattern_func.parameters.len() != check_func.parameters.len() {\n                    return false;\n                }\n\n                let params_match = pattern_func\n                    .parameters\n                    .iter()\n                    .zip(check_func.parameters.iter())\n                    .all(|(p_param, c_param)| {\n                        match (\u0026p_param.type_annotation, \u0026c_param.type_annotation) {\n                            (Some(p_type), Some(c_type)) =\u003e {\n                                try_match_and_infer(c_type, p_type, inferred, type_env)\n                            }\n                            _ =\u003e true,\n                        }\n                    });\n\n                params_match\n                    \u0026\u0026 try_match_and_infer(\n                        \u0026check_func.return_type,\n                        \u0026pattern_func.return_type,\n                        inferred,\n                        type_env,\n                    )\n            } else {\n                false\n            }\n        }\n\n        // Tuple pattern\n        TypeKind::Tuple(pattern_types) =\u003e {\n            if let TypeKind::Tuple(check_types) = \u0026check_type.kind {\n                if pattern_types.len() != check_types.len() {\n                    return false;\n                }\n                pattern_types\n                    .iter()\n                    .zip(check_types.iter())\n                    .all(|(p, c)| try_match_and_infer(c, p, inferred, type_env))\n            } else {\n                false\n            }\n        }\n\n        // For other patterns, just check type equality\n        _ =\u003e {\n            use crate::core::type_compat::TypeCompatibility;\n            TypeCompatibility::is_assignable(check_type, pattern)\n        }\n    }\n}\n\n/// Substitute inferred type variables in a type\nfn substitute_inferred_types(\n    typ: \u0026Type,\n    inferred: \u0026FxHashMap\u003cString, Type\u003e,\n) -\u003e Result\u003cType, String\u003e {\n    match \u0026typ.kind {\n        // If it's a reference to an inferred type variable, substitute it\n        TypeKind::Reference(type_ref) if type_ref.type_arguments.is_none() =\u003e {\n            let type_name = type_ref.name.node.to_string();\n            if let Some(inferred_type) = inferred.get(\u0026type_name) {\n                Ok(inferred_type.clone())\n            } else {\n                Ok(typ.clone())\n            }\n        }\n\n        // Recursively substitute in compound types\n        TypeKind::Array(elem) =\u003e {\n            let substituted_elem = substitute_inferred_types(elem, inferred)?;\n            Ok(Type::new(\n                TypeKind::Array(Box::new(substituted_elem)),\n                typ.span,\n            ))\n        }\n\n        TypeKind::Union(types) =\u003e {\n            let substituted: Result\u003cVec\u003c_\u003e, _\u003e = types\n                .iter()\n                .map(|t| substitute_inferred_types(t, inferred))\n                .collect();\n            Ok(Type::new(TypeKind::Union(substituted?), typ.span))\n        }\n\n        TypeKind::Intersection(types) =\u003e {\n            let substituted: Result\u003cVec\u003c_\u003e, _\u003e = types\n                .iter()\n                .map(|t| substitute_inferred_types(t, inferred))\n                .collect();\n            Ok(Type::new(TypeKind::Intersection(substituted?), typ.span))\n        }\n\n        TypeKind::Tuple(types) =\u003e {\n            let substituted: Result\u003cVec\u003c_\u003e, _\u003e = types\n                .iter()\n                .map(|t| substitute_inferred_types(t, inferred))\n                .collect();\n            Ok(Type::new(TypeKind::Tuple(substituted?), typ.span))\n        }\n\n        // For other types, return as-is\n        _ =\u003e Ok(typ.clone()),\n    }\n}\n\n/// Extract keys from a type for mapped type iteration\n/// Currently supports: string literal unions and type references to them\nfn extract_keys_from_type(\n    typ: \u0026Type,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    match \u0026typ.kind {\n        TypeKind::Literal(Literal::String(s)) =\u003e Ok(vec![s.clone()]),\n        TypeKind::Union(types) =\u003e {\n            let mut keys = Vec::new();\n            for t in types {\n                match \u0026t.kind {\n                    TypeKind::Literal(Literal::String(s)) =\u003e {\n                        keys.push(s.clone());\n                    }\n                    TypeKind::Reference(type_ref) =\u003e {\n                        let type_name = interner.resolve(type_ref.name.node).to_string();\n                        match type_env.lookup_type(\u0026type_name) {\n                            Some(resolved_type) =\u003e {\n                                let resolved_keys =\n                                    extract_keys_from_type(resolved_type, type_env, interner)?;\n                                keys.extend(resolved_keys);\n                            }\n                            None =\u003e {\n                                return Err(format!(\n                                    \"Type '{}' not found in type environment\",\n                                    type_name\n                                ));\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        return Err(\n                            \"Mapped type currently only supports string literal unions\".to_string()\n                        );\n                    }\n                }\n            }\n            Ok(keys)\n        }\n        // Type reference - resolve it using the type environment\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = interner.resolve(type_ref.name.node).to_string();\n            match type_env.lookup_type(\u0026type_name) {\n                Some(resolved_type) =\u003e extract_keys_from_type(resolved_type, type_env, interner),\n                None =\u003e Err(format!(\n                    \"Type '{}' not found in type environment\",\n                    type_name\n                )),\n            }\n        }\n        // Future: support keyof T\n        _ =\u003e Err(\n            \"Mapped type 'in' clause must be a string literal or union of string literals\"\n                .to_string(),\n        ),\n    }\n}\n\n// Helper functions\n\n/// Extract string literal keys from a type (for Pick/Omit)\nfn extract_string_literal_keys(typ: \u0026Type) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    match \u0026typ.kind {\n        TypeKind::Literal(Literal::String(s)) =\u003e Ok(vec![s.clone()]),\n        TypeKind::Union(types) =\u003e types\n            .iter()\n            .map(|t| match \u0026t.kind {\n                TypeKind::Literal(Literal::String(s)) =\u003e Ok(s.clone()),\n                _ =\u003e Err(\n                    \"Pick/Omit key type must be string literal or union of string literals\"\n                        .to_string(),\n                ),\n            })\n            .collect(),\n        _ =\u003e {\n            Err(\"Pick/Omit key type must be string literal or union of string literals\".to_string())\n        }\n    }\n}\n\n/// Check if a type is nil or void\nfn is_nil_or_void(typ: \u0026Type) -\u003e bool {\n    matches!(\n        typ.kind,\n        TypeKind::Primitive(PrimitiveType::Nil) | TypeKind::Primitive(PrimitiveType::Void)\n    )\n}\n\n/// Simple type assignability check\nfn is_assignable_to(source: \u0026Type, target: \u0026Type) -\u003e bool {\n    use crate::core::type_compat::TypeCompatibility;\n    TypeCompatibility::is_assignable(source, target)\n}\n\n/// Evaluate a template literal type to a union of string literals\n/// For example: `Hello ${T}` where T = \"World\" | \"Rust\" becomes \"Hello World\" | \"Hello Rust\"\npub fn evaluate_template_literal_type(\n    template: \u0026typedlua_parser::ast::types::TemplateLiteralType,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, String\u003e {\n    use typedlua_parser::ast::types::TemplateLiteralTypePart;\n\n    // Extract all interpolated types and get their possible values\n    let mut part_expansions: Vec\u003cVec\u003cString\u003e\u003e = Vec::new();\n\n    for part in \u0026template.parts {\n        match part {\n            TemplateLiteralTypePart::String(s) =\u003e {\n                // Static string - single value\n                part_expansions.push(vec![s.clone()]);\n            }\n            TemplateLiteralTypePart::Type(ty) =\u003e {\n                // Type interpolation - expand to all possible string values\n                let values = expand_type_to_strings(ty, type_env, interner)?;\n                if values.is_empty() {\n                    return Err(\n                        \"Template literal type interpolation produced no values\".to_string()\n                    );\n                }\n                part_expansions.push(values);\n            }\n        }\n    }\n\n    // Generate all combinations\n    let combinations = cartesian_product(\u0026part_expansions);\n\n    // Limit the number of combinations to prevent exponential explosion\n    // TypeScript uses 100,000 as the limit\n    const MAX_TEMPLATE_LITERAL_COMBINATIONS: usize = 10000;\n\n    if combinations.len() \u003e MAX_TEMPLATE_LITERAL_COMBINATIONS {\n        return Err(format!(\n            \"Template literal type expansion resulted in {} combinations, which exceeds the limit of {}. \\\n             Consider using a broader type like 'string' instead.\",\n            combinations.len(),\n            MAX_TEMPLATE_LITERAL_COMBINATIONS\n        ));\n    }\n\n    // If there's only one combination, return a single string literal\n    // Otherwise, return a union of string literals\n    if combinations.len() == 1 {\n        Ok(Type::new(\n            TypeKind::Literal(Literal::String(combinations[0].clone())),\n            template.span,\n        ))\n    } else {\n        let literal_types: Vec\u003cType\u003e = combinations\n            .into_iter()\n            .map(|s| Type::new(TypeKind::Literal(Literal::String(s)), template.span))\n            .collect();\n\n        Ok(Type::new(TypeKind::Union(literal_types), template.span))\n    }\n}\n\n/// Expand a type to all possible string literal values\nfn expand_type_to_strings(\n    ty: \u0026Type,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    // First resolve any type references\n    let resolved = match \u0026ty.kind {\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = interner.resolve(type_ref.name.node).to_string();\n            if let Some(resolved) = type_env.lookup_type(\u0026type_name) {\n                resolved\n            } else {\n                ty\n            }\n        }\n        _ =\u003e ty,\n    };\n\n    match \u0026resolved.kind {\n        TypeKind::Literal(Literal::String(s)) =\u003e Ok(vec![s.clone()]),\n        TypeKind::Literal(Literal::Number(n)) =\u003e Ok(vec![n.to_string()]),\n        TypeKind::Literal(Literal::Boolean(b)) =\u003e Ok(vec![b.to_string()]),\n        TypeKind::Literal(Literal::Nil) =\u003e Ok(vec![\"nil\".to_string()]),\n        TypeKind::Primitive(PrimitiveType::String) =\u003e {\n            Err(\"Cannot interpolate primitive string type in template literal - use string literal union instead\".to_string())\n        }\n        TypeKind::Primitive(PrimitiveType::Number) =\u003e {\n            Err(\"Cannot interpolate primitive number type in template literal - use number literal union instead\".to_string())\n        }\n        TypeKind::Union(types) =\u003e types\n            .iter()\n            .map(|t| expand_type_to_strings(t, type_env, interner))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .map(|v| v.into_iter().flatten().collect()),\n        _ =\u003e Err(format!(\n            \"Cannot interpolate type {:?} in template literal - only string/number/boolean literals and unions are supported\",\n            resolved.kind\n        )),\n    }\n}\n\n/// Generate cartesian product of string vectors\n/// For example: [[\"a\", \"b\"], [\"1\", \"2\"]] -\u003e [\"a1\", \"a2\", \"b1\", \"b2\"]\nfn cartesian_product(vecs: \u0026[Vec\u003cString\u003e]) -\u003e Vec\u003cString\u003e {\n    if vecs.is_empty() {\n        return vec![String::new()];\n    }\n\n    if vecs.len() == 1 {\n        return vecs[0].clone();\n    }\n\n    vecs.iter().fold(vec![String::new()], |acc, v| {\n        acc.iter()\n            .flat_map(|existing| {\n                v.iter().map(move |item| {\n                    let mut new_item = existing.clone();\n                    new_item.push_str(item);\n                    new_item\n                })\n            })\n            .collect()\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::Ident;\n\n    fn make_span() -\u003e Span {\n        Span::new(0, 0, 0, 0)\n    }\n\n    fn make_object_type(properties: Vec\u003c(\u0026str, Type, bool, bool)\u003e) -\u003e Type {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        make_object_type_with_interner(\u0026interner, properties)\n    }\n\n    fn make_object_type_with_interner(\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n        properties: Vec\u003c(\u0026str, Type, bool, bool)\u003e,\n    ) -\u003e Type {\n        let members = properties\n            .into_iter()\n            .map(|(name, typ, optional, readonly)| {\n                let name_id = interner.intern(name);\n                ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: readonly,\n                    name: Ident::new(name_id, make_span()),\n                    is_optional: optional,\n                    type_annotation: typ,\n                    span: make_span(),\n                })\n            })\n            .collect();\n\n        Type::new(\n            TypeKind::Object(ObjectType {\n                members,\n                span: make_span(),\n            }),\n            make_span(),\n        )\n    }\n\n    #[test]\n    fn test_partial() {\n        let obj = make_object_type(vec![\n            (\n                \"name\",\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                false,\n                false,\n            ),\n            (\n                \"age\",\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                false,\n                false,\n            ),\n        ]);\n\n        let result = partial(\u0026[obj], make_span()).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            for member in \u0026obj_type.members {\n                if let ObjectTypeMember::Property(prop) = member {\n                    assert!(\n                        prop.is_optional,\n                        \"Property {} should be optional\",\n                        prop.name.node\n                    );\n                }\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_required() {\n        let obj = make_object_type(vec![\n            (\n                \"name\",\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                true,\n                false,\n            ),\n            (\n                \"age\",\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                true,\n                false,\n            ),\n        ]);\n\n        let result = required(\u0026[obj], make_span()).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            for member in \u0026obj_type.members {\n                if let ObjectTypeMember::Property(prop) = member {\n                    assert!(\n                        !prop.is_optional,\n                        \"Property {} should be required\",\n                        prop.name.node\n                    );\n                }\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_readonly() {\n        let obj = make_object_type(vec![\n            (\n                \"name\",\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                false,\n                false,\n            ),\n            (\n                \"age\",\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                false,\n                false,\n            ),\n        ]);\n\n        let result = readonly(\u0026[obj], make_span()).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            for member in \u0026obj_type.members {\n                if let ObjectTypeMember::Property(prop) = member {\n                    assert!(\n                        prop.is_readonly,\n                        \"Property {} should be readonly\",\n                        prop.name.node\n                    );\n                }\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_record() {\n        let key_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            assert!(matches!(obj_type.members[0], ObjectTypeMember::Index(_)));\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_exclude() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n        let exclude = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = self::exclude(\u0026[union, exclude], make_span()).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n            assert!(types\n                .iter()\n                .all(|t| !matches!(t.kind, TypeKind::Primitive(PrimitiveType::String))));\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_non_nilable() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = non_nilable(\u0026[union], make_span()).unwrap();\n\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_nilable() {\n        let typ = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let result = nilable(\u0026[typ], make_span()).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::String))));\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::Nil))));\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_return_type() {\n        use typedlua_parser::ast::types::FunctionType;\n\n        let func = Type::new(\n            TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    make_span(),\n                )),\n                throws: None,\n                span: make_span(),\n            }),\n            make_span(),\n        );\n\n        let result = return_type(\u0026[func], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_pick() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"email\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Pick\u003cObj, \"name\" | \"age\"\u003e\n        let keys = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"name\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"age\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n\n        let result = pick(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            // Should have name and age, but not email\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_pick_single_key() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Pick\u003cObj, \"name\"\u003e\n        let keys = Type::new(\n            TypeKind::Literal(Literal::String(\"name\".to_string())),\n            make_span(),\n        );\n\n        let result = pick(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_omit() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"email\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Omit\u003cObj, \"email\"\u003e\n        let keys = Type::new(\n            TypeKind::Literal(Literal::String(\"email\".to_string())),\n            make_span(),\n        );\n\n        let result = omit(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            // Should have name and age, but not email\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_omit_multiple_keys() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"email\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Omit\u003cObj, \"name\" | \"age\"\u003e\n        let keys = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"name\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"age\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n\n        let result = omit(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            // Should only have email\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Tests\n    // ========================================================================\n\n    #[test]\n    fn test_extract() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n        let extract_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = extract(\u0026[union, extract_type], make_span()).unwrap();\n\n        // Should extract just string\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_extract_multiple() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n\n        // Extract string | number\n        let extract_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = extract(\u0026[union, extract_type], make_span()).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_parameters() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n        use typedlua_parser::ast::types::FunctionType;\n\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n\n        let func = Type::new(\n            TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![\n                    Parameter {\n                        pattern: Pattern::Identifier(Ident::new(x_id, make_span())),\n                        type_annotation: Some(Type::new(\n                            TypeKind::Primitive(PrimitiveType::String),\n                            make_span(),\n                        )),\n                        default: None,\n                        is_rest: false,\n                        is_optional: false,\n                        span: make_span(),\n                    },\n                    Parameter {\n                        pattern: Pattern::Identifier(Ident::new(y_id, make_span())),\n                        type_annotation: Some(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Number),\n                            make_span(),\n                        )),\n                        default: None,\n                        is_rest: false,\n                        is_optional: false,\n                        span: make_span(),\n                    },\n                ],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Void),\n                    make_span(),\n                )),\n                throws: None,\n                span: make_span(),\n            }),\n            make_span(),\n        );\n\n        let result = parameters(\u0026[func], make_span()).unwrap();\n\n        if let TypeKind::Tuple(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n            assert!(matches!(\n                types[0].kind,\n                TypeKind::Primitive(PrimitiveType::String)\n            ));\n            assert!(matches!(\n                types[1].kind,\n                TypeKind::Primitive(PrimitiveType::Number)\n            ));\n        } else {\n            panic!(\"Expected tuple type\");\n        }\n    }\n\n    #[test]\n    fn test_apply_utility_type_partial() {\n        let obj = make_object_type(vec![(\n            \"name\",\n            Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n            false,\n            false,\n        )]);\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result =\n            apply_utility_type(\"Partial\", \u0026[obj], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            if let ObjectTypeMember::Property(prop) = \u0026obj_type.members[0] {\n                assert!(prop.is_optional);\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_apply_utility_type_unknown() {\n        let obj = make_object_type(vec![]);\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = apply_utility_type(\"UnknownType\", \u0026[obj], make_span(), \u0026interner, \u0026common_ids);\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Unknown utility type\"));\n    }\n\n    #[test]\n    fn test_partial_wrong_arg_count() {\n        let obj = make_object_type(vec![]);\n        let result = partial(\u0026[], make_span());\n        assert!(result.is_err());\n\n        let result = partial(\u0026[obj.clone(), obj], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_partial_non_object() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let result = partial(\u0026[string_type], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_required_wrong_arg_count() {\n        let _obj = make_object_type(vec![]);\n        let result = required(\u0026[], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_readonly_array() {\n        let array_type = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            ))),\n            make_span(),\n        );\n\n        let result = readonly(std::slice::from_ref(\u0026array_type), make_span()).unwrap();\n        // Arrays are returned as-is for now\n        assert!(matches!(result.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_record_number_keys() {\n        let key_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            if let ObjectTypeMember::Index(idx) = \u0026obj_type.members[0] {\n                assert!(matches!(idx.key_type, IndexKeyType::Number));\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_record_union_string_literals() {\n        // Record\u003c\"a\" | \"b\", number\u003e\n        let key_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"a\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"b\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            assert!(matches!(obj_type.members[0], ObjectTypeMember::Index(_)));\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_record_invalid_key_type() {\n        let key_type = Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span());\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_exclude_non_union() {\n        // Exclude\u003cstring, number\u003e should return string (since string is not assignable to number)\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let result = exclude(\u0026[string_type.clone(), number_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_all_types() {\n        // Exclude\u003cstring, string\u003e should return never\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = exclude(\u0026[string_type.clone(), string_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_extract_non_union_match() {\n        // Extract\u003cstring, string\u003e should return string\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = extract(\u0026[string_type.clone(), string_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_extract_non_union_no_match() {\n        // Extract\u003cstring, number\u003e should return never\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let result = extract(\u0026[string_type, number_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_non_nilable_nullable_type() {\n        let nullable = Type::new(\n            TypeKind::Nullable(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            ))),\n            make_span(),\n        );\n\n        let result = non_nilable(\u0026[nullable], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_non_nilable_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = non_nilable(\u0026[string_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_non_nilable_only_nil() {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n\n        let result = non_nilable(\u0026[nil_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_nilable_already_nilable() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = nilable(std::slice::from_ref(\u0026union), make_span()).unwrap();\n        // Should return the same type since it already has nil\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_nilable_nullable() {\n        let nullable = Type::new(\n            TypeKind::Nullable(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            ))),\n            make_span(),\n        );\n\n        let result = nilable(std::slice::from_ref(\u0026nullable), make_span()).unwrap();\n        // Should return the same nullable type\n        assert!(matches!(result.kind, TypeKind::Nullable(_)));\n    }\n\n    #[test]\n    fn test_return_type_non_function() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = return_type(\u0026[string_type], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parameters_non_function() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = parameters(\u0026[string_type], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_nil_or_void() {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let void_type = Type::new(TypeKind::Primitive(PrimitiveType::Void), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        assert!(is_nil_or_void(\u0026nil_type));\n        assert!(is_nil_or_void(\u0026void_type));\n        assert!(!is_nil_or_void(\u0026string_type));\n    }\n\n    #[test]\n    fn test_extract_string_literal_keys() {\n        let single_key = Type::new(\n            TypeKind::Literal(Literal::String(\"name\".to_string())),\n            make_span(),\n        );\n        let keys = extract_string_literal_keys(\u0026single_key).unwrap();\n        assert_eq!(keys, vec![\"name\"]);\n\n        let union_keys = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"a\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"b\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n        let keys = extract_string_literal_keys(\u0026union_keys).unwrap();\n        assert_eq!(keys.len(), 2);\n    }\n\n    #[test]\n    fn test_extract_string_literal_keys_invalid() {\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let result = extract_string_literal_keys(\u0026number_type);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_cartesian_product() {\n        let vecs = vec![\n            vec![\"a\".to_string(), \"b\".to_string()],\n            vec![\"1\".to_string(), \"2\".to_string()],\n        ];\n\n        let result = cartesian_product(\u0026vecs);\n        assert_eq!(result.len(), 4);\n        assert!(result.contains(\u0026\"a1\".to_string()));\n        assert!(result.contains(\u0026\"a2\".to_string()));\n        assert!(result.contains(\u0026\"b1\".to_string()));\n        assert!(result.contains(\u0026\"b2\".to_string()));\n    }\n\n    #[test]\n    fn test_cartesian_product_empty() {\n        let vecs: Vec\u003cVec\u003cString\u003e\u003e = vec![];\n        let result = cartesian_product(\u0026vecs);\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0], \"\");\n    }\n\n    #[test]\n    fn test_cartesian_product_single() {\n        let vecs = vec![vec![\"a\".to_string(), \"b\".to_string()]];\n        let result = cartesian_product(\u0026vecs);\n        assert_eq!(result.len(), 2);\n        assert!(result.contains(\u0026\"a\".to_string()));\n        assert!(result.contains(\u0026\"b\".to_string()));\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":24}},{"line":21,"address":[],"length":0,"stats":{"Line":24}},{"line":22,"address":[],"length":0,"stats":{"Line":36}},{"line":23,"address":[],"length":0,"stats":{"Line":26}},{"line":24,"address":[],"length":0,"stats":{"Line":24}},{"line":25,"address":[],"length":0,"stats":{"Line":31}},{"line":26,"address":[],"length":0,"stats":{"Line":21}},{"line":27,"address":[],"length":0,"stats":{"Line":19}},{"line":28,"address":[],"length":0,"stats":{"Line":15}},{"line":29,"address":[],"length":0,"stats":{"Line":13}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":7}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":51,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":17}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":58,"address":[],"length":0,"stats":{"Line":36}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":24}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":73,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":3}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":12}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":10}},{"line":141,"address":[],"length":0,"stats":{"Line":7}},{"line":142,"address":[],"length":0,"stats":{"Line":7}},{"line":143,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":145,"address":[],"length":0,"stats":{"Line":21}},{"line":146,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":14}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":7}},{"line":180,"address":[],"length":0,"stats":{"Line":7}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":14}},{"line":188,"address":[],"length":0,"stats":{"Line":14}},{"line":191,"address":[],"length":0,"stats":{"Line":12}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":12}},{"line":226,"address":[],"length":0,"stats":{"Line":24}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":232,"address":[],"length":0,"stats":{"Line":12}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":4}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":8}},{"line":251,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":258,"address":[],"length":0,"stats":{"Line":12}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":15}},{"line":262,"address":[],"length":0,"stats":{"Line":11}},{"line":263,"address":[],"length":0,"stats":{"Line":11}},{"line":265,"address":[],"length":0,"stats":{"Line":44}},{"line":266,"address":[],"length":0,"stats":{"Line":22}},{"line":267,"address":[],"length":0,"stats":{"Line":7}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":292,"address":[],"length":0,"stats":{"Line":4}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":12}},{"line":307,"address":[],"length":0,"stats":{"Line":12}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":16}},{"line":311,"address":[],"length":0,"stats":{"Line":12}},{"line":312,"address":[],"length":0,"stats":{"Line":12}},{"line":314,"address":[],"length":0,"stats":{"Line":48}},{"line":315,"address":[],"length":0,"stats":{"Line":24}},{"line":316,"address":[],"length":0,"stats":{"Line":7}},{"line":318,"address":[],"length":0,"stats":{"Line":5}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":4}},{"line":330,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":4}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":5}},{"line":341,"address":[],"length":0,"stats":{"Line":5}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":10}},{"line":349,"address":[],"length":0,"stats":{"Line":10}},{"line":351,"address":[],"length":0,"stats":{"Line":5}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":353,"address":[],"length":0,"stats":{"Line":9}},{"line":355,"address":[],"length":0,"stats":{"Line":30}},{"line":359,"address":[],"length":0,"stats":{"Line":6}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":3}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":6}},{"line":370,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":6}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":12}},{"line":388,"address":[],"length":0,"stats":{"Line":12}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":391,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":394,"address":[],"length":0,"stats":{"Line":40}},{"line":398,"address":[],"length":0,"stats":{"Line":8}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":4}},{"line":401,"address":[],"length":0,"stats":{"Line":3}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":6}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":5}},{"line":419,"address":[],"length":0,"stats":{"Line":5}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":10}},{"line":428,"address":[],"length":0,"stats":{"Line":5}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":430,"address":[],"length":0,"stats":{"Line":6}},{"line":432,"address":[],"length":0,"stats":{"Line":10}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":444,"address":[],"length":0,"stats":{"Line":2}},{"line":446,"address":[],"length":0,"stats":{"Line":4}},{"line":447,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":4}},{"line":457,"address":[],"length":0,"stats":{"Line":4}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":8}},{"line":467,"address":[],"length":0,"stats":{"Line":8}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":1}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":1}},{"line":486,"address":[],"length":0,"stats":{"Line":4}},{"line":487,"address":[],"length":0,"stats":{"Line":4}},{"line":488,"address":[],"length":0,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":4}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":3}},{"line":498,"address":[],"length":0,"stats":{"Line":3}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":6}},{"line":507,"address":[],"length":0,"stats":{"Line":3}},{"line":508,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":1}},{"line":514,"address":[],"length":0,"stats":{"Line":3}},{"line":515,"address":[],"length":0,"stats":{"Line":3}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":6}},{"line":524,"address":[],"length":0,"stats":{"Line":3}},{"line":525,"address":[],"length":0,"stats":{"Line":2}},{"line":526,"address":[],"length":0,"stats":{"Line":6}},{"line":527,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":10}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":540,"address":[],"length":0,"stats":{"Line":13}},{"line":546,"address":[],"length":0,"stats":{"Line":26}},{"line":547,"address":[],"length":0,"stats":{"Line":5}},{"line":549,"address":[],"length":0,"stats":{"Line":20}},{"line":551,"address":[],"length":0,"stats":{"Line":16}},{"line":555,"address":[],"length":0,"stats":{"Line":65}},{"line":557,"address":[],"length":0,"stats":{"Line":39}},{"line":559,"address":[],"length":0,"stats":{"Line":42}},{"line":560,"address":[],"length":0,"stats":{"Line":116}},{"line":563,"address":[],"length":0,"stats":{"Line":58}},{"line":564,"address":[],"length":0,"stats":{"Line":11}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":18}},{"line":570,"address":[],"length":0,"stats":{"Line":58}},{"line":571,"address":[],"length":0,"stats":{"Line":10}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":19}},{"line":576,"address":[],"length":0,"stats":{"Line":29}},{"line":577,"address":[],"length":0,"stats":{"Line":58}},{"line":578,"address":[],"length":0,"stats":{"Line":116}},{"line":579,"address":[],"length":0,"stats":{"Line":58}},{"line":580,"address":[],"length":0,"stats":{"Line":58}},{"line":581,"address":[],"length":0,"stats":{"Line":29}},{"line":586,"address":[],"length":0,"stats":{"Line":26}},{"line":587,"address":[],"length":0,"stats":{"Line":13}},{"line":588,"address":[],"length":0,"stats":{"Line":13}},{"line":589,"address":[],"length":0,"stats":{"Line":13}},{"line":591,"address":[],"length":0,"stats":{"Line":13}},{"line":596,"address":[],"length":0,"stats":{"Line":9}},{"line":602,"address":[],"length":0,"stats":{"Line":18}},{"line":603,"address":[],"length":0,"stats":{"Line":5}},{"line":604,"address":[],"length":0,"stats":{"Line":20}},{"line":605,"address":[],"length":0,"stats":{"Line":10}},{"line":606,"address":[],"length":0,"stats":{"Line":15}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":613,"address":[],"length":0,"stats":{"Line":9}},{"line":614,"address":[],"length":0,"stats":{"Line":9}},{"line":615,"address":[],"length":0,"stats":{"Line":27}},{"line":616,"address":[],"length":0,"stats":{"Line":9}},{"line":618,"address":[],"length":0,"stats":{"Line":27}},{"line":619,"address":[],"length":0,"stats":{"Line":48}},{"line":620,"address":[],"length":0,"stats":{"Line":16}},{"line":621,"address":[],"length":0,"stats":{"Line":16}},{"line":623,"address":[],"length":0,"stats":{"Line":6}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":625,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":18}},{"line":633,"address":[],"length":0,"stats":{"Line":2}},{"line":634,"address":[],"length":0,"stats":{"Line":1}},{"line":635,"address":[],"length":0,"stats":{"Line":1}},{"line":637,"address":[],"length":0,"stats":{"Line":8}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":16}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":660,"address":[],"length":0,"stats":{"Line":4}},{"line":661,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[],"length":0,"stats":{"Line":6}},{"line":665,"address":[],"length":0,"stats":{"Line":6}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":2}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":8}},{"line":717,"address":[],"length":0,"stats":{"Line":8}},{"line":720,"address":[],"length":0,"stats":{"Line":6}},{"line":721,"address":[],"length":0,"stats":{"Line":1}},{"line":723,"address":[],"length":0,"stats":{"Line":1}},{"line":728,"address":[],"length":0,"stats":{"Line":4}},{"line":729,"address":[],"length":0,"stats":{"Line":4}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":8}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":2}},{"line":754,"address":[],"length":0,"stats":{"Line":2}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":2}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":16}},{"line":944,"address":[],"length":0,"stats":{"Line":1}},{"line":945,"address":[],"length":0,"stats":{"Line":3}},{"line":946,"address":[],"length":0,"stats":{"Line":13}},{"line":947,"address":[],"length":0,"stats":{"Line":26}},{"line":948,"address":[],"length":0,"stats":{"Line":71}},{"line":949,"address":[],"length":0,"stats":{"Line":28}},{"line":950,"address":[],"length":0,"stats":{"Line":56}},{"line":951,"address":[],"length":0,"stats":{"Line":84}},{"line":953,"address":[],"length":0,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":4}},{"line":955,"address":[],"length":0,"stats":{"Line":2}},{"line":956,"address":[],"length":0,"stats":{"Line":1}},{"line":957,"address":[],"length":0,"stats":{"Line":1}},{"line":958,"address":[],"length":0,"stats":{"Line":4}},{"line":959,"address":[],"length":0,"stats":{"Line":3}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":13}},{"line":979,"address":[],"length":0,"stats":{"Line":2}},{"line":980,"address":[],"length":0,"stats":{"Line":8}},{"line":981,"address":[],"length":0,"stats":{"Line":4}},{"line":982,"address":[],"length":0,"stats":{"Line":10}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":11}},{"line":1001,"address":[],"length":0,"stats":{"Line":5}},{"line":1002,"address":[],"length":0,"stats":{"Line":15}},{"line":1003,"address":[],"length":0,"stats":{"Line":10}},{"line":1005,"address":[],"length":0,"stats":{"Line":15}},{"line":1006,"address":[],"length":0,"stats":{"Line":20}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":1}},{"line":1020,"address":[],"length":0,"stats":{"Line":15}},{"line":1021,"address":[],"length":0,"stats":{"Line":10}},{"line":1022,"address":[],"length":0,"stats":{"Line":12}},{"line":1028,"address":[],"length":0,"stats":{"Line":25}},{"line":1030,"address":[],"length":0,"stats":{"Line":75}},{"line":1035,"address":[],"length":0,"stats":{"Line":11}},{"line":1043,"address":[],"length":0,"stats":{"Line":33}},{"line":1045,"address":[],"length":0,"stats":{"Line":61}},{"line":1046,"address":[],"length":0,"stats":{"Line":25}},{"line":1047,"address":[],"length":0,"stats":{"Line":24}},{"line":1049,"address":[],"length":0,"stats":{"Line":48}},{"line":1051,"address":[],"length":0,"stats":{"Line":13}},{"line":1053,"address":[],"length":0,"stats":{"Line":65}},{"line":1054,"address":[],"length":0,"stats":{"Line":26}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":39}},{"line":1065,"address":[],"length":0,"stats":{"Line":33}},{"line":1071,"address":[],"length":0,"stats":{"Line":11}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":11}},{"line":1083,"address":[],"length":0,"stats":{"Line":6}},{"line":1084,"address":[],"length":0,"stats":{"Line":3}},{"line":1085,"address":[],"length":0,"stats":{"Line":3}},{"line":1088,"address":[],"length":0,"stats":{"Line":24}},{"line":1090,"address":[],"length":0,"stats":{"Line":74}},{"line":1093,"address":[],"length":0,"stats":{"Line":16}},{"line":1098,"address":[],"length":0,"stats":{"Line":34}},{"line":1104,"address":[],"length":0,"stats":{"Line":68}},{"line":1105,"address":[],"length":0,"stats":{"Line":13}},{"line":1106,"address":[],"length":0,"stats":{"Line":52}},{"line":1107,"address":[],"length":0,"stats":{"Line":39}},{"line":1108,"address":[],"length":0,"stats":{"Line":13}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":21}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":60}},{"line":1118,"address":[],"length":0,"stats":{"Line":9}},{"line":1119,"address":[],"length":0,"stats":{"Line":6}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":18}},{"line":1129,"address":[],"length":0,"stats":{"Line":93}},{"line":1131,"address":[],"length":0,"stats":{"Line":45}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":14}},{"line":1142,"address":[],"length":0,"stats":{"Line":28}},{"line":1143,"address":[],"length":0,"stats":{"Line":2}},{"line":1146,"address":[],"length":0,"stats":{"Line":13}},{"line":1147,"address":[],"length":0,"stats":{"Line":4}},{"line":1150,"address":[],"length":0,"stats":{"Line":81}},{"line":1151,"address":[],"length":0,"stats":{"Line":26}},{"line":1152,"address":[],"length":0,"stats":{"Line":59}},{"line":1153,"address":[],"length":0,"stats":{"Line":116}},{"line":1154,"address":[],"length":0,"stats":{"Line":150}},{"line":1155,"address":[],"length":0,"stats":{"Line":150}},{"line":1156,"address":[],"length":0,"stats":{"Line":50}},{"line":1159,"address":[],"length":0,"stats":{"Line":26}}],"covered":370,"coverable":576},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","utils","mod.rs"],"content":"pub mod narrowing_integration;\npub mod symbol_table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","utils","narrowing_integration.rs"],"content":"/// Integration module for type narrowing with the type checker\n/// This provides the scaffolding for how narrowing will be used during type checking\nuse crate::visitors::{narrow_type_from_condition, NarrowingContext};\nuse rustc_hash::FxHashMap;\nuse typedlua_parser::ast::expression::Expression;\nuse typedlua_parser::ast::types::Type;\nuse typedlua_parser::string_interner::{StringId, StringInterner};\n\n/// Demonstration of how type narrowing integrates with if statement checking\n///\n/// This is a template/example showing how the type checker would use narrowing\n/// when checking if statements. Full integration requires statement type checking\n/// which is not yet implemented.\npub struct IfStatementNarrowingExample;\n\nimpl IfStatementNarrowingExample {\n    /// Example: How to narrow types when type checking an if statement\n    ///\n    /// ```text\n    /// // Given code:\n    /// local x: string | nil = getValue()\n    /// if x != nil then\n    ///     -- In this branch, x is narrowed to string\n    ///     print(x.upper(x))  // Valid: x is string here\n    /// else\n    ///     -- In this branch, x is nil\n    ///     print(\"x is nil\")\n    /// end\n    /// ```\n    #[allow(dead_code)]\n    pub fn check_if_statement_with_narrowing(\n        condition: \u0026Expression,\n        base_context: \u0026NarrowingContext,\n        variable_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n        interner: \u0026StringInterner,\n    ) -\u003e (NarrowingContext, NarrowingContext) {\n        // Step 1: Analyze the condition to produce narrowed contexts\n        let (then_context, else_context) =\n            narrow_type_from_condition(condition, base_context, variable_types, interner);\n\n        (then_context, else_context)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::expression::{BinaryOp, ExpressionKind, Literal};\n    use typedlua_parser::ast::types::{PrimitiveType, TypeKind};\n    use typedlua_parser::ast::Spanned;\n    use typedlua_parser::span::Span;\n    use typedlua_parser::string_interner::StringId;\n\n    fn make_span() -\u003e Span {\n        Span::new(0, 0, 0, 0)\n    }\n\n    fn get_string_id(s: \u0026str, interner: \u0026StringInterner) -\u003e StringId {\n        interner.intern(s)\n    }\n\n    #[test]\n    fn test_if_statement_narrowing_example() {\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        // Setup: x: string | nil\n        let mut variable_types = FxHashMap::default();\n        let x_id = get_string_id(\"x\", \u0026interner);\n        variable_types.insert(\n            x_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Condition: x != nil\n        let condition = Expression::new(\n            ExpressionKind::Binary(\n                BinaryOp::NotEqual,\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(x_id),\n                    make_span(),\n                )),\n                Box::new(Expression::new(\n                    ExpressionKind::Literal(Literal::Nil),\n                    make_span(),\n                )),\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: x should be narrowed to string\n        let then_type = then_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            then_type.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // In else branch: x should be nil\n        let else_type = else_ctx\n            .get_narrowed_type(x_id)\n            .unwrap_or_else(|| variable_types.get(\u0026x_id).unwrap());\n        assert!(matches!(\n            else_type.kind,\n            TypeKind::Primitive(PrimitiveType::Nil)\n        ));\n    }\n\n    #[test]\n    fn test_typeof_narrowing_example() {\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        let mut variable_types = FxHashMap::default();\n        let x_id = get_string_id(\"x\", \u0026interner);\n        let typeof_id = get_string_id(\"typeof\", \u0026interner);\n        variable_types.insert(\n            x_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Condition: typeof(x) == \"string\"\n        let condition = Expression::new(\n            ExpressionKind::Binary(\n                BinaryOp::Equal,\n                Box::new(Expression::new(\n                    ExpressionKind::Call(\n                        Box::new(Expression::new(\n                            ExpressionKind::Identifier(typeof_id),\n                            make_span(),\n                        )),\n                        vec![typedlua_parser::ast::expression::Argument {\n                            value: Expression::new(ExpressionKind::Identifier(x_id), make_span()),\n                            is_spread: false,\n                            span: make_span(),\n                        }],\n                        None,\n                    ),\n                    make_span(),\n                )),\n                Box::new(Expression::new(\n                    ExpressionKind::Literal(Literal::String(\"string\".to_string())),\n                    make_span(),\n                )),\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: x should be string\n        let then_type = then_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            then_type.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // In else branch: x should be number\n        let else_type = else_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            else_type.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_type_guard_narrowing() {\n        use typedlua_parser::ast::types::{FunctionType, TypePredicate};\n\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        // Setup: x: string | number | nil\n        let mut variable_types = FxHashMap::default();\n        let x_id = get_string_id(\"x\", \u0026interner);\n        let is_string_id = get_string_id(\"isString\", \u0026interner);\n\n        // Register the variable type\n        variable_types.insert(\n            x_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Register isString as a type guard function: (x: any) =\u003e x is string\n        let type_predicate = TypePredicate {\n            parameter_name: Spanned::new(x_id, make_span()),\n            type_annotation: Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            )),\n            span: make_span(),\n        };\n        let func_type = FunctionType {\n            type_parameters: None,\n            parameters: vec![],\n            return_type: Box::new(Type::new(\n                TypeKind::TypePredicate(type_predicate),\n                make_span(),\n            )),\n            throws: None,\n            span: make_span(),\n        };\n        variable_types.insert(\n            is_string_id,\n            Type::new(TypeKind::Function(func_type), make_span()),\n        );\n\n        // Condition: isString(x)\n        let condition = Expression::new(\n            ExpressionKind::Call(\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(is_string_id),\n                    make_span(),\n                )),\n                vec![typedlua_parser::ast::expression::Argument {\n                    value: Expression::new(ExpressionKind::Identifier(x_id), make_span()),\n                    is_spread: false,\n                    span: make_span(),\n                }],\n                None,\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: x should be narrowed to string\n        let then_type = then_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            then_type.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // In else branch: x should be number | nil\n        let else_type = else_ctx.get_narrowed_type(x_id).unwrap();\n        if let TypeKind::Union(types) = \u0026else_type.kind {\n            assert_eq!(types.len(), 2);\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::Number))));\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::Nil))));\n        } else {\n            panic!(\"Expected union type for else branch\");\n        }\n    }\n\n    #[test]\n    fn test_instanceof_narrowing() {\n        use typedlua_parser::ast::expression::ExpressionKind;\n        use typedlua_parser::ast::types::TypeReference;\n\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        let mut variable_types = FxHashMap::default();\n        let pet_id = get_string_id(\"pet\", \u0026interner);\n        let animal_id = get_string_id(\"Animal\", \u0026interner);\n        let dog_id = get_string_id(\"Dog\", \u0026interner);\n        variable_types.insert(\n            pet_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: Spanned::new(animal_id, make_span()),\n                            type_arguments: None,\n                            span: make_span(),\n                        }),\n                        make_span(),\n                    ),\n                    Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: Spanned::new(dog_id, make_span()),\n                            type_arguments: None,\n                            span: make_span(),\n                        }),\n                        make_span(),\n                    ),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Condition: pet instanceof Dog\n        let condition = Expression::new(\n            ExpressionKind::Binary(\n                BinaryOp::Instanceof,\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(pet_id),\n                    make_span(),\n                )),\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(dog_id),\n                    make_span(),\n                )),\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, _else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: pet should be narrowed to Dog\n        let then_type = then_ctx.get_narrowed_type(pet_id).unwrap();\n        if let TypeKind::Reference(type_ref) = \u0026then_type.kind {\n            assert_eq!(type_ref.name.node, dog_id);\n        } else {\n            panic!(\"Expected reference type for then branch\");\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","utils","symbol_table.rs"],"content":"use rustc_hash::FxHashMap;\nuse serde::{Deserialize, Serialize};\nuse typedlua_parser::ast::types::Type;\nuse typedlua_parser::span::Span;\n\n/// Kind of symbol (variable, function, class, etc.)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum SymbolKind {\n    Variable,\n    Const,\n    Function,\n    Class,\n    Interface,\n    TypeAlias,\n    Enum,\n    Parameter,\n    Namespace,\n}\n\n/// A symbol in the symbol table\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Symbol {\n    pub name: String,\n    pub kind: SymbolKind,\n    pub typ: Type,\n    pub span: Span,\n    pub is_exported: bool,\n    pub references: Vec\u003cSpan\u003e,\n}\n\nimpl Symbol {\n    pub fn new(name: String, kind: SymbolKind, typ: Type, span: Span) -\u003e Self {\n        Self {\n            name,\n            kind,\n            typ,\n            span,\n            is_exported: false,\n            references: Vec::new(),\n        }\n    }\n\n    /// Add a reference to this symbol\n    pub fn add_reference(\u0026mut self, span: Span) {\n        self.references.push(span);\n    }\n}\n\n/// A scope containing symbols\n#[derive(Debug, Clone)]\npub struct Scope {\n    symbols: FxHashMap\u003cString, Symbol\u003e,\n}\n\nimpl Scope {\n    pub fn new() -\u003e Self {\n        Self {\n            symbols: FxHashMap::default(),\n        }\n    }\n\n    /// Declare a symbol in this scope\n    pub fn declare(\u0026mut self, symbol: Symbol) -\u003e Result\u003c(), String\u003e {\n        if self.symbols.contains_key(\u0026symbol.name) {\n            return Err(format!(\n                \"Symbol '{}' already declared in this scope\",\n                symbol.name\n            ));\n        }\n        self.symbols.insert(symbol.name.clone(), symbol);\n        Ok(())\n    }\n\n    /// Look up a symbol in this scope only\n    pub fn lookup(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbols.get(name)\n    }\n\n    /// Look up a symbol only in this scope (not parent scopes)\n    pub fn lookup_local(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbols.get(name)\n    }\n\n    /// Get all symbols in this scope\n    pub fn symbols(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Symbol\u003e {\n        self.symbols.values()\n    }\n}\n\nimpl Default for Scope {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Symbol table managing scopes\n#[derive(Debug)]\npub struct SymbolTable {\n    current_scope: Scope,\n    scope_stack: Vec\u003cScope\u003e,\n}\n\nimpl SymbolTable {\n    pub fn new() -\u003e Self {\n        Self {\n            current_scope: Scope::new(),\n            scope_stack: Vec::new(),\n        }\n    }\n\n    /// Enter a new scope (O(1) - no cloning)\n    pub fn enter_scope(\u0026mut self) {\n        let parent = std::mem::take(\u0026mut self.current_scope);\n        self.scope_stack.push(parent);\n    }\n\n    /// Exit current scope\n    pub fn exit_scope(\u0026mut self) {\n        if let Some(parent) = self.scope_stack.pop() {\n            self.current_scope = parent;\n        }\n    }\n\n    /// Declare a symbol in the current scope\n    pub fn declare(\u0026mut self, symbol: Symbol) -\u003e Result\u003c(), String\u003e {\n        self.current_scope.declare(symbol)\n    }\n\n    /// Look up a symbol in current scope, then walk the scope stack (most recent first)\n    pub fn lookup(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        if let Some(symbol) = self.current_scope.symbols.get(name) {\n            return Some(symbol);\n        }\n        for scope in self.scope_stack.iter().rev() {\n            if let Some(symbol) = scope.symbols.get(name) {\n                return Some(symbol);\n            }\n        }\n        None\n    }\n\n    /// Look up a symbol only in the current scope\n    pub fn lookup_local(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.current_scope.lookup_local(name)\n    }\n\n    /// Add a reference to a symbol\n    /// Returns true if the symbol was found and reference was added\n    pub fn add_reference(\u0026mut self, name: \u0026str, span: Span) -\u003e bool {\n        // Try current scope first\n        if let Some(symbol) = self.current_scope.symbols.get_mut(name) {\n            symbol.add_reference(span);\n            return true;\n        }\n\n        // Walk the scope stack (most recent first)\n        for scope in self.scope_stack.iter_mut().rev() {\n            if let Some(symbol) = scope.symbols.get_mut(name) {\n                symbol.add_reference(span);\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Get the current scope\n    pub fn current_scope(\u0026self) -\u003e \u0026Scope {\n        \u0026self.current_scope\n    }\n\n    /// Get all symbols visible from the current scope (current + all parent scopes on stack)\n    pub fn all_visible_symbols(\u0026self) -\u003e FxHashMap\u003cString, \u0026Symbol\u003e {\n        let mut result = FxHashMap::default();\n\n        // Add from oldest scope to newest so newer scopes shadow older ones\n        for scope in \u0026self.scope_stack {\n            for (name, symbol) in \u0026scope.symbols {\n                result.insert(name.clone(), symbol);\n            }\n        }\n\n        // Current scope shadows everything\n        for (name, symbol) in \u0026self.current_scope.symbols {\n            result.insert(name.clone(), symbol);\n        }\n\n        result\n    }\n}\n\nimpl Default for SymbolTable {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Serializable representation of a symbol with scope depth\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SerializableSymbol {\n    pub name: String,\n    pub kind: SymbolKind,\n    pub typ: Type,\n    pub span: Span,\n    pub is_exported: bool,\n    pub references: Vec\u003cSpan\u003e,\n    pub scope_depth: usize,\n}\n\n/// Serializable representation of SymbolTable (flattened scopes)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SerializableSymbolTable {\n    pub symbols: Vec\u003cSerializableSymbol\u003e,\n}\n\nimpl SymbolTable {\n    /// Convert to serializable format by flattening scope hierarchy\n    pub fn to_serializable(\u0026self) -\u003e SerializableSymbolTable {\n        let mut symbols = Vec::new();\n\n        // Scope stack: depth 0 = oldest (bottom of stack), increasing depth\n        for (depth, scope) in self.scope_stack.iter().enumerate() {\n            for symbol in scope.symbols.values() {\n                symbols.push(SerializableSymbol {\n                    name: symbol.name.clone(),\n                    kind: symbol.kind,\n                    typ: symbol.typ.clone(),\n                    span: symbol.span,\n                    is_exported: symbol.is_exported,\n                    references: symbol.references.clone(),\n                    scope_depth: depth,\n                });\n            }\n        }\n\n        // Current scope is the deepest\n        let current_depth = self.scope_stack.len();\n        for symbol in self.current_scope.symbols.values() {\n            symbols.push(SerializableSymbol {\n                name: symbol.name.clone(),\n                kind: symbol.kind,\n                typ: symbol.typ.clone(),\n                span: symbol.span,\n                is_exported: symbol.is_exported,\n                references: symbol.references.clone(),\n                scope_depth: current_depth,\n            });\n        }\n\n        SerializableSymbolTable { symbols }\n    }\n\n    /// Reconstruct from serializable format\n    pub fn from_serializable(data: SerializableSymbolTable) -\u003e Self {\n        // Group symbols by scope depth\n        let mut symbols_by_depth: FxHashMap\u003cusize, Vec\u003cSerializableSymbol\u003e\u003e = FxHashMap::default();\n        for symbol in data.symbols {\n            symbols_by_depth\n                .entry(symbol.scope_depth)\n                .or_default()\n                .push(symbol);\n        }\n\n        let max_depth = symbols_by_depth.keys().max().copied().unwrap_or(0);\n\n        // Build scope stack from depth 0 to max_depth-1, current_scope = max_depth\n        let mut scope_stack = Vec::new();\n        for depth in 0..max_depth {\n            let mut scope = Scope::new();\n            if let Some(symbols) = symbols_by_depth.get(\u0026depth) {\n                for serializable in symbols {\n                    let symbol = Symbol {\n                        name: serializable.name.clone(),\n                        kind: serializable.kind,\n                        typ: serializable.typ.clone(),\n                        span: serializable.span,\n                        is_exported: serializable.is_exported,\n                        references: serializable.references.clone(),\n                    };\n                    scope.symbols.insert(symbol.name.clone(), symbol);\n                }\n            }\n            scope_stack.push(scope);\n        }\n\n        // Current scope is the deepest level\n        let mut current_scope = Scope::new();\n        if let Some(symbols) = symbols_by_depth.get(\u0026max_depth) {\n            for serializable in symbols {\n                let symbol = Symbol {\n                    name: serializable.name.clone(),\n                    kind: serializable.kind,\n                    typ: serializable.typ.clone(),\n                    span: serializable.span,\n                    is_exported: serializable.is_exported,\n                    references: serializable.references.clone(),\n                };\n                current_scope.symbols.insert(symbol.name.clone(), symbol);\n            }\n        }\n\n        SymbolTable {\n            current_scope,\n            scope_stack,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::types::{PrimitiveType, TypeKind};\n\n    fn make_test_type() -\u003e Type {\n        Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        )\n    }\n\n    #[test]\n    fn test_scope_declare_and_lookup() {\n        let mut scope = Scope::new();\n        let symbol = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n\n        scope.declare(symbol).unwrap();\n        assert!(scope.lookup(\"x\").is_some());\n        assert!(scope.lookup(\"y\").is_none());\n    }\n\n    #[test]\n    fn test_scope_duplicate_declaration() {\n        let mut scope = Scope::new();\n        let symbol1 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        let symbol2 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n\n        scope.declare(symbol1).unwrap();\n        assert!(scope.declare(symbol2).is_err());\n    }\n\n    #[test]\n    fn test_symbol_table_scopes() {\n        let mut table = SymbolTable::new();\n\n        // Declare in global scope\n        let symbol1 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        table.declare(symbol1).unwrap();\n\n        // Enter new scope\n        table.enter_scope();\n\n        // Should still see x from parent scope via stack walk\n        assert!(table.lookup(\"x\").is_some());\n\n        // Declare y in inner scope\n        let symbol2 = Symbol::new(\n            \"y\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        table.declare(symbol2).unwrap();\n\n        assert!(table.lookup(\"y\").is_some());\n\n        // Exit scope\n        table.exit_scope();\n\n        // y should no longer be visible\n        assert!(table.lookup(\"y\").is_none());\n        // x should still be visible\n        assert!(table.lookup(\"x\").is_some());\n    }\n\n    #[test]\n    fn test_symbol_table_shadowing() {\n        let mut table = SymbolTable::new();\n\n        // Declare x in global scope\n        let symbol1 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        table.declare(symbol1).unwrap();\n\n        // Enter new scope and shadow x\n        table.enter_scope();\n        let symbol2 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Const,\n            make_test_type(),\n            Span::new(1, 1, 1, 1),\n        );\n        table.declare(symbol2).unwrap();\n\n        // Should see the inner x\n        let x = table.lookup(\"x\").unwrap();\n        assert_eq!(x.kind, SymbolKind::Const);\n\n        // Exit scope\n        table.exit_scope();\n\n        // Should see the outer x again\n        let x = table.lookup(\"x\").unwrap();\n        assert_eq!(x.kind, SymbolKind::Variable);\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1690}},{"line":39,"address":[],"length":0,"stats":{"Line":1690}},{"line":44,"address":[],"length":0,"stats":{"Line":104}},{"line":45,"address":[],"length":0,"stats":{"Line":312}},{"line":56,"address":[],"length":0,"stats":{"Line":726}},{"line":58,"address":[],"length":0,"stats":{"Line":726}},{"line":63,"address":[],"length":0,"stats":{"Line":1881}},{"line":64,"address":[],"length":0,"stats":{"Line":5643}},{"line":65,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[],"length":0,"stats":{"Line":10}},{"line":67,"address":[],"length":0,"stats":{"Line":10}},{"line":70,"address":[],"length":0,"stats":{"Line":9355}},{"line":71,"address":[],"length":0,"stats":{"Line":1871}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":80,"address":[],"length":0,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":21}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":351}},{"line":92,"address":[],"length":0,"stats":{"Line":351}},{"line":104,"address":[],"length":0,"stats":{"Line":366}},{"line":106,"address":[],"length":0,"stats":{"Line":366}},{"line":107,"address":[],"length":0,"stats":{"Line":366}},{"line":112,"address":[],"length":0,"stats":{"Line":351}},{"line":113,"address":[],"length":0,"stats":{"Line":1053}},{"line":114,"address":[],"length":0,"stats":{"Line":1053}},{"line":118,"address":[],"length":0,"stats":{"Line":345}},{"line":119,"address":[],"length":0,"stats":{"Line":1033}},{"line":120,"address":[],"length":0,"stats":{"Line":344}},{"line":125,"address":[],"length":0,"stats":{"Line":1870}},{"line":126,"address":[],"length":0,"stats":{"Line":5610}},{"line":130,"address":[],"length":0,"stats":{"Line":301}},{"line":131,"address":[],"length":0,"stats":{"Line":713}},{"line":132,"address":[],"length":0,"stats":{"Line":111}},{"line":134,"address":[],"length":0,"stats":{"Line":5420}},{"line":135,"address":[],"length":0,"stats":{"Line":10257}},{"line":136,"address":[],"length":0,"stats":{"Line":177}},{"line":139,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":103}},{"line":151,"address":[],"length":0,"stats":{"Line":307}},{"line":152,"address":[],"length":0,"stats":{"Line":303}},{"line":153,"address":[],"length":0,"stats":{"Line":101}},{"line":157,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":40}},{"line":177,"address":[],"length":0,"stats":{"Line":76}},{"line":178,"address":[],"length":0,"stats":{"Line":156}},{"line":179,"address":[],"length":0,"stats":{"Line":128}},{"line":184,"address":[],"length":0,"stats":{"Line":4052}},{"line":185,"address":[],"length":0,"stats":{"Line":4032}},{"line":188,"address":[],"length":0,"stats":{"Line":20}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}}],"covered":60,"coverable":114},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","access_control","access_control_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::visitors::{\n        AccessControl, AccessControlVisitor, ClassContext, ClassMemberInfo, ClassMemberKind,\n        TypeCheckVisitor,\n    };\n    use typedlua_parser::ast::statement::AccessModifier;\n    use typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\n    use typedlua_parser::prelude::OperatorKind;\n    use typedlua_parser::span::Span;\n\n    fn create_test_member(name: \u0026str, access: AccessModifier) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Property {\n                type_annotation: Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    Span::default(),\n                ),\n            },\n            is_final: false,\n        }\n    }\n\n    fn create_test_method(name: \u0026str, access: AccessModifier) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Method {\n                parameters: vec![],\n                return_type: None,\n                is_abstract: false,\n            },\n            is_final: false,\n        }\n    }\n\n    fn create_test_getter(\n        name: \u0026str,\n        access: AccessModifier,\n        return_type: Type,\n    ) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Getter { return_type },\n            is_final: false,\n        }\n    }\n\n    fn create_test_setter(name: \u0026str, access: AccessModifier, param_type: Type) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Setter {\n                parameter_type: param_type,\n            },\n            is_final: false,\n        }\n    }\n\n    fn create_test_operator(\n        name: \u0026str,\n        access: AccessModifier,\n        operator: OperatorKind,\n    ) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: true,\n            kind: ClassMemberKind::Operator {\n                operator,\n                parameters: vec![],\n                return_type: None,\n            },\n            is_final: false,\n        }\n    }\n\n    #[test]\n    fn test_access_control_visitor_name() {\n        let access_control = AccessControl::new();\n        assert_eq!(access_control.name(), \"AccessControl\");\n    }\n\n    #[test]\n    fn test_public_member_accessible_from_anywhere() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a public member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"publicProp\", AccessModifier::Public),\n        );\n\n        // Access from outside the class (no current class context)\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"publicProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Public members should be accessible from anywhere\"\n        );\n    }\n\n    #[test]\n    fn test_private_member_accessible_within_same_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a private member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n\n        // Access from within the same class\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Private members should be accessible within the same class\"\n        );\n    }\n\n    #[test]\n    fn test_private_member_not_accessible_from_other_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a private member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n\n        // Try to access from a different class\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Private members should not be accessible from other classes\"\n        );\n        let err = result.unwrap_err();\n        assert!(\n            err.message.contains(\"private\"),\n            \"Error message should mention 'private'\"\n        );\n        assert!(\n            err.message.contains(\"privateProp\"),\n            \"Error message should mention the member name\"\n        );\n    }\n\n    #[test]\n    fn test_private_member_not_accessible_from_outside() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a private member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n\n        // Try to access from outside any class\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Private members should not be accessible from outside classes\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_accessible_within_same_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a protected member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Access from within the same class\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected members should be accessible within the same class\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_accessible_from_subclass() {\n        let mut access_control = AccessControl::new();\n\n        // Register a parent class with a protected member\n        access_control.register_class(\"ParentClass\", None);\n        access_control.register_member(\n            \"ParentClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Register a child class\n        access_control.register_class(\"ChildClass\", Some(\"ParentClass\".to_string()));\n\n        // Access from the child class context\n        let current_class = Some(ClassContext {\n            name: \"ChildClass\".to_string(),\n            parent: Some(\"ParentClass\".to_string()),\n            extends_type: None,\n        });\n\n        // Set the current class for is_subclass check\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"ParentClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected members should be accessible from subclasses\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_not_accessible_from_unrelated_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a protected member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Try to access from an unrelated class\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Protected members should not be accessible from unrelated classes\"\n        );\n        let err = result.unwrap_err();\n        assert!(\n            err.message.contains(\"protected\"),\n            \"Error message should mention 'protected'\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_not_accessible_from_outside() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a protected member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Try to access from outside any class\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Protected members should not be accessible from outside classes\"\n        );\n    }\n\n    #[test]\n    fn test_member_not_found_allows_access() {\n        let access_control = AccessControl::new();\n\n        // Try to access a member that doesn't exist\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"nonExistentProp\",\n            Span::default(),\n        );\n\n        assert!(result.is_err(), \"Access to nonexistent members should fail\");\n    }\n\n    #[test]\n    fn test_class_registration() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"TestClass\", Some(\"ParentClass\".to_string()));\n\n        // Verify class is registered by checking we can add members\n        access_control.register_member(\n            \"TestClass\",\n            create_test_member(\"prop\", AccessModifier::Public),\n        );\n        let members = access_control.get_class_members(\"TestClass\");\n        assert!(members.is_some(), \"Class should be registered\");\n        assert_eq!(members.unwrap().len(), 1, \"Class should have one member\");\n    }\n\n    #[test]\n    fn test_final_class_marking() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"FinalClass\", None);\n        assert!(\n            !access_control.is_class_final(\"FinalClass\"),\n            \"Class should not be final by default\"\n        );\n\n        access_control.mark_class_final(\"FinalClass\", true);\n        assert!(\n            access_control.is_class_final(\"FinalClass\"),\n            \"Class should be marked as final\"\n        );\n\n        access_control.mark_class_final(\"FinalClass\", false);\n        assert!(\n            !access_control.is_class_final(\"FinalClass\"),\n            \"Class should no longer be final\"\n        );\n    }\n\n    #[test]\n    fn test_current_class_context() {\n        let mut access_control = AccessControl::new();\n\n        // Initially no current class\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Should have no current class initially\"\n        );\n\n        // Set current class\n        let context = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: Some(\"ParentClass\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(context.clone());\n\n        let retrieved = access_control.get_current_class();\n        assert!(retrieved.is_some(), \"Should have a current class\");\n        assert_eq!(\n            retrieved.as_ref().unwrap().name,\n            \"MyClass\",\n            \"Current class name should match\"\n        );\n        assert_eq!(\n            retrieved.as_ref().unwrap().parent,\n            Some(\"ParentClass\".to_string()),\n            \"Parent class should match\"\n        );\n\n        // Clear current class\n        access_control.set_current_class(None);\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Current class should be cleared\"\n        );\n    }\n\n    #[test]\n    fn test_is_subclass_direct_parent() {\n        let mut access_control = AccessControl::new();\n\n        // Register parent and child\n        access_control.register_class(\"ParentClass\", None);\n        access_control.register_class(\"ChildClass\", Some(\"ParentClass\".to_string()));\n\n        // Set current class context for the child\n        access_control.set_current_class(Some(ClassContext {\n            name: \"ChildClass\".to_string(),\n            parent: Some(\"ParentClass\".to_string()),\n            extends_type: None,\n        }));\n\n        assert!(\n            access_control.is_subclass(\"ChildClass\", \"ParentClass\"),\n            \"ChildClass should be a subclass of ParentClass\"\n        );\n        assert!(\n            !access_control.is_subclass(\"ParentClass\", \"ChildClass\"),\n            \"ParentClass should not be a subclass of ChildClass\"\n        );\n    }\n\n    #[test]\n    fn test_is_subclass_unrelated_classes() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"ClassA\", None);\n        access_control.register_class(\"ClassB\", None);\n\n        access_control.set_current_class(Some(ClassContext {\n            name: \"ClassA\".to_string(),\n            parent: None,\n            extends_type: None,\n        }));\n\n        assert!(\n            !access_control.is_subclass(\"ClassA\", \"ClassB\"),\n            \"Unrelated classes should not be subclasses\"\n        );\n    }\n\n    #[test]\n    fn test_multiple_members_same_class() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"publicProp\", AccessModifier::Public),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        let members = access_control.get_class_members(\"MyClass\").unwrap();\n        assert_eq!(members.len(), 3, \"Class should have three members\");\n    }\n\n    #[test]\n    fn test_method_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_method(\"publicMethod\", AccessModifier::Public),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_method(\"privateMethod\", AccessModifier::Private),\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        // Public method should be accessible\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"publicMethod\",\n            Span::default(),\n        );\n        assert!(result.is_ok(), \"Public method should be accessible\");\n\n        // Private method should be accessible within same class\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateMethod\",\n            Span::default(),\n        );\n        assert!(\n            result.is_ok(),\n            \"Private method should be accessible within same class\"\n        );\n    }\n\n    #[test]\n    fn test_error_message_contains_relevant_info() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"secret\", AccessModifier::Private),\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"secret\",\n            Span::default(),\n        );\n        let err = result.unwrap_err();\n\n        assert!(\n            err.message.contains(\"secret\"),\n            \"Error should mention the member name\"\n        );\n        assert!(\n            err.message.contains(\"MyClass\"),\n            \"Error should mention the class name\"\n        );\n        assert!(\n            err.message.contains(\"private\"),\n            \"Error should mention the access modifier\"\n        );\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Access Control Tests\n    // ========================================================================\n\n    #[test]\n    fn test_protected_access_from_grandchild_class() {\n        let mut access_control = AccessControl::new();\n\n        // Set up inheritance hierarchy: GrandParent -\u003e Parent -\u003e Child\n        access_control.register_class(\"GrandParent\", None);\n        access_control.register_member(\n            \"GrandParent\",\n            create_test_member(\"familySecret\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"Parent\", Some(\"GrandParent\".to_string()));\n        access_control.register_class(\"Child\", Some(\"Parent\".to_string()));\n\n        // Access from grandchild\n        // Note: Current is_subclass implementation only checks direct parent\n        // For full hierarchy support, the context would need grandparent info\n        let current_class = Some(ClassContext {\n            name: \"Child\".to_string(),\n            parent: Some(\"GrandParent\".to_string()), // Directly set to GrandParent for test\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"GrandParent\",\n            \"familySecret\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected members should be accessible from grandchild classes\"\n        );\n    }\n\n    #[test]\n    fn test_protected_access_from_sibling_class() {\n        let mut access_control = AccessControl::new();\n\n        // Set up sibling classes with common parent\n        access_control.register_class(\"Parent\", None);\n        access_control.register_member(\n            \"Parent\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"Child1\", Some(\"Parent\".to_string()));\n        access_control.register_class(\"Child2\", Some(\"Parent\".to_string()));\n\n        // Both siblings can access the protected member from Parent\n        // because they both inherit from Parent\n        let current_class = Some(ClassContext {\n            name: \"Child2\".to_string(),\n            parent: Some(\"Parent\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"Parent\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        // Child2 can access Parent's protected member because Child2 is a subclass of Parent\n        assert!(\n            result.is_ok(),\n            \"Child2 should be able to access Parent's protected member\"\n        );\n    }\n\n    #[test]\n    fn test_static_public_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticProp\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        // Static public members should be accessible from anywhere\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"staticProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Static public members should be accessible from anywhere\"\n        );\n    }\n\n    #[test]\n    fn test_static_private_member_access_from_same_class() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticPrivate\".to_string(),\n                access: AccessModifier::Private,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"staticPrivate\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Static private members should be accessible within the same class\"\n        );\n    }\n\n    #[test]\n    fn test_static_private_member_not_accessible_from_other_class() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticPrivate\".to_string(),\n                access: AccessModifier::Private,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"staticPrivate\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Static private members should not be accessible from other classes\"\n        );\n    }\n\n    #[test]\n    fn test_access_nonexistent_member() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        // Don't register any members\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"nonexistent\",\n            Span::default(),\n        );\n\n        // Nonexistent members should fail\n        assert!(result.is_err(), \"Accessing nonexistent member should fail\");\n    }\n\n    #[test]\n    fn test_access_nonexistent_class() {\n        let access_control = AccessControl::new();\n\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"NonexistentClass\",\n            \"someProp\",\n            Span::default(),\n        );\n\n        // Nonexistent classes should fail\n        assert!(\n            result.is_err(),\n            \"Accessing member of nonexistent class should fail\"\n        );\n    }\n\n    #[test]\n    fn test_is_not_subclass_of_unrelated() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"ClassA\", None);\n        access_control.register_class(\"ClassB\", None);\n\n        // Set current class context\n        let context = Some(ClassContext {\n            name: \"ClassA\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        access_control.set_current_class(context);\n\n        assert!(\n            !access_control.is_subclass(\"ClassA\", \"ClassB\"),\n            \"ClassA should not be subclass of ClassB\"\n        );\n    }\n\n    #[test]\n    fn test_get_class_members() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"prop1\", AccessModifier::Public),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"prop2\", AccessModifier::Private),\n        );\n\n        let members = access_control.get_class_members(\"MyClass\");\n        assert!(members.is_some(), \"Should return Some for existing class\");\n        assert_eq!(members.unwrap().len(), 2, \"Should return all class members\");\n    }\n\n    #[test]\n    fn test_get_class_members_nonexistent() {\n        let access_control = AccessControl::new();\n\n        let members = access_control.get_class_members(\"NonexistentClass\");\n        assert!(members.is_none(), \"Nonexistent class should return None\");\n    }\n\n    #[test]\n    fn test_class_final_status() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n\n        // Initially not final\n        assert!(\n            !access_control.is_class_final(\"MyClass\"),\n            \"Class should not be final initially\"\n        );\n\n        // Mark as final\n        access_control.mark_class_final(\"MyClass\", true);\n        assert!(\n            access_control.is_class_final(\"MyClass\"),\n            \"Class should be final after marking\"\n        );\n\n        // Mark as not final again\n        access_control.mark_class_final(\"MyClass\", false);\n        assert!(\n            !access_control.is_class_final(\"MyClass\"),\n            \"Class should not be final after unmarking\"\n        );\n    }\n\n    #[test]\n    fn test_final_class_cannot_be_extended() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"FinalClass\", None);\n        access_control.mark_class_final(\"FinalClass\", true);\n\n        // Check that the class is marked as final\n        assert!(\n            access_control.is_class_final(\"FinalClass\"),\n            \"Class should be final\"\n        );\n    }\n\n    #[test]\n    fn test_set_and_get_current_class() {\n        let mut access_control = AccessControl::new();\n\n        // Initially no current class\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Should have no current class initially\"\n        );\n\n        // Set current class\n        let context = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        access_control.set_current_class(context.clone());\n\n        // Verify current class is set\n        let current = access_control.get_current_class();\n        assert!(current.is_some(), \"Should have current class after setting\");\n        assert_eq!(\n            current.as_ref().unwrap().name,\n            \"MyClass\",\n            \"Current class name should match\"\n        );\n\n        // Clear current class\n        access_control.set_current_class(None);\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Should have no current class after clearing\"\n        );\n    }\n\n    #[test]\n    fn test_getter_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"value\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Getter {\n                    return_type: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result =\n            access_control.check_member_access(\u0026current_class, \"MyClass\", \"value\", Span::default());\n\n        assert!(result.is_ok(), \"Getter should be accessible\");\n    }\n\n    #[test]\n    fn test_setter_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"value\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Setter {\n                    parameter_type: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result =\n            access_control.check_member_access(\u0026current_class, \"MyClass\", \"value\", Span::default());\n\n        assert!(result.is_ok(), \"Setter should be accessible\");\n    }\n\n    #[test]\n    fn test_operator_overload_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"__add\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Operator {\n                    operator: OperatorKind::Add,\n                    parameters: vec![],\n                    return_type: None,\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class: Option\u003cClassContext\u003e = None;\n\n        let result =\n            access_control.check_member_access(\u0026current_class, \"MyClass\", \"__add\", Span::default());\n\n        assert!(result.is_ok(), \"Operator overload should be accessible\");\n    }\n\n    #[test]\n    fn test_final_property_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"constProp\", AccessModifier::Public),\n        );\n        access_control.register_class(\"MyClass\", None);\n        let mut member = create_test_member(\"constProp\", AccessModifier::Public);\n        member.is_final = true;\n        access_control.register_member(\"MyClass\", member);\n\n        let current_class: Option\u003cClassContext\u003e = None;\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"constProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Final property should be accessible for reading\"\n        );\n    }\n\n    #[test]\n    fn test_protected_access_from_great_grandchild() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"GreatGrandParent\", None);\n        access_control.register_member(\n            \"GreatGrandParent\",\n            create_test_member(\"ancestral\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"GrandParent\", Some(\"GreatGrandParent\".to_string()));\n        access_control.register_class(\"Parent\", Some(\"GrandParent\".to_string()));\n        access_control.register_class(\"Child\", Some(\"Parent\".to_string()));\n\n        let current_class = Some(ClassContext {\n            name: \"Child\".to_string(),\n            parent: Some(\"Parent\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"GreatGrandParent\",\n            \"ancestral\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected member should be accessible from great-grandchild\"\n        );\n    }\n\n    #[test]\n    fn test_is_class_final_nonexistent() {\n        let access_control = AccessControl::new();\n\n        assert!(\n            !access_control.is_class_final(\"NonExistentClass\"),\n            \"Nonexistent class should not be considered final\"\n        );\n    }\n\n    #[test]\n    fn test_register_class_implements() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_class_implements(\n            \"MyClass\",\n            vec![\"Printable\".to_string(), \"Cloneable\".to_string()],\n        );\n\n        let interfaces = access_control.get_class_implements(\"MyClass\");\n        assert!(\n            interfaces.is_some(),\n            \"Should return Some for existing class\"\n        );\n        let interfaces = interfaces.unwrap();\n        assert_eq!(interfaces.len(), 2, \"Should have two interfaces\");\n        assert!(interfaces.contains(\u0026\"Printable\".to_string()));\n        assert!(interfaces.contains(\u0026\"Cloneable\".to_string()));\n    }\n\n    #[test]\n    fn test_get_class_implements_nonexistent() {\n        let access_control = AccessControl::new();\n\n        let interfaces = access_control.get_class_implements(\"NonExistentClass\");\n        assert!(interfaces.is_none(), \"Nonexistent class should return None\");\n    }\n\n    #[test]\n    fn test_mixed_static_and_instance_members() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"instanceProp\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticProp\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let members = access_control.get_class_members(\"MyClass\").unwrap();\n        assert_eq!(members.len(), 2, \"Class should have both members\");\n    }\n\n    #[test]\n    fn test_protected_with_same_named_member_in_child() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"Parent\", None);\n        access_control.register_member(\n            \"Parent\",\n            create_test_member(\"value\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"Child\", Some(\"Parent\".to_string()));\n        access_control.register_member(\n            \"Child\",\n            create_test_member(\"value\", AccessModifier::Private),\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"Child\".to_string(),\n            parent: Some(\"Parent\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        // Child should be able to access its own private member\n        let result =\n            access_control.check_member_access(\u0026current_class, \"Child\", \"value\", Span::default());\n        assert!(result.is_ok(), \"Child should access its own private member\");\n\n        // Parent's protected member should still be accessible\n        let result =\n            access_control.check_member_access(\u0026current_class, \"Parent\", \"value\", Span::default());\n        assert!(\n            result.is_ok(),\n            \"Child should access parent's protected member\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","access_control.rs"],"content":"use super::TypeCheckVisitor;\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::{AccessModifier, Parameter};\nuse typedlua_parser::ast::types::Type;\nuse typedlua_parser::prelude::OperatorKind;\nuse typedlua_parser::span::Span;\n\n/// Information about a class member for access checking\n#[derive(Clone)]\npub struct ClassMemberInfo {\n    pub(crate) name: String,\n    pub(crate) access: AccessModifier,\n    pub(crate) _is_static: bool,\n    pub(crate) kind: ClassMemberKind,\n    pub(crate) is_final: bool,\n}\n\n#[derive(Clone)]\npub enum ClassMemberKind {\n    Property {\n        type_annotation: Type,\n    },\n    Method {\n        parameters: Vec\u003cParameter\u003e,\n        return_type: Option\u003cType\u003e,\n        is_abstract: bool,\n    },\n    Getter {\n        return_type: Type,\n    },\n    Setter {\n        parameter_type: Type,\n    },\n    Operator {\n        operator: OperatorKind,\n        parameters: Vec\u003cParameter\u003e,\n        return_type: Option\u003cType\u003e,\n    },\n}\n\n/// Context for tracking the current class during type checking\n#[derive(Clone)]\npub struct ClassContext {\n    pub(crate) name: String,\n    pub(crate) parent: Option\u003cString\u003e,\n    /// The full extends type (preserves type arguments for generic parent classes)\n    pub(crate) extends_type: Option\u003ctypedlua_parser::ast::types::Type\u003e,\n}\n\n/// Trait for access control checks on class members\npub trait AccessControlVisitor: TypeCheckVisitor {\n    /// Check if access to a class member is allowed based on access modifier\n    fn check_member_access(\n        \u0026self,\n        current_class: \u0026Option\u003cClassContext\u003e,\n        class_name: \u0026str,\n        member_name: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e;\n\n    /// Check if a class is a subclass of another\n    fn is_subclass(\u0026self, child: \u0026str, ancestor: \u0026str) -\u003e bool;\n\n    /// Register a class with its members\n    fn register_class(\u0026mut self, name: \u0026str, parent: Option\u003cString\u003e);\n\n    /// Register a class member\n    fn register_member(\u0026mut self, class_name: \u0026str, member: ClassMemberInfo);\n\n    /// Mark a class as final\n    fn mark_class_final(\u0026mut self, name: \u0026str, is_final: bool);\n\n    /// Check if a class is marked as final\n    fn is_class_final(\u0026self, name: \u0026str) -\u003e bool;\n\n    /// Get class members\n    fn get_class_members(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cClassMemberInfo\u003e\u003e;\n\n    /// Get parent class name\n    fn get_parent_class(\u0026self, class_name: \u0026str) -\u003e Option\u003cString\u003e;\n\n    /// Set current class context\n    fn set_current_class(\u0026mut self, class: Option\u003cClassContext\u003e);\n\n    /// Get current class context\n    fn get_current_class(\u0026self) -\u003e \u0026Option\u003cClassContext\u003e;\n\n    /// Register the interfaces that a class implements\n    fn register_class_implements(\u0026mut self, class_name: \u0026str, interfaces: Vec\u003cString\u003e);\n\n    /// Get the interfaces implemented by a class\n    fn get_class_implements(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cString\u003e\u003e;\n}\n\n/// Default implementation of access control\n#[derive(Default)]\npub struct AccessControl {\n    class_members: FxHashMap\u003cString, Vec\u003cClassMemberInfo\u003e\u003e,\n    final_classes: FxHashMap\u003cString, bool\u003e,\n    class_parents: FxHashMap\u003cString, Option\u003cString\u003e\u003e, // Store class hierarchy\n    class_implements: FxHashMap\u003cString, Vec\u003cString\u003e\u003e, // Store class -\u003e interfaces mapping\n    current_class: Option\u003cClassContext\u003e,\n}\n\nimpl AccessControl {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Find a member by walking the class hierarchy (current class, then parent, etc.)\n    /// Also checks implemented interfaces for default method implementations\n    fn find_member_in_hierarchy(\n        \u0026self,\n        class_name: \u0026str,\n        member_name: \u0026str,\n    ) -\u003e Option\u003c\u0026ClassMemberInfo\u003e {\n        let mut current = class_name;\n        loop {\n            if let Some(members) = self.class_members.get(current) {\n                if let Some(info) = members.iter().find(|m| m.name == member_name) {\n                    return Some(info);\n                }\n            }\n            // Walk to parent class\n            if let Some(Some(parent_name)) = self.class_parents.get(current) {\n                // Strip generic arguments from parent name (e.g. \"DataStore\u003cnumber\u003e\" -\u003e \"DataStore\")\n                let base_name = if let Some(idx) = parent_name.find('\u003c') {\n                    \u0026parent_name[..idx]\n                } else {\n                    parent_name.as_str()\n                };\n                if base_name == current {\n                    break; // Prevent infinite loop\n                }\n                current = base_name;\n            } else {\n                break;\n            }\n        }\n\n        // If not found in class hierarchy, check implemented interfaces\n        self.find_member_in_interfaces(class_name, member_name)\n    }\n\n    /// Find a member in the interfaces implemented by a class\n    fn find_member_in_interfaces(\n        \u0026self,\n        class_name: \u0026str,\n        member_name: \u0026str,\n    ) -\u003e Option\u003c\u0026ClassMemberInfo\u003e {\n        if let Some(interfaces) = self.class_implements.get(class_name) {\n            for interface_name in interfaces {\n                // Strip generic arguments from interface name\n                let base_name = if let Some(idx) = interface_name.find('\u003c') {\n                    \u0026interface_name[..idx]\n                } else {\n                    interface_name.as_str()\n                };\n\n                if let Some(members) = self.class_members.get(base_name) {\n                    if let Some(info) = members.iter().find(|m| m.name == member_name) {\n                        return Some(info);\n                    }\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl TypeCheckVisitor for AccessControl {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"AccessControl\"\n    }\n}\n\nimpl AccessControlVisitor for AccessControl {\n    fn check_member_access(\n        \u0026self,\n        current_class: \u0026Option\u003cClassContext\u003e,\n        class_name: \u0026str,\n        member_name: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Get the member info - check current class and parent classes\n        let member_info = self.find_member_in_hierarchy(class_name, member_name);\n\n        if let Some(info) = member_info {\n            match \u0026info.access {\n                AccessModifier::Public =\u003e {\n                    // Public members are accessible from anywhere\n                    Ok(())\n                }\n                AccessModifier::Private =\u003e {\n                    // Private members are only accessible from within the same class\n                    if let Some(ref current) = current_class {\n                        if current.name == class_name {\n                            Ok(())\n                        } else {\n                            Err(TypeCheckError::new(\n                                format!(\n                                    \"Property '{}' is private and only accessible within class '{}'\",\n                                    member_name, class_name\n                                ),\n                                span,\n                            ))\n                        }\n                    } else {\n                        Err(TypeCheckError::new(\n                            format!(\n                                \"Property '{}' is private and only accessible within class '{}'\",\n                                member_name, class_name\n                            ),\n                            span,\n                        ))\n                    }\n                }\n                AccessModifier::Protected =\u003e {\n                    // Protected members are accessible from within the class and subclasses\n                    if let Some(ref current) = current_class {\n                        if current.name == class_name {\n                            // Same class - allowed\n                            Ok(())\n                        } else if self.is_subclass(\u0026current.name, class_name) {\n                            // Subclass - allowed\n                            Ok(())\n                        } else {\n                            Err(TypeCheckError::new(\n                                format!(\n                                    \"Property '{}' is protected and only accessible within class '{}' and its subclasses\",\n                                    member_name, class_name\n                                ),\n                                span,\n                            ))\n                        }\n                    } else {\n                        Err(TypeCheckError::new(\n                            format!(\n                                \"Property '{}' is protected and only accessible within class '{}' and its subclasses\",\n                                member_name, class_name\n                            ),\n                            span,\n                        ))\n                    }\n                }\n            }\n        } else {\n            // Check if class exists\n            if !self.class_members.contains_key(class_name) {\n                return Err(TypeCheckError::new(\n                    format!(\"Class or type '{}' not found\", class_name),\n                    span,\n                ));\n            }\n\n            // Class exists but member not found\n            Err(TypeCheckError::new(\n                format!(\n                    \"Member '{}' not found in class '{}'\",\n                    member_name, class_name\n                ),\n                span,\n            ))\n        }\n    }\n\n    fn is_subclass(\u0026self, child: \u0026str, ancestor: \u0026str) -\u003e bool {\n        // Use stored class hierarchy to check subclass relationship\n        let mut current = child;\n\n        while let Some(parent) = self.class_parents.get(current) {\n            if let Some(ref parent_name) = parent {\n                if parent_name == ancestor {\n                    return true;\n                }\n                current = parent_name;\n            } else {\n                break;\n            }\n        }\n\n        false\n    }\n\n    fn register_class(\u0026mut self, name: \u0026str, parent: Option\u003cString\u003e) {\n        self.class_members.entry(name.to_string()).or_default();\n        self.final_classes.entry(name.to_string()).or_insert(false);\n        self.class_parents.insert(name.to_string(), parent);\n    }\n\n    fn register_member(\u0026mut self, class_name: \u0026str, member: ClassMemberInfo) {\n        if let Some(members) = self.class_members.get_mut(class_name) {\n            members.push(member);\n        }\n    }\n\n    fn mark_class_final(\u0026mut self, name: \u0026str, is_final: bool) {\n        self.final_classes.insert(name.to_string(), is_final);\n    }\n\n    fn is_class_final(\u0026self, name: \u0026str) -\u003e bool {\n        *self.final_classes.get(name).unwrap_or(\u0026false)\n    }\n\n    fn get_class_members(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cClassMemberInfo\u003e\u003e {\n        self.class_members.get(class_name)\n    }\n\n    fn get_parent_class(\u0026self, class_name: \u0026str) -\u003e Option\u003cString\u003e {\n        self.class_parents.get(class_name).cloned().flatten()\n    }\n\n    fn set_current_class(\u0026mut self, class: Option\u003cClassContext\u003e) {\n        self.current_class = class;\n    }\n\n    fn get_current_class(\u0026self) -\u003e \u0026Option\u003cClassContext\u003e {\n        \u0026self.current_class\n    }\n\n    fn register_class_implements(\u0026mut self, class_name: \u0026str, interfaces: Vec\u003cString\u003e) {\n        self.class_implements\n            .insert(class_name.to_string(), interfaces);\n    }\n\n    fn get_class_implements(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cString\u003e\u003e {\n        self.class_implements.get(class_name)\n    }\n}\n\n#[cfg(test)]\nmod access_control_tests;\n","traces":[{"line":107,"address":[],"length":0,"stats":{"Line":380}},{"line":108,"address":[],"length":0,"stats":{"Line":380}},{"line":113,"address":[],"length":0,"stats":{"Line":34}},{"line":118,"address":[],"length":0,"stats":{"Line":68}},{"line":120,"address":[],"length":0,"stats":{"Line":100}},{"line":121,"address":[],"length":0,"stats":{"Line":163}},{"line":122,"address":[],"length":0,"stats":{"Line":31}},{"line":126,"address":[],"length":0,"stats":{"Line":9}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":12}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":34}},{"line":187,"address":[],"length":0,"stats":{"Line":170}},{"line":189,"address":[],"length":0,"stats":{"Line":65}},{"line":190,"address":[],"length":0,"stats":{"Line":31}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":197,"address":[],"length":0,"stats":{"Line":17}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":5}},{"line":201,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":7}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":24}},{"line":227,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":10}},{"line":270,"address":[],"length":0,"stats":{"Line":20}},{"line":272,"address":[],"length":0,"stats":{"Line":38}},{"line":273,"address":[],"length":0,"stats":{"Line":21}},{"line":274,"address":[],"length":0,"stats":{"Line":9}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":124}},{"line":287,"address":[],"length":0,"stats":{"Line":620}},{"line":288,"address":[],"length":0,"stats":{"Line":620}},{"line":289,"address":[],"length":0,"stats":{"Line":620}},{"line":292,"address":[],"length":0,"stats":{"Line":229}},{"line":293,"address":[],"length":0,"stats":{"Line":916}},{"line":294,"address":[],"length":0,"stats":{"Line":458}},{"line":298,"address":[],"length":0,"stats":{"Line":46}},{"line":299,"address":[],"length":0,"stats":{"Line":230}},{"line":302,"address":[],"length":0,"stats":{"Line":16}},{"line":303,"address":[],"length":0,"stats":{"Line":64}},{"line":306,"address":[],"length":0,"stats":{"Line":24}},{"line":307,"address":[],"length":0,"stats":{"Line":72}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":94}},{"line":315,"address":[],"length":0,"stats":{"Line":188}},{"line":318,"address":[],"length":0,"stats":{"Line":115}},{"line":319,"address":[],"length":0,"stats":{"Line":115}},{"line":322,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":5}},{"line":324,"address":[],"length":0,"stats":{"Line":20}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":6}}],"covered":88,"coverable":103},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","inference","inference_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::cli::diagnostics::{CollectingDiagnosticHandler, DiagnosticHandler};\n    use crate::core::type_environment::TypeEnvironment;\n    use crate::utils::symbol_table::SymbolTable;\n    use crate::visitors::{AccessControl, TypeCheckVisitor, TypeInferenceVisitor, TypeInferrer};\n    use crate::NarrowingContext;\n    use std::sync::Arc;\n    use typedlua_parser::ast::expression::*;\n    use typedlua_parser::ast::types::*;\n    use typedlua_parser::ast::Ident;\n    use typedlua_parser::prelude::*;\n    use typedlua_parser::span::Span;\n    use typedlua_parser::string_interner::StringInterner;\n\n    fn create_test_inferrer\u003c'a\u003e(\n        symbol_table: \u0026'a mut SymbolTable,\n        type_env: \u0026'a mut TypeEnvironment,\n        narrowing_context: \u0026'a mut NarrowingContext,\n        access_control: \u0026'a AccessControl,\n        interner: \u0026'a StringInterner,\n        diagnostic_handler: \u0026'a Arc\u003cdyn DiagnosticHandler\u003e,\n    ) -\u003e TypeInferrer\u003c'a\u003e {\n        TypeInferrer::new(\n            symbol_table,\n            type_env,\n            narrowing_context,\n            access_control,\n            interner,\n            diagnostic_handler,\n        )\n    }\n\n    #[test]\n    fn test_infer_literal_number() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Literal(Literal::Number(n)) if n == 42.0));\n    }\n\n    #[test]\n    fn test_infer_literal_string() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Literal(Literal::String(_))));\n    }\n\n    #[test]\n    fn test_infer_literal_boolean() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Literal(Literal::Boolean(true))\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_add() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Add, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_concat() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::String(\" world\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Concatenate, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_infer_unary_op_negate() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::Negate, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_unary_op_not() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::Not, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_infer_array() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let elements = vec![\n            ArrayElement::Expression(Expression {\n                kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                span: Span::default(),\n                annotated_type: None,\n                receiver_class: None,\n            }),\n            ArrayElement::Expression(Expression {\n                kind: ExpressionKind::Literal(Literal::Number(2.0)),\n                span: Span::default(),\n                annotated_type: None,\n                receiver_class: None,\n            }),\n        ];\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(elements),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_empty_array() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(vec![]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_conditional() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let cond = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let then_expr = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let else_expr = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Conditional(cond, then_expr, else_expr),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Conditional with different literal numbers returns a union\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_binary_op_comparison() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::LessThan, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_visitor_name() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        assert_eq!(inferrer.name(), \"TypeInferrer\");\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Type Inference Tests\n    // ========================================================================\n\n    #[test]\n    fn test_infer_literal_nil() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Literal(Literal::Nil)));\n    }\n\n    #[test]\n    fn test_infer_array_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        // Array of numbers: [1, 2, 3]\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(vec![\n                ArrayElement::Expression(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                ArrayElement::Expression(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(2.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                ArrayElement::Expression(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(3.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n            ]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should infer as Array\u003cnumber\u003e\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_array_empty() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        // Empty array: []\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(vec![]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should infer as Array\u003cunknown\u003e\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_binary_op_sub() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Subtract, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_mul() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(6.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(7.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Multiply, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_div() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Divide, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_mod() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Modulo, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_eq() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Equal, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_and() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(false)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::And, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // In Lua, 'and' returns one of its operands, so type is Unknown\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_or() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(false)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Or, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // In Lua, 'or' returns one of its operands, so type is Unknown\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_infer_unary_op_len() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::Length, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Length operator returns number\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_parenthesized() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let inner = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Parenthesized(inner),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Parenthesized expressions now correctly infer the type of their inner expression\n        assert!(\n            matches!(typ.kind, TypeKind::Literal(Literal::Number(n)) if (n - 42.0).abs() \u003c f64::EPSILON)\n        );\n    }\n\n    #[test]\n    fn test_infer_type_assertion() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let inner = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let assert_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        let mut expr = Expression {\n            kind: ExpressionKind::TypeAssertion(inner, assert_type),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Type assertions currently return Unknown (not yet fully implemented)\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_infer_object_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        // Object literal: { x: 1, y: 2 }\n        let name_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Object(vec![\n                ObjectProperty::Property {\n                    key: Ident::new(name_id, Span::default()),\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n                ObjectProperty::Property {\n                    key: Ident::new(y_id, Span::default()),\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Literal(Literal::Number(2.0)),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n            ]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should infer as object type\n        assert!(matches!(typ.kind, TypeKind::Object(_)));\n    }\n\n    #[test]\n    fn test_infer_identifier_not_found() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let x_id = interner.intern(\"x\");\n        let mut expr = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        // Should fail because x is not defined\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_infer_identifier_with_type() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        // Register a variable with a type\n        let x_id = interner.intern(\"x\");\n        let x_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"x\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                x_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_power() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Power, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_integer_divide() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::IntegerDivide, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_bitwise() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::BitwiseAnd, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_shift() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::ShiftLeft, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_not_equal() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::NotEqual, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_infer_null_coalesce() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::NullCoalesce, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // null ?? number should return number\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Literal(Literal::Number(n)) if n == 42.0\n        ));\n    }\n\n    #[test]\n    fn test_infer_optional_member() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let obj_id = interner.intern(\"obj\");\n        let obj_type = Type {\n            kind: TypeKind::Object(ObjectType {\n                members: vec![ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: false,\n                    name: Ident::new(interner.intern(\"prop\"), Span::default()),\n                    is_optional: false,\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                    span: Span::default(),\n                })],\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"obj\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                obj_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj = Box::new(Expression {\n            kind: ExpressionKind::Identifier(obj_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let member = typedlua_parser::ast::Spanned::new(interner.intern(\"prop\"), Span::default());\n\n        let mut expr = Expression {\n            kind: ExpressionKind::OptionalMember(obj, member),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        // Should return an optional type (T | nil)\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_optional_index() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let arr_id = interner.intern(\"arr\");\n        let arr_type = Type {\n            kind: TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                Span::default(),\n            ))),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"arr\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                arr_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj = Box::new(Expression {\n            kind: ExpressionKind::Identifier(arr_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let index = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(0.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::OptionalIndex(obj, index),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should return an optional type (T | nil)\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_optional_call() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let func_id = interner.intern(\"maybeFunc\");\n        let func_type = Type {\n            kind: TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    Span::default(),\n                )),\n                throws: None,\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"maybeFunc\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                func_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let callee = Box::new(Expression {\n            kind: ExpressionKind::Identifier(func_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::OptionalCall(callee, vec![], None),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should return an optional type\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_function_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Function(FunctionExpression {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: None,\n                body: Block {\n                    statements: vec![],\n                    span: Span::default(),\n                },\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Function(_)));\n    }\n\n    #[test]\n    fn test_infer_function_expression_with_return() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Function(FunctionExpression {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: None,\n                body: Block {\n                    statements: vec![],\n                    span: Span::default(),\n                },\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Function(_)));\n    }\n\n    #[test]\n    fn test_infer_arrow_function_basic() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Arrow(ArrowFunction {\n                parameters: vec![],\n                body: ArrowBody::Expression(Box::new(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                })),\n                return_type: None,\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_infer_object_spread() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let other_id = interner.intern(\"other\");\n        let other_type = Type {\n            kind: TypeKind::Object(ObjectType {\n                members: vec![ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: false,\n                    name: Ident::new(interner.intern(\"a\"), Span::default()),\n                    is_optional: false,\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::String),\n                        Span::default(),\n                    ),\n                    span: Span::default(),\n                })],\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"other\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                other_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj_x = interner.intern(\"x\");\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Object(vec![\n                ObjectProperty::Spread {\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Identifier(other_id),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n                ObjectProperty::Property {\n                    key: Ident::new(obj_x, Span::default()),\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Literal(Literal::Number(42.0)),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n            ]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Object(_)));\n    }\n\n    #[test]\n    fn test_infer_try_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Try(TryExpression {\n                expression: Box::new(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                catch_variable: Ident::new(interner.intern(\"e\"), Span::default()),\n                catch_expression: Box::new(Expression {\n                    kind: ExpressionKind::Literal(Literal::String(\"error\".to_string())),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Try should return union of both types\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_error_chain() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let result_id = interner.intern(\"result\");\n        let result_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"result\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                result_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Identifier(result_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::ErrorChain(left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_infer_pipe_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let double_id = interner.intern(\"double\");\n        let double_type = Type {\n            kind: TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    Span::default(),\n                )),\n                throws: None,\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"double\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                double_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Identifier(double_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Pipe(left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_infer_index_on_tuple() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let tuple_id = interner.intern(\"tuple\");\n        let tuple_type = Type {\n            kind: TypeKind::Tuple(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), Span::default()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), Span::default()),\n            ]),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"tuple\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                tuple_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj = Box::new(Expression {\n            kind: ExpressionKind::Identifier(tuple_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let index = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(0.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Index(obj, index),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Index on tuple should return union of element types\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_unary_op_bitwise_not() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::BitwiseNot, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_conditional_same_types() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let x_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n        let num_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"x\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                num_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"y\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                num_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let cond = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let then_expr = Box::new(Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let else_expr = Box::new(Expression {\n            kind: ExpressionKind::Identifier(y_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Conditional(cond, then_expr, else_expr),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // When both branches have the same type, should return that type directly (not union)\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","inference.rs"],"content":"use super::super::visitors::{AccessControl, AccessControlVisitor, ClassMemberKind};\nuse super::TypeCheckVisitor;\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_compat::TypeCompatibility;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::types::generics::infer_type_arguments;\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse std::sync::Arc;\nuse tracing::{debug, error, instrument, span, Level};\nuse typedlua_parser::ast::expression::*;\nuse typedlua_parser::ast::pattern::{ArrayPatternElement, Pattern};\nuse typedlua_parser::ast::statement::{Block, OperatorKind, Statement};\nuse typedlua_parser::ast::types::*;\nuse typedlua_parser::prelude::{\n    Argument, MatchArm, MatchArmBody, MatchExpression, PropertySignature,\n};\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Represents a variable binding from a pattern\n#[derive(Debug, Clone)]\nstruct PatternBinding {\n    typ: Type,\n    span: Span,\n}\n\n/// Collection of bindings from a pattern\n#[derive(Debug, Clone)]\nstruct PatternBindings {\n    bindings: FxHashMap\u003cString, PatternBinding\u003e,\n}\n\n/// Trait for type inference operations\npub trait TypeInferenceVisitor: TypeCheckVisitor {\n    /// Infer the type of an expression\n    fn infer_expression(\u0026mut self, expr: \u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of binary operation\n    fn infer_binary_op(\n        \u0026self,\n        op: BinaryOp,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of unary operation\n    fn infer_unary_op(\n        \u0026self,\n        op: UnaryOp,\n        operand: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of function call\n    fn infer_call(\n        \u0026mut self,\n        callee_type: \u0026Type,\n        args: \u0026mut [Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of a method call on an object\n    fn infer_method(\n        \u0026self,\n        obj_type: \u0026Type,\n        method_name: \u0026str,\n        _args: \u0026[Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of member access\n    fn infer_member(\n        \u0026self,\n        obj_type: \u0026Type,\n        member: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of index access\n    fn infer_index(\u0026self, obj_type: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Make a type optional by adding nil to the union\n    fn make_optional(\u0026self, typ: Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Remove nil from a type\n    fn remove_nil(\u0026self, typ: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Check if a type is nil\n    fn is_nil(\u0026self, typ: \u0026Type) -\u003e bool;\n\n    /// Infer type of null coalescing operation\n    fn infer_null_coalesce(\n        \u0026self,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Check match expression and return result type\n    fn check_match(\u0026mut self, match_expr: \u0026mut MatchExpression) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Check a pattern and bind variables\n    fn check_pattern(\n        \u0026mut self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e;\n}\n\n/// Type inference implementation\npub struct TypeInferrer\u003c'a\u003e {\n    symbol_table: \u0026'a mut SymbolTable,\n    type_env: \u0026'a mut TypeEnvironment,\n    narrowing_context: \u0026'a mut super::NarrowingContext,\n    access_control: \u0026'a AccessControl,\n    interner: \u0026'a StringInterner,\n    diagnostic_handler: \u0026'a Arc\u003cdyn DiagnosticHandler\u003e,\n}\n\nimpl\u003c'a\u003e TypeInferrer\u003c'a\u003e {\n    pub fn new(\n        symbol_table: \u0026'a mut SymbolTable,\n        type_env: \u0026'a mut TypeEnvironment,\n        narrowing_context: \u0026'a mut super::NarrowingContext,\n        access_control: \u0026'a AccessControl,\n        interner: \u0026'a StringInterner,\n        diagnostic_handler: \u0026'a Arc\u003cdyn DiagnosticHandler\u003e,\n    ) -\u003e Self {\n        Self {\n            symbol_table,\n            type_env,\n            narrowing_context,\n            access_control,\n            interner,\n            diagnostic_handler,\n        }\n    }\n}\n\nimpl TypeCheckVisitor for TypeInferrer\u003c'_\u003e {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"TypeInferrer\"\n    }\n}\n\nimpl TypeInferenceVisitor for TypeInferrer\u003c'_\u003e {\n    #[instrument(skip(self, expr), fields(expr_kind))]\n    fn infer_expression(\u0026mut self, expr: \u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let span = expr.span;\n        let expr_kind = format!(\"{:?}\", expr.kind);\n\n        span!(Level::DEBUG, \"infer_expression\", kind = %expr_kind);\n\n        match \u0026mut expr.kind {\n            ExpressionKind::Literal(lit) =\u003e {\n                debug!(literal = ?lit, \"Inferring literal type\");\n                Ok(Type::new(TypeKind::Literal(lit.clone()), span))\n            }\n\n            ExpressionKind::Identifier(name) =\u003e {\n                let name_str = self.interner.resolve(*name);\n                debug!(name = %name_str, \"Inferring identifier type\");\n\n                // Check for narrowed type first\n                if let Some(narrowed_type) = self.narrowing_context.get_narrowed_type(*name) {\n                    debug!(name = %name_str, \"Found narrowed type\");\n                    return Ok(narrowed_type.clone());\n                }\n\n                // Fall back to symbol table\n                if let Some(symbol) = self.symbol_table.lookup(\u0026name_str) {\n                    debug!(name = %name_str, type = ?symbol.typ, \"Found in symbol table\");\n                    Ok(symbol.typ.clone())\n                } else {\n                    error!(name = %name_str, \"Undefined variable\");\n                    Err(TypeCheckError::new(\n                        format!(\"Undefined variable '{}'\", name_str),\n                        span,\n                    ))\n                }\n            }\n\n            ExpressionKind::Binary(op, left, right) =\u003e {\n                debug!(op = ?op, \"Inferring binary operation type\");\n                let left_type = self.infer_expression(left)?;\n                let right_type = self.infer_expression(right)?;\n                self.infer_binary_op(*op, \u0026left_type, \u0026right_type, span)\n            }\n\n            ExpressionKind::Unary(op, operand) =\u003e {\n                debug!(op = ?op, \"Inferring unary operation type\");\n                let operand_type = self.infer_expression(operand)?;\n                self.infer_unary_op(*op, \u0026operand_type, span)\n            }\n\n            ExpressionKind::Call(callee, args, ref mut stored_type_args) =\u003e {\n                let callee_type = self.infer_expression(callee)?;\n\n                // If callee is a generic function, infer and store type arguments\n                if let TypeKind::Function(func_type) = \u0026callee_type.kind {\n                    if let Some(type_params) = \u0026func_type.type_parameters {\n                        // Infer argument types\n                        let mut arg_types = Vec::with_capacity(args.len());\n                        for arg in args.iter_mut() {\n                            let arg_type =\n                                self.infer_expression(\u0026mut arg.value).unwrap_or_else(|_| {\n                                    Type::new(\n                                        TypeKind::Primitive(PrimitiveType::Unknown),\n                                        arg.value.span,\n                                    )\n                                });\n                            arg_types.push(arg_type);\n                        }\n\n                        // Infer type arguments from function signature and argument types\n                        if let Ok(inferred_types) =\n                            infer_type_arguments(type_params, \u0026func_type.parameters, \u0026arg_types)\n                        {\n                            *stored_type_args = Some(inferred_types);\n                        }\n                    }\n                }\n\n                self.infer_call(\u0026callee_type, args, span)\n            }\n\n            ExpressionKind::MethodCall(object, method, args, _) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let method_name = self.interner.resolve(method.node);\n                let method_type = self.infer_method(\u0026obj_type, \u0026method_name, args, span)?;\n\n                // Set receiver_class based on inferred type (not variable name)\n                // This enables method-to-function conversion optimization\n                if let TypeKind::Reference(type_ref) = \u0026obj_type.kind {\n                    let type_name = self.interner.resolve(type_ref.name.node);\n                    // Only set for classes (not interfaces) - check class_members\n                    if self.access_control.get_class_members(\u0026type_name).is_some() {\n                        expr.receiver_class = Some(ReceiverClassInfo {\n                            class_name: type_ref.name.node,\n                            is_static: false,\n                        });\n                    }\n                }\n\n                expr.annotated_type = Some(method_type.clone());\n                Ok(method_type)\n            }\n\n            ExpressionKind::Member(object, member) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let member_name = self.interner.resolve(member.node);\n                self.infer_member(\u0026obj_type, \u0026member_name, span)\n            }\n\n            ExpressionKind::Index(object, index) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let _index_type = self.infer_expression(index)?;\n                self.infer_index(\u0026obj_type, span)\n            }\n\n            ExpressionKind::OptionalMember(object, member) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let member_name = self.interner.resolve(member.node);\n                let member_type = self.infer_member(\u0026obj_type, \u0026member_name, span)?;\n                self.make_optional(member_type, span)\n            }\n\n            ExpressionKind::OptionalIndex(object, index) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let _index_type = self.infer_expression(index)?;\n                let indexed_type = self.infer_index(\u0026obj_type, span)?;\n                self.make_optional(indexed_type, span)\n            }\n\n            ExpressionKind::OptionalCall(callee, args, ref mut stored_type_args) =\u003e {\n                let callee_type = self.infer_expression(callee)?;\n\n                // If callee is a generic function, infer and store type arguments\n                if let TypeKind::Function(func_type) = \u0026callee_type.kind {\n                    if let Some(type_params) = \u0026func_type.type_parameters {\n                        let mut arg_types = Vec::with_capacity(args.len());\n                        for arg in args.iter_mut() {\n                            let arg_type =\n                                self.infer_expression(\u0026mut arg.value).unwrap_or_else(|_| {\n                                    Type::new(\n                                        TypeKind::Primitive(PrimitiveType::Unknown),\n                                        arg.value.span,\n                                    )\n                                });\n                            arg_types.push(arg_type);\n                        }\n\n                        if let Ok(inferred_types) =\n                            infer_type_arguments(type_params, \u0026func_type.parameters, \u0026arg_types)\n                        {\n                            *stored_type_args = Some(inferred_types);\n                        }\n                    }\n                }\n\n                let return_type = self.infer_call(\u0026callee_type, args, span)?;\n                self.make_optional(return_type, span)\n            }\n\n            ExpressionKind::OptionalMethodCall(object, method, args, _) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let method_name = self.interner.resolve(method.node);\n                let method_type = self.infer_method(\u0026obj_type, \u0026method_name, args, span)?;\n                self.make_optional(method_type, span)\n            }\n\n            ExpressionKind::Array(elements) =\u003e {\n                if elements.is_empty() {\n                    // Empty array has unknown element type\n                    return Ok(Type::new(\n                        TypeKind::Array(Box::new(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            span,\n                        ))),\n                        span,\n                    ));\n                }\n\n                // Collect all element types, including from spreads\n                let mut element_types = Vec::new();\n\n                for elem in elements {\n                    match elem {\n                        ArrayElement::Expression(expr) =\u003e {\n                            let elem_type = self.infer_expression(expr)?;\n                            element_types.push(elem_type);\n                        }\n                        ArrayElement::Spread(expr) =\u003e {\n                            // Spread expression should be an array\n                            let spread_type = self.infer_expression(expr)?;\n                            match \u0026spread_type.kind {\n                                TypeKind::Array(elem_type) =\u003e {\n                                    // Extract the element type from the spread array\n                                    element_types.push((**elem_type).clone());\n                                }\n                                _ =\u003e {\n                                    return Err(TypeCheckError::new(\n                                        format!(\n                                            \"Cannot spread non-array type: {:?}\",\n                                            spread_type.kind\n                                        ),\n                                        expr.span,\n                                    ));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Find common type or create union\n                if element_types.is_empty() {\n                    return Ok(Type::new(\n                        TypeKind::Array(Box::new(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            span,\n                        ))),\n                        span,\n                    ));\n                }\n\n                let mut result_type = element_types[0].clone();\n                for elem_type in \u0026element_types[1..] {\n                    if !TypeCompatibility::is_assignable(\u0026result_type, elem_type)\n                        \u0026\u0026 !TypeCompatibility::is_assignable(elem_type, \u0026result_type)\n                    {\n                        // Types are incompatible, create union\n                        match \u0026mut result_type.kind {\n                            TypeKind::Union(types) =\u003e {\n                                if !types\n                                    .iter()\n                                    .any(|t| TypeCompatibility::is_assignable(t, elem_type))\n                                {\n                                    types.push(elem_type.clone());\n                                }\n                            }\n                            _ =\u003e {\n                                result_type = Type::new(\n                                    TypeKind::Union(vec![result_type.clone(), elem_type.clone()]),\n                                    span,\n                                );\n                            }\n                        }\n                    }\n                }\n\n                Ok(Type::new(TypeKind::Array(Box::new(result_type)), span))\n            }\n\n            ExpressionKind::Object(props) =\u003e {\n                // Infer object type from properties\n                let mut members = Vec::new();\n\n                for prop in props {\n                    match prop {\n                        ObjectProperty::Property {\n                            key,\n                            value,\n                            span: prop_span,\n                        } =\u003e {\n                            // Infer the type of the value\n                            let value_type = self.infer_expression(value)?;\n\n                            // Create a property signature\n                            let prop_sig = PropertySignature {\n                                is_readonly: false,\n                                name: key.clone(),\n                                is_optional: false,\n                                type_annotation: value_type,\n                                span: *prop_span,\n                            };\n\n                            members.push(ObjectTypeMember::Property(prop_sig));\n                        }\n                        ObjectProperty::Computed {\n                            key,\n                            value,\n                            span: computed_span,\n                        } =\u003e {\n                            // Type check the key expression - should be string or number\n                            let key_type = self.infer_expression(key)?;\n                            match \u0026key_type.kind {\n                                TypeKind::Primitive(PrimitiveType::String)\n                                | TypeKind::Primitive(PrimitiveType::Number)\n                                | TypeKind::Primitive(PrimitiveType::Integer)\n                                | TypeKind::Literal(_) =\u003e {\n                                    // Valid key type\n                                }\n                                _ =\u003e {\n                                    return Err(TypeCheckError::new(\n                                        format!(\"Computed property key must be string or number, got {:?}\", key_type.kind),\n                                        *computed_span,\n                                    ));\n                                }\n                            }\n\n                            // Type check the value expression\n                            self.infer_expression(value)?;\n\n                            // Note: We can't add computed properties to the static object type\n                            // since we don't know the key at compile time, but we still validate them\n                        }\n                        ObjectProperty::Spread {\n                            value,\n                            span: spread_span,\n                        } =\u003e {\n                            // Spread object properties\n                            let spread_type = self.infer_expression(value)?;\n                            match \u0026spread_type.kind {\n                                TypeKind::Object(obj_type) =\u003e {\n                                    // Add all members from the spread object\n                                    for member in \u0026obj_type.members {\n                                        members.push(member.clone());\n                                    }\n                                }\n                                _ =\u003e {\n                                    return Err(TypeCheckError::new(\n                                        format!(\n                                            \"Cannot spread non-object type: {:?}\",\n                                            spread_type.kind\n                                        ),\n                                        *spread_span,\n                                    ));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                Ok(Type::new(\n                    TypeKind::Object(ObjectType { members, span }),\n                    span,\n                ))\n            }\n\n            ExpressionKind::Function(func_expr) =\u003e {\n                // Enter a new scope for the function expression\n                self.symbol_table.enter_scope();\n\n                // Register parameters in the scope\n                for param in \u0026func_expr.parameters {\n                    if let Pattern::Identifier(ident) = \u0026param.pattern {\n                        let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                            // Use the declared type\n                            type_ann.clone()\n                        } else {\n                            // No type annotation - use unknown\n                            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                        };\n\n                        let symbol = Symbol::new(\n                            self.interner.resolve(ident.node).to_string(),\n                            SymbolKind::Variable,\n                            param_type,\n                            ident.span,\n                        );\n                        let _ = self.symbol_table.declare(symbol);\n                    }\n                }\n\n                // Infer the return type from the block body\n                let mut body = func_expr.body.clone();\n                let body_type = match self.infer_block_return_type(\u0026mut body)? {\n                    Some(return_type) =\u003e return_type,\n                    None =\u003e {\n                        // No return statements found - void function\n                        Type::new(TypeKind::Primitive(PrimitiveType::Void), span)\n                    }\n                };\n\n                // Check return type if specified\n                if let Some(declared_return_type) = \u0026func_expr.return_type {\n                    if !TypeCompatibility::is_assignable(\u0026body_type, declared_return_type) {\n                        self.diagnostic_handler.error(\n                            span,\n                            \u0026format!(\n                                \"Function expression return type mismatch: expected '{:?}', found '{:?}'\",\n                                declared_return_type.kind, body_type.kind\n                            ),\n                        );\n                    }\n                }\n\n                // Exit the function scope\n                self.symbol_table.exit_scope();\n\n                // Build the function type\n                let func_type = FunctionType {\n                    type_parameters: func_expr.type_parameters.clone(),\n                    parameters: func_expr.parameters.clone(),\n                    return_type: Box::new(\n                        func_expr\n                            .return_type\n                            .clone()\n                            .unwrap_or_else(|| body_type.clone()),\n                    ),\n                    throws: None,\n                    span,\n                };\n\n                Ok(Type::new(TypeKind::Function(func_type), span))\n            }\n\n            ExpressionKind::Arrow(arrow_fn) =\u003e {\n                // Enter a new scope for the arrow function\n                self.symbol_table.enter_scope();\n\n                // Register parameters in the scope\n                for param in \u0026arrow_fn.parameters {\n                    if let Pattern::Identifier(ident) = \u0026param.pattern {\n                        let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                            // Use the declared type\n                            type_ann.clone()\n                        } else {\n                            // No type annotation - use unknown\n                            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                        };\n\n                        let symbol = Symbol::new(\n                            self.interner.resolve(ident.node).to_string(),\n                            SymbolKind::Variable,\n                            param_type,\n                            ident.span,\n                        );\n                        let _ = self.symbol_table.declare(symbol);\n                    }\n                }\n\n                // Infer the body type\n                let body_type = match \u0026arrow_fn.body {\n                    ArrowBody::Expression(expr_box) =\u003e {\n                        // Make a mutable copy to infer\n                        let mut expr_copy = (**expr_box).clone();\n                        self.infer_expression(\u0026mut expr_copy)?\n                    }\n                    ArrowBody::Block(_block) =\u003e {\n                        // Block bodies not fully supported yet\n                        Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)\n                    }\n                };\n\n                // Check return type if specified\n                if let Some(declared_return_type) = \u0026arrow_fn.return_type {\n                    if !TypeCompatibility::is_assignable(\u0026body_type, declared_return_type) {\n                        self.diagnostic_handler.error(\n                            span,\n                            \u0026format!(\n                                \"Arrow function return type mismatch: expected '{:?}', found '{:?}'\",\n                                declared_return_type.kind, body_type.kind\n                            ),\n                        );\n                    }\n                }\n\n                // Exit the arrow function scope\n                self.symbol_table.exit_scope();\n\n                // Return a function type\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n\n            ExpressionKind::Conditional(cond, then_expr, else_expr) =\u003e {\n                let _cond_type = self.infer_expression(cond)?;\n                let then_type = self.infer_expression(then_expr)?;\n                let else_type = self.infer_expression(else_expr)?;\n\n                // Return union of both branches\n                if TypeCompatibility::is_assignable(\u0026then_type, \u0026else_type) {\n                    Ok(else_type)\n                } else if TypeCompatibility::is_assignable(\u0026else_type, \u0026then_type) {\n                    Ok(then_type)\n                } else {\n                    Ok(Type::new(TypeKind::Union(vec![then_type, else_type]), span))\n                }\n            }\n\n            ExpressionKind::Match(match_expr) =\u003e self.check_match(match_expr),\n\n            ExpressionKind::Pipe(left_expr, right_expr) =\u003e {\n                // Pipe operator: left |\u003e right\n                // The right side should be a function, and we apply left as the first argument\n                let _left_type = self.infer_expression(left_expr)?;\n\n                // For now, we'll infer the result type by checking the right expression\n                // In a full implementation, we'd check if right is a function and apply left to it\n                // For simplicity, we'll type check right and return its type\n                // (This handles cases like: value |\u003e func where func returns something)\n                self.infer_expression(right_expr)\n            }\n\n            ExpressionKind::Try(try_expr) =\u003e {\n                let expr_type = self.infer_expression(\u0026mut try_expr.expression)?;\n                let catch_type = self.infer_expression(\u0026mut try_expr.catch_expression)?;\n\n                if TypeCompatibility::is_assignable(\u0026expr_type, \u0026catch_type) {\n                    Ok(catch_type)\n                } else if TypeCompatibility::is_assignable(\u0026catch_type, \u0026expr_type) {\n                    Ok(expr_type)\n                } else {\n                    Ok(Type::new(\n                        TypeKind::Union(vec![expr_type, catch_type]),\n                        span,\n                    ))\n                }\n            }\n\n            ExpressionKind::ErrorChain(left_expr, right_expr) =\u003e {\n                let _left_type = self.infer_expression(left_expr)?;\n                self.infer_expression(right_expr)\n            }\n\n            ExpressionKind::New(callee, _args, type_args) =\u003e {\n                // Infer the class type from the callee expression\n                // For `new ClassName(args)`, callee is Identifier(\"ClassName\")\n                // For `new ClassName\u003cT\u003e(args)`, type_args carries the \u003cT\u003e\n                match \u0026callee.kind {\n                    ExpressionKind::Identifier(name) =\u003e {\n                        let class_name = self.interner.resolve(*name);\n\n                        // Check if the class is abstract\n                        if self.type_env.is_abstract_class(\u0026class_name) {\n                            return Err(TypeCheckError::new(\n                                format!(\"Cannot instantiate abstract class '{}'\", class_name),\n                                span,\n                            ));\n                        }\n\n                        // Return a Reference type to the class, preserving type arguments\n                        Ok(Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: typedlua_parser::ast::Spanned::new(*name, span),\n                                type_arguments: type_args.clone(),\n                                span,\n                            }),\n                            span,\n                        ))\n                    }\n                    _ =\u003e {\n                        // For complex callee expressions, infer the callee type\n                        // and use it as the result type\n                        Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n                    }\n                }\n            }\n\n            ExpressionKind::Parenthesized(inner) =\u003e {\n                // Parenthesized expressions have the same type as their inner expression\n                self.infer_expression(inner)\n            }\n\n            _ =\u003e {\n                // For unimplemented expression types, return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n        }\n    }\n\n    fn infer_binary_op(\n        \u0026self,\n        op: BinaryOp,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match op {\n            BinaryOp::Add\n            | BinaryOp::Subtract\n            | BinaryOp::Multiply\n            | BinaryOp::Divide\n            | BinaryOp::Modulo\n            | BinaryOp::Power\n            | BinaryOp::IntegerDivide =\u003e {\n                // Check for operator overload on the left operand's class\n                if let Some(return_type) = self.check_operator_overload(left, op) {\n                    return Ok(return_type);\n                }\n\n                // Check that both operands are numbers\n                let left_is_number = matches!(\n                    left.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                        | TypeKind::Literal(Literal::Number(_))\n                );\n                let right_is_number = matches!(\n                    right.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                        | TypeKind::Literal(Literal::Number(_))\n                );\n\n                if !left_is_number {\n                    self.diagnostic_handler.error(\n                        span,\n                        \u0026format!(\n                            \"Left operand of arithmetic operation must be a number, found {:?}\",\n                            left.kind\n                        ),\n                    );\n                }\n                if !right_is_number {\n                    self.diagnostic_handler.error(\n                        span,\n                        \u0026format!(\n                            \"Right operand of arithmetic operation must be a number, found {:?}\",\n                            right.kind\n                        ),\n                    );\n                }\n\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span))\n            }\n            BinaryOp::Concatenate =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::String), span))\n            }\n            BinaryOp::Equal\n            | BinaryOp::NotEqual\n            | BinaryOp::LessThan\n            | BinaryOp::LessThanOrEqual\n            | BinaryOp::GreaterThan\n            | BinaryOp::GreaterThanOrEqual\n            | BinaryOp::Instanceof =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span))\n            }\n            BinaryOp::And | BinaryOp::Or =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            BinaryOp::NullCoalesce =\u003e self.infer_null_coalesce(left, right, span),\n            BinaryOp::BitwiseAnd\n            | BinaryOp::BitwiseOr\n            | BinaryOp::BitwiseXor\n            | BinaryOp::ShiftLeft\n            | BinaryOp::ShiftRight =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span))\n            }\n        }\n    }\n\n    fn infer_unary_op(\n        \u0026self,\n        op: UnaryOp,\n        _operand: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match op {\n            UnaryOp::Negate =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n            UnaryOp::Not =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span)),\n            UnaryOp::Length =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n            UnaryOp::BitwiseNot =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n        }\n    }\n\n    #[instrument(skip(self, callee_type, args), fields(args_count = args.len(), return_type))]\n    fn infer_call(\n        \u0026mut self,\n        callee_type: \u0026Type,\n        args: \u0026mut [Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        debug!(callee_type = ?callee_type.kind, \"Inferring function call type\");\n\n        match \u0026callee_type.kind {\n            TypeKind::Function(func_type) =\u003e {\n                // Check argument count\n                let actual_args = args.len();\n                debug!(actual_args, \"Checking function call argument count\");\n\n                // Count required parameters (non-optional, non-rest)\n                let required_params = func_type\n                    .parameters\n                    .iter()\n                    .filter(|p| !p.is_rest \u0026\u0026 !p.is_optional)\n                    .count();\n\n                // Check if the last parameter is a rest parameter\n                let has_rest_param = func_type\n                    .parameters\n                    .last()\n                    .map(|p| p.is_rest)\n                    .unwrap_or(false);\n\n                // Count optional parameters\n                let optional_params = func_type\n                    .parameters\n                    .iter()\n                    .filter(|p| p.is_optional \u0026\u0026 !p.is_rest)\n                    .count();\n\n                let max_params = if has_rest_param {\n                    usize::MAX\n                } else {\n                    required_params + optional_params\n                };\n\n                // Check minimum required arguments\n                if actual_args \u003c required_params {\n                    error!(\n                        expected_min = required_params,\n                        actual = actual_args,\n                        \"Too few arguments\"\n                    );\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Function expects at least {} arguments but received {}\",\n                            required_params, actual_args\n                        ),\n                        span,\n                    ));\n                }\n\n                // Check maximum allowed arguments (unless rest parameter)\n                if !has_rest_param \u0026\u0026 actual_args \u003e max_params {\n                    error!(\n                        expected_max = max_params,\n                        actual = actual_args,\n                        \"Too many arguments\"\n                    );\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Function expects at most {} arguments but received {}\",\n                            max_params, actual_args\n                        ),\n                        span,\n                    ));\n                }\n\n                // Check argument types match parameter types\n                for (i, arg) in args.iter_mut().enumerate() {\n                    if i \u003c func_type.parameters.len() {\n                        let param = \u0026func_type.parameters[i];\n\n                        // Infer the argument type\n                        if let Ok(arg_type) = self.infer_expression(\u0026mut arg.value) {\n                            if let Some(param_type) = \u0026param.type_annotation {\n                                // Check if argument type is assignable to parameter type\n                                if !TypeCompatibility::is_assignable(\u0026arg_type, param_type) {\n                                    self.diagnostic_handler.error(\n                                        arg.value.span,\n                                        \u0026format!(\n                                            \"Type mismatch in function call: argument {} has type '{:?}' which is not assignable to parameter type '{:?}'\",\n                                            i + 1,\n                                            arg_type.kind,\n                                            param_type.kind\n                                        ),\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                Ok((*func_type.return_type).clone())\n            }\n            _ =\u003e {\n                // Non-function called - return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n        }\n    }\n\n    fn infer_method(\n        \u0026self,\n        obj_type: \u0026Type,\n        method_name: \u0026str,\n        _args: \u0026[Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        // Look up the method in the object type\n        match \u0026obj_type.kind {\n            TypeKind::Object(obj) =\u003e {\n                for member in \u0026obj.members {\n                    if let ObjectTypeMember::Method(method) = member {\n                        if self.interner.resolve(method.name.node) == method_name {\n                            // Return the return type of the method\n                            return Ok(method.return_type.clone());\n                        }\n                    }\n                }\n                // Method not found - return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            TypeKind::Reference(type_ref) =\u003e {\n                let type_name = self.interner.resolve(type_ref.name.node);\n                if let Some(class_members) = self.access_control.get_class_members(\u0026type_name) {\n                    for member in class_members {\n                        if member.name == method_name {\n                            if let ClassMemberKind::Method { return_type, .. } = \u0026member.kind {\n                                return Ok(return_type.clone().unwrap_or_else(|| {\n                                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)\n                                }));\n                            }\n                        }\n                    }\n                }\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            _ =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)),\n        }\n    }\n\n    fn infer_member(\n        \u0026self,\n        obj_type: \u0026Type,\n        member: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match \u0026obj_type.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                let type_name = self.interner.resolve(type_ref.name.node);\n\n                // Check if this is a generic type alias with type arguments\n                if let Some(type_args) = \u0026type_ref.type_arguments {\n                    if let Some(generic_alias) = self.type_env.get_generic_type_alias(\u0026type_name) {\n                        // Instantiate the generic type alias with the provided type arguments\n                        use crate::types::generics::instantiate_type;\n                        let instantiated = instantiate_type(\n                            \u0026generic_alias.typ,\n                            \u0026generic_alias.type_parameters,\n                            type_args,\n                        )\n                        .map_err(|e| TypeCheckError::new(e, span))?;\n                        return self.infer_member(\u0026instantiated, member, span);\n                    }\n                }\n\n                // Check if this is a type parameter with a constraint\n                // If so, resolve member access on the constraint type\n                if let Some(constraint) = self.type_env.get_type_param_constraint(\u0026type_name) {\n                    return self.infer_member(constraint, member, span);\n                }\n\n                // Check access modifiers for class members (only for actual classes)\n                self.check_member_access(\u0026type_name, member, span)?;\n\n                // Try to resolve the type reference to get the actual type\n                // Use lookup_type to check both type aliases and interfaces\n                if let Some(resolved) = self.type_env.lookup_type(\u0026type_name) {\n                    // Check for infinite recursion - if resolved type is the same as input, avoid loop\n                    if matches!(resolved.kind, TypeKind::Reference(_)) {\n                        // If resolved is still a reference, check if it's the same reference\n                        if let TypeKind::Reference(resolved_ref) = \u0026resolved.kind {\n                            if resolved_ref.name.node == type_ref.name.node {\n                                // Same type reference - check if it's a field of the enum\n                                // For enums, we need to check fields defined in the enum declaration\n                                // For now, return unknown to avoid infinite loop\n                                // The field will be looked up from the symbol table instead\n                                return Ok(Type::new(\n                                    TypeKind::Primitive(PrimitiveType::Unknown),\n                                    span,\n                                ));\n                            }\n                        }\n                    }\n                    return self.infer_member(resolved, member, span);\n                }\n\n                // Fall back to access_control for class property/getter types.\n                // Only use concrete type annotations (no unresolved type parameters).\n                // Generic class members contain raw type params like T that need\n                // substitution, so we skip those and fall through to Unknown.\n                if let Some(class_members) = self.access_control.get_class_members(\u0026type_name) {\n                    for m in class_members {\n                        if m.name == member {\n                            match \u0026m.kind {\n                                ClassMemberKind::Property { type_annotation }\n                                    if !self.type_has_unresolved_params(type_annotation) =\u003e\n                                {\n                                    return Ok(type_annotation.clone());\n                                }\n                                ClassMemberKind::Getter { return_type }\n                                    if !self.type_has_unresolved_params(return_type) =\u003e\n                                {\n                                    return Ok(return_type.clone());\n                                }\n                                ClassMemberKind::Method {\n                                    return_type: Some(rt),\n                                    ..\n                                } if !self.type_has_unresolved_params(rt) =\u003e {\n                                    return Ok(rt.clone());\n                                }\n                                _ =\u003e {}\n                            }\n                        }\n                    }\n                }\n\n                // If not resolvable, return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            TypeKind::Object(obj) =\u003e {\n                // Find member in object type\n                let member_id = self.interner.intern(member);\n                for obj_member in \u0026obj.members {\n                    match obj_member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            if prop.name.node == member_id {\n                                return Ok(prop.type_annotation.clone());\n                            }\n                        }\n                        ObjectTypeMember::Method(method) =\u003e {\n                            if method.name.node == member_id {\n                                return Ok(Type::new(\n                                    TypeKind::Primitive(PrimitiveType::Unknown),\n                                    span,\n                                ));\n                            }\n                        }\n                        _ =\u003e {}\n                    }\n                }\n                // Member not found\n                Err(TypeCheckError::new(\n                    format!(\"Property '{}' does not exist\", member),\n                    span,\n                ))\n            }\n            TypeKind::Union(types) =\u003e {\n                // For union types, try to find the member in each non-nil variant\n                let non_nil_types: Vec\u003c\u0026Type\u003e = types.iter().filter(|t| !self.is_nil(t)).collect();\n\n                if non_nil_types.is_empty() {\n                    // All types are nil - member access on nil returns nil\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Nil), span))\n                } else if non_nil_types.len() == 1 {\n                    // Single non-nil type - look up member on that\n                    self.infer_member(non_nil_types[0], member, span)\n                } else {\n                    // Multiple non-nil types - try to look up member on first valid one\n                    // For simplicity, we try each type and return the first successful lookup\n                    for typ in non_nil_types {\n                        if let Ok(member_type) = self.infer_member(typ, member, span) {\n                            return Ok(member_type);\n                        }\n                    }\n                    // If none succeeded, return unknown\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n                }\n            }\n            TypeKind::Nullable(inner) =\u003e {\n                // For nullable types, look up member on the inner type\n                self.infer_member(inner, member, span)\n            }\n            _ =\u003e {\n                // Non-object member access - return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n        }\n    }\n\n    fn infer_index(\u0026self, obj_type: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match \u0026obj_type.kind {\n            TypeKind::Array(elem_type) =\u003e Ok((**elem_type).clone()),\n            TypeKind::Tuple(types) =\u003e {\n                // For now, return union of all tuple types\n                if types.is_empty() {\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n                } else if types.len() == 1 {\n                    Ok(types[0].clone())\n                } else {\n                    Ok(Type::new(TypeKind::Union(types.clone()), span))\n                }\n            }\n            _ =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)),\n        }\n    }\n\n    fn make_optional(\u0026self, typ: Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), span);\n        Ok(Type::new(TypeKind::Union(vec![typ, nil_type]), span))\n    }\n\n    fn remove_nil(\u0026self, typ: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match \u0026typ.kind {\n            TypeKind::Union(types) =\u003e {\n                let non_nil_types: Vec\u003cType\u003e =\n                    types.iter().filter(|t| !self.is_nil(t)).cloned().collect();\n                if non_nil_types.is_empty() {\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n                } else if non_nil_types.len() == 1 {\n                    Ok(non_nil_types[0].clone())\n                } else {\n                    Ok(Type::new(TypeKind::Union(non_nil_types), span))\n                }\n            }\n            _ =\u003e {\n                if self.is_nil(typ) {\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n                } else {\n                    Ok(typ.clone())\n                }\n            }\n        }\n    }\n\n    fn is_nil(\u0026self, typ: \u0026Type) -\u003e bool {\n        match \u0026typ.kind {\n            TypeKind::Primitive(PrimitiveType::Nil) =\u003e true,\n            TypeKind::Literal(Literal::Nil) =\u003e true,\n            TypeKind::Nullable(inner) =\u003e self.is_nil(inner),\n            _ =\u003e false,\n        }\n    }\n\n    fn infer_null_coalesce(\n        \u0026self,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        // If left is T | nil, the result is T (left without nil)\n        // If left is just nil, the result is the type of right\n        // Otherwise, the result is the type of left\n        let left_without_nil = self.remove_nil(left, span)?;\n\n        // If left was just nil, return right's type\n        // Otherwise return left's type without nil\n        let result = if matches!(\n            left_without_nil.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ) {\n            right.clone()\n        } else {\n            left_without_nil\n        };\n\n        Ok(result)\n    }\n\n    #[instrument(skip(self, match_expr), fields(arms = match_expr.arms.len()))]\n    fn check_match(\u0026mut self, match_expr: \u0026mut MatchExpression) -\u003e Result\u003cType, TypeCheckError\u003e {\n        debug!(span = ?match_expr.span, \"Checking match expression\");\n\n        // Type check the value being matched\n        let value_type = self.infer_expression(\u0026mut match_expr.value)?;\n        debug!(value_type = ?value_type.kind, \"Matched value type\");\n\n        if match_expr.arms.is_empty() {\n            error!(\"Match expression has no arms\");\n            return Err(TypeCheckError::new(\n                \"Match expression must have at least one arm\".to_string(),\n                match_expr.span,\n            ));\n        }\n\n        // Check exhaustiveness\n        self.check_exhaustiveness(\u0026match_expr.arms, \u0026value_type, match_expr.span)?;\n\n        // Check for unreachable patterns\n        self.check_unreachable_patterns(\u0026match_expr.arms);\n\n        // Type check each arm and collect result types\n        let mut arm_types = Vec::new();\n\n        for arm in match_expr.arms.iter_mut() {\n            // Enter a new scope for this arm\n            self.symbol_table.enter_scope();\n\n            // First check that the pattern is compatible with the value type\n            self.check_pattern(\u0026arm.pattern, \u0026value_type)?;\n\n            // Then narrow the type based on the pattern for variable bindings\n            let _narrowed_type = self.narrow_type_by_pattern(\u0026arm.pattern, \u0026value_type)?;\n\n            // Check the guard if present\n            if let Some(guard) = \u0026mut arm.guard {\n                let guard_type = self.infer_expression(guard)?;\n                // Guard should be boolean (primitive or literal)\n                let is_boolean =\n                    matches!(guard_type.kind, TypeKind::Primitive(PrimitiveType::Boolean))\n                        || matches!(guard_type.kind, TypeKind::Literal(Literal::Boolean(_)));\n\n                if !is_boolean {\n                    return Err(TypeCheckError::new(\n                        format!(\"Match guard must be boolean, found {:?}\", guard_type.kind),\n                        guard.span,\n                    ));\n                }\n            }\n\n            // Check the arm body\n            let arm_type = match \u0026mut arm.body {\n                MatchArmBody::Expression(expr) =\u003e self.infer_expression(expr)?,\n                MatchArmBody::Block(block) =\u003e {\n                    // Type check the block\n                    for _stmt in \u0026mut block.statements {\n                        // For now, we can't easily check statements here\n                        // This would require access to the full type checker\n                    }\n                    // Return type is void for blocks without explicit return\n                    Type::new(TypeKind::Primitive(PrimitiveType::Void), block.span)\n                }\n            };\n\n            arm_types.push(arm_type);\n\n            // Exit the arm scope\n            self.symbol_table.exit_scope();\n        }\n\n        // All arms should have compatible types - return a union\n        if arm_types.is_empty() {\n            return Ok(Type::new(\n                TypeKind::Primitive(PrimitiveType::Never),\n                match_expr.span,\n            ));\n        }\n\n        // Find the common type or create a union\n        let mut result_type = arm_types[0].clone();\n        for arm_type in \u0026arm_types[1..] {\n            if TypeCompatibility::is_assignable(\u0026result_type, arm_type) {\n                // Keep result_type\n            } else if TypeCompatibility::is_assignable(arm_type, \u0026result_type) {\n                result_type = arm_type.clone();\n            } else {\n                // Types are incompatible, create a union\n                match \u0026mut result_type.kind {\n                    TypeKind::Union(types) =\u003e {\n                        types.push(arm_type.clone());\n                    }\n                    _ =\u003e {\n                        result_type = Type::new(\n                            TypeKind::Union(vec![result_type.clone(), arm_type.clone()]),\n                            match_expr.span,\n                        );\n                    }\n                }\n            }\n        }\n\n        Ok(result_type)\n    }\n\n    fn check_pattern(\n        \u0026mut self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        match pattern {\n            Pattern::Identifier(ident) =\u003e {\n                // Bind the identifier to the expected type\n                let symbol = Symbol::new(\n                    self.interner.resolve(ident.node).to_string(),\n                    SymbolKind::Variable,\n                    expected_type.clone(),\n                    ident.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, ident.span))?;\n                Ok(())\n            }\n            Pattern::Literal(lit, span) =\u003e {\n                // Check that the literal pattern type is compatible with the expected type\n                // For example, a string literal pattern should not match a number value\n                let pattern_is_number = matches!(lit, Literal::Number(_) | Literal::Integer(_));\n                let pattern_is_string = matches!(lit, Literal::String(_));\n                let pattern_is_boolean = matches!(lit, Literal::Boolean(_));\n                let pattern_is_nil = matches!(lit, Literal::Nil);\n\n                let expected_is_number = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Number | PrimitiveType::Integer)\n                        | TypeKind::Literal(Literal::Number(_) | Literal::Integer(_))\n                );\n                let expected_is_string = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                        | TypeKind::Literal(Literal::String(_))\n                );\n                let expected_is_boolean = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Boolean)\n                        | TypeKind::Literal(Literal::Boolean(_))\n                );\n                let expected_is_nil = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Nil) | TypeKind::Literal(Literal::Nil)\n                );\n\n                let is_compatible = (pattern_is_number \u0026\u0026 expected_is_number)\n                    || (pattern_is_string \u0026\u0026 expected_is_string)\n                    || (pattern_is_boolean \u0026\u0026 expected_is_boolean)\n                    || (pattern_is_nil \u0026\u0026 expected_is_nil);\n\n                if !is_compatible {\n                    self.diagnostic_handler.error(\n                        *span,\n                        \u0026format!(\n                            \"Pattern type mismatch: cannot match literal '{:?}' against type '{:?}'\",\n                            lit, expected_type.kind\n                        ),\n                    );\n                }\n                Ok(())\n            }\n            Pattern::Wildcard(_) =\u003e {\n                // Wildcard matches anything\n                Ok(())\n            }\n            Pattern::Array(array_pattern) =\u003e {\n                // Expected type should be an array\n                match \u0026expected_type.kind {\n                    TypeKind::Array(elem_type) =\u003e {\n                        for elem in \u0026array_pattern.elements {\n                            match elem {\n                                ArrayPatternElement::Pattern(pat) =\u003e {\n                                    self.check_pattern(pat, elem_type)?;\n                                }\n                                ArrayPatternElement::Rest(ident) =\u003e {\n                                    // Rest pattern gets the array type\n                                    let symbol = Symbol::new(\n                                        self.interner.resolve(ident.node).to_string(),\n                                        SymbolKind::Variable,\n                                        expected_type.clone(),\n                                        ident.span,\n                                    );\n                                    self.symbol_table\n                                        .declare(symbol)\n                                        .map_err(|e| TypeCheckError::new(e, ident.span))?;\n                                }\n                                ArrayPatternElement::Hole =\u003e {\n                                    // Hole doesn't bind anything\n                                }\n                            }\n                        }\n                        Ok(())\n                    }\n                    _ =\u003e Err(TypeCheckError::new(\n                        format!(\n                            \"Array pattern requires array type, found {:?}\",\n                            expected_type.kind\n                        ),\n                        array_pattern.span,\n                    )),\n                }\n            }\n            Pattern::Object(object_pattern) =\u003e {\n                // Extract property types from the expected object type\n                match \u0026expected_type.kind {\n                    TypeKind::Object(obj_type) =\u003e {\n                        for prop in \u0026object_pattern.properties {\n                            // Find the property type in the object\n                            let prop_type = obj_type\n                                .members\n                                .iter()\n                                .find_map(|member| {\n                                    if let ObjectTypeMember::Property(prop_sig) = member {\n                                        if prop_sig.name.node == prop.key.node {\n                                            return Some(prop_sig.type_annotation.clone());\n                                        }\n                                    }\n                                    None\n                                })\n                                .unwrap_or_else(|| {\n                                    Type::new(\n                                        TypeKind::Primitive(PrimitiveType::Unknown),\n                                        prop.span,\n                                    )\n                                });\n\n                            if let Some(value_pattern) = \u0026prop.value {\n                                self.check_pattern(value_pattern, \u0026prop_type)?;\n                            } else {\n                                // Shorthand: bind the key as a variable\n                                let symbol = Symbol::new(\n                                    self.interner.resolve(prop.key.node).to_string(),\n                                    SymbolKind::Variable,\n                                    prop_type,\n                                    prop.key.span,\n                                );\n                                self.symbol_table\n                                    .declare(symbol)\n                                    .map_err(|e| TypeCheckError::new(e, prop.key.span))?;\n                            }\n                        }\n                        Ok(())\n                    }\n                    _ =\u003e {\n                        // If it's not an object type, accept any object pattern for now\n                        // This handles cases like Table type\n                        for prop in \u0026object_pattern.properties {\n                            let prop_type =\n                                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), prop.span);\n\n                            if let Some(value_pattern) = \u0026prop.value {\n                                self.check_pattern(value_pattern, \u0026prop_type)?;\n                            } else {\n                                let symbol = Symbol::new(\n                                    self.interner.resolve(prop.key.node).to_string(),\n                                    SymbolKind::Variable,\n                                    prop_type,\n                                    prop.key.span,\n                                );\n                                self.symbol_table\n                                    .declare(symbol)\n                                    .map_err(|e| TypeCheckError::new(e, prop.key.span))?;\n                            }\n                        }\n                        Ok(())\n                    }\n                }\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // Validate that all alternatives bind the same variables with compatible types\n                self.validate_or_pattern_bindings(or_pattern, expected_type)?;\n\n                // Type check and declare symbols from the first alternative only\n                // All alternatives are guaranteed to have the same bindings due to validation above\n                if let Some(first) = or_pattern.alternatives.first() {\n                    self.check_pattern(first, expected_type)?;\n                }\n\n                Ok(())\n            }\n        }\n    }\n}\n\nimpl TypeInferrer\u003c'_\u003e {\n    /// Check if a type contains unresolved type parameters (References that aren't\n    /// known types, interfaces, or classes). Used to guard the access_control fallback\n    /// in infer_member so we don't return raw type annotations with unsubstituted\n    /// type parameters from generic classes.\n    fn type_has_unresolved_params(\u0026self, ty: \u0026Type) -\u003e bool {\n        match \u0026ty.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                let name = self.interner.resolve(type_ref.name.node);\n                self.type_env.lookup_type(\u0026name).is_none()\n                    \u0026\u0026 self.access_control.get_class_members(\u0026name).is_none()\n            }\n            TypeKind::Union(types) | TypeKind::Intersection(types) | TypeKind::Tuple(types) =\u003e {\n                types.iter().any(|t| self.type_has_unresolved_params(t))\n            }\n            TypeKind::Array(elem) | TypeKind::Nullable(elem) | TypeKind::Parenthesized(elem) =\u003e {\n                self.type_has_unresolved_params(elem)\n            }\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if a type has an operator overload for the given binary operation.\n    /// Returns the operator's return type if found.\n    fn check_operator_overload(\u0026self, operand_type: \u0026Type, op: BinaryOp) -\u003e Option\u003cType\u003e {\n        let op_kind = match op {\n            BinaryOp::Add =\u003e OperatorKind::Add,\n            BinaryOp::Subtract =\u003e OperatorKind::Subtract,\n            BinaryOp::Multiply =\u003e OperatorKind::Multiply,\n            BinaryOp::Divide =\u003e OperatorKind::Divide,\n            BinaryOp::Modulo =\u003e OperatorKind::Modulo,\n            BinaryOp::Power =\u003e OperatorKind::Power,\n            BinaryOp::IntegerDivide =\u003e OperatorKind::FloorDivide,\n            BinaryOp::Concatenate =\u003e OperatorKind::Concatenate,\n            BinaryOp::Equal =\u003e OperatorKind::Equal,\n            BinaryOp::NotEqual =\u003e OperatorKind::NotEqual,\n            BinaryOp::LessThan =\u003e OperatorKind::LessThan,\n            BinaryOp::LessThanOrEqual =\u003e OperatorKind::LessThanOrEqual,\n            BinaryOp::GreaterThan =\u003e OperatorKind::GreaterThan,\n            BinaryOp::GreaterThanOrEqual =\u003e OperatorKind::GreaterThanOrEqual,\n            BinaryOp::BitwiseAnd =\u003e OperatorKind::BitwiseAnd,\n            BinaryOp::BitwiseOr =\u003e OperatorKind::BitwiseOr,\n            BinaryOp::BitwiseXor =\u003e OperatorKind::BitwiseXor,\n            BinaryOp::ShiftLeft =\u003e OperatorKind::ShiftLeft,\n            BinaryOp::ShiftRight =\u003e OperatorKind::ShiftRight,\n            _ =\u003e return None,\n        };\n\n        // Get the class name from the operand type\n        let class_name = match \u0026operand_type.kind {\n            TypeKind::Reference(type_ref) =\u003e self.interner.resolve(type_ref.name.node),\n            _ =\u003e return None,\n        };\n\n        // Look up class members for operator overloads\n        let members = self.access_control.get_class_members(\u0026class_name)?;\n        for member in members {\n            if let ClassMemberKind::Operator {\n                operator,\n                return_type,\n                ..\n            } = \u0026member.kind\n            {\n                if *operator == op_kind {\n                    return return_type.clone();\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Extract all variable bindings from a pattern\n    fn extract_pattern_bindings(\n        \u0026self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003cPatternBindings, TypeCheckError\u003e {\n        let mut bindings = PatternBindings {\n            bindings: FxHashMap::default(),\n        };\n        self.extract_pattern_bindings_recursive(pattern, expected_type, \u0026mut bindings)?;\n        Ok(bindings)\n    }\n\n    /// Recursive helper for extracting bindings from a pattern\n    fn extract_pattern_bindings_recursive(\n        \u0026self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n        bindings: \u0026mut PatternBindings,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        match pattern {\n            Pattern::Identifier(ident) =\u003e {\n                // Add binding for the identifier\n                let name = self.interner.resolve(ident.node).to_string();\n                let binding = PatternBinding {\n                    typ: expected_type.clone(),\n                    span: ident.span,\n                };\n                bindings.bindings.insert(name, binding);\n                Ok(())\n            }\n            Pattern::Array(array_pattern) =\u003e {\n                // Extract element type and recurse into elements\n                let elem_type_box: Box\u003cType\u003e = match \u0026expected_type.kind {\n                    TypeKind::Array(et) =\u003e et.clone(),\n                    _ =\u003e {\n                        // If expected type is not an array, use Unknown as element type\n                        // This allows us to extract bindings even when type info is incomplete\n                        Box::new(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            expected_type.span,\n                        ))\n                    }\n                };\n\n                for elem in \u0026array_pattern.elements {\n                    match elem {\n                        ArrayPatternElement::Pattern(pat) =\u003e {\n                            self.extract_pattern_bindings_recursive(pat, \u0026elem_type_box, bindings)?;\n                        }\n                        ArrayPatternElement::Rest(ident) =\u003e {\n                            let name = self.interner.resolve(ident.node).to_string();\n                            let binding = PatternBinding {\n                                typ: expected_type.clone(),\n                                span: ident.span,\n                            };\n                            bindings.bindings.insert(name, binding);\n                        }\n                        ArrayPatternElement::Hole =\u003e {\n                            // Hole doesn't bind anything\n                        }\n                    }\n                }\n                Ok(())\n            }\n            Pattern::Object(object_pattern) =\u003e {\n                // Extract property types and recurse\n                for prop in \u0026object_pattern.properties {\n                    let prop_type = match \u0026expected_type.kind {\n                        TypeKind::Object(obj_type) =\u003e obj_type\n                            .members\n                            .iter()\n                            .find_map(|member| {\n                                if let ObjectTypeMember::Property(prop_sig) = member {\n                                    if prop_sig.name.node == prop.key.node {\n                                        return Some(prop_sig.type_annotation.clone());\n                                    }\n                                }\n                                None\n                            })\n                            .unwrap_or_else(|| {\n                                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), prop.span)\n                            }),\n                        _ =\u003e {\n                            // If expected type is not an object, use Unknown for property type\n                            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), prop.span)\n                        }\n                    };\n\n                    if let Some(value_pattern) = \u0026prop.value {\n                        self.extract_pattern_bindings_recursive(\n                            value_pattern,\n                            \u0026prop_type,\n                            bindings,\n                        )?;\n                    } else {\n                        // Shorthand: { x } means { x: x }\n                        let name = self.interner.resolve(prop.key.node).to_string();\n                        let binding = PatternBinding {\n                            typ: prop_type,\n                            span: prop.key.span,\n                        };\n                        bindings.bindings.insert(name, binding);\n                    }\n                }\n                Ok(())\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // For or-patterns, we'll handle this at a higher level\n                // For now, just extract from the first alternative\n                if let Some(first) = or_pattern.alternatives.first() {\n                    self.extract_pattern_bindings_recursive(first, expected_type, bindings)?;\n                }\n                Ok(())\n            }\n            Pattern::Literal(_, _) | Pattern::Wildcard(_) =\u003e {\n                // No bindings\n                Ok(())\n            }\n        }\n    }\n\n    /// Validate that all alternatives in an or-pattern bind the same variables with compatible types\n    fn validate_or_pattern_bindings(\n        \u0026self,\n        or_pattern: \u0026typedlua_parser::ast::pattern::OrPattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003cPatternBindings, TypeCheckError\u003e {\n        use rustc_hash::FxHashSet;\n\n        if or_pattern.alternatives.is_empty() {\n            return Err(TypeCheckError::new(\n                \"Or-pattern must have at least one alternative\",\n                or_pattern.span,\n            ));\n        }\n\n        // Extract bindings from first alternative (reference)\n        let first_alt = \u0026or_pattern.alternatives[0];\n        let first_bindings = self.extract_pattern_bindings(first_alt, expected_type)?;\n\n        // Check each subsequent alternative\n        for (i, alt) in or_pattern.alternatives.iter().enumerate().skip(1) {\n            let alt_bindings = self.extract_pattern_bindings(alt, expected_type)?;\n\n            // Check 1: Same variable names\n            let first_names: FxHashSet\u003c\u0026String\u003e = first_bindings.bindings.keys().collect();\n            let alt_names: FxHashSet\u003c\u0026String\u003e = alt_bindings.bindings.keys().collect();\n\n            // Variables in first but not in alt\n            if let Some(missing) = first_names.difference(\u0026alt_names).next() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Or-pattern alternative {} does not bind variable '{}' (bound in alternative 0)\",\n                        i, missing\n                    ),\n                    alt.span(),\n                ));\n            }\n\n            // Variables in alt but not in first\n            if let Some(extra) = alt_names.difference(\u0026first_names).next() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Or-pattern alternative {} binds variable '{}' not present in alternative 0\",\n                        i, extra\n                    ),\n                    alt.span(),\n                ));\n            }\n\n            // Check 2: Type compatibility for common variables\n            for (name, first_binding) in \u0026first_bindings.bindings {\n                let alt_binding = \u0026alt_bindings.bindings[name];\n\n                // Types must be mutually assignable\n                if !TypeCompatibility::is_assignable(\u0026first_binding.typ, \u0026alt_binding.typ)\n                    \u0026\u0026 !TypeCompatibility::is_assignable(\u0026alt_binding.typ, \u0026first_binding.typ)\n                {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Variable '{}' has incompatible types across or-pattern alternatives: {:?} vs {:?}\",\n                            name, first_binding.typ.kind, alt_binding.typ.kind\n                        ),\n                        alt_binding.span,\n                    ));\n                }\n            }\n        }\n\n        Ok(first_bindings)\n    }\n\n    /// Check if an earlier pattern subsumes a later pattern\n    /// Returns true if all values matching the later pattern would also match the earlier pattern\n    fn pattern_subsumes(\u0026self, earlier: \u0026Pattern, later: \u0026Pattern) -\u003e bool {\n        match (earlier, later) {\n            // Wildcard and identifier always subsume everything\n            (Pattern::Wildcard(_), _) | (Pattern::Identifier(_), _) =\u003e true,\n\n            // Nothing subsumes wildcard/identifier (they're most general)\n            (_, Pattern::Wildcard(_)) | (_, Pattern::Identifier(_)) =\u003e false,\n\n            // Literal subsumption: exact match only\n            (Pattern::Literal(a, _), Pattern::Literal(b, _)) =\u003e a == b,\n\n            // Or-pattern subsumption cases\n            (Pattern::Or(or1), Pattern::Or(or2)) =\u003e {\n                self.or_pattern_subsumes_or_pattern(\u0026or1.alternatives, \u0026or2.alternatives)\n            }\n            (Pattern::Or(or_pat), later_pat) =\u003e {\n                self.or_pattern_subsumes_pattern(\u0026or_pat.alternatives, later_pat)\n            }\n            (earlier_pat, Pattern::Or(or_pat)) =\u003e {\n                self.pattern_subsumes_or_pattern(earlier_pat, \u0026or_pat.alternatives)\n            }\n\n            // Array pattern subsumption\n            (Pattern::Array(arr1), Pattern::Array(arr2)) =\u003e self.array_pattern_subsumes(arr1, arr2),\n\n            // Object pattern subsumption\n            (Pattern::Object(obj1), Pattern::Object(obj2)) =\u003e {\n                self.object_pattern_subsumes(obj1, obj2)\n            }\n\n            // Different pattern types don't subsume each other\n            _ =\u003e false,\n        }\n    }\n\n    /// Or-pattern subsumes single pattern if ANY alternative subsumes it\n    fn or_pattern_subsumes_pattern(\u0026self, or_alts: \u0026[Pattern], later: \u0026Pattern) -\u003e bool {\n        or_alts.iter().any(|alt| self.pattern_subsumes(alt, later))\n    }\n\n    /// Single pattern subsumes or-pattern if it subsumes ALL alternatives\n    fn pattern_subsumes_or_pattern(\u0026self, earlier: \u0026Pattern, or_alts: \u0026[Pattern]) -\u003e bool {\n        or_alts\n            .iter()\n            .all(|alt| self.pattern_subsumes(earlier, alt))\n    }\n\n    /// Or-pattern subsumes or-pattern if every later alternative is subsumed by some earlier alternative\n    fn or_pattern_subsumes_or_pattern(\n        \u0026self,\n        earlier_alts: \u0026[Pattern],\n        later_alts: \u0026[Pattern],\n    ) -\u003e bool {\n        later_alts.iter().all(|later_alt| {\n            earlier_alts\n                .iter()\n                .any(|earlier_alt| self.pattern_subsumes(earlier_alt, later_alt))\n        })\n    }\n\n    /// Array pattern subsumption\n    fn array_pattern_subsumes(\n        \u0026self,\n        earlier: \u0026typedlua_parser::ast::pattern::ArrayPattern,\n        later: \u0026typedlua_parser::ast::pattern::ArrayPattern,\n    ) -\u003e bool {\n        let earlier_elems = \u0026earlier.elements;\n        let later_elems = \u0026later.elements;\n\n        // Check if patterns have rest elements\n        let earlier_has_rest = earlier_elems\n            .iter()\n            .any(|e| matches!(e, ArrayPatternElement::Rest(_)));\n        let later_has_rest = later_elems\n            .iter()\n            .any(|e| matches!(e, ArrayPatternElement::Rest(_)));\n\n        // If neither has rest, lengths must match\n        if !earlier_has_rest \u0026\u0026 !later_has_rest \u0026\u0026 earlier_elems.len() != later_elems.len() {\n            return false;\n        }\n\n        // If earlier has rest but later doesn't, earlier can match more cases\n        // Need to check that later's elements match earlier's prefix\n        if earlier_has_rest \u0026\u0026 !later_has_rest {\n            // Find the position of the rest element in earlier\n            if let Some(rest_pos) = earlier_elems\n                .iter()\n                .position(|e| matches!(e, ArrayPatternElement::Rest(_)))\n            {\n                // Check that later has at least rest_pos elements\n                if later_elems.len() \u003c rest_pos {\n                    return false;\n                }\n\n                // Check element-by-element for the prefix\n                for i in 0..rest_pos {\n                    if !self.array_elements_subsume_single(\u0026earlier_elems[i], \u0026later_elems[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n\n        // Element-by-element subsumption\n        earlier_elems\n            .iter()\n            .zip(later_elems.iter())\n            .all(|(e1, e2)| self.array_elements_subsume_single(e1, e2))\n    }\n\n    /// Check if array pattern element e1 subsumes e2\n    fn array_elements_subsume_single(\n        \u0026self,\n        e1: \u0026ArrayPatternElement,\n        e2: \u0026ArrayPatternElement,\n    ) -\u003e bool {\n        match (e1, e2) {\n            (ArrayPatternElement::Pattern(p1), ArrayPatternElement::Pattern(p2)) =\u003e {\n                self.pattern_subsumes(p1, p2)\n            }\n            (ArrayPatternElement::Rest(_), ArrayPatternElement::Rest(_)) =\u003e true,\n            (ArrayPatternElement::Hole, ArrayPatternElement::Hole) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    /// Object pattern subsumption\n    fn object_pattern_subsumes(\n        \u0026self,\n        earlier: \u0026typedlua_parser::ast::pattern::ObjectPattern,\n        later: \u0026typedlua_parser::ast::pattern::ObjectPattern,\n    ) -\u003e bool {\n        let earlier_props = \u0026earlier.properties;\n        let later_props = \u0026later.properties;\n\n        // Earlier must have  properties (less constrained)\n        if earlier_props.len() \u003e later_props.len() {\n            return false;\n        }\n\n        // Every property in earlier must subsume corresponding property in later\n        earlier_props.iter().all(|earlier_prop| {\n            later_props.iter().any(|later_prop| {\n                // Properties must have same key\n                if earlier_prop.key.node != later_prop.key.node {\n                    return false;\n                }\n\n                // Check value pattern subsumption\n                match (\u0026earlier_prop.value, \u0026later_prop.value) {\n                    (Some(p1), Some(p2)) =\u003e self.pattern_subsumes(p1, p2),\n                    (None, None) =\u003e true,     // Both are shorthand bindings\n                    (None, Some(_)) =\u003e true,  // Earlier shorthand subsumes explicit pattern\n                    (Some(_), None) =\u003e false, // Explicit pattern more specific\n                }\n            })\n        })\n    }\n\n    /// Check for unreachable patterns in match arms\n    fn check_unreachable_patterns(\u0026self, arms: \u0026[MatchArm]) {\n        for (i, arm) in arms.iter().enumerate() {\n            // Skip checking arms with guards - they may not match\n            if arm.guard.is_some() {\n                continue;\n            }\n\n            // Check against all previous arms\n            for (j, earlier_arm) in arms[..i].iter().enumerate() {\n                // Earlier arms with guards don't guarantee subsumption\n                if earlier_arm.guard.is_some() {\n                    continue;\n                }\n\n                if self.pattern_subsumes(\u0026earlier_arm.pattern, \u0026arm.pattern) {\n                    self.emit_unreachable_warning(i, j, earlier_arm, arm);\n                    break; // Only warn once per unreachable pattern\n                }\n            }\n        }\n    }\n\n    /// Emit a warning for an unreachable pattern\n    fn emit_unreachable_warning(\n        \u0026self,\n        _current_idx: usize,\n        subsuming_idx: usize,\n        earlier_arm: \u0026MatchArm,\n        current_arm: \u0026MatchArm,\n    ) {\n        use crate::cli::diagnostics::error_codes::UNREACHABLE_PATTERN;\n\n        let message = format!(\n            \"Pattern is unreachable because it is already covered by arm {} (line {})\",\n            subsuming_idx + 1,\n            earlier_arm.pattern.span().line\n        );\n\n        let diagnostic =\n            crate::cli::diagnostics::Diagnostic::warning(current_arm.pattern.span(), message)\n                .with_code(UNREACHABLE_PATTERN);\n\n        self.diagnostic_handler.report(diagnostic);\n    }\n\n    /// Check member access permissions\n    fn check_member_access(\n        \u0026self,\n        class_name: \u0026str,\n        member_name: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.access_control.check_member_access(\n            self.access_control.get_current_class(),\n            class_name,\n            member_name,\n            span,\n        )\n    }\n\n    /// Check if match arms are exhaustive for the given type\n    /// Helper to collect all literals from a pattern, including those in or-patterns\n    fn collect_pattern_literals\u003c'a\u003e(\u0026self, pattern: \u0026'a Pattern, literals: \u0026mut Vec\u003c\u0026'a Literal\u003e) {\n        match pattern {\n            Pattern::Literal(lit, _) =\u003e {\n                literals.push(lit);\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // Recursively collect from all alternatives\n                for alt in \u0026or_pattern.alternatives {\n                    self.collect_pattern_literals(alt, literals);\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn check_exhaustiveness(\n        \u0026self,\n        arms: \u0026[MatchArm],\n        value_type: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // If there's a wildcard or identifier pattern without a guard, it's exhaustive\n        let has_wildcard = arms.iter().any(|arm| {\n            let is_wildcard = matches!(arm.pattern, Pattern::Wildcard(_) | Pattern::Identifier(_))\n                \u0026\u0026 arm.guard.is_none();\n            eprintln!(\n                \"DEBUG check_exhaustiveness: arm pattern = {:?}, is_wildcard = {}\",\n                arm.pattern, is_wildcard\n            );\n            is_wildcard\n        });\n        eprintln!(\n            \"DEBUG check_exhaustiveness: has_wildcard = {}\",\n            has_wildcard\n        );\n\n        if has_wildcard {\n            return Ok(());\n        }\n\n        // Check exhaustiveness based on type\n        eprintln!(\n            \"DEBUG check_exhaustiveness: value_type.kind = {:?}\",\n            value_type.kind\n        );\n        match \u0026value_type.kind {\n            TypeKind::Primitive(PrimitiveType::Boolean) =\u003e {\n                // Boolean must match both true and false\n                let mut has_true = false;\n                let mut has_false = false;\n\n                eprintln!(\n                    \"DEBUG exhaustiveness: checking {} arms for boolean\",\n                    arms.len()\n                );\n                for arm in arms {\n                    // Collect all literals from the pattern, including those in or-patterns\n                    let mut literals = Vec::new();\n                    self.collect_pattern_literals(\u0026arm.pattern, \u0026mut literals);\n\n                    for lit in literals {\n                        if let Literal::Boolean(b) = lit {\n                            if *b {\n                                has_true = true;\n                            } else {\n                                has_false = true;\n                            }\n                        }\n                    }\n                }\n                eprintln!(\n                    \"DEBUG exhaustiveness: has_true={}, has_false={}\",\n                    has_true, has_false\n                );\n\n                if !has_true || !has_false {\n                    return Err(TypeCheckError::new(\n                        \"Non-exhaustive match: missing case for boolean type. Add patterns for both true and false, or use a wildcard (_) pattern.\".to_string(),\n                        span,\n                    ));\n                }\n                Ok(())\n            }\n            TypeKind::Union(types) =\u003e {\n                // For unions, we need to cover all union members\n                // This is a simplified check - we verify that each union member has a potential match\n                for union_type in types {\n                    let covered = arms.iter().any(|arm| {\n                        // Check if this arm could match this union member\n                        self.pattern_could_match(\u0026arm.pattern, union_type)\n                    });\n\n                    if !covered {\n                        return Err(TypeCheckError::new(\n                            format!(\"Non-exhaustive match: union type {:?} is not covered. Add a pattern to match this type or use a wildcard (_) pattern.\", union_type.kind),\n                            span,\n                        ));\n                    }\n                }\n                Ok(())\n            }\n            TypeKind::Literal(lit) =\u003e {\n                // For literal types, must match exactly that literal\n                let covered = arms.iter().any(|arm| {\n                    let mut literals = Vec::new();\n                    self.collect_pattern_literals(\u0026arm.pattern, \u0026mut literals);\n                    literals.contains(\u0026lit)\n                });\n\n                if !covered {\n                    return Err(TypeCheckError::new(\n                        format!(\"Non-exhaustive match: literal {:?} is not matched. Add a pattern to match this literal or use a wildcard (_) pattern.\", lit),\n                        span,\n                    ));\n                }\n                Ok(())\n            }\n            // For other types, we can't easily verify exhaustiveness\n            // Require a wildcard/identifier pattern or emit a warning\n            _ =\u003e {\n                // Emit a warning that exhaustiveness cannot be verified\n                // For now, we'll allow it but this could be improved\n                Ok(())\n            }\n        }\n    }\n\n    /// Helper to check if a pattern could match a type\n    fn pattern_could_match(\u0026self, pattern: \u0026Pattern, typ: \u0026Type) -\u003e bool {\n        match pattern {\n            Pattern::Wildcard(_) | Pattern::Identifier(_) =\u003e true,\n            Pattern::Literal(lit, _) =\u003e match \u0026typ.kind {\n                TypeKind::Literal(type_lit) =\u003e lit == type_lit,\n                TypeKind::Primitive(PrimitiveType::Boolean) =\u003e matches!(lit, Literal::Boolean(_)),\n                TypeKind::Primitive(PrimitiveType::Number) =\u003e matches!(lit, Literal::Number(_)),\n                TypeKind::Primitive(PrimitiveType::String) =\u003e matches!(lit, Literal::String(_)),\n                _ =\u003e false,\n            },\n            Pattern::Array(_) =\u003e matches!(typ.kind, TypeKind::Array(_) | TypeKind::Tuple(_)),\n            Pattern::Object(_) =\u003e matches!(typ.kind, TypeKind::Object(_)),\n            Pattern::Or(or_pattern) =\u003e {\n                // Or-pattern matches if ANY alternative could match\n                or_pattern\n                    .alternatives\n                    .iter()\n                    .any(|alt| self.pattern_could_match(alt, typ))\n            }\n        }\n    }\n\n    /// Narrow the type based on the pattern\n    fn narrow_type_by_pattern(\n        \u0026self,\n        pattern: \u0026Pattern,\n        typ: \u0026Type,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match pattern {\n            Pattern::Wildcard(_) | Pattern::Identifier(_) =\u003e {\n                // No narrowing for wildcard or identifier\n                Ok(typ.clone())\n            }\n            Pattern::Literal(lit, span) =\u003e {\n                // Narrow to literal type\n                Ok(Type::new(TypeKind::Literal(lit.clone()), *span))\n            }\n            Pattern::Array(_) =\u003e {\n                // For array patterns, narrow to array type if it's a union\n                match \u0026typ.kind {\n                    TypeKind::Union(types) =\u003e {\n                        // Find the array type in the union\n                        for t in types {\n                            if matches!(t.kind, TypeKind::Array(_) | TypeKind::Tuple(_)) {\n                                return Ok(t.clone());\n                            }\n                        }\n                        // No array type found, return original\n                        Ok(typ.clone())\n                    }\n                    _ =\u003e Ok(typ.clone()),\n                }\n            }\n            Pattern::Object(obj_pattern) =\u003e {\n                // For object patterns, narrow based on properties\n                match \u0026typ.kind {\n                    TypeKind::Union(types) =\u003e {\n                        // Find object types in the union that have the required properties\n                        let matching_types: Vec\u003c_\u003e = types\n                            .iter()\n                            .filter(|t| {\n                                if let TypeKind::Object(obj_type) = \u0026t.kind {\n                                    // Check if all pattern properties exist in this object type\n                                    obj_pattern.properties.iter().all(|prop| {\n                                        obj_type.members.iter().any(|member| {\n                                            if let ObjectTypeMember::Property(prop_sig) = member {\n                                                prop_sig.name.node == prop.key.node\n                                            } else {\n                                                false\n                                            }\n                                        })\n                                    })\n                                } else {\n                                    false\n                                }\n                            })\n                            .cloned()\n                            .collect();\n\n                        if matching_types.is_empty() {\n                            Ok(typ.clone())\n                        } else if matching_types.len() == 1 {\n                            Ok(matching_types[0].clone())\n                        } else {\n                            Ok(Type::new(TypeKind::Union(matching_types), typ.span))\n                        }\n                    }\n                    _ =\u003e Ok(typ.clone()),\n                }\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // Narrow to union of all narrowed alternative types\n                let mut narrowed_types = Vec::new();\n\n                for alt in \u0026or_pattern.alternatives {\n                    let narrowed = self.narrow_type_by_pattern(alt, typ)?;\n                    narrowed_types.push(narrowed);\n                }\n\n                // If all narrowed to same type, return single type\n                if narrowed_types.len() == 1 {\n                    Ok(narrowed_types[0].clone())\n                } else {\n                    // Different types - return union\n                    Ok(Type::new(TypeKind::Union(narrowed_types), typ.span))\n                }\n            }\n        }\n    }\n\n    /// Infer the return type from a block by collecting all return statements\n    /// Returns None if no return statements are found (void function)\n    fn infer_block_return_type(\n        \u0026mut self,\n        block: \u0026mut Block,\n    ) -\u003e Result\u003cOption\u003cType\u003e, TypeCheckError\u003e {\n        self.infer_block_return_type_recursive(block)\n    }\n\n    /// Recursively collect return types from a block\n    fn infer_block_return_type_recursive(\n        \u0026mut self,\n        block: \u0026mut Block,\n    ) -\u003e Result\u003cOption\u003cType\u003e, TypeCheckError\u003e {\n        let mut return_types: Vec\u003cType\u003e = Vec::new();\n\n        for stmt in \u0026mut block.statements {\n            match stmt {\n                Statement::Return(return_stmt) =\u003e {\n                    // Infer the type of the return expression(s)\n                    if return_stmt.values.is_empty() {\n                        // Void return\n                        return_types.push(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Void),\n                            return_stmt.span,\n                        ));\n                    } else if return_stmt.values.len() == 1 {\n                        // Single return value\n                        let mut expr = return_stmt.values[0].clone();\n                        let typ = self.infer_expression(\u0026mut expr)?;\n                        return_types.push(typ);\n                    } else {\n                        // Multiple return values - create a tuple\n                        let mut tuple_types = Vec::new();\n                        for expr in return_stmt.values.iter_mut() {\n                            let mut expr_copy: Expression = expr.clone();\n                            let typ = self.infer_expression(\u0026mut expr_copy)?;\n                            tuple_types.push(typ);\n                        }\n                        return_types\n                            .push(Type::new(TypeKind::Tuple(tuple_types), return_stmt.span));\n                    }\n                }\n                Statement::If(if_stmt) =\u003e {\n                    // Check the then block\n                    if let Some(then_type) =\n                        self.infer_block_return_type_recursive(\u0026mut if_stmt.then_block)?\n                    {\n                        return_types.push(then_type);\n                    }\n\n                    // Check else-if blocks\n                    for else_if in \u0026mut if_stmt.else_ifs {\n                        if let Some(else_if_type) =\n                            self.infer_block_return_type_recursive(\u0026mut else_if.block)?\n                        {\n                            return_types.push(else_if_type);\n                        }\n                    }\n\n                    // Check else block\n                    if let Some(else_block) = \u0026mut if_stmt.else_block {\n                        if let Some(else_type) =\n                            self.infer_block_return_type_recursive(else_block)?\n                        {\n                            return_types.push(else_type);\n                        }\n                    }\n                }\n                Statement::Try(try_stmt) =\u003e {\n                    // Check try block\n                    if let Some(try_type) =\n                        self.infer_block_return_type_recursive(\u0026mut try_stmt.try_block)?\n                    {\n                        return_types.push(try_type);\n                    }\n\n                    // Check catch blocks\n                    for catch in \u0026mut try_stmt.catch_clauses {\n                        if let Some(catch_type) =\n                            self.infer_block_return_type_recursive(\u0026mut catch.body)?\n                        {\n                            return_types.push(catch_type);\n                        }\n                    }\n\n                    // Check finally block (though finally typically doesn't return)\n                    if let Some(finally) = \u0026mut try_stmt.finally_block {\n                        if let Some(finally_type) =\n                            self.infer_block_return_type_recursive(finally)?\n                        {\n                            return_types.push(finally_type);\n                        }\n                    }\n                }\n                Statement::While(while_stmt) =\u003e {\n                    if let Some(body_type) =\n                        self.infer_block_return_type_recursive(\u0026mut while_stmt.body)?\n                    {\n                        return_types.push(body_type);\n                    }\n                }\n                Statement::Repeat(repeat_stmt) =\u003e {\n                    if let Some(body_type) =\n                        self.infer_block_return_type_recursive(\u0026mut repeat_stmt.body)?\n                    {\n                        return_types.push(body_type);\n                    }\n                }\n                Statement::For(for_stmt) =\u003e match \u0026mut **for_stmt {\n                    typedlua_parser::ast::statement::ForStatement::Numeric(numeric) =\u003e {\n                        if let Some(body_type) =\n                            self.infer_block_return_type_recursive(\u0026mut numeric.body)?\n                        {\n                            return_types.push(body_type);\n                        }\n                    }\n                    typedlua_parser::ast::statement::ForStatement::Generic(generic) =\u003e {\n                        if let Some(body_type) =\n                            self.infer_block_return_type_recursive(\u0026mut generic.body)?\n                        {\n                            return_types.push(body_type);\n                        }\n                    }\n                },\n                _ =\u003e {\n                    // Other statements don't contain return statements at the top level\n                    // but might contain them in nested expressions (like lambdas)\n                }\n            }\n        }\n\n        if return_types.is_empty() {\n            Ok(None)\n        } else if return_types.len() == 1 {\n            Ok(Some(return_types[0].clone()))\n        } else {\n            // Multiple return types - try to find a common type\n            // For now, create a union of all return types\n            Ok(Some(Type::new(TypeKind::Union(return_types), block.span)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod inference_tests;\n","traces":[{"line":124,"address":[],"length":0,"stats":{"Line":346}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":690}},{"line":152,"address":[],"length":0,"stats":{"Line":1380}},{"line":153,"address":[],"length":0,"stats":{"Line":2070}},{"line":155,"address":[],"length":0,"stats":{"Line":1380}},{"line":157,"address":[],"length":0,"stats":{"Line":690}},{"line":158,"address":[],"length":0,"stats":{"Line":294}},{"line":159,"address":[],"length":0,"stats":{"Line":294}},{"line":160,"address":[],"length":0,"stats":{"Line":588}},{"line":163,"address":[],"length":0,"stats":{"Line":169}},{"line":164,"address":[],"length":0,"stats":{"Line":676}},{"line":165,"address":[],"length":0,"stats":{"Line":169}},{"line":168,"address":[],"length":0,"stats":{"Line":347}},{"line":169,"address":[],"length":0,"stats":{"Line":9}},{"line":170,"address":[],"length":0,"stats":{"Line":9}},{"line":174,"address":[],"length":0,"stats":{"Line":477}},{"line":175,"address":[],"length":0,"stats":{"Line":157}},{"line":176,"address":[],"length":0,"stats":{"Line":157}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":264}},{"line":187,"address":[],"length":0,"stats":{"Line":88}},{"line":188,"address":[],"length":0,"stats":{"Line":352}},{"line":189,"address":[],"length":0,"stats":{"Line":352}},{"line":190,"address":[],"length":0,"stats":{"Line":528}},{"line":193,"address":[],"length":0,"stats":{"Line":20}},{"line":194,"address":[],"length":0,"stats":{"Line":10}},{"line":195,"address":[],"length":0,"stats":{"Line":40}},{"line":196,"address":[],"length":0,"stats":{"Line":50}},{"line":199,"address":[],"length":0,"stats":{"Line":72}},{"line":200,"address":[],"length":0,"stats":{"Line":96}},{"line":203,"address":[],"length":0,"stats":{"Line":42}},{"line":204,"address":[],"length":0,"stats":{"Line":23}},{"line":206,"address":[],"length":0,"stats":{"Line":20}},{"line":207,"address":[],"length":0,"stats":{"Line":16}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":24}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":18}},{"line":219,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":120}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":40}},{"line":253,"address":[],"length":0,"stats":{"Line":80}},{"line":254,"address":[],"length":0,"stats":{"Line":80}},{"line":255,"address":[],"length":0,"stats":{"Line":100}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":4}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":6}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":5}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":6}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":7}},{"line":316,"address":[],"length":0,"stats":{"Line":14}},{"line":318,"address":[],"length":0,"stats":{"Line":4}},{"line":319,"address":[],"length":0,"stats":{"Line":6}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":10}},{"line":330,"address":[],"length":0,"stats":{"Line":29}},{"line":331,"address":[],"length":0,"stats":{"Line":12}},{"line":332,"address":[],"length":0,"stats":{"Line":12}},{"line":333,"address":[],"length":0,"stats":{"Line":48}},{"line":334,"address":[],"length":0,"stats":{"Line":36}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":10}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":15}},{"line":370,"address":[],"length":0,"stats":{"Line":12}},{"line":371,"address":[],"length":0,"stats":{"Line":14}},{"line":372,"address":[],"length":0,"stats":{"Line":14}},{"line":375,"address":[],"length":0,"stats":{"Line":7}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":14}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":384,"address":[],"length":0,"stats":{"Line":5}},{"line":385,"address":[],"length":0,"stats":{"Line":15}},{"line":386,"address":[],"length":0,"stats":{"Line":20}},{"line":387,"address":[],"length":0,"stats":{"Line":5}},{"line":394,"address":[],"length":0,"stats":{"Line":10}},{"line":397,"address":[],"length":0,"stats":{"Line":24}},{"line":399,"address":[],"length":0,"stats":{"Line":48}},{"line":401,"address":[],"length":0,"stats":{"Line":106}},{"line":402,"address":[],"length":0,"stats":{"Line":41}},{"line":404,"address":[],"length":0,"stats":{"Line":40}},{"line":405,"address":[],"length":0,"stats":{"Line":40}},{"line":406,"address":[],"length":0,"stats":{"Line":40}},{"line":409,"address":[],"length":0,"stats":{"Line":160}},{"line":414,"address":[],"length":0,"stats":{"Line":120}},{"line":417,"address":[],"length":0,"stats":{"Line":40}},{"line":420,"address":[],"length":0,"stats":{"Line":120}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":1}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":455,"address":[],"length":0,"stats":{"Line":4}},{"line":456,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":460,"address":[],"length":0,"stats":{"Line":3}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":48}},{"line":478,"address":[],"length":0,"stats":{"Line":24}},{"line":479,"address":[],"length":0,"stats":{"Line":24}},{"line":483,"address":[],"length":0,"stats":{"Line":14}},{"line":485,"address":[],"length":0,"stats":{"Line":28}},{"line":488,"address":[],"length":0,"stats":{"Line":30}},{"line":489,"address":[],"length":0,"stats":{"Line":16}},{"line":490,"address":[],"length":0,"stats":{"Line":22}},{"line":492,"address":[],"length":0,"stats":{"Line":12}},{"line":495,"address":[],"length":0,"stats":{"Line":6}},{"line":499,"address":[],"length":0,"stats":{"Line":24}},{"line":500,"address":[],"length":0,"stats":{"Line":8}},{"line":501,"address":[],"length":0,"stats":{"Line":8}},{"line":502,"address":[],"length":0,"stats":{"Line":8}},{"line":504,"address":[],"length":0,"stats":{"Line":16}},{"line":509,"address":[],"length":0,"stats":{"Line":42}},{"line":510,"address":[],"length":0,"stats":{"Line":56}},{"line":511,"address":[],"length":0,"stats":{"Line":20}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":519,"address":[],"length":0,"stats":{"Line":24}},{"line":520,"address":[],"length":0,"stats":{"Line":20}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":28}},{"line":536,"address":[],"length":0,"stats":{"Line":28}},{"line":537,"address":[],"length":0,"stats":{"Line":28}},{"line":538,"address":[],"length":0,"stats":{"Line":14}},{"line":548,"address":[],"length":0,"stats":{"Line":28}},{"line":551,"address":[],"length":0,"stats":{"Line":3}},{"line":553,"address":[],"length":0,"stats":{"Line":6}},{"line":556,"address":[],"length":0,"stats":{"Line":7}},{"line":557,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":6}},{"line":560,"address":[],"length":0,"stats":{"Line":4}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":6}},{"line":568,"address":[],"length":0,"stats":{"Line":2}},{"line":569,"address":[],"length":0,"stats":{"Line":2}},{"line":570,"address":[],"length":0,"stats":{"Line":2}},{"line":572,"address":[],"length":0,"stats":{"Line":4}},{"line":577,"address":[],"length":0,"stats":{"Line":6}},{"line":578,"address":[],"length":0,"stats":{"Line":2}},{"line":580,"address":[],"length":0,"stats":{"Line":6}},{"line":581,"address":[],"length":0,"stats":{"Line":6}},{"line":583,"address":[],"length":0,"stats":{"Line":1}},{"line":585,"address":[],"length":0,"stats":{"Line":3}},{"line":590,"address":[],"length":0,"stats":{"Line":5}},{"line":591,"address":[],"length":0,"stats":{"Line":4}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":6}},{"line":606,"address":[],"length":0,"stats":{"Line":6}},{"line":609,"address":[],"length":0,"stats":{"Line":6}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":611,"address":[],"length":0,"stats":{"Line":8}},{"line":612,"address":[],"length":0,"stats":{"Line":8}},{"line":615,"address":[],"length":0,"stats":{"Line":6}},{"line":616,"address":[],"length":0,"stats":{"Line":1}},{"line":617,"address":[],"length":0,"stats":{"Line":3}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":3}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":2}},{"line":629,"address":[],"length":0,"stats":{"Line":4}},{"line":635,"address":[],"length":0,"stats":{"Line":3}},{"line":638,"address":[],"length":0,"stats":{"Line":1}},{"line":639,"address":[],"length":0,"stats":{"Line":4}},{"line":640,"address":[],"length":0,"stats":{"Line":4}},{"line":642,"address":[],"length":0,"stats":{"Line":3}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":3}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":2}},{"line":648,"address":[],"length":0,"stats":{"Line":2}},{"line":649,"address":[],"length":0,"stats":{"Line":1}},{"line":654,"address":[],"length":0,"stats":{"Line":2}},{"line":655,"address":[],"length":0,"stats":{"Line":4}},{"line":656,"address":[],"length":0,"stats":{"Line":3}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":2}},{"line":695,"address":[],"length":0,"stats":{"Line":6}},{"line":700,"address":[],"length":0,"stats":{"Line":52}},{"line":705,"address":[],"length":0,"stats":{"Line":88}},{"line":712,"address":[],"length":0,"stats":{"Line":88}},{"line":721,"address":[],"length":0,"stats":{"Line":105}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":35}},{"line":727,"address":[],"length":0,"stats":{"Line":25}},{"line":731,"address":[],"length":0,"stats":{"Line":35}},{"line":732,"address":[],"length":0,"stats":{"Line":19}},{"line":737,"address":[],"length":0,"stats":{"Line":35}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":35}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":70}},{"line":759,"address":[],"length":0,"stats":{"Line":12}},{"line":768,"address":[],"length":0,"stats":{"Line":64}},{"line":771,"address":[],"length":0,"stats":{"Line":14}},{"line":773,"address":[],"length":0,"stats":{"Line":5}},{"line":779,"address":[],"length":0,"stats":{"Line":14}},{"line":784,"address":[],"length":0,"stats":{"Line":10}},{"line":790,"address":[],"length":0,"stats":{"Line":10}},{"line":791,"address":[],"length":0,"stats":{"Line":8}},{"line":792,"address":[],"length":0,"stats":{"Line":4}},{"line":793,"address":[],"length":0,"stats":{"Line":4}},{"line":794,"address":[],"length":0,"stats":{"Line":4}},{"line":799,"address":[],"length":0,"stats":{"Line":25}},{"line":805,"address":[],"length":0,"stats":{"Line":25}},{"line":807,"address":[],"length":0,"stats":{"Line":25}},{"line":808,"address":[],"length":0,"stats":{"Line":19}},{"line":810,"address":[],"length":0,"stats":{"Line":57}},{"line":811,"address":[],"length":0,"stats":{"Line":19}},{"line":814,"address":[],"length":0,"stats":{"Line":38}},{"line":815,"address":[],"length":0,"stats":{"Line":19}},{"line":817,"address":[],"length":0,"stats":{"Line":67}},{"line":821,"address":[],"length":0,"stats":{"Line":38}},{"line":822,"address":[],"length":0,"stats":{"Line":19}},{"line":824,"address":[],"length":0,"stats":{"Line":19}},{"line":828,"address":[],"length":0,"stats":{"Line":38}},{"line":829,"address":[],"length":0,"stats":{"Line":19}},{"line":831,"address":[],"length":0,"stats":{"Line":45}},{"line":834,"address":[],"length":0,"stats":{"Line":38}},{"line":835,"address":[],"length":0,"stats":{"Line":2}},{"line":837,"address":[],"length":0,"stats":{"Line":17}},{"line":841,"address":[],"length":0,"stats":{"Line":19}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":36}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":109}},{"line":874,"address":[],"length":0,"stats":{"Line":52}},{"line":875,"address":[],"length":0,"stats":{"Line":48}},{"line":878,"address":[],"length":0,"stats":{"Line":72}},{"line":879,"address":[],"length":0,"stats":{"Line":47}},{"line":881,"address":[],"length":0,"stats":{"Line":53}},{"line":882,"address":[],"length":0,"stats":{"Line":21}},{"line":883,"address":[],"length":0,"stats":{"Line":14}},{"line":884,"address":[],"length":0,"stats":{"Line":14}},{"line":885,"address":[],"length":0,"stats":{"Line":7}},{"line":886,"address":[],"length":0,"stats":{"Line":7}},{"line":887,"address":[],"length":0,"stats":{"Line":7}},{"line":888,"address":[],"length":0,"stats":{"Line":7}},{"line":897,"address":[],"length":0,"stats":{"Line":19}},{"line":901,"address":[],"length":0,"stats":{"Line":12}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":21}},{"line":952,"address":[],"length":0,"stats":{"Line":21}},{"line":953,"address":[],"length":0,"stats":{"Line":8}},{"line":954,"address":[],"length":0,"stats":{"Line":32}},{"line":957,"address":[],"length":0,"stats":{"Line":8}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":16}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":40}},{"line":982,"address":[],"length":0,"stats":{"Line":16}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":24}},{"line":1007,"address":[],"length":0,"stats":{"Line":20}},{"line":1008,"address":[],"length":0,"stats":{"Line":10}},{"line":1009,"address":[],"length":0,"stats":{"Line":8}},{"line":1010,"address":[],"length":0,"stats":{"Line":8}},{"line":1011,"address":[],"length":0,"stats":{"Line":32}},{"line":1013,"address":[],"length":0,"stats":{"Line":8}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":12}},{"line":1037,"address":[],"length":0,"stats":{"Line":48}},{"line":1038,"address":[],"length":0,"stats":{"Line":68}},{"line":1039,"address":[],"length":0,"stats":{"Line":34}},{"line":1040,"address":[],"length":0,"stats":{"Line":14}},{"line":1041,"address":[],"length":0,"stats":{"Line":14}},{"line":1042,"address":[],"length":0,"stats":{"Line":9}},{"line":1045,"address":[],"length":0,"stats":{"Line":20}},{"line":1046,"address":[],"length":0,"stats":{"Line":20}},{"line":1047,"address":[],"length":0,"stats":{"Line":6}},{"line":1048,"address":[],"length":0,"stats":{"Line":3}},{"line":1049,"address":[],"length":0,"stats":{"Line":3}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":2}},{"line":1095,"address":[],"length":0,"stats":{"Line":2}},{"line":1096,"address":[],"length":0,"stats":{"Line":2}},{"line":1097,"address":[],"length":0,"stats":{"Line":2}},{"line":1098,"address":[],"length":0,"stats":{"Line":1}},{"line":1100,"address":[],"length":0,"stats":{"Line":2}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":1}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":2}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":3}},{"line":1113,"address":[],"length":0,"stats":{"Line":12}},{"line":1114,"address":[],"length":0,"stats":{"Line":9}},{"line":1117,"address":[],"length":0,"stats":{"Line":1}},{"line":1118,"address":[],"length":0,"stats":{"Line":1}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":3}},{"line":1132,"address":[],"length":0,"stats":{"Line":2}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":1}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":1}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":1}},{"line":1158,"address":[],"length":0,"stats":{"Line":5}},{"line":1162,"address":[],"length":0,"stats":{"Line":1}},{"line":1163,"address":[],"length":0,"stats":{"Line":1}},{"line":1166,"address":[],"length":0,"stats":{"Line":2}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":1}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1184,"address":[],"length":0,"stats":{"Line":0}},{"line":1185,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1304,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1367,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1375,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1385,"address":[],"length":0,"stats":{"Line":0}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1389,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1402,"address":[],"length":0,"stats":{"Line":0}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1419,"address":[],"length":0,"stats":{"Line":0}},{"line":1422,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":0}},{"line":1436,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":8}},{"line":1471,"address":[],"length":0,"stats":{"Line":8}},{"line":1472,"address":[],"length":0,"stats":{"Line":1}},{"line":1473,"address":[],"length":0,"stats":{"Line":4}},{"line":1474,"address":[],"length":0,"stats":{"Line":3}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1478,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":7}},{"line":1489,"address":[],"length":0,"stats":{"Line":35}},{"line":1490,"address":[],"length":0,"stats":{"Line":70}},{"line":1491,"address":[],"length":0,"stats":{"Line":17}},{"line":1492,"address":[],"length":0,"stats":{"Line":1}},{"line":1493,"address":[],"length":0,"stats":{"Line":11}},{"line":1494,"address":[],"length":0,"stats":{"Line":1}},{"line":1495,"address":[],"length":0,"stats":{"Line":2}},{"line":1496,"address":[],"length":0,"stats":{"Line":2}},{"line":1497,"address":[],"length":0,"stats":{"Line":1}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":35}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":35}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1524,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1529,"address":[],"length":0,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1571,"address":[],"length":0,"stats":{"Line":0}},{"line":1575,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[],"length":0,"stats":{"Line":0}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[],"length":0,"stats":{"Line":0}},{"line":1606,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1612,"address":[],"length":0,"stats":{"Line":0}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1627,"address":[],"length":0,"stats":{"Line":0}},{"line":1628,"address":[],"length":0,"stats":{"Line":0}},{"line":1629,"address":[],"length":0,"stats":{"Line":0}},{"line":1630,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[],"length":0,"stats":{"Line":0}},{"line":1637,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[],"length":0,"stats":{"Line":0}},{"line":1647,"address":[],"length":0,"stats":{"Line":0}},{"line":1648,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":0}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1693,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1727,"address":[],"length":0,"stats":{"Line":0}},{"line":1732,"address":[],"length":0,"stats":{"Line":0}},{"line":1733,"address":[],"length":0,"stats":{"Line":0}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1741,"address":[],"length":0,"stats":{"Line":0}},{"line":1744,"address":[],"length":0,"stats":{"Line":0}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1747,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":0}},{"line":1750,"address":[],"length":0,"stats":{"Line":0}},{"line":1751,"address":[],"length":0,"stats":{"Line":0}},{"line":1755,"address":[],"length":0,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1763,"address":[],"length":0,"stats":{"Line":0}},{"line":1768,"address":[],"length":0,"stats":{"Line":0}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1774,"address":[],"length":0,"stats":{"Line":0}},{"line":1776,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1785,"address":[],"length":0,"stats":{"Line":0}},{"line":1786,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1788,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1799,"address":[],"length":0,"stats":{"Line":0}},{"line":1802,"address":[],"length":0,"stats":{"Line":0}},{"line":1804,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1807,"address":[],"length":0,"stats":{"Line":0}},{"line":1810,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1816,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[],"length":0,"stats":{"Line":0}},{"line":1823,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1828,"address":[],"length":0,"stats":{"Line":0}},{"line":1829,"address":[],"length":0,"stats":{"Line":0}},{"line":1830,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1840,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1845,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1851,"address":[],"length":0,"stats":{"Line":0}},{"line":1852,"address":[],"length":0,"stats":{"Line":0}},{"line":1854,"address":[],"length":0,"stats":{"Line":0}},{"line":1855,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1876,"address":[],"length":0,"stats":{"Line":0}},{"line":1878,"address":[],"length":0,"stats":{"Line":0}},{"line":1879,"address":[],"length":0,"stats":{"Line":0}},{"line":1883,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1885,"address":[],"length":0,"stats":{"Line":0}},{"line":1886,"address":[],"length":0,"stats":{"Line":0}},{"line":1887,"address":[],"length":0,"stats":{"Line":0}},{"line":1894,"address":[],"length":0,"stats":{"Line":0}},{"line":1895,"address":[],"length":0,"stats":{"Line":0}},{"line":1897,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1902,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1908,"address":[],"length":0,"stats":{"Line":0}},{"line":1909,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1929,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":8}},{"line":1946,"address":[],"length":0,"stats":{"Line":16}},{"line":1947,"address":[],"length":0,"stats":{"Line":8}},{"line":1948,"address":[],"length":0,"stats":{"Line":8}},{"line":1949,"address":[],"length":0,"stats":{"Line":8}},{"line":1950,"address":[],"length":0,"stats":{"Line":8}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1959,"address":[],"length":0,"stats":{"Line":0}},{"line":1961,"address":[],"length":0,"stats":{"Line":0}},{"line":1963,"address":[],"length":0,"stats":{"Line":0}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1967,"address":[],"length":0,"stats":{"Line":0}},{"line":1971,"address":[],"length":0,"stats":{"Line":0}},{"line":1978,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1988,"address":[],"length":0,"stats":{"Line":0}},{"line":1992,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":2001,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[],"length":0,"stats":{"Line":0}},{"line":2007,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2011,"address":[],"length":0,"stats":{"Line":0}},{"line":2013,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2018,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2026,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2031,"address":[],"length":0,"stats":{"Line":0}},{"line":2032,"address":[],"length":0,"stats":{"Line":0}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2034,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2042,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2045,"address":[],"length":0,"stats":{"Line":0}},{"line":2048,"address":[],"length":0,"stats":{"Line":0}},{"line":2049,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2055,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2059,"address":[],"length":0,"stats":{"Line":0}},{"line":2060,"address":[],"length":0,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2062,"address":[],"length":0,"stats":{"Line":0}},{"line":2065,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2067,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2071,"address":[],"length":0,"stats":{"Line":0}},{"line":2078,"address":[],"length":0,"stats":{"Line":0}},{"line":2084,"address":[],"length":0,"stats":{"Line":0}},{"line":2085,"address":[],"length":0,"stats":{"Line":0}},{"line":2086,"address":[],"length":0,"stats":{"Line":0}},{"line":2087,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2091,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2094,"address":[],"length":0,"stats":{"Line":0}},{"line":2095,"address":[],"length":0,"stats":{"Line":0}},{"line":2096,"address":[],"length":0,"stats":{"Line":0}},{"line":2098,"address":[],"length":0,"stats":{"Line":0}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[],"length":0,"stats":{"Line":0}},{"line":2107,"address":[],"length":0,"stats":{"Line":0}},{"line":2112,"address":[],"length":0,"stats":{"Line":0}},{"line":2115,"address":[],"length":0,"stats":{"Line":0}},{"line":2117,"address":[],"length":0,"stats":{"Line":0}},{"line":2119,"address":[],"length":0,"stats":{"Line":0}},{"line":2123,"address":[],"length":0,"stats":{"Line":0}},{"line":2124,"address":[],"length":0,"stats":{"Line":0}},{"line":2126,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2128,"address":[],"length":0,"stats":{"Line":0}},{"line":2132,"address":[],"length":0,"stats":{"Line":0}},{"line":2134,"address":[],"length":0,"stats":{"Line":0}},{"line":2137,"address":[],"length":0,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2140,"address":[],"length":0,"stats":{"Line":0}},{"line":2142,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2147,"address":[],"length":0,"stats":{"Line":0}},{"line":2148,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2150,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2157,"address":[],"length":0,"stats":{"Line":0}},{"line":2163,"address":[],"length":0,"stats":{"Line":0}},{"line":2164,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2168,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[],"length":0,"stats":{"Line":0}},{"line":2174,"address":[],"length":0,"stats":{"Line":0}},{"line":2176,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[],"length":0,"stats":{"Line":0}},{"line":2179,"address":[],"length":0,"stats":{"Line":0}},{"line":2180,"address":[],"length":0,"stats":{"Line":0}},{"line":2184,"address":[],"length":0,"stats":{"Line":0}},{"line":2185,"address":[],"length":0,"stats":{"Line":0}},{"line":2188,"address":[],"length":0,"stats":{"Line":0}},{"line":2196,"address":[],"length":0,"stats":{"Line":14}},{"line":2200,"address":[],"length":0,"stats":{"Line":42}},{"line":2204,"address":[],"length":0,"stats":{"Line":14}},{"line":2208,"address":[],"length":0,"stats":{"Line":42}},{"line":2210,"address":[],"length":0,"stats":{"Line":36}},{"line":2211,"address":[],"length":0,"stats":{"Line":11}},{"line":2212,"address":[],"length":0,"stats":{"Line":10}},{"line":2214,"address":[],"length":0,"stats":{"Line":20}},{"line":2216,"address":[],"length":0,"stats":{"Line":0}},{"line":2217,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2220,"address":[],"length":0,"stats":{"Line":10}},{"line":2222,"address":[],"length":0,"stats":{"Line":30}},{"line":2223,"address":[],"length":0,"stats":{"Line":40}},{"line":2224,"address":[],"length":0,"stats":{"Line":30}},{"line":2227,"address":[],"length":0,"stats":{"Line":0}},{"line":2228,"address":[],"length":0,"stats":{"Line":0}},{"line":2229,"address":[],"length":0,"stats":{"Line":0}},{"line":2230,"address":[],"length":0,"stats":{"Line":0}},{"line":2231,"address":[],"length":0,"stats":{"Line":0}},{"line":2233,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2237,"address":[],"length":0,"stats":{"Line":0}},{"line":2239,"address":[],"length":0,"stats":{"Line":0}},{"line":2240,"address":[],"length":0,"stats":{"Line":0}},{"line":2242,"address":[],"length":0,"stats":{"Line":0}},{"line":2246,"address":[],"length":0,"stats":{"Line":0}},{"line":2247,"address":[],"length":0,"stats":{"Line":0}},{"line":2248,"address":[],"length":0,"stats":{"Line":0}},{"line":2250,"address":[],"length":0,"stats":{"Line":0}},{"line":2255,"address":[],"length":0,"stats":{"Line":0}},{"line":2256,"address":[],"length":0,"stats":{"Line":0}},{"line":2257,"address":[],"length":0,"stats":{"Line":0}},{"line":2259,"address":[],"length":0,"stats":{"Line":0}},{"line":2263,"address":[],"length":0,"stats":{"Line":0}},{"line":2265,"address":[],"length":0,"stats":{"Line":0}},{"line":2266,"address":[],"length":0,"stats":{"Line":0}},{"line":2268,"address":[],"length":0,"stats":{"Line":0}},{"line":2272,"address":[],"length":0,"stats":{"Line":0}},{"line":2273,"address":[],"length":0,"stats":{"Line":0}},{"line":2274,"address":[],"length":0,"stats":{"Line":0}},{"line":2276,"address":[],"length":0,"stats":{"Line":0}},{"line":2281,"address":[],"length":0,"stats":{"Line":0}},{"line":2282,"address":[],"length":0,"stats":{"Line":0}},{"line":2283,"address":[],"length":0,"stats":{"Line":0}},{"line":2285,"address":[],"length":0,"stats":{"Line":0}},{"line":2289,"address":[],"length":0,"stats":{"Line":0}},{"line":2290,"address":[],"length":0,"stats":{"Line":0}},{"line":2291,"address":[],"length":0,"stats":{"Line":0}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2296,"address":[],"length":0,"stats":{"Line":0}},{"line":2297,"address":[],"length":0,"stats":{"Line":0}},{"line":2298,"address":[],"length":0,"stats":{"Line":0}},{"line":2300,"address":[],"length":0,"stats":{"Line":0}},{"line":2303,"address":[],"length":0,"stats":{"Line":0}},{"line":2304,"address":[],"length":0,"stats":{"Line":0}},{"line":2305,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2308,"address":[],"length":0,"stats":{"Line":0}},{"line":2311,"address":[],"length":0,"stats":{"Line":0}},{"line":2312,"address":[],"length":0,"stats":{"Line":0}},{"line":2313,"address":[],"length":0,"stats":{"Line":0}},{"line":2315,"address":[],"length":0,"stats":{"Line":0}},{"line":2319,"address":[],"length":0,"stats":{"Line":1}},{"line":2326,"address":[],"length":0,"stats":{"Line":28}},{"line":2327,"address":[],"length":0,"stats":{"Line":4}},{"line":2328,"address":[],"length":0,"stats":{"Line":10}},{"line":2329,"address":[],"length":0,"stats":{"Line":10}},{"line":2333,"address":[],"length":0,"stats":{"Line":0}}],"covered":335,"coverable":1042},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","mod.rs"],"content":"mod access_control;\nmod inference;\nmod narrowing;\n\n// GenericVisitor types are available from typechecker::generics module directly\npub use access_control::{\n    AccessControl, AccessControlVisitor, ClassContext, ClassMemberInfo, ClassMemberKind,\n};\npub use inference::{TypeInferenceVisitor, TypeInferrer};\npub use narrowing::{narrow_type_from_condition, NarrowingContext, NarrowingVisitor, TypeNarrower};\n\npub trait TypeCheckVisitor {\n    #[allow(dead_code)]\n    fn name(\u0026self) -\u003e \u0026'static str;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","narrowing.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::expression::{BinaryOp, Expression, ExpressionKind, Literal, UnaryOp};\nuse typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\nuse typedlua_parser::string_interner::StringId;\n\n/// Trait for type narrowing operations\n///\n/// This trait defines the interface for narrowing types based on conditions and patterns.\n/// It is used by the type checker to refine variable types in conditional branches.\npub trait NarrowingVisitor {\n    /// Narrow types based on a condition expression\n    ///\n    /// Returns (then_context, else_context) with refined types for each branch.\n    /// The then_context contains types that apply when the condition is true,\n    /// and the else_context contains types that apply when the condition is false.\n    fn narrow_from_condition(\n        \u0026self,\n        condition: \u0026Expression,\n        base_ctx: \u0026NarrowingContext,\n        original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n    ) -\u003e (NarrowingContext, NarrowingContext);\n\n    /// Get the current narrowing context\n    fn get_context(\u0026self) -\u003e \u0026NarrowingContext;\n\n    /// Get a mutable reference to the narrowing context\n    fn get_context_mut(\u0026mut self) -\u003e \u0026mut NarrowingContext;\n}\n\n/// Type narrowing context - tracks refined types for variables in the current scope\n#[derive(Debug, Clone)]\npub struct NarrowingContext {\n    /// Map from variable name to narrowed type\n    narrowed_types: FxHashMap\u003cStringId, Type\u003e,\n}\n\nimpl Default for NarrowingContext {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl NarrowingContext {\n    pub fn new() -\u003e Self {\n        Self {\n            narrowed_types: FxHashMap::default(),\n        }\n    }\n\n    /// Get the narrowed type for a variable, if any\n    pub fn get_narrowed_type(\u0026self, name: StringId) -\u003e Option\u003c\u0026Type\u003e {\n        self.narrowed_types.get(\u0026name)\n    }\n\n    /// Set a narrowed type for a variable\n    pub fn set_narrowed_type(\u0026mut self, name: StringId, typ: Type) {\n        self.narrowed_types.insert(name, typ);\n    }\n\n    /// Remove a narrowed type (when variable is reassigned)\n    pub fn remove_narrowed_type(\u0026mut self, name: StringId) {\n        self.narrowed_types.remove(\u0026name);\n    }\n\n    /// Merge two narrowing contexts (for branch join points)\n    pub fn merge(then_ctx: \u0026Self, else_ctx: \u0026Self) -\u003e Self {\n        // For now, we only keep types that are the same in both branches\n        // More sophisticated: create union types for divergent branches\n        let mut merged = NarrowingContext::new();\n\n        for (name, then_type) in \u0026then_ctx.narrowed_types {\n            if let Some(else_type) = else_ctx.narrowed_types.get(name) {\n                if types_equal(then_type, else_type) {\n                    merged.narrowed_types.insert(*name, then_type.clone());\n                }\n            }\n        }\n\n        merged\n    }\n\n    /// Clone the context for a new branch\n    pub fn clone_for_branch(\u0026self) -\u003e Self {\n        self.clone()\n    }\n}\n\n/// Type narrower implementation that tracks narrowed types\npub struct TypeNarrower {\n    context: NarrowingContext,\n}\n\nimpl TypeNarrower {\n    /// Create a new type narrower with an empty context\n    pub fn new() -\u003e Self {\n        Self {\n            context: NarrowingContext::new(),\n        }\n    }\n}\n\nimpl Default for TypeNarrower {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl NarrowingVisitor for TypeNarrower {\n    fn narrow_from_condition(\n        \u0026self,\n        condition: \u0026Expression,\n        base_ctx: \u0026NarrowingContext,\n        original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n    ) -\u003e (NarrowingContext, NarrowingContext) {\n        narrow_type_from_condition(condition, base_ctx, original_types, interner)\n    }\n\n    fn get_context(\u0026self) -\u003e \u0026NarrowingContext {\n        \u0026self.context\n    }\n\n    fn get_context_mut(\u0026mut self) -\u003e \u0026mut NarrowingContext {\n        \u0026mut self.context\n    }\n}\n\n/// Narrow a type based on a condition expression\n/// Returns (then_context, else_context) with refined types for each branch\npub fn narrow_type_from_condition(\n    condition: \u0026Expression,\n    base_ctx: \u0026NarrowingContext,\n    original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n    interner: \u0026typedlua_parser::string_interner::StringInterner,\n) -\u003e (NarrowingContext, NarrowingContext) {\n    let mut then_ctx = base_ctx.clone_for_branch();\n    let mut else_ctx = base_ctx.clone_for_branch();\n\n    match \u0026condition.kind {\n        // typeof x == \"string\"\n        ExpressionKind::Binary(BinaryOp::Equal, left, right) =\u003e {\n            if let Some((var_name, type_name)) = extract_typeof_check(interner, left, right) {\n                if let Some(narrowed_type) = typeof_string_to_type(\u0026type_name) {\n                    then_ctx.set_narrowed_type(var_name, narrowed_type.clone());\n\n                    // In else branch, exclude the checked type\n                    if let Some(original) = original_types.get(\u0026var_name) {\n                        if let Some(else_type) = exclude_type(original, \u0026narrowed_type) {\n                            else_ctx.set_narrowed_type(var_name, else_type);\n                        }\n                    }\n                }\n            } else {\n                // Check for x == nil equality narrowing\n                if let Some((var_name, is_nil)) = extract_nil_check(interner, left, right) {\n                    if is_nil {\n                        // then: x is nil\n                        then_ctx.set_narrowed_type(\n                            var_name,\n                            Type::new(TypeKind::Primitive(PrimitiveType::Nil), condition.span),\n                        );\n\n                        // else: x is non-nil\n                        if let Some(original) = original_types.get(\u0026var_name) {\n                            if let Some(non_nil) = remove_nil_from_type(original) {\n                                else_ctx.set_narrowed_type(var_name, non_nil);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // typeof x != \"string\"\n        ExpressionKind::Binary(BinaryOp::NotEqual, left, right) =\u003e {\n            if let Some((var_name, type_name)) = extract_typeof_check(interner, left, right) {\n                if let Some(narrowed_type) = typeof_string_to_type(\u0026type_name) {\n                    // Flip the narrowing for != operator\n                    else_ctx.set_narrowed_type(var_name, narrowed_type.clone());\n\n                    if let Some(original) = original_types.get(\u0026var_name) {\n                        if let Some(then_type) = exclude_type(original, \u0026narrowed_type) {\n                            then_ctx.set_narrowed_type(var_name, then_type);\n                        }\n                    }\n                }\n            } else {\n                // x != nil\n                if let Some((var_name, is_nil)) = extract_nil_check(interner, left, right) {\n                    if is_nil {\n                        // Flip for != operator\n                        // then: x is non-nil\n                        if let Some(original) = original_types.get(\u0026var_name) {\n                            if let Some(non_nil) = remove_nil_from_type(original) {\n                                then_ctx.set_narrowed_type(var_name, non_nil);\n                            }\n                        }\n\n                        // else: x is nil\n                        else_ctx.set_narrowed_type(\n                            var_name,\n                            Type::new(TypeKind::Primitive(PrimitiveType::Nil), condition.span),\n                        );\n                    }\n                }\n            }\n        }\n\n        // not condition (flip the branches)\n        ExpressionKind::Unary(UnaryOp::Not, operand) =\u003e {\n            let (inner_then, inner_else) =\n                narrow_type_from_condition(operand, base_ctx, original_types, interner);\n            return (inner_else, inner_then); // Flip!\n        }\n\n        // condition1 and condition2\n        ExpressionKind::Binary(BinaryOp::And, left, right) =\u003e {\n            // First narrow with left condition\n            let (left_then, _left_else) =\n                narrow_type_from_condition(left, base_ctx, original_types, interner);\n\n            // Then narrow the 'then' branch with right condition\n            let (final_then, _final_else) =\n                narrow_type_from_condition(right, \u0026left_then, original_types, interner);\n\n            return (final_then, else_ctx);\n        }\n\n        // condition1 or condition2\n        ExpressionKind::Binary(BinaryOp::Or, left, right) =\u003e {\n            // For 'or', we narrow in the else branch with the right condition\n            let (left_then, left_else) =\n                narrow_type_from_condition(left, base_ctx, original_types, interner);\n            let (right_then, right_else) =\n                narrow_type_from_condition(right, \u0026left_else, original_types, interner);\n\n            // Then branch: either left or right was true\n            let merged_then = NarrowingContext::merge(\u0026left_then, \u0026right_then);\n\n            return (merged_then, right_else);\n        }\n\n        // Type guard function call: isString(x)\n        ExpressionKind::Call(function, arguments, _) =\u003e {\n            if let Some((var_name, narrowed_type)) =\n                extract_type_guard_call(function, arguments, original_types)\n            {\n                // In then branch: narrow to the guarded type\n                then_ctx.set_narrowed_type(var_name, narrowed_type.clone());\n\n                // In else branch: exclude the guarded type\n                if let Some(original) = original_types.get(\u0026var_name) {\n                    if let Some(else_type) = exclude_type(original, \u0026narrowed_type) {\n                        else_ctx.set_narrowed_type(var_name, else_type);\n                    }\n                }\n            }\n        }\n\n        // instanceof check: x instanceof ClassName\n        ExpressionKind::Binary(BinaryOp::Instanceof, left, right) =\u003e {\n            if let ExpressionKind::Identifier(var_name) = \u0026left.kind {\n                if let ExpressionKind::Identifier(class_name) = \u0026right.kind {\n                    // In then branch: narrow to the class type\n                    // For now, create a reference to the class type\n                    let class_type = Type::new(\n                        TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                            name: typedlua_parser::ast::Ident::new(*class_name, condition.span),\n                            type_arguments: None,\n                            span: condition.span,\n                        }),\n                        condition.span,\n                    );\n                    then_ctx.set_narrowed_type(*var_name, class_type.clone());\n\n                    // In else branch: exclude the class type\n                    if let Some(original) = original_types.get(var_name) {\n                        if let Some(else_type) = exclude_type(original, \u0026class_type) {\n                            else_ctx.set_narrowed_type(*var_name, else_type);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Truthiness check: if x then ...\n        ExpressionKind::Identifier(name) =\u003e {\n            if let Some(original) = original_types.get(name) {\n                // In then branch: x is truthy (non-nil, non-false)\n                if let Some(truthy_type) = make_truthy_type(original) {\n                    then_ctx.set_narrowed_type(*name, truthy_type);\n                }\n\n                // In else branch: x is falsy (nil or false)\n                if let Some(falsy_type) = make_falsy_type(original) {\n                    else_ctx.set_narrowed_type(*name, falsy_type);\n                }\n            }\n        }\n\n        _ =\u003e {\n            // No narrowing for other expression types\n        }\n    }\n\n    (then_ctx, else_ctx)\n}\n\n/// Extract typeof check: typeof x == \"string\" -\u003e Some((x, \"string\"))\nfn extract_typeof_check(\n    interner: \u0026typedlua_parser::string_interner::StringInterner,\n    left: \u0026Expression,\n    right: \u0026Expression,\n) -\u003e Option\u003c(StringId, String)\u003e {\n    // Check: typeof x == \"string\"\n    if let ExpressionKind::Call(function, arguments, _) = \u0026left.kind {\n        if let ExpressionKind::Identifier(func_name) = \u0026function.kind {\n            if interner.resolve(*func_name) == \"typeof\" \u0026\u0026 arguments.len() == 1 {\n                if let ExpressionKind::Identifier(var_name) = \u0026arguments[0].value.kind {\n                    if let ExpressionKind::Literal(Literal::String(type_name)) = \u0026right.kind {\n                        return Some((*var_name, type_name.clone()));\n                    }\n                }\n            }\n        }\n    }\n\n    // Check: \"string\" == typeof x (reversed)\n    if let ExpressionKind::Literal(Literal::String(type_name)) = \u0026left.kind {\n        if let ExpressionKind::Call(function, arguments, _) = \u0026right.kind {\n            if let ExpressionKind::Identifier(func_name) = \u0026function.kind {\n                if interner.resolve(*func_name) == \"typeof\" \u0026\u0026 arguments.len() == 1 {\n                    if let ExpressionKind::Identifier(var_name) = \u0026arguments[0].value.kind {\n                        return Some((*var_name, type_name.clone()));\n                    }\n                }\n            }\n        }\n    }\n\n    None\n}\n\n/// Extract type guard function call: isString(x) -\u003e Some((x, string))\n/// Type guards are functions with return type `param is Type`\nfn extract_type_guard_call(\n    function: \u0026Expression,\n    arguments: \u0026[typedlua_parser::ast::expression::Argument],\n    original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e Option\u003c(StringId, Type)\u003e {\n    // Check if this is a function call with one argument\n    if arguments.len() != 1 {\n        return None;\n    }\n\n    // Get the variable being checked\n    let var_name = match \u0026arguments[0].value.kind {\n        ExpressionKind::Identifier(name) =\u003e *name,\n        _ =\u003e return None,\n    };\n\n    // Try to get the function type from the passed context\n    // This allows checking actual type signatures when available\n    if let ExpressionKind::Identifier(func_name) = \u0026function.kind {\n        // Check if we have type information for this function\n        if let Some(func_type) = original_types.get(func_name) {\n            // Check if it's a function with a TypePredicate return type\n            if let TypeKind::Function(func_sig) = \u0026func_type.kind {\n                if let TypeKind::TypePredicate(predicate) = \u0026func_sig.return_type.kind {\n                    // Verify the parameter name matches the argument\n                    if predicate.parameter_name.node == var_name {\n                        return Some((var_name, (*predicate.type_annotation).clone()));\n                    }\n                }\n            }\n        }\n    }\n\n    None\n}\n\n/// Extract nil check: x == nil -\u003e Some((x, true))\nfn extract_nil_check(\n    _interner: \u0026typedlua_parser::string_interner::StringInterner,\n    left: \u0026Expression,\n    right: \u0026Expression,\n) -\u003e Option\u003c(StringId, bool)\u003e {\n    // Check: x == nil\n    if let ExpressionKind::Identifier(var_name) = \u0026left.kind {\n        if let ExpressionKind::Literal(Literal::Nil) = \u0026right.kind {\n            return Some((*var_name, true));\n        }\n    }\n\n    // Check: nil == x (reversed)\n    if let ExpressionKind::Literal(Literal::Nil) = \u0026left.kind {\n        if let ExpressionKind::Identifier(var_name) = \u0026right.kind {\n            return Some((*var_name, true));\n        }\n    }\n\n    None\n}\n\n/// Convert typeof string to a type\nfn typeof_string_to_type(type_name: \u0026str) -\u003e Option\u003cType\u003e {\n    let span = typedlua_parser::span::Span::new(0, 0, 0, 0);\n    match type_name {\n        \"nil\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Nil), span)),\n        \"boolean\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span)),\n        \"number\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n        \"string\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::String), span)),\n        \"table\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Table), span)),\n        _ =\u003e None,\n    }\n}\n\n/// Exclude a type from a union\nfn exclude_type(typ: \u0026Type, to_exclude: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let remaining: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !types_equal(t, to_exclude))\n                .cloned()\n                .collect();\n\n            if remaining.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if remaining.len() == 1 {\n                Some(remaining.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(remaining), typ.span))\n            }\n        }\n        _ if types_equal(typ, to_exclude) =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n        _ =\u003e Some(typ.clone()),\n    }\n}\n\n/// Remove nil from a type (for non-nil narrowing)\nfn remove_nil_from_type(typ: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let remaining: Vec\u003cType\u003e = types.iter().filter(|t| !is_nil_type(t)).cloned().collect();\n\n            if remaining.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if remaining.len() == 1 {\n                Some(remaining.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(remaining), typ.span))\n            }\n        }\n        _ if is_nil_type(typ) =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n        _ =\u003e Some(typ.clone()),\n    }\n}\n\n/// Check if a type is nil (handles both Literal(Nil) and Primitive(Nil))\nfn is_nil_type(typ: \u0026Type) -\u003e bool {\n    matches!(\n        typ.kind,\n        TypeKind::Primitive(PrimitiveType::Nil) | TypeKind::Literal(Literal::Nil)\n    )\n}\n\n/// Make a type truthy (remove nil and false)\nfn make_truthy_type(typ: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let truthy: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !is_falsy_type(t))\n                .cloned()\n                .collect();\n\n            if truthy.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if truthy.len() == 1 {\n                Some(truthy.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(truthy), typ.span))\n            }\n        }\n        _ if is_falsy_type(typ) =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n        _ =\u003e Some(typ.clone()),\n    }\n}\n\n/// Make a type falsy (only nil or false)\nfn make_falsy_type(typ: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let falsy: Vec\u003cType\u003e = types.iter().filter(|t| is_falsy_type(t)).cloned().collect();\n\n            if falsy.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if falsy.len() == 1 {\n                Some(falsy.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(falsy), typ.span))\n            }\n        }\n        _ if is_falsy_type(typ) =\u003e Some(typ.clone()),\n        _ =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n    }\n}\n\n/// Check if a type is falsy (nil or false)\nfn is_falsy_type(typ: \u0026Type) -\u003e bool {\n    matches!(\n        typ.kind,\n        TypeKind::Primitive(PrimitiveType::Nil)\n            | TypeKind::Literal(Literal::Nil)\n            | TypeKind::Literal(Literal::Boolean(false))\n    )\n}\n\n/// Simple type equality check\nfn types_equal(t1: \u0026Type, t2: \u0026Type) -\u003e bool {\n    match (\u0026t1.kind, \u0026t2.kind) {\n        (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) =\u003e p1 == p2,\n        (TypeKind::Literal(l1), TypeKind::Literal(l2)) =\u003e l1 == l2,\n        _ =\u003e false,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    fn make_span() -\u003e Span {\n        Span::new(0, 0, 0, 0)\n    }\n\n    #[test]\n    fn test_narrowing_context_basic() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let x_id = interner.intern(\"x\");\n        ctx.set_narrowed_type(x_id, string_type.clone());\n\n        assert!(ctx.get_narrowed_type(x_id).is_some());\n        let y_id = interner.intern(\"y\");\n        assert!(ctx.get_narrowed_type(y_id).is_none());\n\n        ctx.remove_narrowed_type(x_id);\n        assert!(ctx.get_narrowed_type(x_id).is_none());\n    }\n\n    #[test]\n    fn test_narrowing_context_merge() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut then_ctx = NarrowingContext::new();\n        let mut else_ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let x_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n\n        // Both have 'x' as string - should be kept\n        then_ctx.set_narrowed_type(x_id, string_type.clone());\n        else_ctx.set_narrowed_type(x_id, string_type.clone());\n\n        // Only then has 'y' - should not be kept\n        then_ctx.set_narrowed_type(y_id, number_type.clone());\n\n        let merged = NarrowingContext::merge(\u0026then_ctx, \u0026else_ctx);\n\n        assert!(merged.get_narrowed_type(x_id).is_some());\n        assert!(merged.get_narrowed_type(y_id).is_none());\n    }\n\n    #[test]\n    fn test_remove_nil_from_union() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let non_nil = remove_nil_from_type(\u0026union_type).unwrap();\n\n        assert!(matches!(\n            non_nil.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_make_truthy_type() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                Type::new(TypeKind::Literal(Literal::Boolean(false)), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let truthy = make_truthy_type(\u0026union_type).unwrap();\n\n        if let TypeKind::Union(types) = \u0026truthy.kind {\n            assert_eq!(types.len(), 2); // string and number\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Tests\n    // ========================================================================\n\n    #[test]\n    fn test_narrowing_context_default() {\n        let ctx: NarrowingContext = Default::default();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n        assert!(ctx.get_narrowed_type(x_id).is_none());\n    }\n\n    #[test]\n    fn test_narrowing_context_clone_for_branch() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let x_id = interner.intern(\"x\");\n        ctx.set_narrowed_type(x_id, string_type.clone());\n\n        let cloned = ctx.clone_for_branch();\n        assert!(cloned.get_narrowed_type(x_id).is_some());\n\n        // Modifying cloned should not affect original\n        let y_id = interner.intern(\"y\");\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let mut cloned_mut = cloned;\n        cloned_mut.set_narrowed_type(y_id, number_type);\n\n        assert!(ctx.get_narrowed_type(y_id).is_none());\n        assert!(cloned_mut.get_narrowed_type(y_id).is_some());\n    }\n\n    #[test]\n    fn test_narrowing_context_merge_different_types() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut then_ctx = NarrowingContext::new();\n        let mut else_ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let x_id = interner.intern(\"x\");\n\n        // Different types for same variable - should not be kept\n        then_ctx.set_narrowed_type(x_id, string_type);\n        else_ctx.set_narrowed_type(x_id, number_type);\n\n        let merged = NarrowingContext::merge(\u0026then_ctx, \u0026else_ctx);\n        assert!(merged.get_narrowed_type(x_id).is_none());\n    }\n\n    #[test]\n    fn test_narrowing_context_merge_empty() {\n        let then_ctx = NarrowingContext::new();\n        let else_ctx = NarrowingContext::new();\n\n        let merged = NarrowingContext::merge(\u0026then_ctx, \u0026else_ctx);\n        // Should be empty\n        assert!(merged\n            .get_narrowed_type(typedlua_parser::string_interner::StringId::from_u32(0))\n            .is_none());\n    }\n\n    #[test]\n    fn test_type_narrower_new() {\n        let narrower = TypeNarrower::new();\n        assert!(narrower\n            .get_context()\n            .get_narrowed_type(typedlua_parser::string_interner::StringId::from_u32(0))\n            .is_none());\n    }\n\n    #[test]\n    fn test_type_narrower_default() {\n        let narrower: TypeNarrower = Default::default();\n        assert!(narrower\n            .get_context()\n            .get_narrowed_type(typedlua_parser::string_interner::StringId::from_u32(0))\n            .is_none());\n    }\n\n    #[test]\n    fn test_type_narrower_get_context_mut() {\n        let mut narrower = TypeNarrower::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let x_id = interner.intern(\"x\");\n\n        {\n            let ctx = narrower.get_context_mut();\n            ctx.set_narrowed_type(x_id, string_type);\n        }\n\n        assert!(narrower.get_context().get_narrowed_type(x_id).is_some());\n    }\n\n    #[test]\n    fn test_is_nil_type() {\n        let nil_prim = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let nil_lit = Type::new(TypeKind::Literal(Literal::Nil), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        assert!(is_nil_type(\u0026nil_prim));\n        assert!(is_nil_type(\u0026nil_lit));\n        assert!(!is_nil_type(\u0026string_type));\n    }\n\n    #[test]\n    fn test_is_falsy_type() {\n        let nil_prim = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let nil_lit = Type::new(TypeKind::Literal(Literal::Nil), make_span());\n        let false_lit = Type::new(TypeKind::Literal(Literal::Boolean(false)), make_span());\n        let true_lit = Type::new(TypeKind::Literal(Literal::Boolean(true)), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        assert!(is_falsy_type(\u0026nil_prim));\n        assert!(is_falsy_type(\u0026nil_lit));\n        assert!(is_falsy_type(\u0026false_lit));\n        assert!(!is_falsy_type(\u0026true_lit));\n        assert!(!is_falsy_type(\u0026string_type));\n    }\n\n    #[test]\n    fn test_remove_nil_from_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n\n        // Non-nil type should remain unchanged\n        let result = remove_nil_from_type(\u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // Nil type should become Never\n        let result = remove_nil_from_type(\u0026nil_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_remove_nil_results_in_single_type() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = remove_nil_from_type(\u0026union_type).unwrap();\n        // Should result in a single type, not a union\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_make_truthy_type_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n\n        // Truthy type should remain unchanged\n        let result = make_truthy_type(\u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // Nil type should become Never\n        let result = make_truthy_type(\u0026nil_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_make_falsy_type() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                Type::new(TypeKind::Literal(Literal::Boolean(false)), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let falsy = make_falsy_type(\u0026union_type).unwrap();\n\n        if let TypeKind::Union(types) = \u0026falsy.kind {\n            assert_eq!(types.len(), 2); // nil and false\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_make_falsy_type_non_union() {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        // Nil type should remain unchanged\n        let result = make_falsy_type(\u0026nil_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Nil)\n        ));\n\n        // String type should become Never\n        let result = make_falsy_type(\u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_type_from_union() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let to_exclude = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let result = exclude_type(\u0026union_type, \u0026to_exclude).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_exclude_type_results_in_single() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let to_exclude = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let result = exclude_type(\u0026union_type, \u0026to_exclude).unwrap();\n\n        // Should result in a single type\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_all_types_becomes_never() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            )]),\n            make_span(),\n        );\n\n        let to_exclude = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let result = exclude_type(\u0026union_type, \u0026to_exclude).unwrap();\n\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_type_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        // Exclude different type - should remain unchanged\n        let result = exclude_type(\u0026string_type, \u0026number_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // Exclude same type - should become Never\n        let result = exclude_type(\u0026string_type, \u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_types_equal() {\n        let string1 = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let string2 = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        assert!(types_equal(\u0026string1, \u0026string2));\n        assert!(!types_equal(\u0026string1, \u0026number));\n    }\n\n    #[test]\n    fn test_typeof_string_to_type() {\n        assert!(typeof_string_to_type(\"nil\").is_some());\n        assert!(typeof_string_to_type(\"boolean\").is_some());\n        assert!(typeof_string_to_type(\"number\").is_some());\n        assert!(typeof_string_to_type(\"string\").is_some());\n        assert!(typeof_string_to_type(\"table\").is_some());\n        assert!(typeof_string_to_type(\"unknown\").is_none());\n        assert!(typeof_string_to_type(\"function\").is_none());\n    }\n\n    #[test]\n    fn test_extract_nil_check_basic() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n\n        // x == nil\n        let left = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n        let right = Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = extract_nil_check(\u0026interner, \u0026left, \u0026right);\n        assert!(result.is_some());\n        let (name, is_nil) = result.unwrap();\n        assert_eq!(name, x_id);\n        assert!(is_nil);\n    }\n\n    #[test]\n    fn test_extract_nil_check_reversed() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n\n        // nil == x\n        let left = Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n        let right = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = extract_nil_check(\u0026interner, \u0026left, \u0026right);\n        assert!(result.is_some());\n    }\n\n    #[test]\n    fn test_extract_nil_check_not_nil() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n\n        // x == \"string\" - not a nil check\n        let left = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n        let right = Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = extract_nil_check(\u0026interner, \u0026left, \u0026right);\n        assert!(result.is_none());\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":355}},{"line":47,"address":[],"length":0,"stats":{"Line":355}},{"line":52,"address":[],"length":0,"stats":{"Line":190}},{"line":53,"address":[],"length":0,"stats":{"Line":570}},{"line":57,"address":[],"length":0,"stats":{"Line":33}},{"line":58,"address":[],"length":0,"stats":{"Line":132}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":7}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":45}},{"line":85,"address":[],"length":0,"stats":{"Line":90}},{"line":96,"address":[],"length":0,"stats":{"Line":292}},{"line":98,"address":[],"length":0,"stats":{"Line":292}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":18}},{"line":117,"address":[],"length":0,"stats":{"Line":90}},{"line":120,"address":[],"length":0,"stats":{"Line":37}},{"line":121,"address":[],"length":0,"stats":{"Line":37}},{"line":124,"address":[],"length":0,"stats":{"Line":352}},{"line":125,"address":[],"length":0,"stats":{"Line":352}},{"line":131,"address":[],"length":0,"stats":{"Line":22}},{"line":137,"address":[],"length":0,"stats":{"Line":66}},{"line":138,"address":[],"length":0,"stats":{"Line":66}},{"line":140,"address":[],"length":0,"stats":{"Line":21}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":11}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":16}},{"line":177,"address":[],"length":0,"stats":{"Line":24}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":40}},{"line":191,"address":[],"length":0,"stats":{"Line":8}},{"line":194,"address":[],"length":0,"stats":{"Line":24}},{"line":195,"address":[],"length":0,"stats":{"Line":24}},{"line":196,"address":[],"length":0,"stats":{"Line":24}},{"line":201,"address":[],"length":0,"stats":{"Line":16}},{"line":202,"address":[],"length":0,"stats":{"Line":8}},{"line":203,"address":[],"length":0,"stats":{"Line":24}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":5}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":9}},{"line":307,"address":[],"length":0,"stats":{"Line":22}},{"line":311,"address":[],"length":0,"stats":{"Line":11}},{"line":317,"address":[],"length":0,"stats":{"Line":13}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":3}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":10}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":13}},{"line":390,"address":[],"length":0,"stats":{"Line":24}},{"line":391,"address":[],"length":0,"stats":{"Line":11}},{"line":392,"address":[],"length":0,"stats":{"Line":10}},{"line":397,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":16}},{"line":409,"address":[],"length":0,"stats":{"Line":8}},{"line":410,"address":[],"length":0,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":9}},{"line":412,"address":[],"length":0,"stats":{"Line":8}},{"line":413,"address":[],"length":0,"stats":{"Line":9}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":8}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":6}},{"line":423,"address":[],"length":0,"stats":{"Line":18}},{"line":425,"address":[],"length":0,"stats":{"Line":45}},{"line":429,"address":[],"length":0,"stats":{"Line":12}},{"line":430,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":434,"address":[],"length":0,"stats":{"Line":5}},{"line":435,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":440,"address":[],"length":0,"stats":{"Line":9}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":1}},{"line":449,"address":[],"length":0,"stats":{"Line":13}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":451,"address":[],"length":0,"stats":{"Line":11}},{"line":452,"address":[],"length":0,"stats":{"Line":110}},{"line":454,"address":[],"length":0,"stats":{"Line":22}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":11}},{"line":460,"address":[],"length":0,"stats":{"Line":22}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":7}},{"line":466,"address":[],"length":0,"stats":{"Line":1}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":474,"address":[],"length":0,"stats":{"Line":27}},{"line":475,"address":[],"length":0,"stats":{"Line":13}},{"line":476,"address":[],"length":0,"stats":{"Line":18}},{"line":482,"address":[],"length":0,"stats":{"Line":3}},{"line":483,"address":[],"length":0,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":1}},{"line":485,"address":[],"length":0,"stats":{"Line":3}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":2}},{"line":502,"address":[],"length":0,"stats":{"Line":7}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":506,"address":[],"length":0,"stats":{"Line":1}},{"line":511,"address":[],"length":0,"stats":{"Line":3}},{"line":512,"address":[],"length":0,"stats":{"Line":2}},{"line":513,"address":[],"length":0,"stats":{"Line":1}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":516,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":1}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":2}},{"line":527,"address":[],"length":0,"stats":{"Line":6}},{"line":528,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":1}},{"line":530,"address":[],"length":0,"stats":{"Line":1}},{"line":536,"address":[],"length":0,"stats":{"Line":16}},{"line":537,"address":[],"length":0,"stats":{"Line":7}},{"line":538,"address":[],"length":0,"stats":{"Line":11}},{"line":546,"address":[],"length":0,"stats":{"Line":19}},{"line":547,"address":[],"length":0,"stats":{"Line":38}},{"line":548,"address":[],"length":0,"stats":{"Line":51}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":2}}],"covered":174,"coverable":224}]};
        var previousData = {"files":[{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","config.rs"],"content":"use serde::{Deserialize, Serialize};\nuse std::path::Path;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum LuaVersion {\n    #[serde(rename = \"5.1\")]\n    Lua51,\n    #[serde(rename = \"5.2\")]\n    Lua52,\n    #[serde(rename = \"5.3\")]\n    Lua53,\n    #[serde(rename = \"5.4\")]\n    #[default]\n    Lua54,\n}\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\npub enum StrictLevel {\n    #[serde(rename = \"off\")]\n    Off,\n    #[serde(rename = \"warning\")]\n    Warning,\n    #[serde(rename = \"error\")]\n    #[default]\n    Error,\n}\n\n/// Module code generation mode\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]\n#[serde(rename_all = \"lowercase\")]\npub enum ModuleMode {\n    /// Generate separate files with require() calls (default)\n    #[default]\n    Require,\n    /// Bundle all modules into a single file\n    Bundle,\n}\n\n/// Optimization level for code generation\n/// Auto mode defaults to O1 in dev mode, O2 in release mode\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum OptimizationLevel {\n    /// No optimizations - fastest compilation\n    O0,\n    /// Basic optimizations - safe transformations (constant folding, DCE, etc.)\n    O1,\n    /// Standard optimizations - includes function inlining\n    O2,\n    /// Aggressive optimizations - may increase compile time\n    O3,\n    /// Auto-detect based on build profile (default)\n    /// O1 for debug/dev builds, O2 for release builds\n    #[default]\n    Auto,\n}\n\n/// Output format for generated Lua code\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize)]\n#[serde(rename_all = \"lowercase\")]\npub enum OutputFormat {\n    /// Human-readable format with proper indentation and newlines (default)\n    #[default]\n    Readable,\n    /// Compact format with minimal whitespace (single space between tokens)\n    Compact,\n    /// Minified format with no unnecessary whitespace\n    Minified,\n}\n\nimpl OptimizationLevel {\n    /// Resolve Auto to an actual optimization level based on build profile\n    #[cfg(debug_assertions)]\n    pub fn resolved(self) -\u003e Self {\n        match self {\n            OptimizationLevel::Auto =\u003e OptimizationLevel::O1,\n            other =\u003e other,\n        }\n    }\n\n    #[cfg(not(debug_assertions))]\n    pub fn resolved(self) -\u003e Self {\n        match self {\n            OptimizationLevel::Auto =\u003e OptimizationLevel::O2,\n            other =\u003e other,\n        }\n    }\n\n    /// Get the effective optimization level for this configuration\n    pub fn effective(\u0026self) -\u003e OptimizationLevel {\n        self.resolved()\n    }\n}\n\n/// Compiler options that control type checking and code generation\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CompilerOptions {\n    /// Enable strict null checking (default: true)\n    #[serde(default = \"default_true\")]\n    pub strict_null_checks: bool,\n\n    /// Naming convention enforcement (default: error)\n    #[serde(default)]\n    pub strict_naming: StrictLevel,\n\n    /// Disallow implicit unknown types (default: false)\n    #[serde(default)]\n    pub no_implicit_unknown: bool,\n\n    /// Disallow explicit unknown types (default: false)\n    #[serde(default)]\n    pub no_explicit_unknown: bool,\n\n    /// Target Lua version (default: 5.4)\n    #[serde(default)]\n    pub target: LuaVersion,\n\n    /// Enable decorator syntax (default: true)\n    #[serde(default = \"default_true\")]\n    pub enable_decorators: bool,\n\n    /// Allow importing non-typed Lua files (default: true)\n    #[serde(default = \"default_true\")]\n    pub allow_non_typed_lua: bool,\n\n    /// Copy plain .lua files to output directory during compilation (default: false)\n    #[serde(default)]\n    pub copy_lua_to_output: bool,\n\n    /// Output directory for compiled files\n    #[serde(default)]\n    pub out_dir: Option\u003cString\u003e,\n\n    /// Output file (bundle all into one file)\n    #[serde(default)]\n    pub out_file: Option\u003cString\u003e,\n\n    /// Generate source maps (default: false)\n    #[serde(default)]\n    pub source_map: bool,\n\n    /// Don't emit output files (type check only, default: false)\n    #[serde(default)]\n    pub no_emit: bool,\n\n    /// Pretty-print diagnostics (default: true)\n    #[serde(default = \"default_true\")]\n    pub pretty: bool,\n\n    /// Module code generation mode (default: require)\n    #[serde(default)]\n    pub module_mode: ModuleMode,\n\n    /// Module search paths for package imports\n    #[serde(default = \"default_module_paths\")]\n    pub module_paths: Vec\u003cString\u003e,\n\n    /// Enforce that namespace declarations match file paths (default: false)\n    #[serde(default)]\n    pub enforce_namespace_path: bool,\n\n    /// Output format for generated Lua code (default: readable)\n    #[serde(default)]\n    pub output_format: OutputFormat,\n}\n\nfn default_true() -\u003e bool {\n    true\n}\n\nfn default_module_paths() -\u003e Vec\u003cString\u003e {\n    vec![\n        \"./?.tl\".to_string(),\n        \"./lua_modules/?.tl\".to_string(),\n        \"./lua_modules/?/init.tl\".to_string(),\n    ]\n}\n\nimpl Default for CompilerOptions {\n    fn default() -\u003e Self {\n        Self {\n            strict_null_checks: true,\n            strict_naming: StrictLevel::Error,\n            no_implicit_unknown: false,\n            no_explicit_unknown: false,\n            target: LuaVersion::Lua54,\n            enable_decorators: true,\n            allow_non_typed_lua: true,\n            copy_lua_to_output: false,\n            out_dir: None,\n            out_file: None,\n            source_map: false,\n            no_emit: false,\n            pretty: true,\n            module_mode: ModuleMode::Require,\n            module_paths: default_module_paths(),\n            enforce_namespace_path: false,\n            output_format: OutputFormat::Readable,\n        }\n    }\n}\n\n/// Main compiler configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct CompilerConfig {\n    /// Compiler options\n    #[serde(default)]\n    pub compiler_options: CompilerOptions,\n\n    /// Files to include (glob patterns)\n    #[serde(default)]\n    pub include: Vec\u003cString\u003e,\n\n    /// Files to exclude (glob patterns)\n    #[serde(default = \"default_exclude\")]\n    pub exclude: Vec\u003cString\u003e,\n}\n\nfn default_exclude() -\u003e Vec\u003cString\u003e {\n    vec![\"**/node_modules/**\".to_string(), \"**/dist/**\".to_string()]\n}\n\nimpl Default for CompilerConfig {\n    fn default() -\u003e Self {\n        Self {\n            compiler_options: CompilerOptions::default(),\n            include: vec![\"**/*.tl\".to_string()],\n            exclude: default_exclude(),\n        }\n    }\n}\n\nimpl CompilerConfig {\n    /// Load configuration from a YAML file (tlconfig.yaml)\n    pub fn from_file(path: \u0026Path) -\u003e Result\u003cSelf, crate::cli::errors::CompilationError\u003e {\n        let content = std::fs::read_to_string(path)?;\n        let config: CompilerConfig = serde_yaml::from_str(\u0026content)\n            .map_err(|e| crate::cli::errors::CompilationError::ConfigError(e.to_string()))?;\n        Ok(config)\n    }\n\n    /// Create a default configuration and write it to tlconfig.yaml\n    pub fn init_file(path: \u0026Path) -\u003e Result\u003c(), crate::cli::errors::CompilationError\u003e {\n        let config = CompilerConfig::default();\n        let yaml = serde_yaml::to_string(\u0026config)\n            .map_err(|e| crate::cli::errors::CompilationError::ConfigError(e.to_string()))?;\n        std::fs::write(path, yaml)?;\n        Ok(())\n    }\n\n    /// Merge this configuration with CLI overrides\n    /// Only non-None/non-default CLI values override file config\n    pub fn merge(\u0026mut self, overrides: \u0026CliOverrides) {\n        // Merge compiler options\n        if let Some(strict_null_checks) = overrides.strict_null_checks {\n            self.compiler_options.strict_null_checks = strict_null_checks;\n        }\n        if let Some(strict_naming) = overrides.strict_naming {\n            self.compiler_options.strict_naming = strict_naming;\n        }\n        if let Some(no_implicit_unknown) = overrides.no_implicit_unknown {\n            self.compiler_options.no_implicit_unknown = no_implicit_unknown;\n        }\n        if let Some(no_explicit_unknown) = overrides.no_explicit_unknown {\n            self.compiler_options.no_explicit_unknown = no_explicit_unknown;\n        }\n        if let Some(target) = overrides.target {\n            self.compiler_options.target = target;\n        }\n        if let Some(enable_decorators) = overrides.enable_decorators {\n            self.compiler_options.enable_decorators = enable_decorators;\n        }\n        if let Some(allow_non_typed_lua) = overrides.allow_non_typed_lua {\n            self.compiler_options.allow_non_typed_lua = allow_non_typed_lua;\n        }\n        if let Some(copy_lua_to_output) = overrides.copy_lua_to_output {\n            self.compiler_options.copy_lua_to_output = copy_lua_to_output;\n        }\n        if let Some(ref out_dir) = overrides.out_dir {\n            self.compiler_options.out_dir = Some(out_dir.clone());\n        }\n        if let Some(ref out_file) = overrides.out_file {\n            self.compiler_options.out_file = Some(out_file.clone());\n        }\n        if let Some(source_map) = overrides.source_map {\n            self.compiler_options.source_map = source_map;\n        }\n        if let Some(no_emit) = overrides.no_emit {\n            self.compiler_options.no_emit = no_emit;\n        }\n        if let Some(pretty) = overrides.pretty {\n            self.compiler_options.pretty = pretty;\n        }\n        if let Some(module_mode) = overrides.module_mode {\n            self.compiler_options.module_mode = module_mode;\n        }\n        if let Some(ref module_paths) = overrides.module_paths {\n            self.compiler_options.module_paths = module_paths.clone();\n        }\n        if let Some(enforce_namespace_path) = overrides.enforce_namespace_path {\n            self.compiler_options.enforce_namespace_path = enforce_namespace_path;\n        }\n        if let Some(output_format) = overrides.output_format {\n            self.compiler_options.output_format = output_format;\n        }\n    }\n}\n\n/// CLI overrides for configuration\n/// All fields are optional - only specified flags override file config\n#[derive(Debug, Default, Clone)]\npub struct CliOverrides {\n    pub strict_null_checks: Option\u003cbool\u003e,\n    pub strict_naming: Option\u003cStrictLevel\u003e,\n    pub no_implicit_unknown: Option\u003cbool\u003e,\n    pub no_explicit_unknown: Option\u003cbool\u003e,\n    pub target: Option\u003cLuaVersion\u003e,\n    pub enable_decorators: Option\u003cbool\u003e,\n    pub allow_non_typed_lua: Option\u003cbool\u003e,\n    pub copy_lua_to_output: Option\u003cbool\u003e,\n    pub out_dir: Option\u003cString\u003e,\n    pub out_file: Option\u003cString\u003e,\n    pub source_map: Option\u003cbool\u003e,\n    pub no_emit: Option\u003cbool\u003e,\n    pub pretty: Option\u003cbool\u003e,\n    pub module_mode: Option\u003cModuleMode\u003e,\n    pub module_paths: Option\u003cVec\u003cString\u003e\u003e,\n    pub enforce_namespace_path: Option\u003cbool\u003e,\n    pub output_format: Option\u003cOutputFormat\u003e,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = CompilerConfig::default();\n        assert!(config.compiler_options.strict_null_checks);\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua54);\n    }\n\n    #[test]\n    fn test_serialize_config() {\n        let config = CompilerConfig::default();\n        let yaml = serde_yaml::to_string(\u0026config).unwrap();\n        assert!(yaml.contains(\"compilerOptions\"));\n    }\n\n    #[test]\n    fn test_deserialize_config() {\n        let yaml = r#\"\ncompilerOptions:\n  target: \"5.3\"\n  enableDecorators: false\n\"#;\n        let config: CompilerConfig = serde_yaml::from_str(yaml).unwrap();\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua53);\n        assert!(!config.compiler_options.enable_decorators);\n    }\n\n    #[test]\n    fn test_config_merge_overrides_file() {\n        let mut config = CompilerConfig::default();\n        // Default has Lua54 and strict_null_checks = true\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua54);\n        assert!(config.compiler_options.strict_null_checks);\n\n        // CLI overrides both\n        let overrides = CliOverrides {\n            target: Some(LuaVersion::Lua51),\n            strict_null_checks: Some(false),\n            ..Default::default()\n        };\n\n        config.merge(\u0026overrides);\n\n        assert_eq!(config.compiler_options.target, LuaVersion::Lua51);\n        assert!(!config.compiler_options.strict_null_checks);\n    }\n\n    #[test]\n    fn test_config_merge_partial_overrides() {\n        let mut config = CompilerConfig::default();\n        assert!(config.compiler_options.strict_null_checks);\n        assert!(config.compiler_options.enable_decorators);\n\n        // Only override one field\n        let overrides = CliOverrides {\n            enable_decorators: Some(false),\n            ..Default::default()\n        };\n\n        config.merge(\u0026overrides);\n\n        // This field was overridden\n        assert!(!config.compiler_options.enable_decorators);\n        // This field remains from file/default\n        assert!(config.compiler_options.strict_null_checks);\n    }\n\n    #[test]\n    fn test_config_merge_empty_overrides() {\n        let mut config = CompilerConfig::default();\n        let original_target = config.compiler_options.target;\n        let original_decorators = config.compiler_options.enable_decorators;\n\n        // Empty overrides shouldn't change anything\n        let overrides = CliOverrides::default();\n        config.merge(\u0026overrides);\n\n        assert_eq!(config.compiler_options.target, original_target);\n        assert_eq!(\n            config.compiler_options.enable_decorators,\n            original_decorators\n        );\n    }\n\n    #[test]\n    fn test_config_merge_output_options() {\n        let mut config = CompilerConfig::default();\n        assert!(config.compiler_options.out_dir.is_none());\n        assert!(config.compiler_options.out_file.is_none());\n\n        let overrides = CliOverrides {\n            out_dir: Some(\"dist\".to_string()),\n            source_map: Some(true),\n            ..Default::default()\n        };\n\n        config.merge(\u0026overrides);\n\n        assert_eq!(config.compiler_options.out_dir, Some(\"dist\".to_string()));\n        assert!(config.compiler_options.source_map);\n        assert!(config.compiler_options.out_file.is_none()); // Not overridden\n    }\n}\n","traces":[{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":169,"address":[],"length":0,"stats":{"Line":3}},{"line":172,"address":[],"length":0,"stats":{"Line":296}},{"line":173,"address":[],"length":0,"stats":{"Line":296}},{"line":174,"address":[],"length":0,"stats":{"Line":592}},{"line":175,"address":[],"length":0,"stats":{"Line":592}},{"line":176,"address":[],"length":0,"stats":{"Line":592}},{"line":181,"address":[],"length":0,"stats":{"Line":295}},{"line":197,"address":[],"length":0,"stats":{"Line":295}},{"line":221,"address":[],"length":0,"stats":{"Line":7}},{"line":222,"address":[],"length":0,"stats":{"Line":35}},{"line":226,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":229,"address":[],"length":0,"stats":{"Line":18}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":255,"address":[],"length":0,"stats":{"Line":4}},{"line":257,"address":[],"length":0,"stats":{"Line":6}},{"line":258,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":263,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":6}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":272,"address":[],"length":0,"stats":{"Line":6}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":4}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":6}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":6}},{"line":288,"address":[],"length":0,"stats":{"Line":1}},{"line":290,"address":[],"length":0,"stats":{"Line":4}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":4}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":4}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":4}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":306,"address":[],"length":0,"stats":{"Line":0}}],"covered":38,"coverable":67},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","diagnostics.rs"],"content":"use std::sync::Mutex;\nuse typedlua_parser::span::Span;\n\n// Bridge implementation for parser crate compatibility\n// This allows core's diagnostic handlers to be used with the parser crate's Lexer and Parser\n\n/// Diagnostic severity level\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum DiagnosticLevel {\n    Error,\n    Warning,\n    Info,\n}\n\n/// Diagnostic code for categorization and documentation\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct DiagnosticCode {\n    /// Numeric code (e.g., 1001, 2004)\n    pub code: u16,\n    /// Category prefix (e.g., \"E\" for error, \"W\" for warning)\n    pub prefix: char,\n}\n\nimpl DiagnosticCode {\n    pub const fn new(prefix: char, code: u16) -\u003e Self {\n        Self { code, prefix }\n    }\n\n    /// Format as string (e.g., \"E1001\", \"W2004\")\n    pub fn as_str(\u0026self) -\u003e String {\n        format!(\"{}{:04}\", self.prefix, self.code)\n    }\n}\n\n/// Related information for a diagnostic (additional context from other locations)\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DiagnosticRelatedInformation {\n    pub span: Span,\n    pub message: String,\n}\n\n/// Suggested fix for a diagnostic\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct DiagnosticSuggestion {\n    pub span: Span,\n    pub replacement: String,\n    pub message: String,\n}\n\n/// A diagnostic message with location, severity, and optional metadata\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Diagnostic {\n    pub level: DiagnosticLevel,\n    pub span: Span,\n    pub message: String,\n    pub code: Option\u003cDiagnosticCode\u003e,\n    pub related_information: Vec\u003cDiagnosticRelatedInformation\u003e,\n    pub suggestions: Vec\u003cDiagnosticSuggestion\u003e,\n}\n\nimpl Diagnostic {\n    pub fn error(span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Error,\n            span,\n            message: message.into(),\n            code: None,\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    pub fn warning(span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Warning,\n            span,\n            message: message.into(),\n            code: None,\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    pub fn info(span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Info,\n            span,\n            message: message.into(),\n            code: None,\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    /// Create an error with a diagnostic code\n    pub fn error_with_code(span: Span, code: DiagnosticCode, message: impl Into\u003cString\u003e) -\u003e Self {\n        Self {\n            level: DiagnosticLevel::Error,\n            span,\n            message: message.into(),\n            code: Some(code),\n            related_information: Vec::new(),\n            suggestions: Vec::new(),\n        }\n    }\n\n    /// Add related information to this diagnostic\n    pub fn with_related(mut self, span: Span, message: impl Into\u003cString\u003e) -\u003e Self {\n        self.related_information.push(DiagnosticRelatedInformation {\n            span,\n            message: message.into(),\n        });\n        self\n    }\n\n    /// Add a suggestion to this diagnostic\n    pub fn with_suggestion(\n        mut self,\n        span: Span,\n        replacement: String,\n        message: impl Into\u003cString\u003e,\n    ) -\u003e Self {\n        self.suggestions.push(DiagnosticSuggestion {\n            span,\n            replacement,\n            message: message.into(),\n        });\n        self\n    }\n\n    /// Set the diagnostic code\n    pub fn with_code(mut self, code: DiagnosticCode) -\u003e Self {\n        self.code = Some(code);\n        self\n    }\n}\n\n/// Trait for handling diagnostics\n/// This allows for dependency injection and testing with mock handlers\npub trait DiagnosticHandler: Send + Sync {\n    fn report(\u0026self, diagnostic: Diagnostic);\n\n    fn error(\u0026self, span: Span, message: \u0026str) {\n        self.report(Diagnostic::error(span, message.to_string()));\n    }\n\n    fn warning(\u0026self, span: Span, message: \u0026str) {\n        self.report(Diagnostic::warning(span, message.to_string()));\n    }\n\n    fn info(\u0026self, span: Span, message: \u0026str) {\n        self.report(Diagnostic::info(span, message.to_string()));\n    }\n\n    fn has_errors(\u0026self) -\u003e bool;\n    fn error_count(\u0026self) -\u003e usize;\n    fn warning_count(\u0026self) -\u003e usize;\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003cDiagnostic\u003e;\n}\n\n/// Console-based diagnostic handler that prints to stderr\npub struct ConsoleDiagnosticHandler {\n    diagnostics: Mutex\u003cVec\u003cDiagnostic\u003e\u003e,\n    pretty: bool,\n}\n\nimpl ConsoleDiagnosticHandler {\n    pub fn new(pretty: bool) -\u003e Self {\n        Self {\n            diagnostics: Mutex::new(Vec::new()),\n            pretty,\n        }\n    }\n}\n\nimpl DiagnosticHandler for ConsoleDiagnosticHandler {\n    fn report(\u0026self, diagnostic: Diagnostic) {\n        let level_str = match diagnostic.level {\n            DiagnosticLevel::Error =\u003e \"error\",\n            DiagnosticLevel::Warning =\u003e \"warning\",\n            DiagnosticLevel::Info =\u003e \"info\",\n        };\n\n        if self.pretty {\n            let code_str = if let Some(code) = \u0026diagnostic.code {\n                format!(\"[{}] \", code.as_str())\n            } else {\n                String::new()\n            };\n            eprintln!(\n                \"\\x1b[1m{}\\x1b[0m {}at {}: {}\",\n                level_str, code_str, diagnostic.span, diagnostic.message\n            );\n\n            // Print related information\n            for related in \u0026diagnostic.related_information {\n                eprintln!(\n                    \"  \\x1b[36mNote\\x1b[0m at {}: {}\",\n                    related.span, related.message\n                );\n            }\n\n            // Print suggestions\n            for suggestion in \u0026diagnostic.suggestions {\n                eprintln!(\"  \\x1b[32mSuggestion\\x1b[0m: {}\", suggestion.message);\n            }\n        } else {\n            let code_str = if let Some(code) = \u0026diagnostic.code {\n                format!(\"[{}] \", code.as_str())\n            } else {\n                String::new()\n            };\n            eprintln!(\n                \"{} {}at {}: {}\",\n                level_str, code_str, diagnostic.span, diagnostic.message\n            );\n\n            // Print related information\n            for related in \u0026diagnostic.related_information {\n                eprintln!(\"  Note at {}: {}\", related.span, related.message);\n            }\n\n            // Print suggestions\n            for suggestion in \u0026diagnostic.suggestions {\n                eprintln!(\"  Suggestion: {}\", suggestion.message);\n            }\n        }\n\n        self.diagnostics.lock().unwrap().push(diagnostic);\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .any(|d| d.level == DiagnosticLevel::Error)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Error)\n            .count()\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Warning)\n            .count()\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003cDiagnostic\u003e {\n        self.diagnostics.lock().unwrap().clone()\n    }\n}\n\n/// Error codes for TypedLua diagnostics\n///\n/// Error codes are organized by component:\n/// - E1000-E1999: Lexer errors\n/// - E2000-E2999: Parser errors\n/// - E3000-E3999: Type checker errors\n/// - E4000-E4999: Code generator errors\n/// - E5000-E5999: Configuration errors\n/// - W1000-W9999: Warnings\npub mod error_codes {\n    use super::DiagnosticCode;\n\n    // ========================================\n    // Lexer Errors (E1000-E1999)\n    // ========================================\n\n    /// Unterminated string literal\n    pub const UNTERMINATED_STRING: DiagnosticCode = DiagnosticCode::new('E', 1001);\n\n    /// Unterminated multi-line comment\n    pub const UNTERMINATED_COMMENT: DiagnosticCode = DiagnosticCode::new('E', 1002);\n\n    /// Invalid number literal format\n    pub const INVALID_NUMBER: DiagnosticCode = DiagnosticCode::new('E', 1003);\n\n    /// Unexpected character\n    pub const UNEXPECTED_CHAR: DiagnosticCode = DiagnosticCode::new('E', 1004);\n\n    /// Invalid escape sequence in string\n    pub const INVALID_ESCAPE: DiagnosticCode = DiagnosticCode::new('E', 1005);\n\n    /// Unterminated template literal\n    pub const UNTERMINATED_TEMPLATE: DiagnosticCode = DiagnosticCode::new('E', 1006);\n\n    /// Invalid hexadecimal number\n    pub const INVALID_HEX_NUMBER: DiagnosticCode = DiagnosticCode::new('E', 1007);\n\n    /// Invalid binary number\n    pub const INVALID_BINARY_NUMBER: DiagnosticCode = DiagnosticCode::new('E', 1008);\n\n    // ========================================\n    // Parser Errors (E2000-E2999)\n    // ========================================\n\n    /// Expected a specific token but found something else\n    pub const EXPECTED_TOKEN: DiagnosticCode = DiagnosticCode::new('E', 2001);\n\n    /// Unexpected token encountered\n    pub const UNEXPECTED_TOKEN: DiagnosticCode = DiagnosticCode::new('E', 2002);\n\n    /// Expected an identifier\n    pub const EXPECTED_IDENTIFIER: DiagnosticCode = DiagnosticCode::new('E', 2003);\n\n    /// Expected an expression\n    pub const EXPECTED_EXPRESSION: DiagnosticCode = DiagnosticCode::new('E', 2004);\n\n    /// Expected a type annotation\n    pub const EXPECTED_TYPE: DiagnosticCode = DiagnosticCode::new('E', 2005);\n\n    /// Expected a pattern\n    pub const EXPECTED_PATTERN: DiagnosticCode = DiagnosticCode::new('E', 2006);\n\n    /// Missing semicolon or statement terminator\n    pub const MISSING_SEMICOLON: DiagnosticCode = DiagnosticCode::new('E', 2007);\n\n    /// Missing 'end' keyword\n    pub const MISSING_END: DiagnosticCode = DiagnosticCode::new('E', 2008);\n\n    /// Missing 'then' keyword after if condition\n    pub const MISSING_THEN: DiagnosticCode = DiagnosticCode::new('E', 2009);\n\n    /// Missing 'do' keyword\n    pub const MISSING_DO: DiagnosticCode = DiagnosticCode::new('E', 2010);\n\n    /// Invalid function parameter\n    pub const INVALID_PARAMETER: DiagnosticCode = DiagnosticCode::new('E', 2011);\n\n    /// Invalid destructuring pattern\n    pub const INVALID_DESTRUCTURING: DiagnosticCode = DiagnosticCode::new('E', 2012);\n\n    /// Break statement outside of loop\n    pub const BREAK_OUTSIDE_LOOP: DiagnosticCode = DiagnosticCode::new('E', 2013);\n\n    /// Continue statement outside of loop\n    pub const CONTINUE_OUTSIDE_LOOP: DiagnosticCode = DiagnosticCode::new('E', 2014);\n\n    /// Invalid assignment target\n    pub const INVALID_ASSIGNMENT: DiagnosticCode = DiagnosticCode::new('E', 2015);\n\n    /// Expected '\u003e\u003e' but found end of tokens (generic type parsing)\n    pub const EXPECTED_DOUBLE_GT: DiagnosticCode = DiagnosticCode::new('E', 2016);\n\n    /// Classes disabled in configuration\n    pub const CLASSES_DISABLED: DiagnosticCode = DiagnosticCode::new('E', 2020);\n\n    /// Decorators disabled in configuration\n    pub const DECORATORS_DISABLED: DiagnosticCode = DiagnosticCode::new('E', 2021);\n\n    /// Functional programming features disabled\n    pub const FP_DISABLED: DiagnosticCode = DiagnosticCode::new('E', 2022);\n\n    // ========================================\n    // Type Checker Errors (E3000-E3999)\n    // ========================================\n\n    /// Type mismatch between expected and actual types\n    pub const TYPE_MISMATCH: DiagnosticCode = DiagnosticCode::new('E', 3001);\n\n    /// Undefined variable or identifier\n    pub const UNDEFINED_VARIABLE: DiagnosticCode = DiagnosticCode::new('E', 3002);\n\n    /// Duplicate declaration\n    pub const DUPLICATE_DECLARATION: DiagnosticCode = DiagnosticCode::new('E', 3003);\n\n    /// Cannot assign to constant\n    pub const ASSIGN_TO_CONST: DiagnosticCode = DiagnosticCode::new('E', 3004);\n\n    /// Type not found\n    pub const TYPE_NOT_FOUND: DiagnosticCode = DiagnosticCode::new('E', 3005);\n\n    /// Property not found on type\n    pub const PROPERTY_NOT_FOUND: DiagnosticCode = DiagnosticCode::new('E', 3006);\n\n    /// Wrong number of arguments in function call\n    pub const WRONG_ARG_COUNT: DiagnosticCode = DiagnosticCode::new('E', 3007);\n\n    /// Cannot call non-function type\n    pub const NOT_CALLABLE: DiagnosticCode = DiagnosticCode::new('E', 3008);\n\n    /// Cannot index non-indexable type\n    pub const NOT_INDEXABLE: DiagnosticCode = DiagnosticCode::new('E', 3009);\n\n    /// Missing return statement\n    pub const MISSING_RETURN: DiagnosticCode = DiagnosticCode::new('E', 3010);\n\n    /// Circular type reference\n    pub const CIRCULAR_TYPE: DiagnosticCode = DiagnosticCode::new('E', 3011);\n\n    /// Interface not found\n    pub const INTERFACE_NOT_FOUND: DiagnosticCode = DiagnosticCode::new('E', 3012);\n\n    /// Class does not implement interface\n    pub const INTERFACE_NOT_IMPLEMENTED: DiagnosticCode = DiagnosticCode::new('E', 3013);\n\n    /// Abstract method has implementation\n    pub const ABSTRACT_METHOD_BODY: DiagnosticCode = DiagnosticCode::new('E', 3014);\n\n    /// Non-abstract class has abstract methods\n    pub const ABSTRACT_METHODS_IN_CONCRETE_CLASS: DiagnosticCode = DiagnosticCode::new('E', 3015);\n\n    /// Multiple constructors in class\n    pub const MULTIPLE_CONSTRUCTORS: DiagnosticCode = DiagnosticCode::new('E', 3016);\n\n    /// Generic type parameter constraint not satisfied\n    pub const CONSTRAINT_NOT_SATISFIED: DiagnosticCode = DiagnosticCode::new('E', 3017);\n\n    /// Wrong number of type arguments\n    pub const WRONG_TYPE_ARG_COUNT: DiagnosticCode = DiagnosticCode::new('E', 3018);\n\n    /// Cannot infer type\n    pub const CANNOT_INFER_TYPE: DiagnosticCode = DiagnosticCode::new('E', 3019);\n\n    /// Pattern match not exhaustive\n    pub const NON_EXHAUSTIVE_MATCH: DiagnosticCode = DiagnosticCode::new('E', 3020);\n\n    /// Invalid type in pattern match\n    pub const INVALID_MATCH_TYPE: DiagnosticCode = DiagnosticCode::new('E', 3021);\n\n    /// Getter and setter type mismatch\n    pub const GETTER_SETTER_MISMATCH: DiagnosticCode = DiagnosticCode::new('E', 3022);\n\n    /// Property marked readonly\n    pub const READONLY_PROPERTY: DiagnosticCode = DiagnosticCode::new('E', 3023);\n\n    /// Access to private member\n    pub const PRIVATE_ACCESS: DiagnosticCode = DiagnosticCode::new('E', 3024);\n\n    /// Access to protected member\n    pub const PROTECTED_ACCESS: DiagnosticCode = DiagnosticCode::new('E', 3025);\n\n    /// Or-pattern alternatives bind different variables\n    pub const INCONSISTENT_OR_PATTERN_BINDINGS: DiagnosticCode = DiagnosticCode::new('E', 3026);\n\n    /// Or-pattern alternatives bind variables with incompatible types\n    pub const INCOMPATIBLE_OR_PATTERN_TYPES: DiagnosticCode = DiagnosticCode::new('E', 3027);\n\n    /// Or-pattern has no alternatives\n    pub const EMPTY_OR_PATTERN: DiagnosticCode = DiagnosticCode::new('E', 3028);\n\n    // ========================================\n    // Code Generator Errors (E4000-E4999)\n    // ========================================\n\n    /// Unsupported feature for target Lua version\n    pub const UNSUPPORTED_FEATURE: DiagnosticCode = DiagnosticCode::new('E', 4001);\n\n    /// Source map generation failed\n    pub const SOURCE_MAP_ERROR: DiagnosticCode = DiagnosticCode::new('E', 4002);\n\n    // ========================================\n    // Configuration Errors (E5000-E5999)\n    // ========================================\n\n    /// Invalid configuration file\n    pub const INVALID_CONFIG: DiagnosticCode = DiagnosticCode::new('E', 5001);\n\n    /// Missing configuration file\n    pub const MISSING_CONFIG: DiagnosticCode = DiagnosticCode::new('E', 5002);\n\n    /// Invalid Lua target version\n    pub const INVALID_TARGET: DiagnosticCode = DiagnosticCode::new('E', 5003);\n\n    // ========================================\n    // Warnings (W1000-W9999)\n    // ========================================\n\n    /// Unused variable\n    pub const UNUSED_VARIABLE: DiagnosticCode = DiagnosticCode::new('W', 1001);\n\n    /// Unused import\n    pub const UNUSED_IMPORT: DiagnosticCode = DiagnosticCode::new('W', 1002);\n\n    /// Deprecated feature\n    pub const DEPRECATED: DiagnosticCode = DiagnosticCode::new('W', 1003);\n\n    /// Unreachable code\n    pub const UNREACHABLE_CODE: DiagnosticCode = DiagnosticCode::new('W', 1004);\n\n    /// Implicit any type\n    pub const IMPLICIT_ANY: DiagnosticCode = DiagnosticCode::new('W', 1005);\n\n    /// Possible nil value\n    pub const POSSIBLE_NIL: DiagnosticCode = DiagnosticCode::new('W', 1006);\n\n    /// Shadowed variable\n    pub const SHADOWED_VARIABLE: DiagnosticCode = DiagnosticCode::new('W', 1007);\n\n    /// Empty block\n    pub const EMPTY_BLOCK: DiagnosticCode = DiagnosticCode::new('W', 1008);\n\n    /// Type could be narrower\n    pub const TYPE_TOO_WIDE: DiagnosticCode = DiagnosticCode::new('W', 1009);\n\n    /// Pattern is unreachable\n    pub const UNREACHABLE_PATTERN: DiagnosticCode = DiagnosticCode::new('W', 1010);\n}\n\n/// Collecting diagnostic handler for testing\n/// Collects all diagnostics without printing\npub struct CollectingDiagnosticHandler {\n    diagnostics: Mutex\u003cVec\u003cDiagnostic\u003e\u003e,\n}\n\nimpl CollectingDiagnosticHandler {\n    pub fn new() -\u003e Self {\n        Self {\n            diagnostics: Mutex::new(Vec::new()),\n        }\n    }\n}\n\nimpl Default for CollectingDiagnosticHandler {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl DiagnosticHandler for CollectingDiagnosticHandler {\n    fn report(\u0026self, diagnostic: Diagnostic) {\n        self.diagnostics.lock().unwrap().push(diagnostic);\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .any(|d| d.level == DiagnosticLevel::Error)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Error)\n            .count()\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        self.diagnostics\n            .lock()\n            .unwrap()\n            .iter()\n            .filter(|d| d.level == DiagnosticLevel::Warning)\n            .count()\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003cDiagnostic\u003e {\n        self.diagnostics.lock().unwrap().clone()\n    }\n}\n\n// Bridge implementations for parser crate compatibility\n// These allow the core's diagnostic handlers to work with typedlua_parser's Lexer and Parser\n\n/// Convert a parser diagnostic to a core diagnostic\nfn convert_parser_diagnostic(diag: typedlua_parser::Diagnostic) -\u003e Diagnostic {\n    let level = match diag.level {\n        typedlua_parser::diagnostics::DiagnosticLevel::Error =\u003e DiagnosticLevel::Error,\n        typedlua_parser::diagnostics::DiagnosticLevel::Warning =\u003e DiagnosticLevel::Warning,\n        typedlua_parser::diagnostics::DiagnosticLevel::Info =\u003e DiagnosticLevel::Info,\n    };\n\n    let code = diag.code.map(|c| DiagnosticCode::new(c.prefix, c.code));\n\n    let related_information = diag\n        .related_information\n        .into_iter()\n        .map(|r| DiagnosticRelatedInformation {\n            span: r.span,\n            message: r.message,\n        })\n        .collect();\n\n    let suggestions = diag\n        .suggestions\n        .into_iter()\n        .map(|s| DiagnosticSuggestion {\n            span: s.span,\n            replacement: s.replacement,\n            message: s.message,\n        })\n        .collect();\n\n    Diagnostic {\n        level,\n        span: diag.span,\n        message: diag.message,\n        code,\n        related_information,\n        suggestions,\n    }\n}\n\nimpl typedlua_parser::DiagnosticHandler for ConsoleDiagnosticHandler {\n    fn report(\u0026self, diagnostic: typedlua_parser::Diagnostic) {\n        DiagnosticHandler::report(self, convert_parser_diagnostic(diagnostic));\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        DiagnosticHandler::has_errors(self)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::error_count(self)\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::warning_count(self)\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003ctypedlua_parser::Diagnostic\u003e {\n        // Convert core diagnostics back to parser diagnostics\n        DiagnosticHandler::get_diagnostics(self)\n            .into_iter()\n            .map(|d| {\n                let level = match d.level {\n                    DiagnosticLevel::Error =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Error,\n                    DiagnosticLevel::Warning =\u003e {\n                        typedlua_parser::diagnostics::DiagnosticLevel::Warning\n                    }\n                    DiagnosticLevel::Info =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Info,\n                };\n                let code = d\n                    .code\n                    .map(|c| typedlua_parser::diagnostics::DiagnosticCode::new(c.prefix, c.code));\n                typedlua_parser::Diagnostic {\n                    level,\n                    span: d.span,\n                    message: d.message,\n                    code,\n                    related_information: d\n                        .related_information\n                        .into_iter()\n                        .map(\n                            |r| typedlua_parser::diagnostics::DiagnosticRelatedInformation {\n                                span: r.span,\n                                message: r.message,\n                            },\n                        )\n                        .collect(),\n                    suggestions: d\n                        .suggestions\n                        .into_iter()\n                        .map(|s| typedlua_parser::diagnostics::DiagnosticSuggestion {\n                            span: s.span,\n                            replacement: s.replacement,\n                            message: s.message,\n                        })\n                        .collect(),\n                }\n            })\n            .collect()\n    }\n}\n\nimpl typedlua_parser::DiagnosticHandler for CollectingDiagnosticHandler {\n    fn report(\u0026self, diagnostic: typedlua_parser::Diagnostic) {\n        DiagnosticHandler::report(self, convert_parser_diagnostic(diagnostic));\n    }\n\n    fn has_errors(\u0026self) -\u003e bool {\n        DiagnosticHandler::has_errors(self)\n    }\n\n    fn error_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::error_count(self)\n    }\n\n    fn warning_count(\u0026self) -\u003e usize {\n        DiagnosticHandler::warning_count(self)\n    }\n\n    fn get_diagnostics(\u0026self) -\u003e Vec\u003ctypedlua_parser::Diagnostic\u003e {\n        DiagnosticHandler::get_diagnostics(self)\n            .into_iter()\n            .map(|d| {\n                let level = match d.level {\n                    DiagnosticLevel::Error =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Error,\n                    DiagnosticLevel::Warning =\u003e {\n                        typedlua_parser::diagnostics::DiagnosticLevel::Warning\n                    }\n                    DiagnosticLevel::Info =\u003e typedlua_parser::diagnostics::DiagnosticLevel::Info,\n                };\n                let code = d\n                    .code\n                    .map(|c| typedlua_parser::diagnostics::DiagnosticCode::new(c.prefix, c.code));\n                typedlua_parser::Diagnostic {\n                    level,\n                    span: d.span,\n                    message: d.message,\n                    code,\n                    related_information: d\n                        .related_information\n                        .into_iter()\n                        .map(\n                            |r| typedlua_parser::diagnostics::DiagnosticRelatedInformation {\n                                span: r.span,\n                                message: r.message,\n                            },\n                        )\n                        .collect(),\n                    suggestions: d\n                        .suggestions\n                        .into_iter()\n                        .map(|s| typedlua_parser::diagnostics::DiagnosticSuggestion {\n                            span: s.span,\n                            replacement: s.replacement,\n                            message: s.message,\n                        })\n                        .collect(),\n                }\n            })\n            .collect()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_diagnostic_creation() {\n        let span = Span::new(0, 5, 1, 1);\n        let diag = Diagnostic::error(span, \"Test error\");\n\n        assert_eq!(diag.level, DiagnosticLevel::Error);\n        assert_eq!(diag.message, \"Test error\");\n        assert!(diag.code.is_none());\n        assert!(diag.related_information.is_empty());\n        assert!(diag.suggestions.is_empty());\n    }\n\n    #[test]\n    fn test_diagnostic_with_code() {\n        let span = Span::new(0, 5, 1, 1);\n        let code = DiagnosticCode::new('E', 1001);\n        let diag = Diagnostic::error_with_code(span, code, \"Syntax error\");\n\n        assert_eq!(diag.code, Some(code));\n        assert_eq!(code.as_str(), \"E1001\");\n    }\n\n    #[test]\n    fn test_diagnostic_with_related_info() {\n        let span = Span::new(0, 5, 1, 1);\n        let related_span = Span::new(10, 15, 2, 1);\n\n        let diag = Diagnostic::error(span, \"Duplicate declaration\")\n            .with_related(related_span, \"Previously declared here\");\n\n        assert_eq!(diag.related_information.len(), 1);\n        assert_eq!(diag.related_information[0].span, related_span);\n        assert_eq!(\n            diag.related_information[0].message,\n            \"Previously declared here\"\n        );\n    }\n\n    #[test]\n    fn test_diagnostic_with_suggestion() {\n        let span = Span::new(0, 5, 1, 1);\n\n        let diag = Diagnostic::error(span, \"Use 'const' instead\").with_suggestion(\n            span,\n            \"const\".to_string(),\n            \"Replace with 'const'\",\n        );\n\n        assert_eq!(diag.suggestions.len(), 1);\n        assert_eq!(diag.suggestions[0].replacement, \"const\");\n        assert_eq!(diag.suggestions[0].message, \"Replace with 'const'\");\n    }\n\n    #[test]\n    fn test_diagnostic_builder_chain() {\n        let span = Span::new(0, 5, 1, 1);\n        let related_span = Span::new(10, 15, 2, 1);\n        let code = DiagnosticCode::new('E', 2004);\n\n        let diag = Diagnostic::error(span, \"Type mismatch\")\n            .with_code(code)\n            .with_related(related_span, \"Expected type defined here\")\n            .with_suggestion(span, \"number\".to_string(), \"Use 'number' type\");\n\n        assert_eq!(diag.code, Some(code));\n        assert_eq!(diag.related_information.len(), 1);\n        assert_eq!(diag.suggestions.len(), 1);\n    }\n\n    #[test]\n    fn test_collecting_handler() {\n        let handler = CollectingDiagnosticHandler::new();\n        let span = Span::new(0, 5, 1, 1);\n\n        handler.error(span, \"Error 1\");\n        handler.warning(span, \"Warning 1\");\n        handler.error(span, \"Error 2\");\n\n        assert_eq!(handler.error_count(), 2);\n        assert_eq!(handler.warning_count(), 1);\n        assert!(handler.has_errors());\n        assert_eq!(handler.get_diagnostics().len(), 3);\n    }\n\n    #[test]\n    fn test_no_errors() {\n        let handler = CollectingDiagnosticHandler::new();\n        let span = Span::new(0, 5, 1, 1);\n\n        handler.warning(span, \"Warning 1\");\n        handler.info(span, \"Info 1\");\n\n        assert!(!handler.has_errors());\n        assert_eq!(handler.error_count(), 0);\n    }\n\n    #[test]\n    fn test_diagnostic_code_formatting() {\n        let code1 = DiagnosticCode::new('E', 1);\n        assert_eq!(code1.as_str(), \"E0001\");\n\n        let code2 = DiagnosticCode::new('W', 1234);\n        assert_eq!(code2.as_str(), \"W1234\");\n\n        let code3 = DiagnosticCode::new('I', 999);\n        assert_eq!(code3.as_str(), \"I0999\");\n    }\n\n    #[test]\n    fn test_error_code_constants() {\n        use super::error_codes::*;\n\n        // Test lexer error codes\n        assert_eq!(UNTERMINATED_STRING.as_str(), \"E1001\");\n        assert_eq!(UNTERMINATED_COMMENT.as_str(), \"E1002\");\n        assert_eq!(INVALID_NUMBER.as_str(), \"E1003\");\n        assert_eq!(UNEXPECTED_CHAR.as_str(), \"E1004\");\n\n        // Test parser error codes\n        assert_eq!(EXPECTED_TOKEN.as_str(), \"E2001\");\n        assert_eq!(UNEXPECTED_TOKEN.as_str(), \"E2002\");\n        assert_eq!(MISSING_END.as_str(), \"E2008\");\n        assert_eq!(CLASSES_DISABLED.as_str(), \"E2020\");\n\n        // Test type checker error codes\n        assert_eq!(TYPE_MISMATCH.as_str(), \"E3001\");\n        assert_eq!(UNDEFINED_VARIABLE.as_str(), \"E3002\");\n        assert_eq!(DUPLICATE_DECLARATION.as_str(), \"E3003\");\n\n        // Test code generator error codes\n        assert_eq!(UNSUPPORTED_FEATURE.as_str(), \"E4001\");\n\n        // Test configuration error codes\n        assert_eq!(INVALID_CONFIG.as_str(), \"E5001\");\n\n        // Test warning codes\n        assert_eq!(UNUSED_VARIABLE.as_str(), \"W1001\");\n        assert_eq!(DEPRECATED.as_str(), \"W1003\");\n    }\n\n    #[test]\n    fn test_error_codes_are_unique() {\n        use super::error_codes::*;\n        use std::collections::HashSet;\n\n        let mut codes = HashSet::new();\n\n        // Collect all error codes\n        let all_codes = vec![\n            // Lexer\n            UNTERMINATED_STRING,\n            UNTERMINATED_COMMENT,\n            INVALID_NUMBER,\n            UNEXPECTED_CHAR,\n            INVALID_ESCAPE,\n            UNTERMINATED_TEMPLATE,\n            INVALID_HEX_NUMBER,\n            INVALID_BINARY_NUMBER,\n            // Parser\n            EXPECTED_TOKEN,\n            UNEXPECTED_TOKEN,\n            EXPECTED_IDENTIFIER,\n            EXPECTED_EXPRESSION,\n            EXPECTED_TYPE,\n            EXPECTED_PATTERN,\n            MISSING_SEMICOLON,\n            MISSING_END,\n            MISSING_THEN,\n            MISSING_DO,\n            INVALID_PARAMETER,\n            INVALID_DESTRUCTURING,\n            BREAK_OUTSIDE_LOOP,\n            CONTINUE_OUTSIDE_LOOP,\n            INVALID_ASSIGNMENT,\n            EXPECTED_DOUBLE_GT,\n            CLASSES_DISABLED,\n            DECORATORS_DISABLED,\n            FP_DISABLED,\n            // Type checker\n            TYPE_MISMATCH,\n            UNDEFINED_VARIABLE,\n            DUPLICATE_DECLARATION,\n            ASSIGN_TO_CONST,\n            TYPE_NOT_FOUND,\n            PROPERTY_NOT_FOUND,\n            WRONG_ARG_COUNT,\n            NOT_CALLABLE,\n            NOT_INDEXABLE,\n            MISSING_RETURN,\n            CIRCULAR_TYPE,\n            INTERFACE_NOT_FOUND,\n            INTERFACE_NOT_IMPLEMENTED,\n            ABSTRACT_METHOD_BODY,\n            ABSTRACT_METHODS_IN_CONCRETE_CLASS,\n            MULTIPLE_CONSTRUCTORS,\n            CONSTRAINT_NOT_SATISFIED,\n            WRONG_TYPE_ARG_COUNT,\n            CANNOT_INFER_TYPE,\n            NON_EXHAUSTIVE_MATCH,\n            INVALID_MATCH_TYPE,\n            GETTER_SETTER_MISMATCH,\n            READONLY_PROPERTY,\n            PRIVATE_ACCESS,\n            PROTECTED_ACCESS,\n            INCONSISTENT_OR_PATTERN_BINDINGS,\n            INCOMPATIBLE_OR_PATTERN_TYPES,\n            EMPTY_OR_PATTERN,\n            // Code generator\n            UNSUPPORTED_FEATURE,\n            SOURCE_MAP_ERROR,\n            // Configuration\n            INVALID_CONFIG,\n            MISSING_CONFIG,\n            INVALID_TARGET,\n            // Warnings\n            UNUSED_VARIABLE,\n            UNUSED_IMPORT,\n            DEPRECATED,\n            UNREACHABLE_CODE,\n            IMPLICIT_ANY,\n            POSSIBLE_NIL,\n            SHADOWED_VARIABLE,\n            EMPTY_BLOCK,\n            TYPE_TOO_WIDE,\n            UNREACHABLE_PATTERN,\n        ];\n\n        // Check all codes are unique\n        for code in all_codes {\n            let key = (code.prefix, code.code);\n            assert!(codes.insert(key), \"Duplicate error code: {}\", code.as_str());\n        }\n    }\n\n    #[test]\n    fn test_error_with_code_and_suggestion() {\n        use super::error_codes::*;\n\n        let span = Span::new(0, 5, 1, 1);\n        let diag = Diagnostic::error_with_code(\n            span,\n            TYPE_MISMATCH,\n            \"Type 'string' is not assignable to type 'number'\",\n        )\n        .with_suggestion(\n            span,\n            \"tonumber(value)\".to_string(),\n            \"Convert to number using tonumber()\",\n        );\n\n        assert_eq!(diag.code, Some(TYPE_MISMATCH));\n        assert_eq!(diag.code.unwrap().as_str(), \"E3001\");\n        assert_eq!(diag.suggestions.len(), 1);\n        assert_eq!(diag.suggestions[0].replacement, \"tonumber(value)\");\n    }\n\n    #[test]\n    fn test_error_with_code_and_related() {\n        use super::error_codes::*;\n\n        let error_span = Span::new(10, 15, 2, 1);\n        let decl_span = Span::new(0, 5, 1, 1);\n\n        let diag = Diagnostic::error_with_code(\n            error_span,\n            DUPLICATE_DECLARATION,\n            \"Duplicate declaration of 'x'\",\n        )\n        .with_related(decl_span, \"Previously declared here\");\n\n        assert_eq!(diag.code, Some(DUPLICATE_DECLARATION));\n        assert_eq!(diag.code.unwrap().as_str(), \"E3003\");\n        assert_eq!(diag.related_information.len(), 1);\n        assert_eq!(\n            diag.related_information[0].message,\n            \"Previously declared here\"\n        );\n    }\n}\n","traces":[{"line":25,"address":[],"length":0,"stats":{"Line":71}},{"line":30,"address":[],"length":0,"stats":{"Line":21}},{"line":31,"address":[],"length":0,"stats":{"Line":42}},{"line":62,"address":[],"length":0,"stats":{"Line":31}},{"line":66,"address":[],"length":0,"stats":{"Line":93}},{"line":68,"address":[],"length":0,"stats":{"Line":31}},{"line":69,"address":[],"length":0,"stats":{"Line":31}},{"line":73,"address":[],"length":0,"stats":{"Line":6}},{"line":77,"address":[],"length":0,"stats":{"Line":18}},{"line":79,"address":[],"length":0,"stats":{"Line":6}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":88,"address":[],"length":0,"stats":{"Line":3}},{"line":90,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":96,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":3}},{"line":109,"address":[],"length":0,"stats":{"Line":9}},{"line":110,"address":[],"length":0,"stats":{"Line":6}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":113,"address":[],"length":0,"stats":{"Line":3}},{"line":117,"address":[],"length":0,"stats":{"Line":3}},{"line":123,"address":[],"length":0,"stats":{"Line":9}},{"line":124,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":6}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":128,"address":[],"length":0,"stats":{"Line":3}},{"line":132,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":143,"address":[],"length":0,"stats":{"Line":27}},{"line":144,"address":[],"length":0,"stats":{"Line":162}},{"line":147,"address":[],"length":0,"stats":{"Line":6}},{"line":148,"address":[],"length":0,"stats":{"Line":36}},{"line":151,"address":[],"length":0,"stats":{"Line":1}},{"line":152,"address":[],"length":0,"stats":{"Line":6}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":177,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":369}},{"line":519,"address":[],"length":0,"stats":{"Line":369}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":100}},{"line":532,"address":[],"length":0,"stats":{"Line":300}},{"line":535,"address":[],"length":0,"stats":{"Line":2}},{"line":536,"address":[],"length":0,"stats":{"Line":4}},{"line":540,"address":[],"length":0,"stats":{"Line":8}},{"line":543,"address":[],"length":0,"stats":{"Line":2}},{"line":544,"address":[],"length":0,"stats":{"Line":4}},{"line":548,"address":[],"length":0,"stats":{"Line":12}},{"line":552,"address":[],"length":0,"stats":{"Line":1}},{"line":553,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":7}},{"line":561,"address":[],"length":0,"stats":{"Line":32}},{"line":562,"address":[],"length":0,"stats":{"Line":64}},{"line":570,"address":[],"length":0,"stats":{"Line":66}},{"line":571,"address":[],"length":0,"stats":{"Line":132}},{"line":572,"address":[],"length":0,"stats":{"Line":66}},{"line":573,"address":[],"length":0,"stats":{"Line":0}},{"line":574,"address":[],"length":0,"stats":{"Line":0}},{"line":577,"address":[],"length":0,"stats":{"Line":396}},{"line":579,"address":[],"length":0,"stats":{"Line":132}},{"line":580,"address":[],"length":0,"stats":{"Line":66}},{"line":582,"address":[],"length":0,"stats":{"Line":66}},{"line":583,"address":[],"length":0,"stats":{"Line":0}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":132}},{"line":589,"address":[],"length":0,"stats":{"Line":66}},{"line":591,"address":[],"length":0,"stats":{"Line":66}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":132}},{"line":601,"address":[],"length":0,"stats":{"Line":132}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":613,"address":[],"length":0,"stats":{"Line":0}},{"line":614,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":642,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":0}},{"line":648,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":654,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":656,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":66}},{"line":672,"address":[],"length":0,"stats":{"Line":264}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":698,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":715,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":718,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}}],"covered":69,"coverable":190},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","errors.rs"],"content":"use thiserror::Error;\n\n#[derive(Debug, Error)]\npub enum CompilationError {\n    #[error(\"I/O error: {0}\")]\n    IoError(#[from] std::io::Error),\n\n    #[error(\"Lexical analysis failed with {0} errors\")]\n    LexicalErrors(usize),\n\n    #[error(\"Parsing failed with {0} errors\")]\n    ParseErrors(usize),\n\n    #[error(\"Type checking failed with {0} errors\")]\n    TypeErrors(usize),\n\n    #[error(\"Code generation failed: {0}\")]\n    CodeGenError(String),\n\n    #[error(\"Configuration error: {0}\")]\n    ConfigError(String),\n}\n\n#[derive(Debug, Error)]\npub enum ResolutionError {\n    #[error(\"Module not found: {0}\")]\n    ModuleNotFound(String),\n\n    #[error(\"Circular dependency detected: {0}\")]\n    CircularDependency(String),\n\n    #[error(\"Non-typed Lua file without type definitions: {0}\")]\n    MissingTypeDefinitions(String),\n\n    #[error(\"Ambiguous module resolution: {0}\")]\n    AmbiguousResolution(String),\n}\n\n#[derive(Debug, Error)]\npub enum LexerError {\n    #[error(\"Unexpected character: {0}\")]\n    UnexpectedCharacter(char),\n\n    #[error(\"Unterminated string literal\")]\n    UnterminatedString,\n\n    #[error(\"Unterminated comment\")]\n    UnterminatedComment,\n\n    #[error(\"Invalid number literal: {0}\")]\n    InvalidNumber(String),\n\n    #[error(\"Invalid escape sequence: {0}\")]\n    InvalidEscape(String),\n}\n\n#[derive(Debug, Error)]\npub enum ParserError {\n    #[error(\"Unexpected token: expected {expected}, found {found}\")]\n    UnexpectedToken { expected: String, found: String },\n\n    #[error(\"Unexpected end of file\")]\n    UnexpectedEof,\n\n    #[error(\"Feature disabled: {0}\")]\n    DisabledFeature(String),\n\n    #[error(\"Invalid syntax: {0}\")]\n    InvalidSyntax(String),\n}\n\n#[derive(Debug, Error)]\npub enum TypeCheckError {\n    #[error(\"Type mismatch: expected {expected}, found {actual}\")]\n    TypeMismatch { expected: String, actual: String },\n\n    #[error(\"Undefined variable: {0}\")]\n    UndefinedVariable(String),\n\n    #[error(\"Undefined type: {0}\")]\n    UndefinedType(String),\n\n    #[error(\"Cannot reassign const variable: {0}\")]\n    ConstReassignment(String),\n\n    #[error(\"Duplicate declaration: {0}\")]\n    DuplicateDeclaration(String),\n\n    #[error(\"Invalid operation: {0}\")]\n    InvalidOperation(String),\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","fs.rs"],"content":"use rustc_hash::FxHashMap;\nuse std::path::{Path, PathBuf};\n\n/// File system abstraction for dependency injection\npub trait FileSystem: Send + Sync {\n    fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, std::io::Error\u003e;\n    fn write_file(\u0026self, path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), std::io::Error\u003e;\n    fn exists(\u0026self, path: \u0026Path) -\u003e bool;\n    fn resolve_path(\u0026self, base: \u0026Path, relative: \u0026str) -\u003e PathBuf;\n}\n\n/// Real file system implementation\npub struct RealFileSystem;\n\nimpl RealFileSystem {\n    pub fn new() -\u003e Self {\n        Self\n    }\n}\n\nimpl Default for RealFileSystem {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl FileSystem for RealFileSystem {\n    fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, std::io::Error\u003e {\n        std::fs::read_to_string(path)\n    }\n\n    fn write_file(\u0026self, path: \u0026Path, content: \u0026str) -\u003e Result\u003c(), std::io::Error\u003e {\n        if let Some(parent) = path.parent() {\n            std::fs::create_dir_all(parent)?;\n        }\n        std::fs::write(path, content)\n    }\n\n    fn exists(\u0026self, path: \u0026Path) -\u003e bool {\n        path.exists()\n    }\n\n    fn resolve_path(\u0026self, base: \u0026Path, relative: \u0026str) -\u003e PathBuf {\n        base.join(relative)\n    }\n}\n\n/// Mock file system for testing\npub struct MockFileSystem {\n    files: FxHashMap\u003cPathBuf, String\u003e,\n}\n\nimpl MockFileSystem {\n    pub fn new() -\u003e Self {\n        Self {\n            files: FxHashMap::default(),\n        }\n    }\n\n    pub fn add_file(\u0026mut self, path: impl Into\u003cPathBuf\u003e, content: impl Into\u003cString\u003e) {\n        self.files.insert(path.into(), content.into());\n    }\n}\n\nimpl Default for MockFileSystem {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl FileSystem for MockFileSystem {\n    fn read_file(\u0026self, path: \u0026Path) -\u003e Result\u003cString, std::io::Error\u003e {\n        self.files.get(path).cloned().ok_or_else(|| {\n            std::io::Error::new(\n                std::io::ErrorKind::NotFound,\n                format!(\"File not found: {}\", path.display()),\n            )\n        })\n    }\n\n    fn write_file(\u0026self, _path: \u0026Path, _content: \u0026str) -\u003e Result\u003c(), std::io::Error\u003e {\n        // Mock implementation - could track writes if needed\n        Ok(())\n    }\n\n    fn exists(\u0026self, path: \u0026Path) -\u003e bool {\n        self.files.contains_key(path)\n    }\n\n    fn resolve_path(\u0026self, base: \u0026Path, relative: \u0026str) -\u003e PathBuf {\n        base.join(relative)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_mock_fs_read() {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/test.txt\", \"Hello, world!\");\n\n        let content = fs.read_file(Path::new(\"/test.txt\")).unwrap();\n        assert_eq!(content, \"Hello, world!\");\n    }\n\n    #[test]\n    fn test_mock_fs_not_found() {\n        let fs = MockFileSystem::new();\n        let result = fs.read_file(Path::new(\"/nonexistent.txt\"));\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_mock_fs_exists() {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/test.txt\", \"content\");\n\n        assert!(fs.exists(Path::new(\"/test.txt\")));\n        assert!(!fs.exists(Path::new(\"/other.txt\")));\n    }\n\n    #[test]\n    fn test_resolve_path() {\n        let fs = RealFileSystem::new();\n        let resolved = fs.resolve_path(Path::new(\"/base\"), \"relative/path.txt\");\n        assert_eq!(resolved, PathBuf::from(\"/base/relative/path.txt\"));\n    }\n}\n","traces":[{"line":16,"address":[],"length":0,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":1}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":10}},{"line":56,"address":[],"length":0,"stats":{"Line":10}},{"line":60,"address":[],"length":0,"stats":{"Line":34}},{"line":61,"address":[],"length":0,"stats":{"Line":204}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":11}},{"line":74,"address":[],"length":0,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":23}},{"line":87,"address":[],"length":0,"stats":{"Line":69}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}}],"covered":15,"coverable":31},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","cli","mod.rs"],"content":"pub mod config;\npub mod diagnostics;\npub mod errors;\npub mod fs;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","mod.rs"],"content":"pub mod type_checker;\npub mod type_compat;\npub mod type_environment;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","type_checker.rs"],"content":"use crate::cli::config::CompilerOptions;\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_compat::TypeCompatibility;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::helpers::{control_flow, type_utilities};\nuse crate::phases;\nuse crate::phases::declaration_checking_phase;\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::visitors::{\n    AccessControl, AccessControlVisitor, ClassContext, ClassMemberInfo, ClassMemberKind,\n    NarrowingVisitor, TypeInferenceVisitor, TypeInferrer, TypeNarrower,\n};\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse std::sync::Arc;\nuse tracing::{debug, error, info, instrument, span, Level};\nuse typedlua_parser::ast::expression::*;\nuse typedlua_parser::ast::pattern::Pattern;\nuse typedlua_parser::ast::statement::*;\nuse typedlua_parser::ast::types::*;\nuse typedlua_parser::ast::Program;\nuse typedlua_parser::span::Span;\n\n/// Type checker for TypedLua programs\npub struct TypeChecker\u003c'a\u003e {\n    symbol_table: SymbolTable,\n    type_env: TypeEnvironment,\n    current_function_return_type: Option\u003cType\u003e,\n    // Visitor pattern integration - Phase 6\n    narrowing: TypeNarrower,\n    access_control: AccessControl,\n    // Note: TypeInferrer is created on-demand in infer_expression_type due to borrowing requirements\n    options: CompilerOptions,\n    /// Module registry for multi-module compilation\n    module_registry: Option\u003cArc\u003ccrate::module_resolver::ModuleRegistry\u003e\u003e,\n    /// Current module ID\n    current_module_id: Option\u003ccrate::module_resolver::ModuleId\u003e,\n    /// Module resolver for imports\n    module_resolver: Option\u003cArc\u003ccrate::module_resolver::ModuleResolver\u003e\u003e,\n    /// Track module dependencies for cache invalidation\n    module_dependencies: Vec\u003cstd::path::PathBuf\u003e,\n    /// Stack of whether we're inside a catch block (for rethrow validation)\n    in_catch_block: Vec\u003cbool\u003e,\n    /// Current namespace path for this module\n    current_namespace: Option\u003cVec\u003cString\u003e\u003e,\n    /// Type parameters for each generic class (needed for override checking)\n    class_type_params: FxHashMap\u003cString, Vec\u003ctypedlua_parser::ast::statement::TypeParameter\u003e\u003e,\n    /// Track class inheritance for circular dependency detection\n    class_parents: FxHashMap\u003cString, String\u003e,\n    /// Track exported names to detect duplicates\n    exported_names: std::collections::HashSet\u003cString\u003e,\n    diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n    interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n    common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n}\n\nimpl\u003c'a\u003e TypeChecker\u003c'a\u003e {\n    /// Create a new TypeChecker without loading the standard library.\n    ///\n    /// This creates a lightweight type checker instance suitable for testing\n    /// or scenarios where stdlib is not needed. Use `with_stdlib()` or\n    /// `new_with_stdlib()` to load the standard library.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let checker = TypeChecker::new(handler, \u0026interner, \u0026common);\n    /// ```\n    pub fn new(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n        common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n    ) -\u003e Self {\n        Self {\n            symbol_table: SymbolTable::new(),\n            type_env: TypeEnvironment::new(),\n            current_function_return_type: None,\n            narrowing: TypeNarrower::new(),\n            options: CompilerOptions::default(),\n            access_control: AccessControl::new(),\n            module_registry: None,\n            current_module_id: None,\n            module_resolver: None,\n            module_dependencies: Vec::new(),\n            in_catch_block: Vec::new(),\n            current_namespace: None,\n            class_type_params: FxHashMap::default(),\n            class_parents: FxHashMap::default(),\n            exported_names: std::collections::HashSet::new(),\n            diagnostic_handler,\n            interner,\n            common,\n        }\n    }\n\n    /// Create a new TypeChecker with the standard library loaded.\n    ///\n    /// This is a convenience method that combines `new()` and `with_stdlib()`.\n    /// For backward compatibility with existing code.\n    ///\n    /// # Example\n    ///\n    /// ```rust,ignore\n    /// let checker = TypeChecker::new_with_stdlib(handler, \u0026interner, \u0026common)?;\n    /// ```\n    pub fn new_with_stdlib(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n        common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n    ) -\u003e Result\u003cSelf, String\u003e {\n        let mut checker = Self::new(diagnostic_handler, interner, common);\n        checker.load_stdlib()?;\n        checker.register_minimal_stdlib();\n        Ok(checker)\n    }\n\n    /// Load the standard library into this type checker.\n    ///\n    /// This method loads the standard library for the configured Lua version.\n    /// It can be called multiple times if the Lua version changes.\n    ///\n    /// # Errors\n    ///\n    /// Returns an error if stdlib parsing fails.\n    pub fn with_stdlib(mut self) -\u003e Result\u003cSelf, String\u003e {\n        self.load_stdlib()?;\n        self.register_minimal_stdlib();\n        Ok(self)\n    }\n\n    pub fn with_options(mut self, options: CompilerOptions) -\u003e Self {\n        // Check if target version changed\n        let version_changed = self.options.target != options.target;\n        self.options = options;\n\n        // Only reload stdlib if the target version changed\n        if version_changed {\n            // Reset symbol table and type environment\n            self.symbol_table = SymbolTable::new();\n            self.type_env = TypeEnvironment::new();\n            self.access_control = AccessControl::new();\n            self.class_type_params = FxHashMap::default();\n            self.exported_names = std::collections::HashSet::new();\n\n            // Reload stdlib with the new target version\n            if let Err(e) = self.load_stdlib() {\n                eprintln!(\"Warning: Failed to load stdlib: {}\", e);\n            }\n        }\n\n        self\n    }\n\n    /// Create a TypeChecker with module support for multi-module compilation\n    pub fn new_with_module_support(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a typedlua_parser::string_interner::StringInterner,\n        common: \u0026'a typedlua_parser::string_interner::CommonIdentifiers,\n        registry: Arc\u003ccrate::module_resolver::ModuleRegistry\u003e,\n        module_id: crate::module_resolver::ModuleId,\n        resolver: Arc\u003ccrate::module_resolver::ModuleResolver\u003e,\n    ) -\u003e Self {\n        let mut checker = Self::new(diagnostic_handler, interner, common);\n        checker.module_registry = Some(registry);\n        checker.current_module_id = Some(module_id);\n        checker.module_resolver = Some(resolver);\n        checker\n    }\n\n    /// Load the standard library for the configured Lua version\n    ///\n    /// This method parses the stdlib definition files and processes their\n    /// statements to populate the type checker's symbol table and type environment.\n    pub fn load_stdlib(\u0026mut self) -\u003e Result\u003c(), String\u003e {\n        use crate::state::stdlib_loader;\n\n        let programs =\n            stdlib_loader::parse_stdlib_files(self.options.target, self.interner, self.common)?;\n\n        for mut program in programs {\n            for statement in \u0026mut program.statements {\n                // Ignore errors from stdlib - best-effort population\n                let _ = self.check_statement(statement);\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Type check a program\n    #[instrument(skip(self, program))]\n    pub fn check_program(\u0026mut self, program: \u0026mut Program) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let span = span!(\n            Level::INFO,\n            \"check_program\",\n            statements = program.statements.len()\n        );\n        let _guard = span.enter();\n\n        debug!(\n            \"Starting type checking for program with {} statements\",\n            program.statements.len()\n        );\n\n        // PASS 1: Register all function declarations (hoisting)\n        // This allows functions to be called before they appear in source order\n        for statement in program.statements.iter() {\n            if let Statement::Function(func_decl) = statement {\n                self.register_function_signature(func_decl)?;\n            }\n        }\n\n        debug!(\"Completed pass 1: function signatures registered\");\n\n        // PASS 2: Type check all statements (including function bodies)\n        let mut first_error: Option\u003cTypeCheckError\u003e = None;\n        let mut statements_checked = 0;\n        for statement in program.statements.iter_mut() {\n            if let Err(e) = self.check_statement(statement) {\n                if first_error.is_none() {\n                    first_error = Some(e);\n                }\n            }\n            statements_checked += 1;\n        }\n\n        debug!(\n            \"Completed pass 2: checked {} statements\",\n            statements_checked\n        );\n\n        if let Some(err) = first_error {\n            error!(error = %err, \"Type checking failed\");\n            Err(err)\n        } else {\n            info!(\"Type checking completed successfully\");\n            Ok(())\n        }\n    }\n\n    /// Register a function's signature in the symbol table without checking its body\n    /// This is used during the first pass of check_program to enable function hoisting\n    fn register_function_signature(\n        \u0026mut self,\n        decl: \u0026FunctionDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_phase\n        phases::declaration_phase::register_function_signature(\n            decl,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Type check a statement\n    #[instrument(skip(self, stmt), fields(stmt_type))]\n    fn check_statement(\u0026mut self, stmt: \u0026mut Statement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let stmt_type = match stmt {\n            Statement::Variable(_) =\u003e \"Variable\",\n            Statement::Function(_) =\u003e \"Function\",\n            Statement::If(_) =\u003e \"If\",\n            Statement::While(_) =\u003e \"While\",\n            Statement::For(_) =\u003e \"For\",\n            Statement::Repeat(_) =\u003e \"Repeat\",\n            Statement::Return(_) =\u003e \"Return\",\n            Statement::Break(_) =\u003e \"Break\",\n            Statement::Continue(_) =\u003e \"Continue\",\n            Statement::Expression(_) =\u003e \"Expression\",\n            Statement::Block(_) =\u003e \"Block\",\n            Statement::Interface(_) =\u003e \"Interface\",\n            Statement::TypeAlias(_) =\u003e \"TypeAlias\",\n            Statement::Enum(_) =\u003e \"Enum\",\n            Statement::Class(_) =\u003e \"Class\",\n            Statement::Import(_) =\u003e \"Import\",\n            Statement::Export(_) =\u003e \"Export\",\n            Statement::Namespace(_) =\u003e \"Namespace\",\n            Statement::Label(_) =\u003e \"Label\",\n            Statement::Goto(_) =\u003e \"Goto\",\n            Statement::Throw(_) =\u003e \"Throw\",\n            Statement::Try(_) =\u003e \"Try\",\n            Statement::Rethrow(_) =\u003e \"Rethrow\",\n            Statement::DeclareFunction(_) =\u003e \"DeclareFunction\",\n            Statement::DeclareNamespace(_) =\u003e \"DeclareNamespace\",\n            Statement::DeclareType(_) =\u003e \"DeclareType\",\n            Statement::DeclareInterface(_) =\u003e \"DeclareInterface\",\n            Statement::DeclareConst(_) =\u003e \"DeclareConst\",\n        };\n\n        span!(Level::DEBUG, \"check_statement\", kind = stmt_type);\n\n        match stmt {\n            Statement::Variable(decl) =\u003e self.check_variable_declaration(decl),\n            Statement::Function(decl) =\u003e self.check_function_declaration(decl),\n            Statement::If(if_stmt) =\u003e self.check_if_statement(if_stmt),\n            Statement::While(while_stmt) =\u003e self.check_while_statement(while_stmt),\n            Statement::For(for_stmt) =\u003e self.check_for_statement(for_stmt),\n            Statement::Repeat(repeat_stmt) =\u003e self.check_repeat_statement(repeat_stmt),\n            Statement::Return(return_stmt) =\u003e self.check_return_statement(return_stmt),\n            Statement::Break(_) | Statement::Continue(_) =\u003e Ok(()),\n            Statement::Expression(expr) =\u003e {\n                self.infer_expression_type(expr)?;\n                Ok(())\n            }\n            Statement::Block(block) =\u003e self.check_block(block),\n            Statement::Interface(iface) =\u003e self.check_interface_declaration(iface),\n            Statement::TypeAlias(alias) =\u003e self.check_type_alias(alias),\n            Statement::Enum(enum_decl) =\u003e self.check_enum_declaration(enum_decl),\n            Statement::Class(class_decl) =\u003e self.check_class_declaration(class_decl),\n            Statement::Import(import) =\u003e self.check_import_statement(import),\n            Statement::Export(export) =\u003e self.check_export_statement(export),\n            // Declaration file statements - register them in the symbol table\n            Statement::DeclareFunction(func) =\u003e self.register_declare_function(func),\n            Statement::DeclareNamespace(ns) =\u003e self.register_declare_namespace(ns),\n            Statement::DeclareType(alias) =\u003e self.check_type_alias(alias), // Reuse existing logic\n            Statement::DeclareInterface(iface) =\u003e self.check_interface_declaration(iface), // Reuse existing logic\n            Statement::DeclareConst(const_decl) =\u003e self.register_declare_const(const_decl),\n            // Exception handling\n            Statement::Throw(throw_stmt) =\u003e self.check_throw_statement(throw_stmt),\n            Statement::Try(try_stmt) =\u003e self.check_try_statement(try_stmt),\n            Statement::Rethrow(span) =\u003e self.check_rethrow_statement(*span),\n            // File-based namespace declaration\n            Statement::Namespace(ns_decl) =\u003e self.check_namespace_declaration(ns_decl),\n            // Label and Goto (Lua compatibility)\n            Statement::Label(_) | Statement::Goto(_) =\u003e Ok(()),\n        }\n    }\n\n    /// Check variable declaration\n    fn check_variable_declaration(\n        \u0026mut self,\n        decl: \u0026mut VariableDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Infer the type of the initializer\n        let init_type = self.infer_expression_type(\u0026mut decl.initializer)?;\n\n        // Get the declared type or use inferred type\n        let var_type = if let Some(type_ann) = \u0026decl.type_annotation {\n            // Resolve the type annotation (handles type references)\n            let resolved_type_ann = self\n                .evaluate_type(type_ann)\n                .map_err(|e| TypeCheckError::new(e, decl.span))?;\n\n            // Deep-resolve both types so nested references (e.g., Address | nil in an\n            // interface property) are resolved before structural comparison\n            let deep_init = self.deep_resolve_type(\u0026init_type);\n            let deep_ann = self.deep_resolve_type(\u0026resolved_type_ann);\n\n            // Check that initializer is assignable to declared type\n            if !TypeCompatibility::is_assignable(\u0026deep_init, \u0026deep_ann) {\n                // Fallback: check if source class implements the target interface.\n                // Use original init_type and type_ann (pre-evaluation) since evaluate_type\n                // resolves interface references to ObjectType, losing the interface name.\n                if !self.check_implements_assignable(\u0026init_type, type_ann) {\n                    self.diagnostic_handler.error(\n                        decl.span,\n                        \u0026format!(\n                            \"Type mismatch in variable declaration: cannot assign type '{:?}' to type '{:?}'\",\n                            deep_init.kind, deep_ann.kind\n                        ),\n                    );\n                }\n            }\n            resolved_type_ann\n        } else {\n            // For const, use narrow type; for local, widen literals\n            if matches!(decl.kind, VariableKind::Const) {\n                init_type\n            } else {\n                self.widen_type(init_type)\n            }\n        };\n\n        // Declare the variable in the symbol table\n        let symbol_kind = match decl.kind {\n            VariableKind::Const =\u003e SymbolKind::Const,\n            VariableKind::Local =\u003e SymbolKind::Variable,\n        };\n\n        self.declare_pattern(\u0026decl.pattern, var_type, symbol_kind, decl.span)?;\n\n        Ok(())\n    }\n\n    /// Declare symbols from a pattern\n    fn declare_pattern(\n        \u0026mut self,\n        pattern: \u0026Pattern,\n        typ: Type,\n        kind: SymbolKind,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_phase\n        phases::declaration_phase::declare_pattern(\n            pattern,\n            typ,\n            kind,\n            span,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Check function declaration\n    fn check_function_declaration(\n        \u0026mut self,\n        decl: \u0026mut FunctionDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // NOTE: Function signature is already registered in the symbol table during pass 1\n        // (see register_function_signature method called from check_program)\n        // This method now only checks the function body\n\n        // Enter new scope for function body\n        self.symbol_table.enter_scope();\n\n        // If generic, declare type parameters as types in scope\n        phases::declaration_checking_phase::register_function_type_parameters(\n            decl.type_parameters.as_deref(),\n            \u0026mut self.type_env,\n            self.interner,\n        )?;\n\n        // Declare parameters\n        for (i, param) in decl.parameters.iter().enumerate() {\n            // Check if rest parameter is in the correct position\n            if param.is_rest \u0026\u0026 i != decl.parameters.len() - 1 {\n                return Err(TypeCheckError::new(\n                    \"Rest parameter must be the last parameter\",\n                    param.span,\n                ));\n            }\n\n            let param_type = if param.is_rest {\n                // Rest parameters are arrays\n                let elem_type = if let Some(type_ann) = \u0026param.type_annotation {\n                    // Evaluate to resolve type references\n                    let evaluated = self\n                        .evaluate_type(type_ann)\n                        .map_err(|e| TypeCheckError::new(e, param.span))\n                        .unwrap_or_else(|_| type_ann.clone());\n                    // Deep resolve to handle nested types\n                    self.deep_resolve_type(\u0026evaluated)\n                } else {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                };\n\n                // Wrap in array type\n                Type::new(TypeKind::Array(Box::new(elem_type)), param.span)\n            } else if let Some(type_ann) = \u0026param.type_annotation {\n                // Evaluate to resolve type references\n                let evaluated = self\n                    .evaluate_type(type_ann)\n                    .map_err(|e| TypeCheckError::new(e, param.span))\n                    .unwrap_or_else(|_| type_ann.clone());\n                // Deep resolve to handle nested types\n                self.deep_resolve_type(\u0026evaluated)\n            } else {\n                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n            };\n\n            self.declare_pattern(\n                \u0026param.pattern,\n                param_type,\n                SymbolKind::Parameter,\n                param.span,\n            )?;\n        }\n\n        // Set current function return type for return statement checking\n        let old_return_type = self.current_function_return_type.clone();\n        let resolved_return_type = decl.return_type.as_ref().map(|rt| {\n            let evaluated = self.evaluate_type(rt).unwrap_or_else(|_| rt.clone());\n            self.deep_resolve_type(\u0026evaluated)\n        });\n        self.current_function_return_type = resolved_return_type;\n\n        // Check function body (scope-safe: always exit scope even on error)\n        let body_result = self.check_block(\u0026mut decl.body);\n\n        // Check that non-void functions have a return statement on all code paths\n        if body_result.is_ok() {\n            if let Some(ref return_type) = decl.return_type {\n                // Only check if return type is not void/nil\n                let is_void = matches!(\n                    return_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Void)\n                        | TypeKind::Primitive(PrimitiveType::Nil)\n                );\n                if !is_void \u0026\u0026 !self.block_always_returns(\u0026decl.body) {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Function '{}' must return a value of type '{}' on all code paths\",\n                            self.interner.resolve(decl.name.node),\n                            self.type_to_string(return_type)\n                        ),\n                        decl.span,\n                    ));\n                }\n            }\n        }\n\n        // Restore previous return type\n        self.current_function_return_type = old_return_type;\n\n        // Clean up type parameter constraints and aliases\n        if let Some(type_params) = \u0026decl.type_parameters {\n            for type_param in type_params {\n                let param_name = self.interner.resolve(type_param.name.node).to_string();\n                self.type_env.remove_type_alias(\u0026param_name);\n                self.type_env.remove_type_param_constraint(\u0026param_name);\n            }\n        }\n\n        // Exit function scope (this will remove type parameter registrations)\n        self.symbol_table.exit_scope();\n\n        body_result\n    }\n\n    /// Check if statement\n    fn check_if_statement(\u0026mut self, if_stmt: \u0026mut IfStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check condition\n        self.infer_expression_type(\u0026mut if_stmt.condition)?;\n\n        // Collect current variable and function types for narrowing\n        // This includes both variables and functions so type predicates can be checked\n        let mut variable_types = FxHashMap::default();\n        for (name, symbol) in self.symbol_table.all_visible_symbols() {\n            let name_id = self.interner.intern(\u0026name);\n            variable_types.insert(name_id, symbol.typ.clone());\n        }\n\n        // Apply type narrowing based on the condition\n        let (then_context, else_context) = self.narrowing.narrow_from_condition(\n            \u0026if_stmt.condition,\n            self.narrowing.get_context(),\n            \u0026variable_types,\n            self.interner,\n        );\n\n        // Check then block with narrowed context\n        let saved_context = self.narrowing.get_context().clone();\n        *self.narrowing.get_context_mut() = then_context;\n        self.check_block(\u0026mut if_stmt.then_block)?;\n\n        // Restore context for else-if and else\n        *self.narrowing.get_context_mut() = else_context.clone();\n\n        // Check else-if clauses\n        for else_if in if_stmt.else_ifs.iter_mut() {\n            self.infer_expression_type(\u0026mut else_if.condition)?;\n\n            // Further narrow based on else-if condition\n            let (elseif_then, elseif_else) = self.narrowing.narrow_from_condition(\n                \u0026else_if.condition,\n                self.narrowing.get_context(),\n                \u0026variable_types,\n                self.interner,\n            );\n\n            *self.narrowing.get_context_mut() = elseif_then;\n            self.check_block(\u0026mut else_if.block)?;\n            *self.narrowing.get_context_mut() = elseif_else;\n        }\n\n        // Check else block\n        if let Some(else_block) = \u0026mut if_stmt.else_block {\n            self.check_block(else_block)?;\n        }\n\n        // Restore original context after if statement\n        *self.narrowing.get_context_mut() = saved_context;\n\n        Ok(())\n    }\n\n    /// Check while statement\n    fn check_while_statement(\n        \u0026mut self,\n        while_stmt: \u0026mut WhileStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.infer_expression_type(\u0026mut while_stmt.condition)?;\n        self.check_block(\u0026mut while_stmt.body)?;\n        Ok(())\n    }\n\n    /// Check for statement\n    fn check_for_statement(\u0026mut self, for_stmt: \u0026mut ForStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        match for_stmt {\n            ForStatement::Numeric(numeric) =\u003e {\n                self.symbol_table.enter_scope();\n\n                // Declare loop variable as number\n                let number_type =\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), numeric.span);\n                let symbol = Symbol::new(\n                    self.interner.resolve(numeric.variable.node).to_string(),\n                    SymbolKind::Variable,\n                    number_type,\n                    numeric.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, numeric.span))?;\n\n                // Check start, end, step expressions\n                self.infer_expression_type(\u0026mut numeric.start)?;\n                self.infer_expression_type(\u0026mut numeric.end)?;\n                if let Some(step) = \u0026mut numeric.step {\n                    self.infer_expression_type(step)?;\n                }\n\n                self.check_block(\u0026mut numeric.body)?;\n                self.symbol_table.exit_scope();\n            }\n            ForStatement::Generic(generic) =\u003e {\n                self.symbol_table.enter_scope();\n\n                // Declare loop variables with unknown type\n\n                let unknown_type =\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), generic.span);\n                for var in \u0026generic.variables {\n                    let symbol = Symbol::new(\n                        self.interner.resolve(var.node).to_string(),\n                        SymbolKind::Variable,\n                        unknown_type.clone(),\n                        generic.span,\n                    );\n                    self.symbol_table\n                        .declare(symbol)\n                        .map_err(|e| TypeCheckError::new(e, generic.span))?;\n                }\n\n                // Check iterators\n                for iter in \u0026mut generic.iterators {\n                    self.infer_expression_type(iter)?;\n                }\n\n                self.check_block(\u0026mut generic.body)?;\n                self.symbol_table.exit_scope();\n            }\n        }\n        Ok(())\n    }\n\n    /// Check repeat statement\n    fn check_repeat_statement(\n        \u0026mut self,\n        repeat_stmt: \u0026mut RepeatStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.symbol_table.enter_scope();\n        self.check_block(\u0026mut repeat_stmt.body)?;\n        self.infer_expression_type(\u0026mut repeat_stmt.until)?;\n        self.symbol_table.exit_scope();\n        Ok(())\n    }\n\n    /// Check return statement\n    fn check_return_statement(\n        \u0026mut self,\n        return_stmt: \u0026mut ReturnStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        if !return_stmt.values.is_empty() {\n            // Infer types for all return values\n            let return_types: Result\u003cVec\u003c_\u003e, _\u003e = return_stmt\n                .values\n                .iter_mut()\n                .map(|expr| self.infer_expression_type(expr))\n                .collect();\n            let return_types = return_types?;\n\n            // Create the actual return type (single value or tuple)\n            let actual_return_type = if return_types.len() == 1 {\n                return_types[0].clone()\n            } else {\n                Type::new(TypeKind::Tuple(return_types), return_stmt.span)\n            };\n\n            // Check against expected return type\n            if let Some(expected_type) = \u0026self.current_function_return_type {\n                // Type predicates have an implicit boolean return type\n                let effective_expected_type =\n                    if matches!(expected_type.kind, TypeKind::TypePredicate(_)) {\n                        Type::new(\n                            TypeKind::Primitive(PrimitiveType::Boolean),\n                            expected_type.span,\n                        )\n                    } else {\n                        expected_type.clone()\n                    };\n\n                if !TypeCompatibility::is_assignable(\u0026actual_return_type, \u0026effective_expected_type)\n                {\n                    return Err(TypeCheckError::new(\n                        \"Return type mismatch\",\n                        return_stmt.span,\n                    ));\n                }\n            }\n        } else {\n            // Check that void return is allowed\n            if let Some(expected_type) = \u0026self.current_function_return_type {\n                let void_type =\n                    Type::new(TypeKind::Primitive(PrimitiveType::Void), return_stmt.span);\n                if !TypeCompatibility::is_assignable(\u0026void_type, expected_type) {\n                    return Err(TypeCheckError::new(\n                        \"Function expects a return value\",\n                        return_stmt.span,\n                    ));\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Check block\n    fn check_block(\u0026mut self, block: \u0026mut Block) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.symbol_table.enter_scope();\n        let mut first_error: Option\u003cTypeCheckError\u003e = None;\n        for stmt in \u0026mut block.statements {\n            if let Err(e) = self.check_statement(stmt) {\n                if first_error.is_none() {\n                    first_error = Some(e);\n                }\n            }\n        }\n        self.symbol_table.exit_scope();\n        if let Some(err) = first_error {\n            Err(err)\n        } else {\n            Ok(())\n        }\n    }\n\n    /// Check interface declaration\n    fn check_interface_declaration(\n        \u0026mut self,\n        iface: \u0026mut InterfaceDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_checking_phase for interface registration and validation\n        let (has_default_bodies, iface_type) =\n            phases::declaration_checking_phase::check_interface_declaration(\n                iface,\n                \u0026mut self.type_env,\n                \u0026mut self.symbol_table,\n                \u0026mut self.access_control,\n                self.interner,\n            )?;\n\n        // Type-check default method bodies if present\n        if has_default_bodies {\n            for member in iface.members.iter_mut() {\n                if let InterfaceMember::Method(method) = member {\n                    if let Some(body) = \u0026mut method.body {\n                        self.symbol_table.enter_scope();\n\n                        let self_symbol = Symbol::new(\n                            \"self\".to_string(),\n                            SymbolKind::Parameter,\n                            iface_type.clone(),\n                            method.span,\n                        );\n                        self.symbol_table\n                            .declare(self_symbol)\n                            .map_err(|e| TypeCheckError::new(e, method.span))?;\n\n                        let _ = self.check_block(body);\n\n                        self.symbol_table.exit_scope();\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Validate interface members for correctness\n    #[allow(dead_code)]\n    fn validate_interface_members(\n        \u0026self,\n        members: \u0026[ObjectTypeMember],\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::validate_interface_members(members, span)\n    }\n\n    /// Check type alias\n    fn check_type_alias(\u0026mut self, alias: \u0026TypeAliasDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // For non-generic aliases, evaluate the type before delegating\n        let evaluated_type = if alias.type_parameters.is_none() {\n            Some(\n                self.evaluate_type(\u0026alias.type_annotation)\n                    .map_err(|e| TypeCheckError::new(e, alias.span))?,\n            )\n        } else {\n            None\n        };\n\n        // Delegate to declaration_checking_phase\n        phases::declaration_checking_phase::check_type_alias(\n            alias,\n            \u0026mut self.type_env,\n            \u0026mut self.symbol_table,\n            self.interner,\n            evaluated_type,\n        )\n    }\n\n    /// Check export statement and register exported symbols\n    fn check_export_statement(\u0026mut self, export: \u0026ExportDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Extract export names and check for duplicates\n        match \u0026export.kind {\n            ExportKind::Declaration(decl) =\u003e {\n                // Extract the name being exported\n                let export_name = match \u0026**decl {\n                    Statement::Variable(var_decl) =\u003e {\n                        // Extract variable name from pattern\n                        match \u0026var_decl.pattern {\n                            typedlua_parser::ast::pattern::Pattern::Identifier(name) =\u003e {\n                                Some(self.interner.resolve(name.node).to_string())\n                            }\n                            _ =\u003e None, // Complex patterns - skip for now\n                        }\n                    }\n                    Statement::Function(func_decl) =\u003e {\n                        Some(self.interner.resolve(func_decl.name.node).to_string())\n                    }\n                    Statement::Class(class_decl) =\u003e {\n                        Some(self.interner.resolve(class_decl.name.node).to_string())\n                    }\n                    Statement::Interface(iface_decl) =\u003e {\n                        Some(self.interner.resolve(iface_decl.name.node).to_string())\n                    }\n                    Statement::TypeAlias(alias_decl) =\u003e {\n                        Some(self.interner.resolve(alias_decl.name.node).to_string())\n                    }\n                    Statement::Enum(enum_decl) =\u003e {\n                        Some(self.interner.resolve(enum_decl.name.node).to_string())\n                    }\n                    _ =\u003e None,\n                };\n\n                // Check for duplicate export\n                if let Some(name) = \u0026export_name {\n                    if !self.exported_names.insert(name.clone()) {\n                        return Err(TypeCheckError::new(\n                            format!(\"Duplicate export '{}'\", name),\n                            export.span,\n                        ));\n                    }\n                }\n            }\n            ExportKind::Named { specifiers, .. } =\u003e {\n                // Check each specifier for duplicates\n                for spec in specifiers {\n                    let export_name = if let Some(exported) = \u0026spec.exported {\n                        self.interner.resolve(exported.node).to_string()\n                    } else {\n                        self.interner.resolve(spec.local.node).to_string()\n                    };\n                    if !self.exported_names.insert(export_name.clone()) {\n                        return Err(TypeCheckError::new(\n                            format!(\"Duplicate export '{}'\", export_name),\n                            export.span,\n                        ));\n                    }\n                }\n            }\n            ExportKind::Default(_) =\u003e {\n                // Check for duplicate default export\n                if !self.exported_names.insert(\"default\".to_string()) {\n                    return Err(TypeCheckError::new(\n                        \"Duplicate default export\".to_string(),\n                        export.span,\n                    ));\n                }\n            }\n        }\n\n        // Now process the export declaration\n        match \u0026export.kind {\n            ExportKind::Declaration(decl) =\u003e {\n                // Process the declaration to register it in the symbol table\n                // Note: Most check functions require \u0026mut, but we only have \u0026 here\n                // For now, only handle TypeAlias which takes \u0026TypeAliasDeclaration\n                match \u0026**decl {\n                    Statement::TypeAlias(alias) =\u003e self.check_type_alias(alias),\n                    Statement::Interface(iface) =\u003e {\n                        // Register interface in both type_env and symbol_table\n                        // This is a subset of what check_interface_declaration does\n                        let iface_name = self.interner.resolve(iface.name.node).to_string();\n\n                        // Store type parameter names for generic interfaces\n                        if let Some(type_params) = \u0026iface.type_parameters {\n                            let param_names: Vec\u003cString\u003e = type_params\n                                .iter()\n                                .map(|tp| self.interner.resolve(tp.name.node).to_string())\n                                .collect();\n                            self.type_env\n                                .register_interface_type_params(iface_name.clone(), param_names);\n                        }\n\n                        // Create object type from interface members\n                        let obj_type = Type::new(\n                            TypeKind::Object(ObjectType {\n                                members: iface\n                                    .members\n                                    .iter()\n                                    .map(|member| match member {\n                                        InterfaceMember::Property(prop) =\u003e {\n                                            ObjectTypeMember::Property(prop.clone())\n                                        }\n                                        InterfaceMember::Method(method) =\u003e {\n                                            ObjectTypeMember::Method(method.clone())\n                                        }\n                                        InterfaceMember::Index(index) =\u003e {\n                                            ObjectTypeMember::Index(index.clone())\n                                        }\n                                    })\n                                    .collect(),\n                                span: iface.span,\n                            }),\n                            iface.span,\n                        );\n\n                        // Register in type_env\n                        self.type_env\n                            .register_interface(iface_name.clone(), obj_type.clone())\n                            .map_err(|e| TypeCheckError::new(e, iface.span))?;\n\n                        // Also register in symbol table for export extraction\n                        let symbol = Symbol {\n                            name: iface_name,\n                            typ: obj_type,\n                            kind: SymbolKind::Interface,\n                            span: iface.span,\n                            is_exported: true,\n                            references: Vec::new(),\n                        };\n                        let _ = self.symbol_table.declare(symbol);\n\n                        Ok(())\n                    }\n                    // TODO: Handle other declaration types (Function, Class, Variable, Enum)\n                    // These require mutable references and would need the ExportDeclaration to be mutable\n                    _ =\u003e Ok(()),\n                }\n            }\n            ExportKind::Named {\n                specifiers: _,\n                source,\n            } =\u003e {\n                // For re-exports, we don't need to register anything in the local symbol table\n                // The symbols will be resolved from the source module during extract_exports\n                // However, we should validate that the source module exists\n                if let Some(source_path) = source {\n                    if let (Some(resolver), Some(current_id)) =\n                        (\u0026self.module_resolver, \u0026self.current_module_id)\n                    {\n                        if let Err(e) = resolver.resolve(source_path, current_id.path()) {\n                            return Err(TypeCheckError::new(\n                                format!(\"Cannot resolve module '{}': {}\", source_path, e),\n                                export.span,\n                            ));\n                        }\n                    }\n                }\n                Ok(())\n            }\n            ExportKind::Default(expr) =\u003e {\n                // Type check the default export expression\n                let mut expr_clone = expr.clone();\n                self.infer_expression_type(\u0026mut expr_clone)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Check enum declaration\n    fn check_enum_declaration(\n        \u0026mut self,\n        enum_decl: \u0026mut EnumDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to declaration_checking_phase for simple enums\n        let is_rich_enum = phases::declaration_checking_phase::check_enum_declaration(\n            enum_decl,\n            \u0026mut self.type_env,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )?;\n\n        // If it's a rich enum, handle it here\n        if is_rich_enum {\n            self.check_rich_enum_declaration(enum_decl)?;\n        }\n\n        Ok(())\n    }\n\n    /// Check rich enum declaration with fields, constructor, and methods\n    fn check_rich_enum_declaration(\n        \u0026mut self,\n        enum_decl: \u0026mut EnumDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Register enum types and members with phase function\n        let enum_self_type = phases::declaration_checking_phase::check_rich_enum_declaration(\n            enum_decl,\n            \u0026mut self.type_env,\n            \u0026mut self.access_control,\n            self.interner,\n        )?;\n\n        // Check constructor body if present\n        if let Some(ref mut constructor) = enum_decl.constructor {\n            self.symbol_table.enter_scope();\n            let self_symbol = Symbol::new(\n                \"self\".to_string(),\n                SymbolKind::Parameter,\n                enum_self_type.clone(),\n                constructor.span,\n            );\n            let _ = self.symbol_table.declare(self_symbol);\n            let _ = self.check_block(\u0026mut constructor.body);\n            self.symbol_table.exit_scope();\n        }\n\n        // Check method bodies\n        for method in enum_decl.methods.iter_mut() {\n            self.symbol_table.enter_scope();\n            let self_symbol = Symbol::new(\n                \"self\".to_string(),\n                SymbolKind::Parameter,\n                enum_self_type.clone(),\n                method.span,\n            );\n            let _ = self.symbol_table.declare(self_symbol);\n            let _ = self.check_block(\u0026mut method.body);\n            self.symbol_table.exit_scope();\n        }\n\n        Ok(())\n    }\n\n    /// Resolve a type reference, handling utility types and generic type application\n    #[instrument(skip(self, type_ref), fields(type_name))]\n    fn resolve_type_reference(\u0026self, type_ref: \u0026TypeReference) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let name = self.interner.resolve(type_ref.name.node);\n        span!(Level::DEBUG, \"resolve_type_reference\", type_name = %name);\n\n        let span = type_ref.span;\n\n        // Check if it's a utility type\n        if let Some(type_args) = \u0026type_ref.type_arguments {\n            if TypeEnvironment::is_utility_type(\u0026name) {\n                // Resolve type arguments first (they might be type references)\n                let resolved_args: Result\u003cVec\u003cType\u003e, TypeCheckError\u003e = type_args\n                    .iter()\n                    .map(|arg| {\n                        self.evaluate_type(arg)\n                            .map_err(|e| TypeCheckError::new(e, arg.span))\n                    })\n                    .collect();\n                let resolved_args = resolved_args?;\n\n                return self\n                    .type_env\n                    .resolve_utility_type(\u0026name, \u0026resolved_args, span, self.interner, self.common)\n                    .map_err(|e| TypeCheckError::new(e, span));\n            }\n\n            // Check for generic type alias\n            if let Some(generic_alias) = self.type_env.get_generic_type_alias(\u0026name) {\n                use crate::types::generics::instantiate_type;\n                return instantiate_type(\n                    \u0026generic_alias.typ,\n                    \u0026generic_alias.type_parameters,\n                    type_args,\n                )\n                .map_err(|e| TypeCheckError::new(e, span));\n            }\n        }\n\n        // Regular type lookup\n        match self.type_env.lookup_type(\u0026name) {\n            Some(typ) =\u003e Ok(typ.clone()),\n            None =\u003e Err(TypeCheckError::new(\n                format!(\"Type '{}' not found\", name),\n                span,\n            )),\n        }\n    }\n\n    /// Check class declaration\n    #[instrument(skip(self, class_decl), fields(class_name))]\n    fn check_class_declaration(\n        \u0026mut self,\n        class_decl: \u0026mut ClassDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let class_name = self.interner.resolve(class_decl.name.node).to_string();\n        span!(Level::INFO, \"check_class_declaration\", class_name);\n\n        debug!(\n            members = class_decl.members.len(),\n            \"Checking class declaration\"\n        );\n\n        // Check decorators\n        self.check_decorators(\u0026mut class_decl.decorators)?;\n\n        debug!(\"Checking class {}\", class_name);\n\n        // Register class symbol (focused function - ~15 lines saved)\n        let _class_type = phases::declaration_checking_phase::register_class_symbol(\n            class_decl,\n            \u0026mut self.symbol_table,\n            \u0026mut self.type_env,\n            \u0026mut self.class_type_params,\n            self.interner,\n        )?;\n\n        // Enter a new scope for the class\n        self.symbol_table.enter_scope();\n\n        // Register type parameters if this is a generic class\n        // Register class type parameters in the type environment\n        phases::declaration_checking_phase::register_class_type_parameters(\n            class_decl.type_parameters.as_deref(),\n            \u0026mut self.type_env,\n            self.interner,\n        )?;\n\n        // Validate class inheritance (focused function - ~20 lines saved)\n        if let Some(extends_type) = \u0026class_decl.extends {\n            phases::validation_phase::validate_class_inheritance(\n                \u0026class_name,\n                extends_type,\n                \u0026self.access_control,\n                \u0026mut self.class_parents,\n                self.interner,\n                class_decl.span,\n            )?;\n        }\n\n        // Register class implements relationships before compliance checking,\n        // so covariant return type checks can look up the class hierarchy\n        phases::declaration_checking_phase::register_class_implements(\n            class_name.clone(),\n            class_decl.implements.clone(),\n            \u0026mut self.type_env,\n            \u0026mut self.access_control,\n            self.interner,\n        );\n\n        // Check interface implementation\n        for interface_type in \u0026class_decl.implements {\n            if let TypeKind::Reference(type_ref) = \u0026interface_type.kind {\n                let interface_name = self.interner.resolve(type_ref.name.node);\n                if let Some(interface) = self.type_env.get_interface(\u0026interface_name) {\n                    // If the interface has type arguments, instantiate it\n                    let instantiated = if let Some(type_args) = \u0026type_ref.type_arguments {\n                        declaration_checking_phase::instantiate_generic_interface(\n                            interface.clone(),\n                            type_args,\n                            \u0026interface_name,\n                            |typ, args, iface_name| {\n                                self.substitute_type_args_in_type(typ, args, iface_name)\n                            },\n                        )\n                    } else {\n                        interface.clone()\n                    };\n                    self.check_class_implements_interface(class_decl, \u0026instantiated)?;\n                } else {\n                    return Err(TypeCheckError::new(\n                        format!(\"Interface '{}' not found\", interface_name),\n                        class_decl.span,\n                    ));\n                }\n            } else {\n                return Err(TypeCheckError::new(\n                    \"Class can only implement interfaces (type references)\",\n                    class_decl.span,\n                ));\n            }\n        }\n\n        // Process primary constructor parameters - they become class properties\n        let mut primary_constructor_properties = Vec::new();\n        if let Some(primary_params) = \u0026class_decl.primary_constructor {\n            for param in primary_params {\n                // Validate: ensure no member with same name exists\n                let param_name = \u0026param.name.node;\n                if class_decl.members.iter().any(|m| match m {\n                    ClassMember::Property(p) =\u003e \u0026p.name.node == param_name,\n                    ClassMember::Method(m) =\u003e \u0026m.name.node == param_name,\n                    ClassMember::Getter(g) =\u003e \u0026g.name.node == param_name,\n                    ClassMember::Setter(s) =\u003e \u0026s.name.node == param_name,\n                    ClassMember::Constructor(_) =\u003e false,\n                    ClassMember::Operator(_) =\u003e false,\n                }) {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Primary constructor parameter '{}' conflicts with existing class member\",\n                            param_name\n                        ),\n                        param.span,\n                    ));\n                }\n\n                primary_constructor_properties.push(param);\n            }\n\n            // Register the class constructor for parent argument validation\n            self.type_env.register_class_constructor(\n                class_name.clone(),\n                class_decl.primary_constructor.clone().unwrap(),\n            );\n        }\n\n        // Validate parent constructor arguments if present\n        if let Some(parent_args) = \u0026mut class_decl.parent_constructor_args {\n            // Type check each parent constructor argument\n            for arg in parent_args.iter_mut() {\n                self.infer_expression_type(arg)?;\n            }\n\n            // Validate argument count and types match parent constructor\n            if let Some(extends_type) = \u0026class_decl.extends {\n                if let TypeKind::Reference(type_ref) = \u0026extends_type.kind {\n                    let parent_name = self.interner.resolve(type_ref.name.node);\n                    // Clone the constructor parameters to avoid borrow issues\n                    let parent_constructor =\n                        self.type_env.get_class_constructor(\u0026parent_name).cloned();\n\n                    if let Some(parent_constructor) = parent_constructor {\n                        // Check argument count\n                        if parent_args.len() != parent_constructor.len() {\n                            return Err(TypeCheckError::new(\n                                format!(\n                                    \"Parent constructor argument count mismatch: expected {}, found {}\",\n                                    parent_constructor.len(),\n                                    parent_args.len()\n                                ),\n                                class_decl.span,\n                            ));\n                        }\n\n                        // Check argument types\n                        for (i, (arg, param)) in parent_args\n                            .iter_mut()\n                            .zip(parent_constructor.iter())\n                            .enumerate()\n                        {\n                            let arg_type = self.infer_expression_type(arg)?;\n                            let param_type = \u0026param.type_annotation;\n                            if !TypeCompatibility::is_assignable(\u0026arg_type, param_type) {\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Parent constructor argument {} type mismatch: expected '{:?}', found '{:?}'\",\n                                        i + 1,\n                                        param_type.kind,\n                                        arg_type.kind\n                                    ),\n                                    arg.span,\n                                ));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Collect class members for access checking\n        let mut member_infos = Vec::new();\n\n        // Add primary constructor parameters as properties\n        for param in \u0026primary_constructor_properties {\n            member_infos.push(ClassMemberInfo {\n                name: self.interner.resolve(param.name.node).to_string(),\n                access: param.access.unwrap_or(AccessModifier::Public),\n                _is_static: false,\n                kind: ClassMemberKind::Property {\n                    type_annotation: param.type_annotation.clone(),\n                },\n                is_final: param.is_readonly, // readonly maps to final for properties\n            });\n        }\n\n        // Extract regular class member information\n        let mut class_member_infos = phases::declaration_checking_phase::extract_class_member_infos(\n            class_decl,\n            self.interner,\n        );\n        member_infos.append(\u0026mut class_member_infos);\n\n        // Extract parent class name first\n        let parent = class_decl.extends.as_ref().and_then(|ext| {\n            if let TypeKind::Reference(type_ref) = \u0026ext.kind {\n                Some(self.interner.resolve(type_ref.name.node).to_string())\n            } else {\n                None\n            }\n        });\n\n        // Register class and all its members with access control visitor\n        self.access_control\n            .register_class(\u0026class_name, parent.clone());\n        for member_info in member_infos {\n            self.access_control\n                .register_member(\u0026class_name, member_info);\n        }\n\n        // Mark class as final if needed\n        self.access_control\n            .mark_class_final(\u0026class_name, class_decl.is_final);\n\n        // Set current class context\n        let old_class = self.access_control.get_current_class().clone();\n        self.access_control.set_current_class(Some(ClassContext {\n            name: self.interner.resolve(class_decl.name.node).to_string(),\n            parent,\n            extends_type: class_decl.extends.clone(),\n        }));\n\n        // Check all class members\n        // Use soft error handling for member bodies so the class is still\n        // registered even if individual members have type errors. This prevents\n        // cascading \"undefined variable\" errors for code that uses the class.\n        let mut has_constructor = false;\n        let mut abstract_methods = Vec::new();\n        let mut first_member_error: Option\u003cTypeCheckError\u003e = None;\n\n        for member in class_decl.members.iter_mut() {\n            let result = match member {\n                ClassMember::Property(prop) =\u003e self.check_class_property(prop),\n                ClassMember::Constructor(ctor) =\u003e {\n                    if has_constructor {\n                        Err(TypeCheckError::new(\n                            \"Class can only have one constructor\",\n                            ctor.span,\n                        ))\n                    } else {\n                        has_constructor = true;\n                        self.check_constructor(ctor)\n                    }\n                }\n                ClassMember::Method(method) =\u003e {\n                    if method.is_abstract {\n                        if !class_decl.is_abstract {\n                            Err(TypeCheckError::new(\n                                format!(\n                                    \"Abstract method '{}' can only be in abstract class\",\n                                    method.name.node\n                                ),\n                                method.span,\n                            ))\n                        } else {\n                            abstract_methods\n                                .push(self.interner.resolve(method.name.node).to_string());\n                            self.check_class_method(method)\n                        }\n                    } else {\n                        self.check_class_method(method)\n                    }\n                }\n                ClassMember::Getter(getter) =\u003e self.check_class_getter(getter),\n                ClassMember::Setter(setter) =\u003e self.check_class_setter(setter),\n                ClassMember::Operator(op) =\u003e self.check_operator_declaration(op),\n            };\n\n            if let Err(e) = result {\n                if first_member_error.is_none() {\n                    first_member_error = Some(e);\n                }\n            }\n        }\n\n        // Restore previous class context\n        self.access_control.set_current_class(old_class);\n\n        // Exit class scope\n        self.symbol_table.exit_scope();\n\n        // Clean up type parameters from type environment after class scope\n        if let Some(type_params) = \u0026class_decl.type_parameters {\n            for type_param in type_params {\n                let param_name = self.interner.resolve(type_param.name.node).to_string();\n                self.type_env.remove_type_alias(\u0026param_name);\n            }\n        }\n\n        // Check that concrete classes implement all inherited abstract methods\n        if !class_decl.is_abstract {\n            if let Some(extends_type) = \u0026class_decl.extends {\n                if let TypeKind::Reference(type_ref) = \u0026extends_type.kind {\n                    let parent_name = self.interner.resolve(type_ref.name.node);\n                    // Check for abstract methods in parent class\n                    self.check_abstract_methods_implemented(\n                        \u0026class_name,\n                        \u0026parent_name,\n                        \u0026class_decl.members,\n                    )?;\n                }\n            }\n        }\n\n        // Handle member errors based on severity.\n        // Critical errors (abstract methods in non-abstract class, multiple constructors)\n        // should fail hard. Other errors become warnings to prevent cascading failures.\n        if let Some(err) = first_member_error {\n            if phases::declaration_checking_phase::is_critical_member_error(\u0026err.message) {\n                return Err(err);\n            } else {\n                // Non-critical errors become warnings\n                self.diagnostic_handler.warning(\n                    class_decl.span,\n                    \u0026format!(\"Error in class '{}' member: {}\", class_name, err.message),\n                );\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check that a class properly implements an interface\n    fn check_class_implements_interface(\n        \u0026self,\n        class_decl: \u0026ClassDeclaration,\n        interface: \u0026Type,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::check_class_implements_interface(\n            class_decl,\n            interface,\n            \u0026self.type_env,\n            self.interner,\n        )\n    }\n\n    /// Validate that all class properties are compatible with interface index signature\n    #[allow(dead_code)]\n    fn validate_index_signature(\n        \u0026self,\n        class_decl: \u0026ClassDeclaration,\n        index_sig: \u0026IndexSignature,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::validate_index_signature(class_decl, index_sig, self.interner)\n    }\n\n    /// Check that a class implements all abstract methods from its parent class\n    fn check_abstract_methods_implemented(\n        \u0026self,\n        class_name: \u0026str,\n        parent_name: \u0026str,\n        class_members: \u0026[ClassMember],\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::validation_phase::check_abstract_methods_implemented(\n            class_name,\n            parent_name,\n            class_members,\n            \u0026self.access_control,\n            self.interner,\n        )\n    }\n\n    /// Check decorators\n    fn check_decorators(\n        \u0026mut self,\n        decorators: \u0026mut [typedlua_parser::ast::statement::Decorator],\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check if decorators are enabled\n        if !decorators.is_empty() \u0026\u0026 !self.options.enable_decorators {\n            return Err(TypeCheckError::new(\n                \"Decorators require decorator features to be enabled. Enable 'enableDecorators' in your configuration.\".to_string(),\n                decorators[0].span,\n            ));\n        }\n\n        // Check for duplicate decorators\n        let mut seen_decorators = std::collections::HashSet::new();\n        for decorator in decorators.iter() {\n            // Get decorator name for comparison\n            let decorator_name = match \u0026decorator.expression {\n                typedlua_parser::ast::statement::DecoratorExpression::Identifier(name) =\u003e {\n                    self.interner.resolve(name.node).to_string()\n                }\n                typedlua_parser::ast::statement::DecoratorExpression::Call { callee, .. } =\u003e {\n                    // For calls, use the callee name\n                    if let typedlua_parser::ast::statement::DecoratorExpression::Identifier(name) =\n                        \u0026**callee\n                    {\n                        self.interner.resolve(name.node).to_string()\n                    } else {\n                        continue; // Skip complex expressions\n                    }\n                }\n                typedlua_parser::ast::statement::DecoratorExpression::Member { .. } =\u003e {\n                    continue; // Skip member expressions for duplicate checking\n                }\n            };\n\n            if !seen_decorators.insert(decorator_name.clone()) {\n                self.diagnostic_handler.warning(\n                    decorator.span,\n                    \u0026format!(\"Duplicate decorator '@{}'\", decorator_name),\n                );\n            }\n        }\n\n        // For now, we just validate that decorator expressions are valid\n        // Full decorator type checking would require:\n        // 1. Checking that decorator functions exist\n        // 2. Validating decorator function signatures match target type\n        // 3. Checking decorator arguments are type-compatible\n        // This is simplified for now - decorators are allowed but not deeply validated\n\n        for decorator in decorators.iter_mut() {\n            self.check_decorator_expression(\u0026mut decorator.expression)?;\n        }\n\n        Ok(())\n    }\n\n    /// Check a decorator expression\n    fn check_decorator_expression(\n        \u0026mut self,\n        expr: \u0026mut typedlua_parser::ast::statement::DecoratorExpression,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        use typedlua_parser::ast::statement::DecoratorExpression;\n\n        match expr {\n            DecoratorExpression::Identifier(name) =\u003e {\n                // Verify the decorator identifier exists (could be a function or imported decorator)\n                // For now, we allow any identifier - full validation would check it's a valid decorator function\n                let name_str = self.interner.resolve(name.node);\n                if self.symbol_table.lookup(\u0026name_str).is_none() {\n                    // It's okay if it doesn't exist - it might be a built-in decorator like @readonly, @sealed\n                    // We'll allow it through for now\n                }\n                Ok(())\n            }\n            DecoratorExpression::Call {\n                callee, arguments, ..\n            } =\u003e {\n                // Check the callee\n                self.check_decorator_expression(callee)?;\n\n                // Type check all arguments\n                for arg in arguments.iter_mut() {\n                    self.infer_expression_type(arg)?;\n                }\n\n                Ok(())\n            }\n            DecoratorExpression::Member { object, .. } =\u003e {\n                // Check the object part\n                self.check_decorator_expression(object)?;\n                Ok(())\n            }\n        }\n    }\n\n    /// Check class property\n    fn check_class_property(\n        \u0026mut self,\n        prop: \u0026mut PropertyDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut prop.decorators)?;\n\n        // Check initializer if present\n        if let Some(initializer) = \u0026mut prop.initializer {\n            let init_type = self.infer_expression_type(initializer)?;\n\n            // Verify initializer type is assignable to declared type\n            if !TypeCompatibility::is_assignable(\u0026init_type, \u0026prop.type_annotation) {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Property '{}' initializer type does not match declared type\",\n                        prop.name.node\n                    ),\n                    prop.span,\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check constructor\n    fn check_constructor(\n        \u0026mut self,\n        ctor: \u0026mut ConstructorDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Enter constructor scope\n        self.symbol_table.enter_scope();\n\n        // Inner function to do the actual checking, so we can ensure scope cleanup\n        let result = (|| -\u003e Result\u003c(), TypeCheckError\u003e {\n            // Declare 'self' parameter (implicit in constructors)\n            if let Some(class_ctx) = self.access_control.get_current_class() {\n                let self_type = Type::new(\n                    TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                        name: typedlua_parser::ast::Spanned::new(\n                            self.interner.intern(\u0026class_ctx.name),\n                            ctor.span,\n                        ),\n                        type_arguments: None,\n                        span: ctor.span,\n                    }),\n                    ctor.span,\n                );\n                let symbol = crate::utils::symbol_table::Symbol::new(\n                    \"self\".to_string(),\n                    crate::utils::symbol_table::SymbolKind::Parameter,\n                    self_type,\n                    ctor.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, ctor.span))?;\n            }\n\n            // Declare parameters\n            for param in \u0026ctor.parameters {\n                let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                    // Evaluate the type annotation to resolve any type references\n                    let evaluated = self\n                        .evaluate_type(type_ann)\n                        .map_err(|e| TypeCheckError::new(e, param.span))\n                        .unwrap_or_else(|_| type_ann.clone()); // Fall back to unevaluated if evaluation fails\n\n                    // Deep resolve to handle nested types in function types, arrays, etc.\n                    self.deep_resolve_type(\u0026evaluated)\n                } else {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                };\n\n                self.declare_pattern(\n                    \u0026param.pattern,\n                    param_type,\n                    SymbolKind::Parameter,\n                    param.span,\n                )?;\n            }\n\n            // Check constructor body\n            self.check_block(\u0026mut ctor.body)?;\n\n            Ok(())\n        })();\n\n        // Always exit scope, even on error\n        self.symbol_table.exit_scope();\n\n        result\n    }\n\n    /// Check class method\n    fn check_class_method(\u0026mut self, method: \u0026mut MethodDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut method.decorators)?;\n\n        // Check override keyword if present\n        if method.is_override {\n            self.check_method_override(method)?;\n        } else if let Some(class_context) = self.access_control.get_current_class() {\n            // Check if method shadows a parent method without override keyword\n            if let Some(parent_name) = \u0026class_context.parent {\n                if let Some(parent_members) = self.access_control.get_class_members(parent_name) {\n                    let method_name = self.interner.resolve(method.name.node);\n                    if parent_members.iter().any(|m| m.name == method_name) {\n                        self.diagnostic_handler.warning(\n                            method.span,\n                            \u0026format!(\n                                \"Method '{}' overrides a method from parent class '{}' but is missing the 'override' keyword\",\n                                method_name,\n                                parent_name\n                            ),\n                        );\n                    }\n                }\n            }\n        }\n\n        // Abstract methods don't have a body to check\n        if method.is_abstract {\n            if method.body.is_some() {\n                return Err(TypeCheckError::new(\n                    format!(\"Abstract method '{}' cannot have a body\", method.name.node),\n                    method.span,\n                ));\n            }\n            return Ok(());\n        }\n\n        // Non-abstract methods must have a body\n        if method.body.is_none() {\n            return Err(TypeCheckError::new(\n                format!(\n                    \"Non-abstract method '{}' must have a body\",\n                    method.name.node\n                ),\n                method.span,\n            ));\n        }\n\n        // Enter method scope\n        self.symbol_table.enter_scope();\n\n        // Do all method body work in a closure to ensure scope cleanup on error\n        let old_return_type = self.current_function_return_type.clone();\n        let result = (|| -\u003e Result\u003c(), TypeCheckError\u003e {\n            // Declare 'self' parameter for non-static methods\n            if !method.is_static {\n                if let Some(class_ctx) = self.access_control.get_current_class() {\n                    let self_type = Type::new(\n                        TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                            name: typedlua_parser::ast::Spanned::new(\n                                self.interner.intern(\u0026class_ctx.name),\n                                method.span,\n                            ),\n                            type_arguments: None,\n                            span: method.span,\n                        }),\n                        method.span,\n                    );\n                    let symbol = crate::utils::symbol_table::Symbol::new(\n                        \"self\".to_string(),\n                        crate::utils::symbol_table::SymbolKind::Parameter,\n                        self_type,\n                        method.span,\n                    );\n                    self.symbol_table\n                        .declare(symbol)\n                        .map_err(|e| TypeCheckError::new(e, method.span))?;\n                }\n            }\n\n            // Register type parameters if generic (with duplicate checking and constraint support)\n            phases::declaration_checking_phase::register_function_type_parameters(\n                method.type_parameters.as_deref(),\n                \u0026mut self.type_env,\n                self.interner,\n            )?;\n\n            // Declare parameters\n            for param in \u0026method.parameters {\n                let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                    // Evaluate the type annotation to resolve any type references (e.g., T, U in generic methods)\n                    let evaluated = self\n                        .evaluate_type(type_ann)\n                        .map_err(|e| TypeCheckError::new(e, param.span))\n                        .unwrap_or_else(|_| type_ann.clone()); // Fall back to unevaluated if evaluation fails\n\n                    // Deep resolve to handle nested types in function types, arrays, etc.\n                    self.deep_resolve_type(\u0026evaluated)\n                } else {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                };\n\n                self.declare_pattern(\n                    \u0026param.pattern,\n                    param_type,\n                    SymbolKind::Parameter,\n                    param.span,\n                )?;\n            }\n\n            // Set current function return type for return statement checking\n            self.current_function_return_type = method.return_type.clone();\n\n            // Check method body\n            if let Some(body) = \u0026mut method.body {\n                self.check_block(body)?;\n            }\n\n            Ok(())\n        })();\n\n        // Always restore return type and exit scope, even on error\n        self.current_function_return_type = old_return_type;\n        self.symbol_table.exit_scope();\n\n        // Clean up method type parameters from type environment\n        if let Some(type_params) = \u0026method.type_parameters {\n            for type_param in type_params {\n                let param_name = self.interner.resolve(type_param.name.node).to_string();\n                self.type_env.remove_type_alias(\u0026param_name);\n            }\n        }\n\n        result\n    }\n\n    /// Check class getter\n    fn check_class_getter(\u0026mut self, getter: \u0026mut GetterDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut getter.decorators)?;\n\n        // Enter getter scope\n        self.symbol_table.enter_scope();\n\n        // Declare 'self' parameter for non-static getters\n        if !getter.is_static {\n            if let Some(class_ctx) = self.access_control.get_current_class() {\n                let self_type = Type::new(\n                    TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                        name: typedlua_parser::ast::Spanned::new(\n                            self.interner.intern(\u0026class_ctx.name),\n                            getter.span,\n                        ),\n                        type_arguments: None,\n                        span: getter.span,\n                    }),\n                    getter.span,\n                );\n                let symbol = crate::utils::symbol_table::Symbol::new(\n                    \"self\".to_string(),\n                    crate::utils::symbol_table::SymbolKind::Parameter,\n                    self_type,\n                    getter.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, getter.span))?;\n            }\n        }\n\n        // Set current function return type\n        let old_return_type = self.current_function_return_type.clone();\n        self.current_function_return_type = Some(getter.return_type.clone());\n\n        // Check getter body\n        self.check_block(\u0026mut getter.body)?;\n\n        // Restore previous return type\n        self.current_function_return_type = old_return_type;\n\n        // Exit getter scope\n        self.symbol_table.exit_scope();\n\n        Ok(())\n    }\n\n    /// Check class setter\n    fn check_class_setter(\u0026mut self, setter: \u0026mut SetterDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Check decorators\n        self.check_decorators(\u0026mut setter.decorators)?;\n\n        // Enter setter scope\n        self.symbol_table.enter_scope();\n\n        // Declare 'self' parameter for non-static setters\n        if !setter.is_static {\n            if let Some(class_ctx) = self.access_control.get_current_class() {\n                let self_type = Type::new(\n                    TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                        name: typedlua_parser::ast::Spanned::new(\n                            self.interner.intern(\u0026class_ctx.name),\n                            setter.span,\n                        ),\n                        type_arguments: None,\n                        span: setter.span,\n                    }),\n                    setter.span,\n                );\n                let symbol = crate::utils::symbol_table::Symbol::new(\n                    \"self\".to_string(),\n                    crate::utils::symbol_table::SymbolKind::Parameter,\n                    self_type,\n                    setter.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, setter.span))?;\n            }\n        }\n\n        // Declare the parameter\n        let param_type = if let Some(type_ann) = \u0026setter.parameter.type_annotation {\n            // Evaluate to resolve type references\n            let evaluated = self\n                .evaluate_type(type_ann)\n                .map_err(|e| TypeCheckError::new(e, setter.parameter.span))\n                .unwrap_or_else(|_| type_ann.clone());\n            // Deep resolve to handle nested types\n            self.deep_resolve_type(\u0026evaluated)\n        } else {\n            Type::new(\n                TypeKind::Primitive(PrimitiveType::Unknown),\n                setter.parameter.span,\n            )\n        };\n\n        self.declare_pattern(\n            \u0026setter.parameter.pattern,\n            param_type,\n            SymbolKind::Parameter,\n            setter.parameter.span,\n        )?;\n\n        // Check setter body\n        self.check_block(\u0026mut setter.body)?;\n\n        // Exit setter scope\n        self.symbol_table.exit_scope();\n\n        Ok(())\n    }\n\n    /// Check operator declaration\n    fn check_operator_declaration(\n        \u0026mut self,\n        op: \u0026mut OperatorDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        if op.operator == OperatorKind::NewIndex {\n            if op.parameters.len() != 2 {\n                return Err(TypeCheckError::new(\n                    \"operator []= must have exactly 2 parameters\",\n                    op.span,\n                ));\n            }\n        } else if op.parameters.is_empty() {\n            if !matches!(op.operator, OperatorKind::UnaryMinus | OperatorKind::Length) {\n                return Err(TypeCheckError::new(\n                    \"Only unary minus (-) and length (#) operators can have 0 parameters\",\n                    op.span,\n                ));\n            }\n        } else if op.parameters.len() == 1 {\n            if matches!(op.operator, OperatorKind::UnaryMinus | OperatorKind::Length) {\n                return Err(TypeCheckError::new(\n                    \"Binary operator must have exactly 1 parameter\",\n                    op.span,\n                ));\n            }\n        } else {\n            return Err(TypeCheckError::new(\n                \"Operator must have 0, 1, or 2 parameters\",\n                op.span,\n            ));\n        }\n\n        match op.operator {\n            OperatorKind::Equal | OperatorKind::NotEqual =\u003e {\n                if let Some(ref ret_type) = op.return_type {\n                    if !self.is_boolean_type(ret_type) {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Operator '{}' must return 'boolean'\",\n                                self.operator_kind_name(\u0026op.operator)\n                            ),\n                            ret_type.span,\n                        ));\n                    }\n                }\n            }\n            OperatorKind::LessThan\n            | OperatorKind::LessThanOrEqual\n            | OperatorKind::GreaterThan\n            | OperatorKind::GreaterThanOrEqual =\u003e {\n                if let Some(ref ret_type) = op.return_type {\n                    if !self.is_boolean_type(ret_type) {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Operator '{}' must return 'boolean'\",\n                                self.operator_kind_name(\u0026op.operator)\n                            ),\n                            ret_type.span,\n                        ));\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n\n        self.symbol_table.enter_scope();\n\n        if let Some(class_ctx) = self.access_control.get_current_class() {\n            let self_type = Type::new(\n                TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                    name: typedlua_parser::ast::Spanned::new(\n                        self.interner.intern(\u0026class_ctx.name),\n                        op.span,\n                    ),\n                    type_arguments: None,\n                    span: op.span,\n                }),\n                op.span,\n            );\n            let symbol = crate::utils::symbol_table::Symbol::new(\n                \"self\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Parameter,\n                self_type,\n                op.span,\n            );\n            self.symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, op.span))?;\n        }\n\n        for param in \u0026op.parameters {\n            let param_type = param.type_annotation.clone().unwrap_or_else(|| {\n                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n            });\n\n            self.declare_pattern(\n                \u0026param.pattern,\n                param_type,\n                SymbolKind::Parameter,\n                param.span,\n            )?;\n        }\n\n        let old_return_type = self.current_function_return_type.clone();\n        self.current_function_return_type = op.return_type.clone();\n\n        self.check_block(\u0026mut op.body)?;\n\n        self.current_function_return_type = old_return_type;\n\n        self.symbol_table.exit_scope();\n\n        Ok(())\n    }\n\n    fn is_boolean_type(\u0026self, typ: \u0026Type) -\u003e bool {\n        type_utilities::is_boolean_type(typ)\n    }\n\n    fn operator_kind_name(\u0026self, op: \u0026OperatorKind) -\u003e String {\n        type_utilities::operator_kind_name(op)\n    }\n\n    /// Check that an override method properly overrides a parent method\n    fn check_method_override(\u0026self, method: \u0026MethodDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Get current class context\n        let class_ctx = self\n            .access_control\n            .get_current_class()\n            .as_ref()\n            .ok_or_else(|| {\n                TypeCheckError::new(\n                    \"Override keyword used outside of class context\",\n                    method.span,\n                )\n            })?;\n\n        // Get extends clause type arguments for generic parent instantiation\n        let extends_type_args = class_ctx.extends_type.as_ref().and_then(|ext| {\n            if let TypeKind::Reference(type_ref) = \u0026ext.kind {\n                type_ref.type_arguments.as_ref()\n            } else {\n                None\n            }\n        });\n\n        // Get parent class type parameters (if the parent is generic)\n        let parent_type_params = class_ctx\n            .parent\n            .as_ref()\n            .and_then(|p| self.class_type_params.get(p));\n\n        phases::validation_phase::check_method_override(\n            method,\n            \u0026class_ctx.name,\n            class_ctx.parent.as_ref(),\n            parent_type_params,\n            extends_type_args,\n            \u0026self.access_control,\n            self.interner,\n            |typ| self.deep_resolve_type(typ),\n        )\n    }\n\n    /// Convert type to string for error messages\n    fn type_to_string(\u0026self, typ: \u0026Type) -\u003e String {\n        match \u0026typ.kind {\n            TypeKind::Primitive(prim) =\u003e format!(\"{:?}\", prim).to_lowercase(),\n            TypeKind::Reference(type_ref) =\u003e self.interner.resolve(type_ref.name.node).to_string(),\n            TypeKind::Array(elem) =\u003e format!(\"{}[]\", self.type_to_string(elem)),\n            TypeKind::Union(types) =\u003e {\n                let type_strings: Vec\u003cString\u003e =\n                    types.iter().map(|t| self.type_to_string(t)).collect();\n                type_strings.join(\" | \")\n            }\n            TypeKind::Function(_) =\u003e \"function\".to_string(),\n            TypeKind::Object(_) =\u003e \"object\".to_string(),\n            _ =\u003e format!(\"{:?}\", typ.kind),\n        }\n    }\n\n    /// Infer the type of an expression\n    /// Delegates to TypeInferrer visitor\n    fn infer_expression_type(\u0026mut self, expr: \u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let mut inferrer = TypeInferrer::new(\n            \u0026mut self.symbol_table,\n            \u0026mut self.type_env,\n            self.narrowing.get_context_mut(),\n            \u0026self.access_control,\n            self.interner,\n            \u0026self.diagnostic_handler,\n        );\n        inferrer.infer_expression(expr)\n    }\n\n    /// Evaluate special type constructs (keyof, mapped types, conditional types, etc.)\n    fn evaluate_type(\u0026self, typ: \u0026Type) -\u003e Result\u003cType, String\u003e {\n        match \u0026typ.kind {\n            TypeKind::KeyOf(operand) =\u003e {\n                // First evaluate the operand recursively\n                let evaluated_operand = self.evaluate_type(operand)?;\n                use crate::types::utility_types::evaluate_keyof;\n                evaluate_keyof(\u0026evaluated_operand, \u0026self.type_env, self.interner)\n            }\n            TypeKind::Mapped(mapped) =\u003e {\n                use crate::types::utility_types::evaluate_mapped_type;\n                evaluate_mapped_type(mapped, \u0026self.type_env, self.interner)\n            }\n            TypeKind::Conditional(conditional) =\u003e {\n                use crate::types::utility_types::evaluate_conditional_type;\n                evaluate_conditional_type(conditional, \u0026self.type_env)\n            }\n            TypeKind::TemplateLiteral(template) =\u003e {\n                use crate::types::utility_types::evaluate_template_literal_type;\n                evaluate_template_literal_type(template, \u0026self.type_env, self.interner)\n            }\n            TypeKind::TypeQuery(expr) =\u003e {\n                // typeof(expression) - Look up the type of the expression\n                // For identifiers, we can look them up directly in the type environment\n                use typedlua_parser::ast::expression::ExpressionKind;\n                match \u0026expr.kind {\n                    ExpressionKind::Identifier(name_id) =\u003e {\n                        let name = self.interner.resolve(*name_id);\n                        match self.type_env.lookup_type(\u0026name) {\n                            Some(t) =\u003e Ok(t.clone()),\n                            None =\u003e match self.symbol_table.lookup(\u0026name) {\n                                Some(symbol) =\u003e Ok(symbol.typ.clone()),\n                                None =\u003e {\n                                    Err(format!(\"Cannot resolve typeof for identifier '{}'\", name))\n                                }\n                            },\n                        }\n                    }\n                    ExpressionKind::Call(callee, _args, _type_args) =\u003e {\n                        // For function calls like typeof(getNumber()),\n                        // look up the return type of the function\n                        if let ExpressionKind::Identifier(name_id) = \u0026callee.kind {\n                            let name = self.interner.resolve(*name_id);\n                            match self.symbol_table.lookup(\u0026name) {\n                                Some(symbol) =\u003e {\n                                    if let TypeKind::Function(func) = \u0026symbol.typ.kind {\n                                        Ok((*func.return_type).clone())\n                                    } else {\n                                        Ok(Type::new(\n                                            TypeKind::Primitive(PrimitiveType::Unknown),\n                                            typ.span,\n                                        ))\n                                    }\n                                }\n                                None =\u003e Err(format!(\"Cannot resolve typeof for call '{}'\", name)),\n                            }\n                        } else {\n                            Ok(Type::new(\n                                TypeKind::Primitive(PrimitiveType::Unknown),\n                                typ.span,\n                            ))\n                        }\n                    }\n                    _ =\u003e Ok(Type::new(\n                        TypeKind::Primitive(PrimitiveType::Unknown),\n                        typ.span,\n                    )),\n                }\n            }\n            TypeKind::Reference(type_ref) =\u003e {\n                // Resolve type reference using the proper resolution logic\n                // This handles utility types, generic types, and regular type aliases\n                // If resolution fails (e.g., type parameter not found), return the reference as-is\n                match self.resolve_type_reference(type_ref) {\n                    Ok(resolved) =\u003e Ok(resolved),\n                    Err(_) =\u003e Ok(typ.clone()), // Return the reference unresolved (might be a type parameter)\n                }\n            }\n            _ =\u003e Ok(typ.clone()),\n        }\n    }\n\n    /// Deeply resolve all type references within a type tree.\n    /// Unlike evaluate_type which only resolves top-level references,\n    /// this recursively walks Object, Union, Nullable, Array, etc.\n    /// and resolves any nested TypeKind::Reference nodes.\n    fn deep_resolve_type(\u0026self, typ: \u0026Type) -\u003e Type {\n        match \u0026typ.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                match self.resolve_type_reference(type_ref) {\n                    Ok(resolved) =\u003e {\n                        // Avoid infinite recursion if resolution returns same reference\n                        if matches!(\u0026resolved.kind, TypeKind::Reference(r) if r.name.node == type_ref.name.node)\n                        {\n                            resolved\n                        } else {\n                            self.deep_resolve_type(\u0026resolved)\n                        }\n                    }\n                    Err(_) =\u003e typ.clone(),\n                }\n            }\n            TypeKind::Object(obj_type) =\u003e {\n                use typedlua_parser::ast::types::ObjectTypeMember;\n                let resolved_members: Vec\u003cObjectTypeMember\u003e = obj_type\n                    .members\n                    .iter()\n                    .map(|member| match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                type_annotation: self.deep_resolve_type(\u0026prop.type_annotation),\n                                ..prop.clone()\n                            })\n                        }\n                        other =\u003e other.clone(),\n                    })\n                    .collect();\n                Type::new(\n                    TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                        members: resolved_members,\n                        span: obj_type.span,\n                    }),\n                    typ.span,\n                )\n            }\n            TypeKind::Union(members) =\u003e {\n                let resolved: Vec\u003cType\u003e =\n                    members.iter().map(|m| self.deep_resolve_type(m)).collect();\n                Type::new(TypeKind::Union(resolved), typ.span)\n            }\n            TypeKind::Nullable(inner) =\u003e {\n                let resolved = self.deep_resolve_type(inner);\n                Type::new(TypeKind::Nullable(Box::new(resolved)), typ.span)\n            }\n            TypeKind::Array(elem) =\u003e {\n                let resolved = self.deep_resolve_type(elem);\n                Type::new(TypeKind::Array(Box::new(resolved)), typ.span)\n            }\n            TypeKind::Tuple(elems) =\u003e {\n                let resolved: Vec\u003cType\u003e = elems.iter().map(|e| self.deep_resolve_type(e)).collect();\n                Type::new(TypeKind::Tuple(resolved), typ.span)\n            }\n            TypeKind::Function(func_type) =\u003e {\n                // Recursively resolve parameter types and return type in function types\n                let resolved_params: Vec\u003ctypedlua_parser::ast::statement::Parameter\u003e = func_type\n                    .parameters\n                    .iter()\n                    .map(|param| typedlua_parser::ast::statement::Parameter {\n                        type_annotation: param\n                            .type_annotation\n                            .as_ref()\n                            .map(|t| self.deep_resolve_type(t)),\n                        ..param.clone()\n                    })\n                    .collect();\n\n                let resolved_return = self.deep_resolve_type(\u0026func_type.return_type);\n\n                Type::new(\n                    TypeKind::Function(typedlua_parser::ast::types::FunctionType {\n                        parameters: resolved_params,\n                        return_type: Box::new(resolved_return),\n                        ..func_type.clone()\n                    }),\n                    typ.span,\n                )\n            }\n            _ =\u003e typ.clone(),\n        }\n    }\n\n    /// Check if source type is assignable to target type via implements relationship.\n    /// For example, Box\u003cnumber\u003e is assignable to Storable\u003cnumber\u003e if Box implements Storable\u003cT\u003e.\n    fn check_implements_assignable(\u0026self, source: \u0026Type, target: \u0026Type) -\u003e bool {\n        phases::validation_phase::check_implements_assignable(\n            source,\n            target,\n            \u0026self.type_env,\n            self.interner,\n        )\n    }\n\n    /// Substitute type parameter references in a type with actual type arguments.\n    /// For a generic interface like Container\u003cT\u003e, given type_args [number],\n    /// replaces references to T with number.\n    fn substitute_type_args_in_type(\n        \u0026self,\n        typ: \u0026Type,\n        type_args: \u0026[Type],\n        interface_name: \u0026str,\n    ) -\u003e Type {\n        match \u0026typ.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                let ref_name = self.interner.resolve(type_ref.name.node).to_string();\n                // Check if this reference matches a type parameter of the interface.\n                // Look up the interface's declared type parameter names and find the\n                // positional index so we substitute with the correct type argument.\n                if let Some(param_names) = self.type_env.get_interface_type_params(interface_name) {\n                    if let Some(pos) = param_names.iter().position(|p| p == \u0026ref_name) {\n                        if pos \u003c type_args.len() {\n                            return type_args[pos].clone();\n                        }\n                    }\n                }\n                // Fallback: if no param names are registered, use heuristic\n                if self.type_env.get_interface(interface_name).is_some()\n                    \u0026\u0026 self.type_env.lookup_type(\u0026ref_name).is_none()\n                    \u0026\u0026 self.type_env.lookup_type_alias(\u0026ref_name).is_none()\n                    \u0026\u0026 !type_args.is_empty()\n                {\n                    return type_args[0].clone();\n                }\n                typ.clone()\n            }\n            TypeKind::Array(elem) =\u003e {\n                let subst = self.substitute_type_args_in_type(elem, type_args, interface_name);\n                Type::new(TypeKind::Array(Box::new(subst)), typ.span)\n            }\n            TypeKind::Nullable(inner) =\u003e {\n                let subst = self.substitute_type_args_in_type(inner, type_args, interface_name);\n                Type::new(TypeKind::Nullable(Box::new(subst)), typ.span)\n            }\n            TypeKind::Union(members) =\u003e {\n                let subst: Vec\u003cType\u003e = members\n                    .iter()\n                    .map(|m| self.substitute_type_args_in_type(m, type_args, interface_name))\n                    .collect();\n                Type::new(TypeKind::Union(subst), typ.span)\n            }\n            _ =\u003e typ.clone(),\n        }\n    }\n\n    /// Widen literal types to their base primitive types\n    fn widen_type(\u0026self, typ: Type) -\u003e Type {\n        type_utilities::widen_type(typ)\n    }\n\n    /// Register a declare function statement in the global scope\n    fn register_declare_function(\n        \u0026mut self,\n        func: \u0026DeclareFunctionStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::declaration_phase::register_declare_function(\n            func,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Register a declare const statement in the global scope\n    fn register_declare_const(\n        \u0026mut self,\n        const_decl: \u0026DeclareConstStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::declaration_phase::register_declare_const(\n            const_decl,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Register a declare namespace statement in the global scope\n    fn register_declare_namespace(\n        \u0026mut self,\n        ns: \u0026DeclareNamespaceStatement,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::declaration_phase::register_declare_namespace(\n            ns,\n            \u0026mut self.symbol_table,\n            self.interner,\n        )\n    }\n\n    /// Register minimal stdlib (fallback when full stdlib fails to parse)\n    pub fn register_minimal_stdlib(\u0026mut self) {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n        use typedlua_parser::ast::types::*;\n        use typedlua_parser::ast::Spanned;\n        use typedlua_parser::span::Span;\n\n        let span = Span::new(0, 0, 0, 0);\n\n        // Register string namespace\n        let string_members = vec![\n            ObjectTypeMember::Method(MethodSignature {\n                name: Spanned::new(self.interner.intern(\"upper\"), span),\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(self.interner.intern(\"s\"), span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Primitive(PrimitiveType::String),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Type::new(TypeKind::Primitive(PrimitiveType::String), span),\n                body: None,\n                span,\n            }),\n            ObjectTypeMember::Method(MethodSignature {\n                name: Spanned::new(self.interner.intern(\"lower\"), span),\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(self.interner.intern(\"s\"), span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Primitive(PrimitiveType::String),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Type::new(TypeKind::Primitive(PrimitiveType::String), span),\n                body: None,\n                span,\n            }),\n        ];\n\n        let string_type = Type::new(\n            TypeKind::Object(ObjectType {\n                members: string_members,\n                span,\n            }),\n            span,\n        );\n\n        let _ = self.symbol_table.declare(Symbol::new(\n            \"string\".to_string(),\n            SymbolKind::Const,\n            string_type,\n            span,\n        ));\n\n        // Register math namespace\n        let math_members = vec![\n            ObjectTypeMember::Property(PropertySignature {\n                is_readonly: true,\n                name: Spanned::new(self.interner.intern(\"pi\"), span),\n                is_optional: false,\n                type_annotation: Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n                span,\n            }),\n            ObjectTypeMember::Method(MethodSignature {\n                name: Spanned::new(self.interner.intern(\"abs\"), span),\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(self.interner.intern(\"x\"), span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n                body: None,\n                span,\n            }),\n        ];\n\n        let math_type = Type::new(\n            TypeKind::Object(ObjectType {\n                members: math_members,\n                span,\n            }),\n            span,\n        );\n\n        let _ = self.symbol_table.declare(Symbol::new(\n            \"math\".to_string(),\n            SymbolKind::Const,\n            math_type,\n            span,\n        ));\n    }\n\n    /// Get a reference to the symbol table for LSP queries\n    pub fn symbol_table(\u0026self) -\u003e \u0026SymbolTable {\n        \u0026self.symbol_table\n    }\n\n    /// Get a reference to the type environment for LSP queries\n    pub fn type_env(\u0026self) -\u003e \u0026TypeEnvironment {\n        \u0026self.type_env\n    }\n\n    /// Lookup a symbol by name in the current scope\n    pub fn lookup_symbol(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbol_table.lookup(name)\n    }\n\n    /// Lookup a type by name\n    pub fn lookup_type(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_env.lookup_type(name)\n    }\n\n    /// Extract exports from a program for module system\n    pub fn extract_exports(\u0026self, program: \u0026Program) -\u003e crate::module_resolver::ModuleExports {\n        // Delegate to module_phase for export extraction\n        phases::module_phase::extract_exports(\n            program,\n            \u0026self.symbol_table,\n            self.interner,\n            self.module_registry.as_ref(),\n            self.module_resolver.as_ref(),\n            self.current_module_id.as_ref(),\n        )\n    }\n\n    fn check_throw_statement(\u0026mut self, stmt: \u0026mut ThrowStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.infer_expression_type(\u0026mut stmt.expression)?;\n        Ok(())\n    }\n\n    fn check_rethrow_statement(\u0026self, span: Span) -\u003e Result\u003c(), TypeCheckError\u003e {\n        phases::inference_phase::check_rethrow_statement(\u0026self.in_catch_block, span)\n    }\n\n    fn check_import_statement(\u0026mut self, import: \u0026ImportDeclaration) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Delegate to module_phase for import processing\n        phases::module_phase::check_import_statement(\n            import,\n            \u0026mut self.symbol_table,\n            \u0026mut self.type_env,\n            \u0026mut self.access_control,\n            self.interner,\n            \u0026mut self.module_dependencies,\n            self.module_registry.as_ref(),\n            self.module_resolver.as_ref(),\n            self.current_module_id.as_ref(),\n            \u0026self.diagnostic_handler,\n        )\n    }\n\n    /// Get the list of module dependencies tracked during type checking\n    pub fn get_module_dependencies(\u0026self) -\u003e \u0026[std::path::PathBuf] {\n        \u0026self.module_dependencies\n    }\n\n    fn check_namespace_declaration(\n        \u0026mut self,\n        ns: \u0026NamespaceDeclaration,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        if self.current_namespace.is_some() {\n            return Err(TypeCheckError::new(\n                \"Only one namespace declaration allowed per file\",\n                ns.span,\n            ));\n        }\n\n        let path: Vec\u003cString\u003e = ns\n            .path\n            .iter()\n            .map(|ident| self.interner.resolve(ident.node).to_string())\n            .collect();\n\n        self.current_namespace = Some(path.clone());\n\n        let namespace_type = Type::new(TypeKind::Namespace(path.clone()), ns.span);\n\n        let namespace_name = path\n            .first()\n            .ok_or_else(|| TypeCheckError::new(\"Namespace path cannot be empty\", ns.span))?;\n\n        let symbol = Symbol::new(\n            namespace_name.clone(),\n            SymbolKind::Namespace,\n            namespace_type,\n            ns.span,\n        );\n\n        self.symbol_table\n            .declare(symbol)\n            .map_err(|e| TypeCheckError::new(e, ns.span))?;\n\n        Ok(())\n    }\n\n    fn check_try_statement(\u0026mut self, stmt: \u0026mut TryStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.check_block(\u0026mut stmt.try_block)?;\n\n        for catch_clause in stmt.catch_clauses.iter_mut() {\n            self.check_catch_clause(catch_clause)?;\n        }\n\n        if let Some(finally_block) = \u0026mut stmt.finally_block {\n            self.check_block(finally_block)?;\n        }\n\n        Ok(())\n    }\n\n    fn check_catch_clause(\u0026mut self, clause: \u0026mut CatchClause) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.symbol_table.enter_scope();\n\n        let _catch_var_type = match \u0026clause.pattern {\n            CatchPattern::Untyped { variable, span } =\u003e {\n                let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), *span);\n                let symbol = Symbol::new(\n                    self.interner.resolve(variable.node).to_string(),\n                    SymbolKind::Variable,\n                    any_type.clone(),\n                    *span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, *span))?;\n                any_type\n            }\n            CatchPattern::Typed {\n                variable,\n                type_annotation,\n                span,\n            } =\u003e {\n                let symbol = Symbol::new(\n                    self.interner.resolve(variable.node).to_string(),\n                    SymbolKind::Variable,\n                    type_annotation.clone(),\n                    *span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, *span))?;\n                type_annotation.clone()\n            }\n            CatchPattern::MultiTyped {\n                variable,\n                type_annotations,\n                span,\n            } =\u003e {\n                let union_type = Type::new(TypeKind::Union(type_annotations.clone()), *span);\n                let symbol = Symbol::new(\n                    self.interner.resolve(variable.node).to_string(),\n                    SymbolKind::Variable,\n                    union_type.clone(),\n                    *span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, *span))?;\n                union_type\n            }\n        };\n\n        self.in_catch_block.push(true);\n        let result = self.check_block(\u0026mut clause.body);\n        self.in_catch_block.pop();\n\n        self.symbol_table.exit_scope();\n\n        result\n    }\n\n    /// Check if a class has circular inheritance by walking up the parent chain\n    #[allow(dead_code)]\n    fn has_circular_inheritance(\u0026self, class_name: \u0026str) -\u003e bool {\n        phases::validation_phase::has_circular_inheritance(class_name, \u0026self.class_parents)\n    }\n\n    /// Check if a block always returns (has a return statement on all code paths)\n    fn block_always_returns(\u0026self, block: \u0026Block) -\u003e bool {\n        control_flow::block_always_returns(block, self.interner)\n    }\n\n    /// Check if a statement always returns\n    #[allow(dead_code)]\n    fn statement_always_returns(\u0026self, stmt: \u0026Statement) -\u003e bool {\n        control_flow::statement_always_returns(stmt, self.interner)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::diagnostics::CollectingDiagnosticHandler;\n    use typedlua_parser::lexer::Lexer;\n    use typedlua_parser::parser::Parser;\n\n    fn type_check_source(source: \u0026str) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let (interner, common) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let mut lexer = Lexer::new(source, handler.clone(), \u0026interner);\n        let tokens = lexer.tokenize().expect(\"Lexing failed\");\n        let mut parser = Parser::new(tokens, handler.clone(), \u0026interner, \u0026common);\n        let mut program = parser.parse().expect(\"Parsing failed\");\n\n        let mut type_checker = TypeChecker::new(handler.clone(), \u0026interner, \u0026common);\n        let result = type_checker.check_program(\u0026mut program);\n\n        // Check if there are errors in the diagnostic handler\n        let has_errors = handler\n            .get_diagnostics()\n            .iter()\n            .any(|d| d.level == crate::cli::diagnostics::DiagnosticLevel::Error);\n\n        if has_errors {\n            Err(TypeCheckError::new(\n                \"Type checking failed with errors\",\n                Default::default(),\n            ))\n        } else {\n            result\n        }\n    }\n\n    /// Type check source code with stdlib loaded (for tests that need stdlib)\n    fn type_check_source_with_stdlib(source: \u0026str) -\u003e Result\u003c(), TypeCheckError\u003e {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let (interner, common) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let mut lexer = Lexer::new(source, handler.clone(), \u0026interner);\n        let tokens = lexer.tokenize().expect(\"Lexing failed\");\n        let mut parser = Parser::new(tokens, handler.clone(), \u0026interner, \u0026common);\n        let mut program = parser.parse().expect(\"Parsing failed\");\n\n        let mut type_checker = TypeChecker::new_with_stdlib(handler.clone(), \u0026interner, \u0026common)\n            .expect(\"Failed to load stdlib\");\n        let result = type_checker.check_program(\u0026mut program);\n\n        // Check if there are errors in the diagnostic handler\n        let has_errors = handler\n            .get_diagnostics()\n            .iter()\n            .any(|d| d.level == crate::cli::diagnostics::DiagnosticLevel::Error);\n\n        if has_errors {\n            Err(TypeCheckError::new(\n                \"Type checking failed with errors\",\n                Default::default(),\n            ))\n        } else {\n            result\n        }\n    }\n\n    #[test]\n    fn test_simple_variable_declaration() {\n        let source = \"const x: number = 42\";\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_type_mismatch() {\n        let source = \"const x: string = 42\";\n        assert!(type_check_source(source).is_err());\n    }\n\n    #[test]\n    fn test_type_inference() {\n        let source = \"const x = 42\";\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_object_literal_inference() {\n        // First test: just declare the object\n        let source1 = \"const obj = {x: 10, y: 20}\\n\";\n        let result1 = type_check_source(source1);\n        if let Err(e) = \u0026result1 {\n            eprintln!(\" Error declaring object: {}\", e.message);\n        }\n        assert!(result1.is_ok(), \"Should be able to declare object literal\");\n\n        // Second test: declare and use\n        let source2 = \"const obj = {x: 10, y: 20}\\nconst a = obj.x\\n\";\n        let result2 = type_check_source(source2);\n        if let Err(e) = \u0026result2 {\n            eprintln!(\" Error using object: {}\", e.message);\n        }\n        assert!(result2.is_ok(), \"Should be able to use object properties\");\n    }\n\n    #[test]\n    fn test_function_type_checking() {\n        let source = r#\"\n            function add(a: number, b: number): number\n                return a + b\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_undefined_variable() {\n        let source = \"const x = y\";\n        assert!(type_check_source(source).is_err());\n    }\n\n    #[test]\n    fn test_narrowing_nil_check() {\n        // Test that nil checks narrow types correctly in if statements\n        let source = r#\"\n            function processValue(x: string | nil)\n                if x != nil then\n                    -- x should be narrowed to string here\n                    local y: string = x\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_narrowing_multiple_branches() {\n        // Test narrowing with multiple if branches\n        let source = r#\"\n            function processOptional(x: string | nil)\n                if x != nil then\n                    local s: string = x\n                end\n\n                local y: string | nil = \"test\"\n                if y != nil then\n                    local s2: string = y\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_narrowing_nested_if() {\n        // Test narrowing in nested if statements\n        let source = r#\"\n            function processNested(a: string | nil, b: number | nil)\n                if a != nil then\n                    local x: string = a\n                    if b != nil then\n                        local y: number = b\n                    end\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_narrowing_else_branch() {\n        // Test that else branch gets the complementary narrowing\n        let source = r#\"\n            function checkNil(x: string | nil)\n                if x == nil then\n                    -- In then branch, x is nil, just use it\n                    local temp = x\n                else\n                    -- In else branch, x is narrowed to string\n                    local s: string = x\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_type_predicate_valid_parameter() {\n        // Test that type predicates accept valid parameter names\n        let source = r#\"\n            function isString(x: string | number): x is string\n                return true\n            end\n        \"#;\n        let result = type_check_source(source);\n        if let Err(e) = \u0026result {\n            eprintln!(\"Unexpected error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_type_predicate_invalid_parameter() {\n        // Test that type predicates reject invalid parameter names\n        let source = r#\"\n            function isString(x: string | number): y is string\n                return true\n            end\n        \"#;\n        let result = type_check_source(source);\n        assert!(\n            result.is_err(),\n            \"Expected error for type predicate with invalid parameter name\"\n        );\n        if let Err(e) = result {\n            assert!(\n                e.message.contains(\"Type predicate parameter\"),\n                \"Expected error message about type predicate parameter, got: {}\",\n                e.message\n            );\n        }\n    }\n\n    #[test]\n    fn test_narrowing_double_nil_check() {\n        // Test nil narrowing with two variables\n        let source = r#\"\n            function process(a: string | nil, b: number | nil)\n                if a != nil then\n                    local x: string = a\n                end\n                if b != nil then\n                    local y: number = b\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_basic() {\n        let source = r#\"\n            class Animal\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_with_property() {\n        let source = r#\"\n            class Person\n                name: string\n                age: number = 25\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    // Property type checking is working but literal \"25\" vs number\n    // compatibility depends on the type compatibility implementation\n    // The test would pass with stricter type checking\n\n    #[test]\n    fn test_class_with_constructor() {\n        let source = r#\"\n            class Person\n                constructor(name: string, age: number)\n                    self.name = name\n                    self.age = age\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_multiple_constructors() {\n        let source = r#\"\n            class Person {\n                constructor(name: string) {\n                }\n\n                constructor(name: string, age: number) {\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(e.message.contains(\"one constructor\"));\n        }\n    }\n\n    #[test]\n    fn test_class_with_method() {\n        let source = r#\"\n            class Calculator {\n                add(a: number, b: number): number {\n                    return a + b\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_abstract_class() {\n        let source = r#\"\n            abstract class Animal {\n                abstract makeSound(): string;\n\n                move(): void {\n                    const x: number = 5\n                }\n            }\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_abstract_method_in_concrete_class() {\n        let source = r#\"\n            class Animal\n                abstract makeSound(): string;\n            end\n        \"#;\n        let result = type_check_source(source);\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(e.message.contains(\"abstract class\"));\n        }\n    }\n\n    #[test]\n    fn test_abstract_method_with_body() {\n        // This test just verifies abstract methods work correctly\n        // The parser prevents abstract methods from having bodies by design\n        let source = r#\"\n            abstract class Animal {\n                abstract makeSound(): string;\n\n                concrete(): void {\n                    const x: number = 5\n                }\n            }\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_with_getter() {\n        let source = r#\"\n            class Person\n                get fullName(): string\n                    return \"John Doe\"\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_class_with_setter() {\n        let source = r#\"\n            class Person\n                set age(value: number)\n                    self._age = value\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    // Getter return type checking depends on literal vs primitive type compatibility\n\n    #[test]\n    fn test_generic_class() {\n        let source = r#\"\n            class Container\u003cT\u003e {\n                value: T\n\n                constructor(val: T) {\n                    const temp: T = val\n                }\n\n                getValue(defaultVal: T): T {\n                    return defaultVal\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_class_implements_interface() {\n        let source = r#\"\n            interface Walkable {\n                walk(): void\n            }\n\n            class Person implements Walkable {\n                walk(): void {\n                    const x: number = 5\n                }\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_class_missing_interface_method() {\n        let source = r#\"\n            interface Walkable {\n                walk(): void\n            }\n\n            class Person implements Walkable {\n            }\n        \"#;\n        let result = type_check_source(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(result.is_err());\n        if let Err(e) = result {\n            assert!(e.message.contains(\"does not implement\"));\n        }\n    }\n\n    #[test]\n    fn test_class_static_method() {\n        let source = r#\"\n            class Math\n                static abs(x: number): number\n                    if x \u003c 0 then\n                        return -x\n                    else\n                        return x\n                    end\n                end\n            end\n        \"#;\n        assert!(type_check_source(source).is_ok());\n    }\n\n    #[test]\n    fn test_stdlib_builtins_loaded() {\n        // Test that built-in functions are available\n        let source = r#\"\n            const x = print(\"Hello\")\n            const y = tonumber(\"42\")\n        \"#;\n        let result = type_check_source_with_stdlib(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(\n            result.is_ok(),\n            \"Built-in functions should be available from stdlib\"\n        );\n    }\n\n    #[test]\n    fn test_stdlib_string_library() {\n        // Test that string library functions are available\n        let source = r#\"\n            const upper = string.upper(\"hello\")\n            const lower = string.lower(\"WORLD\")\n        \"#;\n        let result = type_check_source_with_stdlib(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(\n            result.is_ok(),\n            \"String library should be available from stdlib\"\n        );\n    }\n\n    #[test]\n    fn test_stdlib_math_library() {\n        // Test that math library constants and functions are available\n        let source = r#\"\n            const p = math.pi\n            const result = math.abs(-5)\n        \"#;\n        let result = type_check_source_with_stdlib(source);\n        if let Err(ref e) = result {\n            eprintln!(\"Error: {}\", e.message);\n        }\n        assert!(\n            result.is_ok(),\n            \"Math library should be available from stdlib\"\n        );\n    }\n}\n","traces":[{"line":69,"address":[],"length":0,"stats":{"Line":284}},{"line":75,"address":[],"length":0,"stats":{"Line":568}},{"line":76,"address":[],"length":0,"stats":{"Line":568}},{"line":78,"address":[],"length":0,"stats":{"Line":568}},{"line":79,"address":[],"length":0,"stats":{"Line":568}},{"line":80,"address":[],"length":0,"stats":{"Line":568}},{"line":84,"address":[],"length":0,"stats":{"Line":568}},{"line":85,"address":[],"length":0,"stats":{"Line":568}},{"line":87,"address":[],"length":0,"stats":{"Line":568}},{"line":88,"address":[],"length":0,"stats":{"Line":568}},{"line":89,"address":[],"length":0,"stats":{"Line":568}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":111,"address":[],"length":0,"stats":{"Line":15}},{"line":112,"address":[],"length":0,"stats":{"Line":6}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":3}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":12}},{"line":180,"address":[],"length":0,"stats":{"Line":21}},{"line":181,"address":[],"length":0,"stats":{"Line":423}},{"line":183,"address":[],"length":0,"stats":{"Line":276}},{"line":187,"address":[],"length":0,"stats":{"Line":3}},{"line":192,"address":[],"length":0,"stats":{"Line":284}},{"line":193,"address":[],"length":0,"stats":{"Line":568}},{"line":194,"address":[],"length":0,"stats":{"Line":284}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":852}},{"line":200,"address":[],"length":0,"stats":{"Line":284}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":1029}},{"line":208,"address":[],"length":0,"stats":{"Line":499}},{"line":209,"address":[],"length":0,"stats":{"Line":115}},{"line":213,"address":[],"length":0,"stats":{"Line":283}},{"line":216,"address":[],"length":0,"stats":{"Line":849}},{"line":217,"address":[],"length":0,"stats":{"Line":566}},{"line":218,"address":[],"length":0,"stats":{"Line":1026}},{"line":219,"address":[],"length":0,"stats":{"Line":929}},{"line":220,"address":[],"length":0,"stats":{"Line":27}},{"line":221,"address":[],"length":0,"stats":{"Line":9}},{"line":224,"address":[],"length":0,"stats":{"Line":460}},{"line":227,"address":[],"length":0,"stats":{"Line":283}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":292}},{"line":233,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":9}},{"line":236,"address":[],"length":0,"stats":{"Line":274}},{"line":237,"address":[],"length":0,"stats":{"Line":274}},{"line":243,"address":[],"length":0,"stats":{"Line":38}},{"line":249,"address":[],"length":0,"stats":{"Line":38}},{"line":250,"address":[],"length":0,"stats":{"Line":38}},{"line":251,"address":[],"length":0,"stats":{"Line":38}},{"line":257,"address":[],"length":0,"stats":{"Line":705}},{"line":258,"address":[],"length":0,"stats":{"Line":1410}},{"line":259,"address":[],"length":0,"stats":{"Line":182}},{"line":260,"address":[],"length":0,"stats":{"Line":37}},{"line":261,"address":[],"length":0,"stats":{"Line":16}},{"line":262,"address":[],"length":0,"stats":{"Line":5}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":1}},{"line":265,"address":[],"length":0,"stats":{"Line":49}},{"line":266,"address":[],"length":0,"stats":{"Line":1}},{"line":267,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":24}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":28}},{"line":271,"address":[],"length":0,"stats":{"Line":169}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":43}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":1}},{"line":278,"address":[],"length":0,"stats":{"Line":1}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":91}},{"line":283,"address":[],"length":0,"stats":{"Line":31}},{"line":284,"address":[],"length":0,"stats":{"Line":4}},{"line":285,"address":[],"length":0,"stats":{"Line":9}},{"line":286,"address":[],"length":0,"stats":{"Line":6}},{"line":289,"address":[],"length":0,"stats":{"Line":1410}},{"line":291,"address":[],"length":0,"stats":{"Line":705}},{"line":292,"address":[],"length":0,"stats":{"Line":728}},{"line":293,"address":[],"length":0,"stats":{"Line":148}},{"line":294,"address":[],"length":0,"stats":{"Line":64}},{"line":295,"address":[],"length":0,"stats":{"Line":20}},{"line":296,"address":[],"length":0,"stats":{"Line":8}},{"line":297,"address":[],"length":0,"stats":{"Line":4}},{"line":298,"address":[],"length":0,"stats":{"Line":196}},{"line":299,"address":[],"length":0,"stats":{"Line":2}},{"line":300,"address":[],"length":0,"stats":{"Line":24}},{"line":301,"address":[],"length":0,"stats":{"Line":72}},{"line":302,"address":[],"length":0,"stats":{"Line":24}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":305,"address":[],"length":0,"stats":{"Line":112}},{"line":306,"address":[],"length":0,"stats":{"Line":676}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":308,"address":[],"length":0,"stats":{"Line":172}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":16}},{"line":312,"address":[],"length":0,"stats":{"Line":364}},{"line":313,"address":[],"length":0,"stats":{"Line":124}},{"line":314,"address":[],"length":0,"stats":{"Line":16}},{"line":315,"address":[],"length":0,"stats":{"Line":36}},{"line":316,"address":[],"length":0,"stats":{"Line":24}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":0}},{"line":320,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":2}},{"line":329,"address":[],"length":0,"stats":{"Line":182}},{"line":334,"address":[],"length":0,"stats":{"Line":728}},{"line":337,"address":[],"length":0,"stats":{"Line":449}},{"line":339,"address":[],"length":0,"stats":{"Line":178}},{"line":340,"address":[],"length":0,"stats":{"Line":178}},{"line":341,"address":[],"length":0,"stats":{"Line":89}},{"line":345,"address":[],"length":0,"stats":{"Line":356}},{"line":346,"address":[],"length":0,"stats":{"Line":356}},{"line":349,"address":[],"length":0,"stats":{"Line":178}},{"line":353,"address":[],"length":0,"stats":{"Line":64}},{"line":354,"address":[],"length":0,"stats":{"Line":48}},{"line":355,"address":[],"length":0,"stats":{"Line":32}},{"line":356,"address":[],"length":0,"stats":{"Line":16}},{"line":357,"address":[],"length":0,"stats":{"Line":16}},{"line":358,"address":[],"length":0,"stats":{"Line":16}},{"line":363,"address":[],"length":0,"stats":{"Line":89}},{"line":366,"address":[],"length":0,"stats":{"Line":172}},{"line":367,"address":[],"length":0,"stats":{"Line":10}},{"line":369,"address":[],"length":0,"stats":{"Line":243}},{"line":374,"address":[],"length":0,"stats":{"Line":360}},{"line":375,"address":[],"length":0,"stats":{"Line":17}},{"line":376,"address":[],"length":0,"stats":{"Line":163}},{"line":379,"address":[],"length":0,"stats":{"Line":1081}},{"line":381,"address":[],"length":0,"stats":{"Line":179}},{"line":385,"address":[],"length":0,"stats":{"Line":252}},{"line":394,"address":[],"length":0,"stats":{"Line":252}},{"line":395,"address":[],"length":0,"stats":{"Line":252}},{"line":396,"address":[],"length":0,"stats":{"Line":252}},{"line":397,"address":[],"length":0,"stats":{"Line":252}},{"line":398,"address":[],"length":0,"stats":{"Line":252}},{"line":399,"address":[],"length":0,"stats":{"Line":252}},{"line":404,"address":[],"length":0,"stats":{"Line":37}},{"line":413,"address":[],"length":0,"stats":{"Line":74}},{"line":417,"address":[],"length":0,"stats":{"Line":74}},{"line":418,"address":[],"length":0,"stats":{"Line":37}},{"line":419,"address":[],"length":0,"stats":{"Line":37}},{"line":423,"address":[],"length":0,"stats":{"Line":172}},{"line":425,"address":[],"length":0,"stats":{"Line":51}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":98}},{"line":434,"address":[],"length":0,"stats":{"Line":3}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":437,"address":[],"length":0,"stats":{"Line":2}},{"line":438,"address":[],"length":0,"stats":{"Line":1}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":3}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":3}},{"line":448,"address":[],"length":0,"stats":{"Line":96}},{"line":450,"address":[],"length":0,"stats":{"Line":96}},{"line":451,"address":[],"length":0,"stats":{"Line":96}},{"line":452,"address":[],"length":0,"stats":{"Line":48}},{"line":453,"address":[],"length":0,"stats":{"Line":48}},{"line":455,"address":[],"length":0,"stats":{"Line":144}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":98}},{"line":461,"address":[],"length":0,"stats":{"Line":49}},{"line":462,"address":[],"length":0,"stats":{"Line":49}},{"line":463,"address":[],"length":0,"stats":{"Line":49}},{"line":464,"address":[],"length":0,"stats":{"Line":49}},{"line":469,"address":[],"length":0,"stats":{"Line":111}},{"line":470,"address":[],"length":0,"stats":{"Line":180}},{"line":471,"address":[],"length":0,"stats":{"Line":160}},{"line":472,"address":[],"length":0,"stats":{"Line":96}},{"line":474,"address":[],"length":0,"stats":{"Line":74}},{"line":477,"address":[],"length":0,"stats":{"Line":148}},{"line":480,"address":[],"length":0,"stats":{"Line":74}},{"line":481,"address":[],"length":0,"stats":{"Line":69}},{"line":483,"address":[],"length":0,"stats":{"Line":64}},{"line":484,"address":[],"length":0,"stats":{"Line":16}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":96}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":74}},{"line":505,"address":[],"length":0,"stats":{"Line":49}},{"line":506,"address":[],"length":0,"stats":{"Line":57}},{"line":507,"address":[],"length":0,"stats":{"Line":75}},{"line":508,"address":[],"length":0,"stats":{"Line":60}},{"line":509,"address":[],"length":0,"stats":{"Line":30}},{"line":514,"address":[],"length":0,"stats":{"Line":74}},{"line":516,"address":[],"length":0,"stats":{"Line":37}},{"line":520,"address":[],"length":0,"stats":{"Line":16}},{"line":522,"address":[],"length":0,"stats":{"Line":48}},{"line":526,"address":[],"length":0,"stats":{"Line":32}},{"line":527,"address":[],"length":0,"stats":{"Line":137}},{"line":528,"address":[],"length":0,"stats":{"Line":175}},{"line":529,"address":[],"length":0,"stats":{"Line":140}},{"line":533,"address":[],"length":0,"stats":{"Line":80}},{"line":534,"address":[],"length":0,"stats":{"Line":32}},{"line":535,"address":[],"length":0,"stats":{"Line":32}},{"line":536,"address":[],"length":0,"stats":{"Line":16}},{"line":537,"address":[],"length":0,"stats":{"Line":16}},{"line":541,"address":[],"length":0,"stats":{"Line":48}},{"line":542,"address":[],"length":0,"stats":{"Line":32}},{"line":543,"address":[],"length":0,"stats":{"Line":48}},{"line":546,"address":[],"length":0,"stats":{"Line":48}},{"line":549,"address":[],"length":0,"stats":{"Line":34}},{"line":550,"address":[],"length":0,"stats":{"Line":6}},{"line":553,"address":[],"length":0,"stats":{"Line":10}},{"line":554,"address":[],"length":0,"stats":{"Line":4}},{"line":555,"address":[],"length":0,"stats":{"Line":4}},{"line":556,"address":[],"length":0,"stats":{"Line":2}},{"line":557,"address":[],"length":0,"stats":{"Line":2}},{"line":560,"address":[],"length":0,"stats":{"Line":4}},{"line":561,"address":[],"length":0,"stats":{"Line":6}},{"line":562,"address":[],"length":0,"stats":{"Line":4}},{"line":566,"address":[],"length":0,"stats":{"Line":20}},{"line":567,"address":[],"length":0,"stats":{"Line":12}},{"line":571,"address":[],"length":0,"stats":{"Line":32}},{"line":573,"address":[],"length":0,"stats":{"Line":16}},{"line":577,"address":[],"length":0,"stats":{"Line":5}},{"line":581,"address":[],"length":0,"stats":{"Line":15}},{"line":582,"address":[],"length":0,"stats":{"Line":15}},{"line":583,"address":[],"length":0,"stats":{"Line":5}},{"line":587,"address":[],"length":0,"stats":{"Line":2}},{"line":588,"address":[],"length":0,"stats":{"Line":2}},{"line":589,"address":[],"length":0,"stats":{"Line":2}},{"line":590,"address":[],"length":0,"stats":{"Line":4}},{"line":593,"address":[],"length":0,"stats":{"Line":2}},{"line":594,"address":[],"length":0,"stats":{"Line":6}},{"line":596,"address":[],"length":0,"stats":{"Line":6}},{"line":597,"address":[],"length":0,"stats":{"Line":2}},{"line":598,"address":[],"length":0,"stats":{"Line":2}},{"line":599,"address":[],"length":0,"stats":{"Line":2}},{"line":601,"address":[],"length":0,"stats":{"Line":2}},{"line":602,"address":[],"length":0,"stats":{"Line":4}},{"line":603,"address":[],"length":0,"stats":{"Line":2}},{"line":606,"address":[],"length":0,"stats":{"Line":6}},{"line":607,"address":[],"length":0,"stats":{"Line":6}},{"line":608,"address":[],"length":0,"stats":{"Line":2}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":612,"address":[],"length":0,"stats":{"Line":6}},{"line":613,"address":[],"length":0,"stats":{"Line":4}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":625,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":636,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":2}},{"line":647,"address":[],"length":0,"stats":{"Line":1}},{"line":651,"address":[],"length":0,"stats":{"Line":2}},{"line":652,"address":[],"length":0,"stats":{"Line":3}},{"line":653,"address":[],"length":0,"stats":{"Line":3}},{"line":654,"address":[],"length":0,"stats":{"Line":2}},{"line":655,"address":[],"length":0,"stats":{"Line":1}},{"line":659,"address":[],"length":0,"stats":{"Line":49}},{"line":663,"address":[],"length":0,"stats":{"Line":49}},{"line":665,"address":[],"length":0,"stats":{"Line":147}},{"line":666,"address":[],"length":0,"stats":{"Line":49}},{"line":668,"address":[],"length":0,"stats":{"Line":199}},{"line":670,"address":[],"length":0,"stats":{"Line":98}},{"line":673,"address":[],"length":0,"stats":{"Line":98}},{"line":674,"address":[],"length":0,"stats":{"Line":96}},{"line":676,"address":[],"length":0,"stats":{"Line":3}},{"line":680,"address":[],"length":0,"stats":{"Line":97}},{"line":682,"address":[],"length":0,"stats":{"Line":48}},{"line":683,"address":[],"length":0,"stats":{"Line":95}},{"line":685,"address":[],"length":0,"stats":{"Line":1}},{"line":686,"address":[],"length":0,"stats":{"Line":1}},{"line":689,"address":[],"length":0,"stats":{"Line":94}},{"line":692,"address":[],"length":0,"stats":{"Line":96}},{"line":694,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":705,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":49}},{"line":717,"address":[],"length":0,"stats":{"Line":102}},{"line":718,"address":[],"length":0,"stats":{"Line":204}},{"line":719,"address":[],"length":0,"stats":{"Line":306}},{"line":720,"address":[],"length":0,"stats":{"Line":316}},{"line":721,"address":[],"length":0,"stats":{"Line":214}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":204}},{"line":728,"address":[],"length":0,"stats":{"Line":102}},{"line":729,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":102}},{"line":736,"address":[],"length":0,"stats":{"Line":37}},{"line":741,"address":[],"length":0,"stats":{"Line":72}},{"line":743,"address":[],"length":0,"stats":{"Line":37}},{"line":744,"address":[],"length":0,"stats":{"Line":37}},{"line":745,"address":[],"length":0,"stats":{"Line":37}},{"line":746,"address":[],"length":0,"stats":{"Line":37}},{"line":747,"address":[],"length":0,"stats":{"Line":37}},{"line":751,"address":[],"length":0,"stats":{"Line":36}},{"line":752,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":765,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":775,"address":[],"length":0,"stats":{"Line":36}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":173}},{"line":791,"address":[],"length":0,"stats":{"Line":519}},{"line":793,"address":[],"length":0,"stats":{"Line":441}},{"line":794,"address":[],"length":0,"stats":{"Line":147}},{"line":797,"address":[],"length":0,"stats":{"Line":26}},{"line":802,"address":[],"length":0,"stats":{"Line":173}},{"line":803,"address":[],"length":0,"stats":{"Line":173}},{"line":804,"address":[],"length":0,"stats":{"Line":173}},{"line":805,"address":[],"length":0,"stats":{"Line":173}},{"line":806,"address":[],"length":0,"stats":{"Line":173}},{"line":811,"address":[],"length":0,"stats":{"Line":4}},{"line":813,"address":[],"length":0,"stats":{"Line":4}},{"line":814,"address":[],"length":0,"stats":{"Line":3}},{"line":816,"address":[],"length":0,"stats":{"Line":6}},{"line":817,"address":[],"length":0,"stats":{"Line":1}},{"line":819,"address":[],"length":0,"stats":{"Line":1}},{"line":820,"address":[],"length":0,"stats":{"Line":1}},{"line":821,"address":[],"length":0,"stats":{"Line":2}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":826,"address":[],"length":0,"stats":{"Line":2}},{"line":827,"address":[],"length":0,"stats":{"Line":4}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":833,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":6}},{"line":846,"address":[],"length":0,"stats":{"Line":9}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":854,"address":[],"length":0,"stats":{"Line":1}},{"line":856,"address":[],"length":0,"stats":{"Line":3}},{"line":857,"address":[],"length":0,"stats":{"Line":2}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":3}},{"line":862,"address":[],"length":0,"stats":{"Line":3}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":870,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":874,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":882,"address":[],"length":0,"stats":{"Line":4}},{"line":883,"address":[],"length":0,"stats":{"Line":3}},{"line":887,"address":[],"length":0,"stats":{"Line":3}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":889,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":896,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":907,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":910,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":912,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":922,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":937,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":0}},{"line":941,"address":[],"length":0,"stats":{"Line":0}},{"line":943,"address":[],"length":0,"stats":{"Line":0}},{"line":947,"address":[],"length":0,"stats":{"Line":3}},{"line":950,"address":[],"length":0,"stats":{"Line":0}},{"line":951,"address":[],"length":0,"stats":{"Line":0}},{"line":952,"address":[],"length":0,"stats":{"Line":1}},{"line":953,"address":[],"length":0,"stats":{"Line":0}},{"line":957,"address":[],"length":0,"stats":{"Line":1}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":959,"address":[],"length":0,"stats":{"Line":0}},{"line":961,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":969,"address":[],"length":0,"stats":{"Line":1}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":0}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":975,"address":[],"length":0,"stats":{"Line":0}},{"line":981,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":988,"address":[],"length":0,"stats":{"Line":0}},{"line":989,"address":[],"length":0,"stats":{"Line":0}},{"line":990,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":995,"address":[],"length":0,"stats":{"Line":0}},{"line":998,"address":[],"length":0,"stats":{"Line":0}},{"line":1002,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1010,"address":[],"length":0,"stats":{"Line":0}},{"line":1011,"address":[],"length":0,"stats":{"Line":0}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1019,"address":[],"length":0,"stats":{"Line":0}},{"line":1020,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1025,"address":[],"length":0,"stats":{"Line":0}},{"line":1029,"address":[],"length":0,"stats":{"Line":0}},{"line":1030,"address":[],"length":0,"stats":{"Line":0}},{"line":1032,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1034,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":0}},{"line":1037,"address":[],"length":0,"stats":{"Line":0}},{"line":1038,"address":[],"length":0,"stats":{"Line":0}},{"line":1039,"address":[],"length":0,"stats":{"Line":0}},{"line":1042,"address":[],"length":0,"stats":{"Line":0}},{"line":1047,"address":[],"length":0,"stats":{"Line":173}},{"line":1048,"address":[],"length":0,"stats":{"Line":692}},{"line":1049,"address":[],"length":0,"stats":{"Line":346}},{"line":1051,"address":[],"length":0,"stats":{"Line":346}},{"line":1054,"address":[],"length":0,"stats":{"Line":220}},{"line":1055,"address":[],"length":0,"stats":{"Line":94}},{"line":1057,"address":[],"length":0,"stats":{"Line":66}},{"line":1059,"address":[],"length":0,"stats":{"Line":55}},{"line":1060,"address":[],"length":0,"stats":{"Line":99}},{"line":1061,"address":[],"length":0,"stats":{"Line":33}},{"line":1064,"address":[],"length":0,"stats":{"Line":44}},{"line":1066,"address":[],"length":0,"stats":{"Line":22}},{"line":1067,"address":[],"length":0,"stats":{"Line":22}},{"line":1068,"address":[],"length":0,"stats":{"Line":132}},{"line":1069,"address":[],"length":0,"stats":{"Line":22}},{"line":1073,"address":[],"length":0,"stats":{"Line":66}},{"line":1075,"address":[],"length":0,"stats":{"Line":16}},{"line":1076,"address":[],"length":0,"stats":{"Line":16}},{"line":1077,"address":[],"length":0,"stats":{"Line":16}},{"line":1078,"address":[],"length":0,"stats":{"Line":16}},{"line":1080,"address":[],"length":0,"stats":{"Line":16}},{"line":1085,"address":[],"length":0,"stats":{"Line":270}},{"line":1086,"address":[],"length":0,"stats":{"Line":224}},{"line":1087,"address":[],"length":0,"stats":{"Line":46}},{"line":1088,"address":[],"length":0,"stats":{"Line":46}},{"line":1089,"address":[],"length":0,"stats":{"Line":23}},{"line":1096,"address":[],"length":0,"stats":{"Line":43}},{"line":1100,"address":[],"length":0,"stats":{"Line":172}},{"line":1101,"address":[],"length":0,"stats":{"Line":86}},{"line":1103,"address":[],"length":0,"stats":{"Line":43}},{"line":1104,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":0}},{"line":1109,"address":[],"length":0,"stats":{"Line":129}},{"line":1111,"address":[],"length":0,"stats":{"Line":43}},{"line":1115,"address":[],"length":0,"stats":{"Line":43}},{"line":1116,"address":[],"length":0,"stats":{"Line":43}},{"line":1117,"address":[],"length":0,"stats":{"Line":43}},{"line":1118,"address":[],"length":0,"stats":{"Line":43}},{"line":1119,"address":[],"length":0,"stats":{"Line":43}},{"line":1123,"address":[],"length":0,"stats":{"Line":86}},{"line":1128,"address":[],"length":0,"stats":{"Line":86}},{"line":1129,"address":[],"length":0,"stats":{"Line":43}},{"line":1130,"address":[],"length":0,"stats":{"Line":43}},{"line":1134,"address":[],"length":0,"stats":{"Line":51}},{"line":1136,"address":[],"length":0,"stats":{"Line":8}},{"line":1137,"address":[],"length":0,"stats":{"Line":8}},{"line":1138,"address":[],"length":0,"stats":{"Line":8}},{"line":1139,"address":[],"length":0,"stats":{"Line":8}},{"line":1140,"address":[],"length":0,"stats":{"Line":8}},{"line":1141,"address":[],"length":0,"stats":{"Line":8}},{"line":1148,"address":[],"length":0,"stats":{"Line":84}},{"line":1149,"address":[],"length":0,"stats":{"Line":84}},{"line":1150,"address":[],"length":0,"stats":{"Line":42}},{"line":1151,"address":[],"length":0,"stats":{"Line":42}},{"line":1152,"address":[],"length":0,"stats":{"Line":42}},{"line":1156,"address":[],"length":0,"stats":{"Line":49}},{"line":1157,"address":[],"length":0,"stats":{"Line":8}},{"line":1158,"address":[],"length":0,"stats":{"Line":16}},{"line":1159,"address":[],"length":0,"stats":{"Line":12}},{"line":1161,"address":[],"length":0,"stats":{"Line":8}},{"line":1163,"address":[],"length":0,"stats":{"Line":0}},{"line":1164,"address":[],"length":0,"stats":{"Line":0}},{"line":1165,"address":[],"length":0,"stats":{"Line":0}},{"line":1166,"address":[],"length":0,"stats":{"Line":0}},{"line":1167,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":8}},{"line":1173,"address":[],"length":0,"stats":{"Line":17}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1177,"address":[],"length":0,"stats":{"Line":0}},{"line":1181,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1189,"address":[],"length":0,"stats":{"Line":82}},{"line":1190,"address":[],"length":0,"stats":{"Line":41}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1193,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1195,"address":[],"length":0,"stats":{"Line":0}},{"line":1196,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1198,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1200,"address":[],"length":0,"stats":{"Line":0}},{"line":1202,"address":[],"length":0,"stats":{"Line":0}},{"line":1203,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1205,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1216,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1222,"address":[],"length":0,"stats":{"Line":41}},{"line":1224,"address":[],"length":0,"stats":{"Line":0}},{"line":1225,"address":[],"length":0,"stats":{"Line":0}},{"line":1229,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1231,"address":[],"length":0,"stats":{"Line":0}},{"line":1233,"address":[],"length":0,"stats":{"Line":0}},{"line":1234,"address":[],"length":0,"stats":{"Line":0}},{"line":1236,"address":[],"length":0,"stats":{"Line":0}},{"line":1238,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1240,"address":[],"length":0,"stats":{"Line":0}},{"line":1241,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1243,"address":[],"length":0,"stats":{"Line":0}},{"line":1245,"address":[],"length":0,"stats":{"Line":0}},{"line":1250,"address":[],"length":0,"stats":{"Line":0}},{"line":1251,"address":[],"length":0,"stats":{"Line":0}},{"line":1252,"address":[],"length":0,"stats":{"Line":0}},{"line":1253,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1257,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1260,"address":[],"length":0,"stats":{"Line":0}},{"line":1261,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1265,"address":[],"length":0,"stats":{"Line":0}},{"line":1275,"address":[],"length":0,"stats":{"Line":82}},{"line":1278,"address":[],"length":0,"stats":{"Line":41}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1280,"address":[],"length":0,"stats":{"Line":0}},{"line":1281,"address":[],"length":0,"stats":{"Line":0}},{"line":1282,"address":[],"length":0,"stats":{"Line":0}},{"line":1283,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1286,"address":[],"length":0,"stats":{"Line":0}},{"line":1292,"address":[],"length":0,"stats":{"Line":41}},{"line":1293,"address":[],"length":0,"stats":{"Line":41}},{"line":1295,"address":[],"length":0,"stats":{"Line":123}},{"line":1298,"address":[],"length":0,"stats":{"Line":171}},{"line":1299,"address":[],"length":0,"stats":{"Line":14}},{"line":1300,"address":[],"length":0,"stats":{"Line":14}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":41}},{"line":1308,"address":[],"length":0,"stats":{"Line":164}},{"line":1309,"address":[],"length":0,"stats":{"Line":206}},{"line":1310,"address":[],"length":0,"stats":{"Line":110}},{"line":1311,"address":[],"length":0,"stats":{"Line":110}},{"line":1315,"address":[],"length":0,"stats":{"Line":41}},{"line":1316,"address":[],"length":0,"stats":{"Line":123}},{"line":1319,"address":[],"length":0,"stats":{"Line":123}},{"line":1320,"address":[],"length":0,"stats":{"Line":123}},{"line":1321,"address":[],"length":0,"stats":{"Line":164}},{"line":1322,"address":[],"length":0,"stats":{"Line":82}},{"line":1323,"address":[],"length":0,"stats":{"Line":41}},{"line":1330,"address":[],"length":0,"stats":{"Line":82}},{"line":1331,"address":[],"length":0,"stats":{"Line":82}},{"line":1332,"address":[],"length":0,"stats":{"Line":123}},{"line":1334,"address":[],"length":0,"stats":{"Line":146}},{"line":1335,"address":[],"length":0,"stats":{"Line":128}},{"line":1336,"address":[],"length":0,"stats":{"Line":92}},{"line":1337,"address":[],"length":0,"stats":{"Line":9}},{"line":1338,"address":[],"length":0,"stats":{"Line":9}},{"line":1339,"address":[],"length":0,"stats":{"Line":1}},{"line":1340,"address":[],"length":0,"stats":{"Line":1}},{"line":1341,"address":[],"length":0,"stats":{"Line":1}},{"line":1344,"address":[],"length":0,"stats":{"Line":8}},{"line":1345,"address":[],"length":0,"stats":{"Line":24}},{"line":1348,"address":[],"length":0,"stats":{"Line":28}},{"line":1349,"address":[],"length":0,"stats":{"Line":28}},{"line":1350,"address":[],"length":0,"stats":{"Line":5}},{"line":1351,"address":[],"length":0,"stats":{"Line":2}},{"line":1352,"address":[],"length":0,"stats":{"Line":2}},{"line":1353,"address":[],"length":0,"stats":{"Line":1}},{"line":1354,"address":[],"length":0,"stats":{"Line":1}},{"line":1356,"address":[],"length":0,"stats":{"Line":1}},{"line":1359,"address":[],"length":0,"stats":{"Line":4}},{"line":1360,"address":[],"length":0,"stats":{"Line":16}},{"line":1361,"address":[],"length":0,"stats":{"Line":12}},{"line":1364,"address":[],"length":0,"stats":{"Line":69}},{"line":1367,"address":[],"length":0,"stats":{"Line":8}},{"line":1368,"address":[],"length":0,"stats":{"Line":8}},{"line":1369,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":66}},{"line":1373,"address":[],"length":0,"stats":{"Line":6}},{"line":1374,"address":[],"length":0,"stats":{"Line":2}},{"line":1380,"address":[],"length":0,"stats":{"Line":123}},{"line":1383,"address":[],"length":0,"stats":{"Line":82}},{"line":1386,"address":[],"length":0,"stats":{"Line":47}},{"line":1387,"address":[],"length":0,"stats":{"Line":24}},{"line":1388,"address":[],"length":0,"stats":{"Line":30}},{"line":1389,"address":[],"length":0,"stats":{"Line":12}},{"line":1394,"address":[],"length":0,"stats":{"Line":41}},{"line":1395,"address":[],"length":0,"stats":{"Line":44}},{"line":1396,"address":[],"length":0,"stats":{"Line":14}},{"line":1397,"address":[],"length":0,"stats":{"Line":28}},{"line":1399,"address":[],"length":0,"stats":{"Line":14}},{"line":1400,"address":[],"length":0,"stats":{"Line":7}},{"line":1401,"address":[],"length":0,"stats":{"Line":7}},{"line":1402,"address":[],"length":0,"stats":{"Line":7}},{"line":1411,"address":[],"length":0,"stats":{"Line":43}},{"line":1412,"address":[],"length":0,"stats":{"Line":4}},{"line":1413,"address":[],"length":0,"stats":{"Line":2}},{"line":1416,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1423,"address":[],"length":0,"stats":{"Line":39}},{"line":1427,"address":[],"length":0,"stats":{"Line":4}},{"line":1433,"address":[],"length":0,"stats":{"Line":4}},{"line":1434,"address":[],"length":0,"stats":{"Line":4}},{"line":1435,"address":[],"length":0,"stats":{"Line":4}},{"line":1436,"address":[],"length":0,"stats":{"Line":4}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1447,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":7}},{"line":1458,"address":[],"length":0,"stats":{"Line":7}},{"line":1459,"address":[],"length":0,"stats":{"Line":7}},{"line":1460,"address":[],"length":0,"stats":{"Line":7}},{"line":1461,"address":[],"length":0,"stats":{"Line":7}},{"line":1462,"address":[],"length":0,"stats":{"Line":7}},{"line":1467,"address":[],"length":0,"stats":{"Line":97}},{"line":1472,"address":[],"length":0,"stats":{"Line":97}},{"line":1473,"address":[],"length":0,"stats":{"Line":0}},{"line":1474,"address":[],"length":0,"stats":{"Line":0}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":194}},{"line":1481,"address":[],"length":0,"stats":{"Line":194}},{"line":1483,"address":[],"length":0,"stats":{"Line":0}},{"line":1484,"address":[],"length":0,"stats":{"Line":0}},{"line":1485,"address":[],"length":0,"stats":{"Line":0}},{"line":1487,"address":[],"length":0,"stats":{"Line":0}},{"line":1489,"address":[],"length":0,"stats":{"Line":0}},{"line":1490,"address":[],"length":0,"stats":{"Line":0}},{"line":1492,"address":[],"length":0,"stats":{"Line":0}},{"line":1494,"address":[],"length":0,"stats":{"Line":0}},{"line":1497,"address":[],"length":0,"stats":{"Line":0}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1517,"address":[],"length":0,"stats":{"Line":194}},{"line":1518,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":97}},{"line":1525,"address":[],"length":0,"stats":{"Line":0}},{"line":1531,"address":[],"length":0,"stats":{"Line":0}},{"line":1532,"address":[],"length":0,"stats":{"Line":0}},{"line":1535,"address":[],"length":0,"stats":{"Line":0}},{"line":1536,"address":[],"length":0,"stats":{"Line":0}},{"line":1540,"address":[],"length":0,"stats":{"Line":0}},{"line":1542,"address":[],"length":0,"stats":{"Line":0}},{"line":1543,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1549,"address":[],"length":0,"stats":{"Line":0}},{"line":1550,"address":[],"length":0,"stats":{"Line":0}},{"line":1553,"address":[],"length":0,"stats":{"Line":0}},{"line":1555,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1564,"address":[],"length":0,"stats":{"Line":23}},{"line":1569,"address":[],"length":0,"stats":{"Line":69}},{"line":1572,"address":[],"length":0,"stats":{"Line":38}},{"line":1573,"address":[],"length":0,"stats":{"Line":60}},{"line":1576,"address":[],"length":0,"stats":{"Line":30}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1578,"address":[],"length":0,"stats":{"Line":0}},{"line":1579,"address":[],"length":0,"stats":{"Line":0}},{"line":1580,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":23}},{"line":1591,"address":[],"length":0,"stats":{"Line":8}},{"line":1596,"address":[],"length":0,"stats":{"Line":16}},{"line":1599,"address":[],"length":0,"stats":{"Line":16}},{"line":1601,"address":[],"length":0,"stats":{"Line":16}},{"line":1602,"address":[],"length":0,"stats":{"Line":16}},{"line":1603,"address":[],"length":0,"stats":{"Line":8}},{"line":1604,"address":[],"length":0,"stats":{"Line":16}},{"line":1605,"address":[],"length":0,"stats":{"Line":32}},{"line":1606,"address":[],"length":0,"stats":{"Line":16}},{"line":1608,"address":[],"length":0,"stats":{"Line":8}},{"line":1609,"address":[],"length":0,"stats":{"Line":8}},{"line":1611,"address":[],"length":0,"stats":{"Line":8}},{"line":1613,"address":[],"length":0,"stats":{"Line":16}},{"line":1614,"address":[],"length":0,"stats":{"Line":16}},{"line":1615,"address":[],"length":0,"stats":{"Line":8}},{"line":1616,"address":[],"length":0,"stats":{"Line":8}},{"line":1617,"address":[],"length":0,"stats":{"Line":8}},{"line":1619,"address":[],"length":0,"stats":{"Line":8}},{"line":1620,"address":[],"length":0,"stats":{"Line":16}},{"line":1621,"address":[],"length":0,"stats":{"Line":8}},{"line":1625,"address":[],"length":0,"stats":{"Line":28}},{"line":1626,"address":[],"length":0,"stats":{"Line":30}},{"line":1628,"address":[],"length":0,"stats":{"Line":20}},{"line":1629,"address":[],"length":0,"stats":{"Line":20}},{"line":1630,"address":[],"length":0,"stats":{"Line":10}},{"line":1631,"address":[],"length":0,"stats":{"Line":10}},{"line":1634,"address":[],"length":0,"stats":{"Line":30}},{"line":1636,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":20}},{"line":1640,"address":[],"length":0,"stats":{"Line":10}},{"line":1641,"address":[],"length":0,"stats":{"Line":10}},{"line":1642,"address":[],"length":0,"stats":{"Line":10}},{"line":1643,"address":[],"length":0,"stats":{"Line":10}},{"line":1648,"address":[],"length":0,"stats":{"Line":24}},{"line":1650,"address":[],"length":0,"stats":{"Line":8}},{"line":1654,"address":[],"length":0,"stats":{"Line":16}},{"line":1656,"address":[],"length":0,"stats":{"Line":8}},{"line":1660,"address":[],"length":0,"stats":{"Line":27}},{"line":1662,"address":[],"length":0,"stats":{"Line":81}},{"line":1665,"address":[],"length":0,"stats":{"Line":27}},{"line":1666,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":54}},{"line":1669,"address":[],"length":0,"stats":{"Line":31}},{"line":1670,"address":[],"length":0,"stats":{"Line":12}},{"line":1671,"address":[],"length":0,"stats":{"Line":16}},{"line":1672,"address":[],"length":0,"stats":{"Line":22}},{"line":1673,"address":[],"length":0,"stats":{"Line":12}},{"line":1674,"address":[],"length":0,"stats":{"Line":8}},{"line":1675,"address":[],"length":0,"stats":{"Line":4}},{"line":1676,"address":[],"length":0,"stats":{"Line":4}},{"line":1677,"address":[],"length":0,"stats":{"Line":4}},{"line":1678,"address":[],"length":0,"stats":{"Line":4}},{"line":1687,"address":[],"length":0,"stats":{"Line":27}},{"line":1688,"address":[],"length":0,"stats":{"Line":8}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1694,"address":[],"length":0,"stats":{"Line":4}},{"line":1698,"address":[],"length":0,"stats":{"Line":46}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":46}},{"line":1712,"address":[],"length":0,"stats":{"Line":69}},{"line":1713,"address":[],"length":0,"stats":{"Line":46}},{"line":1715,"address":[],"length":0,"stats":{"Line":23}},{"line":1716,"address":[],"length":0,"stats":{"Line":42}},{"line":1717,"address":[],"length":0,"stats":{"Line":42}},{"line":1718,"address":[],"length":0,"stats":{"Line":21}},{"line":1719,"address":[],"length":0,"stats":{"Line":42}},{"line":1720,"address":[],"length":0,"stats":{"Line":84}},{"line":1721,"address":[],"length":0,"stats":{"Line":42}},{"line":1723,"address":[],"length":0,"stats":{"Line":21}},{"line":1724,"address":[],"length":0,"stats":{"Line":21}},{"line":1726,"address":[],"length":0,"stats":{"Line":21}},{"line":1728,"address":[],"length":0,"stats":{"Line":42}},{"line":1729,"address":[],"length":0,"stats":{"Line":42}},{"line":1730,"address":[],"length":0,"stats":{"Line":21}},{"line":1731,"address":[],"length":0,"stats":{"Line":21}},{"line":1732,"address":[],"length":0,"stats":{"Line":21}},{"line":1734,"address":[],"length":0,"stats":{"Line":21}},{"line":1735,"address":[],"length":0,"stats":{"Line":42}},{"line":1736,"address":[],"length":0,"stats":{"Line":21}},{"line":1741,"address":[],"length":0,"stats":{"Line":23}},{"line":1742,"address":[],"length":0,"stats":{"Line":46}},{"line":1743,"address":[],"length":0,"stats":{"Line":23}},{"line":1744,"address":[],"length":0,"stats":{"Line":23}},{"line":1748,"address":[],"length":0,"stats":{"Line":45}},{"line":1749,"address":[],"length":0,"stats":{"Line":33}},{"line":1751,"address":[],"length":0,"stats":{"Line":22}},{"line":1752,"address":[],"length":0,"stats":{"Line":22}},{"line":1753,"address":[],"length":0,"stats":{"Line":11}},{"line":1754,"address":[],"length":0,"stats":{"Line":11}},{"line":1757,"address":[],"length":0,"stats":{"Line":33}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1762,"address":[],"length":0,"stats":{"Line":22}},{"line":1763,"address":[],"length":0,"stats":{"Line":11}},{"line":1764,"address":[],"length":0,"stats":{"Line":11}},{"line":1765,"address":[],"length":0,"stats":{"Line":11}},{"line":1766,"address":[],"length":0,"stats":{"Line":11}},{"line":1771,"address":[],"length":0,"stats":{"Line":69}},{"line":1774,"address":[],"length":0,"stats":{"Line":46}},{"line":1775,"address":[],"length":0,"stats":{"Line":69}},{"line":1778,"address":[],"length":0,"stats":{"Line":23}},{"line":1782,"address":[],"length":0,"stats":{"Line":46}},{"line":1783,"address":[],"length":0,"stats":{"Line":46}},{"line":1786,"address":[],"length":0,"stats":{"Line":24}},{"line":1787,"address":[],"length":0,"stats":{"Line":4}},{"line":1788,"address":[],"length":0,"stats":{"Line":5}},{"line":1789,"address":[],"length":0,"stats":{"Line":2}},{"line":1793,"address":[],"length":0,"stats":{"Line":23}},{"line":1797,"address":[],"length":0,"stats":{"Line":2}},{"line":1799,"address":[],"length":0,"stats":{"Line":6}},{"line":1802,"address":[],"length":0,"stats":{"Line":4}},{"line":1805,"address":[],"length":0,"stats":{"Line":2}},{"line":1806,"address":[],"length":0,"stats":{"Line":4}},{"line":1808,"address":[],"length":0,"stats":{"Line":2}},{"line":1809,"address":[],"length":0,"stats":{"Line":4}},{"line":1810,"address":[],"length":0,"stats":{"Line":8}},{"line":1811,"address":[],"length":0,"stats":{"Line":4}},{"line":1813,"address":[],"length":0,"stats":{"Line":2}},{"line":1814,"address":[],"length":0,"stats":{"Line":2}},{"line":1816,"address":[],"length":0,"stats":{"Line":2}},{"line":1819,"address":[],"length":0,"stats":{"Line":4}},{"line":1820,"address":[],"length":0,"stats":{"Line":2}},{"line":1821,"address":[],"length":0,"stats":{"Line":2}},{"line":1822,"address":[],"length":0,"stats":{"Line":2}},{"line":1824,"address":[],"length":0,"stats":{"Line":2}},{"line":1825,"address":[],"length":0,"stats":{"Line":4}},{"line":1826,"address":[],"length":0,"stats":{"Line":2}},{"line":1831,"address":[],"length":0,"stats":{"Line":6}},{"line":1832,"address":[],"length":0,"stats":{"Line":4}},{"line":1835,"address":[],"length":0,"stats":{"Line":6}},{"line":1838,"address":[],"length":0,"stats":{"Line":4}},{"line":1841,"address":[],"length":0,"stats":{"Line":4}},{"line":1843,"address":[],"length":0,"stats":{"Line":2}},{"line":1847,"address":[],"length":0,"stats":{"Line":2}},{"line":1849,"address":[],"length":0,"stats":{"Line":6}},{"line":1852,"address":[],"length":0,"stats":{"Line":4}},{"line":1855,"address":[],"length":0,"stats":{"Line":2}},{"line":1856,"address":[],"length":0,"stats":{"Line":4}},{"line":1858,"address":[],"length":0,"stats":{"Line":2}},{"line":1859,"address":[],"length":0,"stats":{"Line":4}},{"line":1860,"address":[],"length":0,"stats":{"Line":8}},{"line":1861,"address":[],"length":0,"stats":{"Line":4}},{"line":1863,"address":[],"length":0,"stats":{"Line":2}},{"line":1864,"address":[],"length":0,"stats":{"Line":2}},{"line":1866,"address":[],"length":0,"stats":{"Line":2}},{"line":1869,"address":[],"length":0,"stats":{"Line":4}},{"line":1870,"address":[],"length":0,"stats":{"Line":2}},{"line":1871,"address":[],"length":0,"stats":{"Line":2}},{"line":1872,"address":[],"length":0,"stats":{"Line":2}},{"line":1874,"address":[],"length":0,"stats":{"Line":2}},{"line":1875,"address":[],"length":0,"stats":{"Line":4}},{"line":1876,"address":[],"length":0,"stats":{"Line":2}},{"line":1881,"address":[],"length":0,"stats":{"Line":6}},{"line":1883,"address":[],"length":0,"stats":{"Line":4}},{"line":1884,"address":[],"length":0,"stats":{"Line":4}},{"line":1885,"address":[],"length":0,"stats":{"Line":2}},{"line":1886,"address":[],"length":0,"stats":{"Line":2}},{"line":1888,"address":[],"length":0,"stats":{"Line":6}},{"line":1891,"address":[],"length":0,"stats":{"Line":0}},{"line":1892,"address":[],"length":0,"stats":{"Line":0}},{"line":1896,"address":[],"length":0,"stats":{"Line":4}},{"line":1897,"address":[],"length":0,"stats":{"Line":2}},{"line":1898,"address":[],"length":0,"stats":{"Line":2}},{"line":1899,"address":[],"length":0,"stats":{"Line":2}},{"line":1900,"address":[],"length":0,"stats":{"Line":2}},{"line":1904,"address":[],"length":0,"stats":{"Line":6}},{"line":1907,"address":[],"length":0,"stats":{"Line":4}},{"line":1909,"address":[],"length":0,"stats":{"Line":2}},{"line":1913,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1918,"address":[],"length":0,"stats":{"Line":0}},{"line":1919,"address":[],"length":0,"stats":{"Line":0}},{"line":1920,"address":[],"length":0,"stats":{"Line":0}},{"line":1921,"address":[],"length":0,"stats":{"Line":0}},{"line":1924,"address":[],"length":0,"stats":{"Line":0}},{"line":1925,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1927,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1931,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1935,"address":[],"length":0,"stats":{"Line":0}},{"line":1939,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":0}},{"line":1941,"address":[],"length":0,"stats":{"Line":0}},{"line":1945,"address":[],"length":0,"stats":{"Line":0}},{"line":1946,"address":[],"length":0,"stats":{"Line":0}},{"line":1947,"address":[],"length":0,"stats":{"Line":0}},{"line":1948,"address":[],"length":0,"stats":{"Line":0}},{"line":1949,"address":[],"length":0,"stats":{"Line":0}},{"line":1950,"address":[],"length":0,"stats":{"Line":0}},{"line":1951,"address":[],"length":0,"stats":{"Line":0}},{"line":1952,"address":[],"length":0,"stats":{"Line":0}},{"line":1954,"address":[],"length":0,"stats":{"Line":0}},{"line":1959,"address":[],"length":0,"stats":{"Line":0}},{"line":1960,"address":[],"length":0,"stats":{"Line":0}},{"line":1961,"address":[],"length":0,"stats":{"Line":0}},{"line":1962,"address":[],"length":0,"stats":{"Line":0}},{"line":1963,"address":[],"length":0,"stats":{"Line":0}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1965,"address":[],"length":0,"stats":{"Line":0}},{"line":1966,"address":[],"length":0,"stats":{"Line":0}},{"line":1967,"address":[],"length":0,"stats":{"Line":0}},{"line":1968,"address":[],"length":0,"stats":{"Line":0}},{"line":1970,"address":[],"length":0,"stats":{"Line":0}},{"line":1975,"address":[],"length":0,"stats":{"Line":0}},{"line":1978,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1983,"address":[],"length":0,"stats":{"Line":0}},{"line":1984,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1988,"address":[],"length":0,"stats":{"Line":0}},{"line":1990,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1994,"address":[],"length":0,"stats":{"Line":0}},{"line":1995,"address":[],"length":0,"stats":{"Line":0}},{"line":1996,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":1999,"address":[],"length":0,"stats":{"Line":0}},{"line":2000,"address":[],"length":0,"stats":{"Line":0}},{"line":2003,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2010,"address":[],"length":0,"stats":{"Line":0}},{"line":2011,"address":[],"length":0,"stats":{"Line":0}},{"line":2012,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2023,"address":[],"length":0,"stats":{"Line":0}},{"line":2025,"address":[],"length":0,"stats":{"Line":0}},{"line":2028,"address":[],"length":0,"stats":{"Line":0}},{"line":2029,"address":[],"length":0,"stats":{"Line":0}},{"line":2032,"address":[],"length":0,"stats":{"Line":0}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2040,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2044,"address":[],"length":0,"stats":{"Line":0}},{"line":2045,"address":[],"length":0,"stats":{"Line":0}},{"line":2046,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2052,"address":[],"length":0,"stats":{"Line":0}},{"line":2053,"address":[],"length":0,"stats":{"Line":0}},{"line":2055,"address":[],"length":0,"stats":{"Line":0}},{"line":2060,"address":[],"length":0,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2063,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2067,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2069,"address":[],"length":0,"stats":{"Line":0}},{"line":2070,"address":[],"length":0,"stats":{"Line":0}},{"line":2071,"address":[],"length":0,"stats":{"Line":0}},{"line":2072,"address":[],"length":0,"stats":{"Line":0}},{"line":2073,"address":[],"length":0,"stats":{"Line":0}},{"line":2078,"address":[],"length":0,"stats":{"Line":0}},{"line":2079,"address":[],"length":0,"stats":{"Line":0}},{"line":2080,"address":[],"length":0,"stats":{"Line":0}},{"line":2081,"address":[],"length":0,"stats":{"Line":0}},{"line":2082,"address":[],"length":0,"stats":{"Line":0}},{"line":2083,"address":[],"length":0,"stats":{"Line":0}},{"line":2084,"address":[],"length":0,"stats":{"Line":0}},{"line":2085,"address":[],"length":0,"stats":{"Line":0}},{"line":2086,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2096,"address":[],"length":0,"stats":{"Line":299}},{"line":2098,"address":[],"length":0,"stats":{"Line":299}},{"line":2099,"address":[],"length":0,"stats":{"Line":299}},{"line":2100,"address":[],"length":0,"stats":{"Line":299}},{"line":2101,"address":[],"length":0,"stats":{"Line":299}},{"line":2102,"address":[],"length":0,"stats":{"Line":299}},{"line":2103,"address":[],"length":0,"stats":{"Line":299}},{"line":2105,"address":[],"length":0,"stats":{"Line":897}},{"line":2109,"address":[],"length":0,"stats":{"Line":377}},{"line":2110,"address":[],"length":0,"stats":{"Line":377}},{"line":2111,"address":[],"length":0,"stats":{"Line":4}},{"line":2113,"address":[],"length":0,"stats":{"Line":16}},{"line":2115,"address":[],"length":0,"stats":{"Line":16}},{"line":2117,"address":[],"length":0,"stats":{"Line":13}},{"line":2119,"address":[],"length":0,"stats":{"Line":52}},{"line":2121,"address":[],"length":0,"stats":{"Line":2}},{"line":2123,"address":[],"length":0,"stats":{"Line":6}},{"line":2125,"address":[],"length":0,"stats":{"Line":11}},{"line":2127,"address":[],"length":0,"stats":{"Line":44}},{"line":2129,"address":[],"length":0,"stats":{"Line":0}},{"line":2133,"address":[],"length":0,"stats":{"Line":0}},{"line":2134,"address":[],"length":0,"stats":{"Line":0}},{"line":2135,"address":[],"length":0,"stats":{"Line":0}},{"line":2136,"address":[],"length":0,"stats":{"Line":0}},{"line":2137,"address":[],"length":0,"stats":{"Line":0}},{"line":2138,"address":[],"length":0,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2140,"address":[],"length":0,"stats":{"Line":0}},{"line":2141,"address":[],"length":0,"stats":{"Line":0}},{"line":2146,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2150,"address":[],"length":0,"stats":{"Line":0}},{"line":2151,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2153,"address":[],"length":0,"stats":{"Line":0}},{"line":2154,"address":[],"length":0,"stats":{"Line":0}},{"line":2156,"address":[],"length":0,"stats":{"Line":0}},{"line":2157,"address":[],"length":0,"stats":{"Line":0}},{"line":2158,"address":[],"length":0,"stats":{"Line":0}},{"line":2162,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2167,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[],"length":0,"stats":{"Line":0}},{"line":2172,"address":[],"length":0,"stats":{"Line":0}},{"line":2173,"address":[],"length":0,"stats":{"Line":0}},{"line":2177,"address":[],"length":0,"stats":{"Line":123}},{"line":2181,"address":[],"length":0,"stats":{"Line":246}},{"line":2182,"address":[],"length":0,"stats":{"Line":216}},{"line":2183,"address":[],"length":0,"stats":{"Line":15}},{"line":2186,"address":[],"length":0,"stats":{"Line":224}},{"line":2194,"address":[],"length":0,"stats":{"Line":417}},{"line":2195,"address":[],"length":0,"stats":{"Line":417}},{"line":2196,"address":[],"length":0,"stats":{"Line":50}},{"line":2197,"address":[],"length":0,"stats":{"Line":100}},{"line":2198,"address":[],"length":0,"stats":{"Line":42}},{"line":2200,"address":[],"length":0,"stats":{"Line":195}},{"line":2202,"address":[],"length":0,"stats":{"Line":39}},{"line":2204,"address":[],"length":0,"stats":{"Line":9}},{"line":2207,"address":[],"length":0,"stats":{"Line":16}},{"line":2210,"address":[],"length":0,"stats":{"Line":26}},{"line":2212,"address":[],"length":0,"stats":{"Line":78}},{"line":2213,"address":[],"length":0,"stats":{"Line":26}},{"line":2215,"address":[],"length":0,"stats":{"Line":64}},{"line":2216,"address":[],"length":0,"stats":{"Line":38}},{"line":2217,"address":[],"length":0,"stats":{"Line":38}},{"line":2218,"address":[],"length":0,"stats":{"Line":152}},{"line":2219,"address":[],"length":0,"stats":{"Line":38}},{"line":2222,"address":[],"length":0,"stats":{"Line":0}},{"line":2226,"address":[],"length":0,"stats":{"Line":26}},{"line":2227,"address":[],"length":0,"stats":{"Line":26}},{"line":2228,"address":[],"length":0,"stats":{"Line":26}},{"line":2230,"address":[],"length":0,"stats":{"Line":26}},{"line":2233,"address":[],"length":0,"stats":{"Line":27}},{"line":2234,"address":[],"length":0,"stats":{"Line":54}},{"line":2235,"address":[],"length":0,"stats":{"Line":246}},{"line":2236,"address":[],"length":0,"stats":{"Line":81}},{"line":2238,"address":[],"length":0,"stats":{"Line":2}},{"line":2239,"address":[],"length":0,"stats":{"Line":8}},{"line":2240,"address":[],"length":0,"stats":{"Line":6}},{"line":2242,"address":[],"length":0,"stats":{"Line":6}},{"line":2243,"address":[],"length":0,"stats":{"Line":24}},{"line":2244,"address":[],"length":0,"stats":{"Line":18}},{"line":2246,"address":[],"length":0,"stats":{"Line":3}},{"line":2247,"address":[],"length":0,"stats":{"Line":33}},{"line":2248,"address":[],"length":0,"stats":{"Line":9}},{"line":2250,"address":[],"length":0,"stats":{"Line":17}},{"line":2252,"address":[],"length":0,"stats":{"Line":51}},{"line":2253,"address":[],"length":0,"stats":{"Line":17}},{"line":2255,"address":[],"length":0,"stats":{"Line":17}},{"line":2256,"address":[],"length":0,"stats":{"Line":9}},{"line":2257,"address":[],"length":0,"stats":{"Line":9}},{"line":2258,"address":[],"length":0,"stats":{"Line":9}},{"line":2259,"address":[],"length":0,"stats":{"Line":33}},{"line":2260,"address":[],"length":0,"stats":{"Line":18}},{"line":2264,"address":[],"length":0,"stats":{"Line":68}},{"line":2267,"address":[],"length":0,"stats":{"Line":17}},{"line":2268,"address":[],"length":0,"stats":{"Line":34}},{"line":2269,"address":[],"length":0,"stats":{"Line":51}},{"line":2270,"address":[],"length":0,"stats":{"Line":17}},{"line":2272,"address":[],"length":0,"stats":{"Line":17}},{"line":2275,"address":[],"length":0,"stats":{"Line":572}},{"line":2281,"address":[],"length":0,"stats":{"Line":16}},{"line":2283,"address":[],"length":0,"stats":{"Line":16}},{"line":2284,"address":[],"length":0,"stats":{"Line":16}},{"line":2285,"address":[],"length":0,"stats":{"Line":16}},{"line":2286,"address":[],"length":0,"stats":{"Line":16}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2299,"address":[],"length":0,"stats":{"Line":0}},{"line":2300,"address":[],"length":0,"stats":{"Line":0}},{"line":2301,"address":[],"length":0,"stats":{"Line":0}},{"line":2305,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2307,"address":[],"length":0,"stats":{"Line":0}},{"line":2308,"address":[],"length":0,"stats":{"Line":0}},{"line":2313,"address":[],"length":0,"stats":{"Line":0}},{"line":2314,"address":[],"length":0,"stats":{"Line":0}},{"line":2315,"address":[],"length":0,"stats":{"Line":0}},{"line":2316,"address":[],"length":0,"stats":{"Line":0}},{"line":2318,"address":[],"length":0,"stats":{"Line":0}},{"line":2320,"address":[],"length":0,"stats":{"Line":0}},{"line":2322,"address":[],"length":0,"stats":{"Line":0}},{"line":2323,"address":[],"length":0,"stats":{"Line":0}},{"line":2324,"address":[],"length":0,"stats":{"Line":0}},{"line":2326,"address":[],"length":0,"stats":{"Line":0}},{"line":2327,"address":[],"length":0,"stats":{"Line":0}},{"line":2328,"address":[],"length":0,"stats":{"Line":0}},{"line":2330,"address":[],"length":0,"stats":{"Line":0}},{"line":2331,"address":[],"length":0,"stats":{"Line":0}},{"line":2333,"address":[],"length":0,"stats":{"Line":0}},{"line":2335,"address":[],"length":0,"stats":{"Line":0}},{"line":2337,"address":[],"length":0,"stats":{"Line":0}},{"line":2342,"address":[],"length":0,"stats":{"Line":81}},{"line":2343,"address":[],"length":0,"stats":{"Line":162}},{"line":2347,"address":[],"length":0,"stats":{"Line":91}},{"line":2352,"address":[],"length":0,"stats":{"Line":91}},{"line":2353,"address":[],"length":0,"stats":{"Line":91}},{"line":2354,"address":[],"length":0,"stats":{"Line":91}},{"line":2359,"address":[],"length":0,"stats":{"Line":6}},{"line":2364,"address":[],"length":0,"stats":{"Line":6}},{"line":2365,"address":[],"length":0,"stats":{"Line":6}},{"line":2366,"address":[],"length":0,"stats":{"Line":6}},{"line":2371,"address":[],"length":0,"stats":{"Line":31}},{"line":2376,"address":[],"length":0,"stats":{"Line":31}},{"line":2377,"address":[],"length":0,"stats":{"Line":31}},{"line":2378,"address":[],"length":0,"stats":{"Line":31}},{"line":2383,"address":[],"length":0,"stats":{"Line":3}},{"line":2390,"address":[],"length":0,"stats":{"Line":6}},{"line":2393,"address":[],"length":0,"stats":{"Line":6}},{"line":2394,"address":[],"length":0,"stats":{"Line":3}},{"line":2395,"address":[],"length":0,"stats":{"Line":18}},{"line":2396,"address":[],"length":0,"stats":{"Line":6}},{"line":2397,"address":[],"length":0,"stats":{"Line":9}},{"line":2398,"address":[],"length":0,"stats":{"Line":18}},{"line":2399,"address":[],"length":0,"stats":{"Line":12}},{"line":2400,"address":[],"length":0,"stats":{"Line":9}},{"line":2401,"address":[],"length":0,"stats":{"Line":9}},{"line":2403,"address":[],"length":0,"stats":{"Line":6}},{"line":2404,"address":[],"length":0,"stats":{"Line":6}},{"line":2405,"address":[],"length":0,"stats":{"Line":6}},{"line":2406,"address":[],"length":0,"stats":{"Line":6}},{"line":2408,"address":[],"length":0,"stats":{"Line":12}},{"line":2409,"address":[],"length":0,"stats":{"Line":3}},{"line":2410,"address":[],"length":0,"stats":{"Line":3}},{"line":2412,"address":[],"length":0,"stats":{"Line":3}},{"line":2413,"address":[],"length":0,"stats":{"Line":18}},{"line":2414,"address":[],"length":0,"stats":{"Line":6}},{"line":2415,"address":[],"length":0,"stats":{"Line":9}},{"line":2416,"address":[],"length":0,"stats":{"Line":18}},{"line":2417,"address":[],"length":0,"stats":{"Line":12}},{"line":2418,"address":[],"length":0,"stats":{"Line":9}},{"line":2419,"address":[],"length":0,"stats":{"Line":9}},{"line":2421,"address":[],"length":0,"stats":{"Line":6}},{"line":2422,"address":[],"length":0,"stats":{"Line":6}},{"line":2423,"address":[],"length":0,"stats":{"Line":6}},{"line":2424,"address":[],"length":0,"stats":{"Line":6}},{"line":2426,"address":[],"length":0,"stats":{"Line":12}},{"line":2427,"address":[],"length":0,"stats":{"Line":3}},{"line":2428,"address":[],"length":0,"stats":{"Line":3}},{"line":2433,"address":[],"length":0,"stats":{"Line":3}},{"line":2434,"address":[],"length":0,"stats":{"Line":3}},{"line":2435,"address":[],"length":0,"stats":{"Line":3}},{"line":2437,"address":[],"length":0,"stats":{"Line":3}},{"line":2440,"address":[],"length":0,"stats":{"Line":12}},{"line":2441,"address":[],"length":0,"stats":{"Line":9}},{"line":2442,"address":[],"length":0,"stats":{"Line":6}},{"line":2443,"address":[],"length":0,"stats":{"Line":3}},{"line":2444,"address":[],"length":0,"stats":{"Line":3}},{"line":2448,"address":[],"length":0,"stats":{"Line":6}},{"line":2449,"address":[],"length":0,"stats":{"Line":3}},{"line":2450,"address":[],"length":0,"stats":{"Line":3}},{"line":2451,"address":[],"length":0,"stats":{"Line":18}},{"line":2452,"address":[],"length":0,"stats":{"Line":3}},{"line":2453,"address":[],"length":0,"stats":{"Line":9}},{"line":2454,"address":[],"length":0,"stats":{"Line":3}},{"line":2456,"address":[],"length":0,"stats":{"Line":3}},{"line":2457,"address":[],"length":0,"stats":{"Line":18}},{"line":2458,"address":[],"length":0,"stats":{"Line":6}},{"line":2459,"address":[],"length":0,"stats":{"Line":9}},{"line":2460,"address":[],"length":0,"stats":{"Line":18}},{"line":2461,"address":[],"length":0,"stats":{"Line":12}},{"line":2462,"address":[],"length":0,"stats":{"Line":9}},{"line":2463,"address":[],"length":0,"stats":{"Line":9}},{"line":2465,"address":[],"length":0,"stats":{"Line":6}},{"line":2466,"address":[],"length":0,"stats":{"Line":6}},{"line":2467,"address":[],"length":0,"stats":{"Line":6}},{"line":2468,"address":[],"length":0,"stats":{"Line":6}},{"line":2470,"address":[],"length":0,"stats":{"Line":12}},{"line":2471,"address":[],"length":0,"stats":{"Line":3}},{"line":2472,"address":[],"length":0,"stats":{"Line":3}},{"line":2477,"address":[],"length":0,"stats":{"Line":3}},{"line":2478,"address":[],"length":0,"stats":{"Line":3}},{"line":2479,"address":[],"length":0,"stats":{"Line":3}},{"line":2481,"address":[],"length":0,"stats":{"Line":3}},{"line":2484,"address":[],"length":0,"stats":{"Line":12}},{"line":2485,"address":[],"length":0,"stats":{"Line":9}},{"line":2486,"address":[],"length":0,"stats":{"Line":6}},{"line":2487,"address":[],"length":0,"stats":{"Line":3}},{"line":2488,"address":[],"length":0,"stats":{"Line":3}},{"line":2493,"address":[],"length":0,"stats":{"Line":0}},{"line":2494,"address":[],"length":0,"stats":{"Line":0}},{"line":2498,"address":[],"length":0,"stats":{"Line":0}},{"line":2499,"address":[],"length":0,"stats":{"Line":0}},{"line":2503,"address":[],"length":0,"stats":{"Line":0}},{"line":2504,"address":[],"length":0,"stats":{"Line":0}},{"line":2508,"address":[],"length":0,"stats":{"Line":0}},{"line":2509,"address":[],"length":0,"stats":{"Line":0}},{"line":2513,"address":[],"length":0,"stats":{"Line":0}},{"line":2516,"address":[],"length":0,"stats":{"Line":0}},{"line":2517,"address":[],"length":0,"stats":{"Line":0}},{"line":2518,"address":[],"length":0,"stats":{"Line":0}},{"line":2519,"address":[],"length":0,"stats":{"Line":0}},{"line":2520,"address":[],"length":0,"stats":{"Line":0}},{"line":2521,"address":[],"length":0,"stats":{"Line":0}},{"line":2525,"address":[],"length":0,"stats":{"Line":0}},{"line":2526,"address":[],"length":0,"stats":{"Line":0}},{"line":2527,"address":[],"length":0,"stats":{"Line":0}},{"line":2530,"address":[],"length":0,"stats":{"Line":0}},{"line":2531,"address":[],"length":0,"stats":{"Line":0}},{"line":2534,"address":[],"length":0,"stats":{"Line":0}},{"line":2537,"address":[],"length":0,"stats":{"Line":0}},{"line":2538,"address":[],"length":0,"stats":{"Line":0}},{"line":2539,"address":[],"length":0,"stats":{"Line":0}},{"line":2540,"address":[],"length":0,"stats":{"Line":0}},{"line":2541,"address":[],"length":0,"stats":{"Line":0}},{"line":2542,"address":[],"length":0,"stats":{"Line":0}},{"line":2543,"address":[],"length":0,"stats":{"Line":0}},{"line":2544,"address":[],"length":0,"stats":{"Line":0}},{"line":2545,"address":[],"length":0,"stats":{"Line":0}},{"line":2546,"address":[],"length":0,"stats":{"Line":0}},{"line":2551,"address":[],"length":0,"stats":{"Line":0}},{"line":2552,"address":[],"length":0,"stats":{"Line":0}},{"line":2555,"address":[],"length":0,"stats":{"Line":0}},{"line":2559,"address":[],"length":0,"stats":{"Line":0}},{"line":2560,"address":[],"length":0,"stats":{"Line":0}},{"line":2561,"address":[],"length":0,"stats":{"Line":0}},{"line":2562,"address":[],"length":0,"stats":{"Line":0}},{"line":2566,"address":[],"length":0,"stats":{"Line":0}},{"line":2567,"address":[],"length":0,"stats":{"Line":0}},{"line":2569,"address":[],"length":0,"stats":{"Line":0}},{"line":2572,"address":[],"length":0,"stats":{"Line":0}},{"line":2574,"address":[],"length":0,"stats":{"Line":0}},{"line":2576,"address":[],"length":0,"stats":{"Line":0}},{"line":2578,"address":[],"length":0,"stats":{"Line":0}},{"line":2581,"address":[],"length":0,"stats":{"Line":0}},{"line":2582,"address":[],"length":0,"stats":{"Line":0}},{"line":2583,"address":[],"length":0,"stats":{"Line":0}},{"line":2584,"address":[],"length":0,"stats":{"Line":0}},{"line":2587,"address":[],"length":0,"stats":{"Line":0}},{"line":2588,"address":[],"length":0,"stats":{"Line":0}},{"line":2589,"address":[],"length":0,"stats":{"Line":0}},{"line":2591,"address":[],"length":0,"stats":{"Line":0}},{"line":2594,"address":[],"length":0,"stats":{"Line":0}},{"line":2595,"address":[],"length":0,"stats":{"Line":0}},{"line":2597,"address":[],"length":0,"stats":{"Line":0}},{"line":2598,"address":[],"length":0,"stats":{"Line":0}},{"line":2601,"address":[],"length":0,"stats":{"Line":0}},{"line":2602,"address":[],"length":0,"stats":{"Line":0}},{"line":2605,"address":[],"length":0,"stats":{"Line":0}},{"line":2608,"address":[],"length":0,"stats":{"Line":0}},{"line":2609,"address":[],"length":0,"stats":{"Line":0}},{"line":2611,"address":[],"length":0,"stats":{"Line":0}},{"line":2612,"address":[],"length":0,"stats":{"Line":0}},{"line":2613,"address":[],"length":0,"stats":{"Line":0}},{"line":2615,"address":[],"length":0,"stats":{"Line":0}},{"line":2616,"address":[],"length":0,"stats":{"Line":0}},{"line":2617,"address":[],"length":0,"stats":{"Line":0}},{"line":2618,"address":[],"length":0,"stats":{"Line":0}},{"line":2620,"address":[],"length":0,"stats":{"Line":0}},{"line":2621,"address":[],"length":0,"stats":{"Line":0}},{"line":2622,"address":[],"length":0,"stats":{"Line":0}},{"line":2623,"address":[],"length":0,"stats":{"Line":0}},{"line":2625,"address":[],"length":0,"stats":{"Line":0}},{"line":2626,"address":[],"length":0,"stats":{"Line":0}},{"line":2627,"address":[],"length":0,"stats":{"Line":0}},{"line":2628,"address":[],"length":0,"stats":{"Line":0}},{"line":2629,"address":[],"length":0,"stats":{"Line":0}},{"line":2631,"address":[],"length":0,"stats":{"Line":0}},{"line":2632,"address":[],"length":0,"stats":{"Line":0}},{"line":2633,"address":[],"length":0,"stats":{"Line":0}},{"line":2634,"address":[],"length":0,"stats":{"Line":0}},{"line":2636,"address":[],"length":0,"stats":{"Line":0}},{"line":2637,"address":[],"length":0,"stats":{"Line":0}},{"line":2638,"address":[],"length":0,"stats":{"Line":0}},{"line":2639,"address":[],"length":0,"stats":{"Line":0}},{"line":2641,"address":[],"length":0,"stats":{"Line":0}},{"line":2642,"address":[],"length":0,"stats":{"Line":0}},{"line":2643,"address":[],"length":0,"stats":{"Line":0}},{"line":2644,"address":[],"length":0,"stats":{"Line":0}},{"line":2645,"address":[],"length":0,"stats":{"Line":0}},{"line":2646,"address":[],"length":0,"stats":{"Line":0}},{"line":2648,"address":[],"length":0,"stats":{"Line":0}},{"line":2649,"address":[],"length":0,"stats":{"Line":0}},{"line":2650,"address":[],"length":0,"stats":{"Line":0}},{"line":2651,"address":[],"length":0,"stats":{"Line":0}},{"line":2653,"address":[],"length":0,"stats":{"Line":0}},{"line":2654,"address":[],"length":0,"stats":{"Line":0}},{"line":2655,"address":[],"length":0,"stats":{"Line":0}},{"line":2656,"address":[],"length":0,"stats":{"Line":0}},{"line":2660,"address":[],"length":0,"stats":{"Line":0}},{"line":2661,"address":[],"length":0,"stats":{"Line":0}},{"line":2662,"address":[],"length":0,"stats":{"Line":0}},{"line":2664,"address":[],"length":0,"stats":{"Line":0}},{"line":2666,"address":[],"length":0,"stats":{"Line":0}},{"line":2671,"address":[],"length":0,"stats":{"Line":0}},{"line":2672,"address":[],"length":0,"stats":{"Line":0}},{"line":2676,"address":[],"length":0,"stats":{"Line":32}},{"line":2677,"address":[],"length":0,"stats":{"Line":96}},{"line":2682,"address":[],"length":0,"stats":{"Line":0}},{"line":2683,"address":[],"length":0,"stats":{"Line":0}}],"covered":779,"coverable":1370},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","type_compat.rs"],"content":"use std::collections::HashSet;\nuse typedlua_parser::ast::expression::Literal;\nuse typedlua_parser::ast::types::{\n    FunctionType, ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind,\n};\n\nfn type_ptr(ty: \u0026Type) -\u003e usize {\n    ty as *const Type as usize\n}\n\n/// Type compatibility checker\npub struct TypeCompatibility;\n\nimpl TypeCompatibility {\n    /// Check if `source` is assignable to `target`\n    pub fn is_assignable(source: \u0026Type, target: \u0026Type) -\u003e bool {\n        let mut visited: HashSet\u003c(usize, usize)\u003e = HashSet::new();\n        Self::is_assignable_recursive(source, target, \u0026mut visited)\n    }\n\n    fn is_assignable_recursive(\n        source: \u0026Type,\n        target: \u0026Type,\n        visited: \u0026mut HashSet\u003c(usize, usize)\u003e,\n    ) -\u003e bool {\n        let source_ptr = type_ptr(source);\n        let target_ptr = type_ptr(target);\n\n        if visited.contains(\u0026(source_ptr, target_ptr)) {\n            return true;\n        }\n        visited.insert((source_ptr, target_ptr));\n\n        // Unknown is assignable to/from anything\n        if matches!(source.kind, TypeKind::Primitive(PrimitiveType::Unknown))\n            || matches!(target.kind, TypeKind::Primitive(PrimitiveType::Unknown))\n        {\n            return true;\n        }\n\n        // Never is assignable to anything\n        if matches!(source.kind, TypeKind::Primitive(PrimitiveType::Never)) {\n            return true;\n        }\n\n        // Nothing is assignable to Never\n        if matches!(target.kind, TypeKind::Primitive(PrimitiveType::Never)) {\n            return false;\n        }\n\n        match (\u0026source.kind, \u0026target.kind) {\n            // Primitive types\n            (TypeKind::Primitive(s), TypeKind::Primitive(t)) =\u003e {\n                Self::is_primitive_assignable(*s, *t)\n            }\n\n            // Literal types\n            (TypeKind::Literal(s_lit), TypeKind::Literal(t_lit)) =\u003e s_lit == t_lit,\n\n            // Literal to primitive\n            (TypeKind::Literal(lit), TypeKind::Primitive(prim)) =\u003e {\n                Self::is_literal_assignable_to_primitive(lit, *prim)\n            }\n\n            // Primitive to literal (reverse direction - primitive nil can satisfy literal nil)\n            (TypeKind::Primitive(PrimitiveType::Nil), TypeKind::Literal(Literal::Nil)) =\u003e true,\n\n            // Also handle the case where source is a union containing nil and target expects literal nil\n            (TypeKind::Union(sources), TypeKind::Literal(Literal::Nil)) =\u003e {\n                // Check if any source member is nil\n                sources\n                    .iter()\n                    .any(|s| Self::is_assignable_recursive(s, target, visited))\n            }\n\n            // Union types\n            (_, TypeKind::Union(targets)) =\u003e {\n                // Source is assignable to union if assignable to any member\n                targets\n                    .iter()\n                    .any(|t| Self::is_assignable_recursive(source, t, visited))\n            }\n            (TypeKind::Union(sources), _) =\u003e {\n                // Union is assignable to target if all members are assignable\n                sources\n                    .iter()\n                    .all(|s| Self::is_assignable_recursive(s, target, visited))\n            }\n\n            // Intersection types\n            (TypeKind::Intersection(sources), _) =\u003e {\n                // Intersection is assignable to target if any member is assignable\n                sources\n                    .iter()\n                    .any(|s| Self::is_assignable_recursive(s, target, visited))\n            }\n            (_, TypeKind::Intersection(targets)) =\u003e {\n                // Source is assignable to intersection if assignable to all members\n                targets\n                    .iter()\n                    .all(|t| Self::is_assignable_recursive(source, t, visited))\n            }\n\n            // Array types\n            (TypeKind::Array(s_elem), TypeKind::Array(t_elem)) =\u003e {\n                Self::is_assignable_recursive(s_elem, t_elem, visited)\n            }\n\n            // Tuple types\n            (TypeKind::Tuple(s_elems), TypeKind::Tuple(t_elems)) =\u003e {\n                if s_elems.len() != t_elems.len() {\n                    return false;\n                }\n                s_elems\n                    .iter()\n                    .zip(t_elems.iter())\n                    .all(|(s, t)| Self::is_assignable_recursive(s, t, visited))\n            }\n\n            // Function types\n            (TypeKind::Function(s_func), TypeKind::Function(t_func)) =\u003e {\n                Self::is_function_assignable(s_func, t_func, visited)\n            }\n\n            // Object types\n            (TypeKind::Object(s_obj), TypeKind::Object(t_obj)) =\u003e {\n                Self::is_object_assignable(s_obj, t_obj, visited)\n            }\n\n            // Nullable types\n            (TypeKind::Nullable(s_inner), TypeKind::Nullable(t_inner)) =\u003e {\n                Self::is_assignable_recursive(s_inner, t_inner, visited)\n            }\n            (TypeKind::Primitive(PrimitiveType::Nil), TypeKind::Nullable(_)) =\u003e true,\n            (_, TypeKind::Nullable(t_inner)) =\u003e {\n                Self::is_assignable_recursive(source, t_inner, visited)\n            }\n\n            // Parenthesized types\n            (TypeKind::Parenthesized(s_inner), _) =\u003e {\n                Self::is_assignable_recursive(s_inner, target, visited)\n            }\n            (_, TypeKind::Parenthesized(t_inner)) =\u003e {\n                Self::is_assignable_recursive(source, t_inner, visited)\n            }\n\n            // Type references\n            // NOTE: Ideally we would resolve type aliases to their underlying types\n            // and check structural compatibility. For now, we use name-based matching.\n            // This means:\n            //   type A = number; type B = number;\n            //   A and B are NOT compatible (should be, but requires type resolution)\n            //\n            // Future enhancement: Pass TypeEnvironment to resolve_type_reference() and\n            // recursively check is_assignable on the resolved types.\n            (TypeKind::Reference(s_ref), TypeKind::Reference(t_ref)) =\u003e {\n                // Check if names match exactly\n                if s_ref.name.node == t_ref.name.node {\n                    // Same type reference name - check type arguments if present\n                    match (\u0026s_ref.type_arguments, \u0026t_ref.type_arguments) {\n                        (None, None) =\u003e true,\n                        (Some(s_args), Some(t_args)) if s_args.len() == t_args.len() =\u003e {\n                            // Check all type arguments are compatible\n                            s_args.iter().zip(t_args.iter()).all(|(s_arg, t_arg)| {\n                                Self::is_assignable_recursive(s_arg, t_arg, visited)\n                            })\n                        }\n                        _ =\u003e false,\n                    }\n                } else {\n                    // Different names - could still be compatible if they resolve to\n                    // the same underlying type, but we don't have type environment here\n                    false\n                }\n            }\n\n            // Type reference vs concrete type - would need type resolution\n            (TypeKind::Reference(_), _) =\u003e {\n                // We can't resolve the reference without a type environment\n                // Conservative: assume incompatible\n                false\n            }\n            (_, TypeKind::Reference(_)) =\u003e {\n                // We can't resolve the reference without a type environment\n                // Conservative: assume incompatible\n                false\n            }\n\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if primitive types are compatible\n    fn is_primitive_assignable(source: PrimitiveType, target: PrimitiveType) -\u003e bool {\n        if source == target {\n            return true;\n        }\n\n        match (source, target) {\n            // Integer is assignable to number\n            (PrimitiveType::Integer, PrimitiveType::Number) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if a literal is assignable to a primitive type\n    fn is_literal_assignable_to_primitive(lit: \u0026Literal, prim: PrimitiveType) -\u003e bool {\n        matches!(\n            (lit, prim),\n            (Literal::Number(_), PrimitiveType::Number)\n                | (Literal::String(_), PrimitiveType::String)\n                | (Literal::Boolean(_), PrimitiveType::Boolean)\n                | (Literal::Nil, PrimitiveType::Nil)\n        )\n    }\n\n    /// Check function type compatibility (contravariant parameters, covariant return)\n    fn is_function_assignable(\n        source: \u0026FunctionType,\n        target: \u0026FunctionType,\n        visited: \u0026mut HashSet\u003c(usize, usize)\u003e,\n    ) -\u003e bool {\n        // Check parameter count\n        if source.parameters.len() != target.parameters.len() {\n            return false;\n        }\n\n        // Parameters are contravariant: target params must be assignable to source params\n        for (s_param, t_param) in source.parameters.iter().zip(target.parameters.iter()) {\n            if let (Some(s_type), Some(t_type)) =\n                (\u0026s_param.type_annotation, \u0026t_param.type_annotation)\n            {\n                if !Self::is_assignable_recursive(t_type, s_type, visited) {\n                    return false;\n                }\n            }\n        }\n\n        // Return type is covariant: source return must be assignable to target return\n        Self::is_assignable_recursive(\u0026source.return_type, \u0026target.return_type, visited)\n    }\n\n    /// Check object type structural compatibility\n    fn is_object_assignable(\n        source: \u0026ObjectType,\n        target: \u0026ObjectType,\n        visited: \u0026mut HashSet\u003c(usize, usize)\u003e,\n    ) -\u003e bool {\n        // For each property in target, source must have a compatible property\n        for t_member in \u0026target.members {\n            match t_member {\n                ObjectTypeMember::Property(t_prop) =\u003e {\n                    // Find corresponding property in source\n                    let found = source.members.iter().any(|s_member| {\n                        if let ObjectTypeMember::Property(s_prop) = s_member {\n                            s_prop.name.node == t_prop.name.node\n                                \u0026\u0026 Self::is_assignable_recursive(\n                                    \u0026s_prop.type_annotation,\n                                    \u0026t_prop.type_annotation,\n                                    visited,\n                                )\n                        } else {\n                            false\n                        }\n                    });\n\n                    if !found \u0026\u0026 !t_prop.is_optional {\n                        return false;\n                    }\n                }\n                ObjectTypeMember::Method(t_method) =\u003e {\n                    // Find corresponding method in source\n                    let found = source.members.iter().any(|s_member| {\n                        if let ObjectTypeMember::Method(s_method) = s_member {\n                            s_method.name.node == t_method.name.node\n                        } else {\n                            false\n                        }\n                    });\n\n                    if !found {\n                        return false;\n                    }\n                }\n                ObjectTypeMember::Index(_) =\u003e {}\n            }\n        }\n\n        true\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    fn make_type(kind: TypeKind) -\u003e Type {\n        Type::new(kind, Span::new(0, 0, 0, 0))\n    }\n\n    #[test]\n    fn test_primitive_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let integer = make_type(TypeKind::Primitive(PrimitiveType::Integer));\n\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026number));\n        assert!(!TypeCompatibility::is_assignable(\u0026number, \u0026string));\n        assert!(TypeCompatibility::is_assignable(\u0026integer, \u0026number));\n        assert!(!TypeCompatibility::is_assignable(\u0026number, \u0026integer));\n    }\n\n    #[test]\n    fn test_literal_assignability() {\n        let num_lit = make_type(TypeKind::Literal(Literal::Number(42.0)));\n        let str_lit = make_type(TypeKind::Literal(Literal::String(\"hello\".to_string())));\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n\n        assert!(TypeCompatibility::is_assignable(\u0026num_lit, \u0026number));\n        assert!(!TypeCompatibility::is_assignable(\u0026num_lit, \u0026string));\n        assert!(TypeCompatibility::is_assignable(\u0026str_lit, \u0026string));\n        assert!(!TypeCompatibility::is_assignable(\u0026str_lit, \u0026number));\n    }\n\n    #[test]\n    fn test_union_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let number_or_string = make_type(TypeKind::Union(vec![number.clone(), string.clone()]));\n\n        // number is assignable to number | string\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026number_or_string));\n        // string is assignable to number | string\n        assert!(TypeCompatibility::is_assignable(\u0026string, \u0026number_or_string));\n    }\n\n    #[test]\n    fn test_array_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let number_array = make_type(TypeKind::Array(Box::new(number.clone())));\n        let string_array = make_type(TypeKind::Array(Box::new(string.clone())));\n\n        assert!(TypeCompatibility::is_assignable(\n            \u0026number_array,\n            \u0026number_array\n        ));\n        assert!(!TypeCompatibility::is_assignable(\n            \u0026number_array,\n            \u0026string_array\n        ));\n    }\n\n    #[test]\n    fn test_nullable_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let nullable_number = make_type(TypeKind::Nullable(Box::new(number.clone())));\n        let nil = make_type(TypeKind::Primitive(PrimitiveType::Nil));\n\n        // nil is assignable to number?\n        assert!(TypeCompatibility::is_assignable(\u0026nil, \u0026nullable_number));\n        // number is assignable to number?\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026nullable_number));\n    }\n\n    #[test]\n    fn test_unknown_assignability() {\n        let unknown = make_type(TypeKind::Primitive(PrimitiveType::Unknown));\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n\n        // unknown is assignable to/from anything\n        assert!(TypeCompatibility::is_assignable(\u0026unknown, \u0026number));\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026unknown));\n    }\n\n    #[test]\n    fn test_parenthesized_type() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let parenthesized = make_type(TypeKind::Parenthesized(Box::new(number.clone())));\n\n        // Parenthesized type should be same as inner type\n        assert!(TypeCompatibility::is_assignable(\u0026parenthesized, \u0026number));\n        assert!(TypeCompatibility::is_assignable(\u0026number, \u0026parenthesized));\n    }\n\n    #[test]\n    fn test_literal_nil_to_nullable() {\n        let nil_type = make_type(TypeKind::Primitive(PrimitiveType::Nil));\n        let nullable_string = make_type(TypeKind::Nullable(Box::new(make_type(\n            TypeKind::Primitive(PrimitiveType::String),\n        ))));\n\n        // nil is assignable to nullable string\n        assert!(TypeCompatibility::is_assignable(\n            \u0026nil_type,\n            \u0026nullable_string\n        ));\n    }\n\n    #[test]\n    fn test_tuple_assignability() {\n        let number = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string = make_type(TypeKind::Primitive(PrimitiveType::String));\n\n        let tuple1 = make_type(TypeKind::Tuple(vec![number.clone(), string.clone()]));\n        let tuple2 = make_type(TypeKind::Tuple(vec![number.clone(), string.clone()]));\n\n        // Same tuples should be assignable\n        assert!(TypeCompatibility::is_assignable(\u0026tuple1, \u0026tuple2));\n\n        let tuple_diff = make_type(TypeKind::Tuple(vec![number.clone(), number.clone()]));\n        assert!(!TypeCompatibility::is_assignable(\u0026tuple_diff, \u0026tuple1));\n    }\n\n    #[test]\n    fn test_function_with_throws() {\n        let func1 = make_type(TypeKind::Function(FunctionType {\n            parameters: vec![],\n            return_type: Box::new(make_type(TypeKind::Primitive(PrimitiveType::Number))),\n            throws: None,\n            span: Span::new(0, 0, 0, 0),\n            type_parameters: None,\n        }));\n        let func2 = make_type(TypeKind::Function(FunctionType {\n            parameters: vec![],\n            return_type: Box::new(make_type(TypeKind::Primitive(PrimitiveType::Number))),\n            throws: None,\n            span: Span::new(0, 0, 0, 0),\n            type_parameters: None,\n        }));\n\n        // Functions should be compatible\n        assert!(TypeCompatibility::is_assignable(\u0026func1, \u0026func2));\n    }\n}\n","traces":[{"line":7,"address":[],"length":0,"stats":{"Line":718}},{"line":8,"address":[],"length":0,"stats":{"Line":718}},{"line":16,"address":[],"length":0,"stats":{"Line":269}},{"line":17,"address":[],"length":0,"stats":{"Line":807}},{"line":18,"address":[],"length":0,"stats":{"Line":1076}},{"line":21,"address":[],"length":0,"stats":{"Line":359}},{"line":26,"address":[],"length":0,"stats":{"Line":1077}},{"line":27,"address":[],"length":0,"stats":{"Line":1077}},{"line":29,"address":[],"length":0,"stats":{"Line":1077}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":1077}},{"line":35,"address":[],"length":0,"stats":{"Line":476}},{"line":36,"address":[],"length":0,"stats":{"Line":572}},{"line":38,"address":[],"length":0,"stats":{"Line":9}},{"line":42,"address":[],"length":0,"stats":{"Line":466}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":568}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":700}},{"line":53,"address":[],"length":0,"stats":{"Line":210}},{"line":54,"address":[],"length":0,"stats":{"Line":315}},{"line":58,"address":[],"length":0,"stats":{"Line":96}},{"line":61,"address":[],"length":0,"stats":{"Line":216}},{"line":62,"address":[],"length":0,"stats":{"Line":324}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":22}},{"line":79,"address":[],"length":0,"stats":{"Line":22}},{"line":81,"address":[],"length":0,"stats":{"Line":166}},{"line":83,"address":[],"length":0,"stats":{"Line":6}},{"line":85,"address":[],"length":0,"stats":{"Line":6}},{"line":87,"address":[],"length":0,"stats":{"Line":38}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":93,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":18}},{"line":97,"address":[],"length":0,"stats":{"Line":3}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":105,"address":[],"length":0,"stats":{"Line":4}},{"line":106,"address":[],"length":0,"stats":{"Line":8}},{"line":110,"address":[],"length":0,"stats":{"Line":4}},{"line":111,"address":[],"length":0,"stats":{"Line":6}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":4}},{"line":116,"address":[],"length":0,"stats":{"Line":4}},{"line":117,"address":[],"length":0,"stats":{"Line":18}},{"line":121,"address":[],"length":0,"stats":{"Line":18}},{"line":122,"address":[],"length":0,"stats":{"Line":36}},{"line":126,"address":[],"length":0,"stats":{"Line":22}},{"line":127,"address":[],"length":0,"stats":{"Line":44}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":2}},{"line":135,"address":[],"length":0,"stats":{"Line":3}},{"line":136,"address":[],"length":0,"stats":{"Line":12}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":4}},{"line":156,"address":[],"length":0,"stats":{"Line":44}},{"line":158,"address":[],"length":0,"stats":{"Line":22}},{"line":160,"address":[],"length":0,"stats":{"Line":44}},{"line":161,"address":[],"length":0,"stats":{"Line":22}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":173,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":186,"address":[],"length":0,"stats":{"Line":10}},{"line":189,"address":[],"length":0,"stats":{"Line":5}},{"line":194,"address":[],"length":0,"stats":{"Line":105}},{"line":195,"address":[],"length":0,"stats":{"Line":105}},{"line":196,"address":[],"length":0,"stats":{"Line":77}},{"line":199,"address":[],"length":0,"stats":{"Line":56}},{"line":201,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":27}},{"line":207,"address":[],"length":0,"stats":{"Line":108}},{"line":208,"address":[],"length":0,"stats":{"Line":13}},{"line":209,"address":[],"length":0,"stats":{"Line":216}},{"line":218,"address":[],"length":0,"stats":{"Line":9}},{"line":224,"address":[],"length":0,"stats":{"Line":27}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":33}},{"line":230,"address":[],"length":0,"stats":{"Line":6}},{"line":231,"address":[],"length":0,"stats":{"Line":6}},{"line":233,"address":[],"length":0,"stats":{"Line":9}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":36}},{"line":244,"address":[],"length":0,"stats":{"Line":11}},{"line":250,"address":[],"length":0,"stats":{"Line":45}},{"line":251,"address":[],"length":0,"stats":{"Line":17}},{"line":252,"address":[],"length":0,"stats":{"Line":17}},{"line":254,"address":[],"length":0,"stats":{"Line":73}},{"line":255,"address":[],"length":0,"stats":{"Line":44}},{"line":256,"address":[],"length":0,"stats":{"Line":22}},{"line":257,"address":[],"length":0,"stats":{"Line":16}},{"line":258,"address":[],"length":0,"stats":{"Line":16}},{"line":259,"address":[],"length":0,"stats":{"Line":16}},{"line":260,"address":[],"length":0,"stats":{"Line":16}},{"line":263,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":18}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":11}}],"covered":87,"coverable":114},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","core","type_environment.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::{ConstructorParameter, TypeParameter};\nuse typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\nuse typedlua_parser::span::Span;\n\n/// A generic type alias with type parameters\n#[derive(Debug, Clone)]\npub struct GenericTypeAlias {\n    pub type_parameters: Vec\u003cTypeParameter\u003e,\n    pub typ: Type,\n}\n\n/// Type environment managing type aliases and interfaces\n#[derive(Debug)]\npub struct TypeEnvironment {\n    /// Type aliases (type Foo = ...)\n    type_aliases: FxHashMap\u003cString, Type\u003e,\n    /// Generic type aliases (type Foo\u003cT\u003e = ...)\n    generic_type_aliases: FxHashMap\u003cString, GenericTypeAlias\u003e,\n    /// Interface types\n    interfaces: FxHashMap\u003cString, Type\u003e,\n    /// Built-in types\n    builtins: FxHashMap\u003cString, Type\u003e,\n    /// Currently resolving types (for cycle detection)\n    resolving: std::cell::RefCell\u003cstd::collections::HashSet\u003cString\u003e\u003e,\n    /// Type parameter constraints (T -\u003e constraint type)\n    type_param_constraints: FxHashMap\u003cString, Type\u003e,\n    /// Class implements relationships (class name -\u003e list of implemented interface types)\n    class_implements: FxHashMap\u003cString, Vec\u003cType\u003e\u003e,\n    /// Abstract classes (class name -\u003e is_abstract)\n    abstract_classes: FxHashMap\u003cString, bool\u003e,\n    /// Class primary constructors (class name -\u003e constructor parameters)\n    class_constructors: FxHashMap\u003cString, Vec\u003cConstructorParameter\u003e\u003e,\n    /// Interface type parameter names (interface name -\u003e ordered parameter names)\n    interface_type_params: FxHashMap\u003cString, Vec\u003cString\u003e\u003e,\n}\n\nimpl TypeEnvironment {\n    pub fn new() -\u003e Self {\n        let mut env = Self {\n            type_aliases: FxHashMap::default(),\n            generic_type_aliases: FxHashMap::default(),\n            interfaces: FxHashMap::default(),\n            builtins: FxHashMap::default(),\n            resolving: std::cell::RefCell::new(std::collections::HashSet::new()),\n            type_param_constraints: FxHashMap::default(),\n            class_implements: FxHashMap::default(),\n            abstract_classes: FxHashMap::default(),\n            class_constructors: FxHashMap::default(),\n            interface_type_params: FxHashMap::default(),\n        };\n\n        env.register_builtins();\n        env\n    }\n\n    /// Register built-in types\n    fn register_builtins(\u0026mut self) {\n        let span = Span::new(0, 0, 0, 0);\n\n        // Primitive types\n        self.builtins.insert(\n            \"nil\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Nil), span),\n        );\n        self.builtins.insert(\n            \"boolean\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span),\n        );\n        self.builtins.insert(\n            \"number\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n        );\n        self.builtins.insert(\n            \"integer\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Integer), span),\n        );\n        self.builtins.insert(\n            \"string\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::String), span),\n        );\n        self.builtins.insert(\n            \"unknown\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span),\n        );\n        self.builtins.insert(\n            \"never\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Never), span),\n        );\n        self.builtins.insert(\n            \"void\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Void), span),\n        );\n        self.builtins.insert(\n            \"table\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Table), span),\n        );\n        self.builtins.insert(\n            \"coroutine\".to_string(),\n            Type::new(TypeKind::Primitive(PrimitiveType::Coroutine), span),\n        );\n    }\n\n    /// Register a type alias\n    pub fn register_type_alias(\u0026mut self, name: String, typ: Type) -\u003e Result\u003c(), String\u003e {\n        if self.type_aliases.contains_key(\u0026name) {\n            return Err(format!(\"Type alias '{}' already defined\", name));\n        }\n        self.type_aliases.insert(name, typ);\n        Ok(())\n    }\n\n    /// Remove a type alias (used for cleaning up scoped type parameters)\n    pub fn remove_type_alias(\u0026mut self, name: \u0026str) {\n        self.type_aliases.remove(name);\n    }\n\n    /// Register a generic type alias\n    pub fn register_generic_type_alias(\n        \u0026mut self,\n        name: String,\n        type_parameters: Vec\u003cTypeParameter\u003e,\n        typ: Type,\n    ) -\u003e Result\u003c(), String\u003e {\n        if self.generic_type_aliases.contains_key(\u0026name) {\n            return Err(format!(\"Generic type alias '{}' already defined\", name));\n        }\n        self.generic_type_aliases.insert(\n            name,\n            GenericTypeAlias {\n                type_parameters,\n                typ,\n            },\n        );\n        Ok(())\n    }\n\n    /// Register an interface\n    pub fn register_interface(\u0026mut self, name: String, typ: Type) -\u003e Result\u003c(), String\u003e {\n        if self.interfaces.contains_key(\u0026name) {\n            return Err(format!(\"Interface '{}' already defined\", name));\n        }\n        self.interfaces.insert(name.clone(), typ);\n        Ok(())\n    }\n\n    /// Register the type parameter names for a generic interface.\n    pub fn register_interface_type_params(\u0026mut self, name: String, params: Vec\u003cString\u003e) {\n        self.interface_type_params.insert(name, params);\n    }\n\n    /// Get the type parameter names for a generic interface.\n    pub fn get_interface_type_params(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cString\u003e\u003e {\n        self.interface_type_params.get(name)\n    }\n\n    /// Look up a type by name (checks type aliases, interfaces, and builtins)\n    pub fn lookup_type(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_aliases\n            .get(name)\n            .or_else(|| self.interfaces.get(name))\n            .or_else(|| self.builtins.get(name))\n    }\n\n    /// Look up a type alias\n    pub fn lookup_type_alias(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_aliases.get(name)\n    }\n\n    /// Look up an interface\n    pub fn lookup_interface(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.interfaces.get(name)\n    }\n\n    /// Get an interface (alias for lookup_interface)\n    pub fn get_interface(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.lookup_interface(name)\n    }\n\n    /// Check if a type name is defined\n    pub fn is_type_defined(\u0026self, name: \u0026str) -\u003e bool {\n        self.lookup_type(name).is_some()\n    }\n\n    /// Register a type parameter constraint (e.g., T extends/implements Identifiable)\n    pub fn register_type_param_constraint(\u0026mut self, name: String, constraint: Type) {\n        self.type_param_constraints.insert(name, constraint);\n    }\n\n    /// Remove a type parameter constraint\n    pub fn remove_type_param_constraint(\u0026mut self, name: \u0026str) {\n        self.type_param_constraints.remove(name);\n    }\n\n    /// Get the constraint for a type parameter\n    pub fn get_type_param_constraint(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Type\u003e {\n        self.type_param_constraints.get(name)\n    }\n\n    /// Register that a class implements one or more interfaces\n    pub fn register_class_implements(\u0026mut self, class_name: String, interfaces: Vec\u003cType\u003e) {\n        self.class_implements.insert(class_name, interfaces);\n    }\n\n    /// Get the interfaces a class implements\n    pub fn get_class_implements(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cType\u003e\u003e {\n        self.class_implements.get(class_name)\n    }\n\n    /// Register a class as abstract\n    pub fn register_abstract_class(\u0026mut self, class_name: String) {\n        self.abstract_classes.insert(class_name, true);\n    }\n\n    /// Check if a class is abstract\n    pub fn is_abstract_class(\u0026self, class_name: \u0026str) -\u003e bool {\n        self.abstract_classes\n            .get(class_name)\n            .copied()\n            .unwrap_or(false)\n    }\n\n    /// Register a class's primary constructor parameters\n    pub fn register_class_constructor(\n        \u0026mut self,\n        class_name: String,\n        params: Vec\u003cConstructorParameter\u003e,\n    ) {\n        self.class_constructors.insert(class_name, params);\n    }\n\n    /// Get a class's primary constructor parameters\n    pub fn get_class_constructor(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cConstructorParameter\u003e\u003e {\n        self.class_constructors.get(class_name)\n    }\n\n    /// Resolve a type reference, detecting cycles\n    pub fn resolve_type_reference(\u0026self, name: \u0026str) -\u003e Result\u003cOption\u003cType\u003e, String\u003e {\n        // Check if we're already resolving this type (cycle detection)\n        if self.resolving.borrow().contains(name) {\n            return Err(format!(\"Recursive type alias '{}' detected\", name));\n        }\n\n        // Mark as resolving\n        self.resolving.borrow_mut().insert(name.to_string());\n\n        // Look up the type\n        let result = self.lookup_type(name).cloned();\n\n        // Unmark\n        self.resolving.borrow_mut().remove(name);\n\n        Ok(result)\n    }\n\n    /// Get a generic type alias\n    pub fn get_generic_type_alias(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026GenericTypeAlias\u003e {\n        self.generic_type_aliases.get(name)\n    }\n\n    /// Check if a name is a built-in utility type\n    pub fn is_utility_type(name: \u0026str) -\u003e bool {\n        matches!(\n            name,\n            \"Partial\"\n                | \"Required\"\n                | \"Readonly\"\n                | \"Record\"\n                | \"Pick\"\n                | \"Omit\"\n                | \"Exclude\"\n                | \"Extract\"\n                | \"NonNilable\"\n                | \"Nilable\"\n                | \"ReturnType\"\n                | \"Parameters\"\n        )\n    }\n\n    /// Resolve a utility type with type arguments\n    pub fn resolve_utility_type(\n        \u0026self,\n        name: \u0026str,\n        type_args: \u0026[Type],\n        span: Span,\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n        common_ids: \u0026typedlua_parser::string_interner::CommonIdentifiers,\n    ) -\u003e Result\u003cType, String\u003e {\n        use crate::types::utility_types::apply_utility_type;\n        apply_utility_type(name, type_args, span, interner, common_ids)\n    }\n}\n\nimpl Default for TypeEnvironment {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_builtins_registered() {\n        let env = TypeEnvironment::new();\n\n        assert!(env.lookup_type(\"number\").is_some());\n        assert!(env.lookup_type(\"string\").is_some());\n        assert!(env.lookup_type(\"boolean\").is_some());\n        assert!(env.lookup_type(\"nil\").is_some());\n        assert!(env.lookup_type(\"unknown\").is_some());\n        assert!(env.lookup_type(\"never\").is_some());\n        assert!(env.lookup_type(\"void\").is_some());\n    }\n\n    #[test]\n    fn test_register_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_type_alias(\"MyNumber\".to_string(), typ)\n            .unwrap();\n\n        assert!(env.lookup_type(\"MyNumber\").is_some());\n        assert!(env.lookup_type_alias(\"MyNumber\").is_some());\n    }\n\n    #[test]\n    fn test_register_interface() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Table),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_interface(\"MyInterface\".to_string(), typ)\n            .unwrap();\n\n        assert!(env.lookup_type(\"MyInterface\").is_some());\n        assert!(env.lookup_interface(\"MyInterface\").is_some());\n    }\n\n    #[test]\n    fn test_duplicate_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_type_alias(\"Foo\".to_string(), typ.clone())\n            .unwrap();\n        assert!(env.register_type_alias(\"Foo\".to_string(), typ).is_err());\n    }\n\n    #[test]\n    fn test_all_builtins_registered() {\n        let env = TypeEnvironment::new();\n\n        let builtins = vec![\n            \"nil\",\n            \"boolean\",\n            \"number\",\n            \"integer\",\n            \"string\",\n            \"unknown\",\n            \"never\",\n            \"void\",\n            \"table\",\n            \"coroutine\",\n        ];\n\n        for builtin in \u0026builtins {\n            assert!(\n                env.lookup_type(builtin).is_some(),\n                \"Builtin type '{}' should be registered\",\n                builtin\n            );\n        }\n    }\n\n    #[test]\n    fn test_is_type_defined() {\n        let mut env = TypeEnvironment::new();\n\n        // Builtins should be defined\n        assert!(env.is_type_defined(\"number\"));\n        assert!(env.is_type_defined(\"string\"));\n\n        // Custom types should not be defined initially\n        assert!(!env.is_type_defined(\"MyType\"));\n\n        // Register custom type\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_type_alias(\"MyType\".to_string(), typ).unwrap();\n\n        // Now it should be defined\n        assert!(env.is_type_defined(\"MyType\"));\n    }\n\n    #[test]\n    fn test_lookup_type_alias_priority() {\n        let mut env = TypeEnvironment::new();\n\n        // Register interface with same name as type alias\n        let alias_type = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_type_alias(\"Foo\".to_string(), alias_type.clone())\n            .unwrap();\n\n        let interface_type = Type::new(\n            TypeKind::Primitive(PrimitiveType::String),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_interface(\"Foo\".to_string(), interface_type.clone())\n            .unwrap();\n\n        // Type aliases take priority over interfaces in lookup_type\n        let found = env.lookup_type(\"Foo\").unwrap();\n        match \u0026found.kind {\n            TypeKind::Primitive(PrimitiveType::Number) =\u003e (), // Type alias\n            TypeKind::Primitive(PrimitiveType::String) =\u003e {\n                panic!(\"Should have found type alias, not interface\")\n            }\n            _ =\u003e panic!(\"Unexpected type\"),\n        }\n    }\n\n    #[test]\n    fn test_register_generic_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        // Create a proper TypeParameter with StringId\n        use typedlua_parser::ast::Spanned;\n        use typedlua_parser::string_interner::StringInterner;\n\n        let interner = StringInterner::new();\n        let t_id = interner.get_or_intern(\"T\");\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, Span::new(0, 1, 1, 0)),\n            constraint: None,\n            default: None,\n            span: Span::new(0, 1, 1, 0),\n        };\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_generic_type_alias(\"Container\".to_string(), vec![type_param], typ)\n            .unwrap();\n\n        let generic_alias = env.get_generic_type_alias(\"Container\");\n        assert!(generic_alias.is_some());\n        assert_eq!(generic_alias.unwrap().type_parameters.len(), 1);\n    }\n\n    #[test]\n    fn test_duplicate_generic_type_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_generic_type_alias(\"Box\".to_string(), vec![], typ.clone())\n            .unwrap();\n        assert!(env\n            .register_generic_type_alias(\"Box\".to_string(), vec![], typ)\n            .is_err());\n    }\n\n    #[test]\n    fn test_duplicate_interface() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Table),\n            Span::new(0, 0, 0, 0),\n        );\n\n        env.register_interface(\"MyInterface\".to_string(), typ.clone())\n            .unwrap();\n        assert!(env\n            .register_interface(\"MyInterface\".to_string(), typ)\n            .is_err());\n    }\n\n    #[test]\n    fn test_resolve_type_reference_success() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_type_alias(\"MyNumber\".to_string(), typ)\n            .unwrap();\n\n        let resolved = env.resolve_type_reference(\"MyNumber\");\n        assert!(resolved.is_ok());\n        assert!(resolved.unwrap().is_some());\n    }\n\n    #[test]\n    fn test_resolve_type_reference_not_found() {\n        let env = TypeEnvironment::new();\n\n        let resolved = env.resolve_type_reference(\"NonExistent\");\n        assert!(resolved.is_ok());\n        assert!(resolved.unwrap().is_none());\n    }\n\n    #[test]\n    fn test_resolve_type_reference_cycle() {\n        let env = TypeEnvironment::new();\n\n        // Create a self-referencing type alias\n        // Note: This requires the type to reference itself, which is tricky\n        // with the current API. For now, we'll just test that the cycle\n        // detection mechanism works by manually marking a type as resolving.\n        env.resolving.borrow_mut().insert(\"Cycle\".to_string());\n\n        let result = env.resolve_type_reference(\"Cycle\");\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Recursive type alias\"));\n\n        // Clean up\n        env.resolving.borrow_mut().remove(\"Cycle\");\n    }\n\n    #[test]\n    fn test_is_utility_type() {\n        let utility_types = vec![\n            \"Partial\",\n            \"Required\",\n            \"Readonly\",\n            \"Record\",\n            \"Pick\",\n            \"Omit\",\n            \"Exclude\",\n            \"Extract\",\n            \"NonNilable\",\n            \"Nilable\",\n            \"ReturnType\",\n            \"Parameters\",\n        ];\n\n        for utility in \u0026utility_types {\n            assert!(\n                TypeEnvironment::is_utility_type(utility),\n                \"'{}' should be recognized as utility type\",\n                utility\n            );\n        }\n\n        let non_utility_types = vec![\"number\", \"string\", \"Array\", \"Map\", \"MyType\"];\n\n        for non_utility in \u0026non_utility_types {\n            assert!(\n                !TypeEnvironment::is_utility_type(non_utility),\n                \"'{}' should not be recognized as utility type\",\n                non_utility\n            );\n        }\n    }\n\n    #[test]\n    fn test_get_interface_alias() {\n        let mut env = TypeEnvironment::new();\n\n        let typ = Type::new(\n            TypeKind::Primitive(PrimitiveType::Table),\n            Span::new(0, 0, 0, 0),\n        );\n        env.register_interface(\"User\".to_string(), typ.clone())\n            .unwrap();\n\n        // get_interface should be an alias for lookup_interface\n        assert!(env.get_interface(\"User\").is_some());\n        assert!(env.get_interface(\"NonExistent\").is_none());\n    }\n\n    #[test]\n    fn test_default_impl() {\n        let env: TypeEnvironment = Default::default();\n        assert!(env.lookup_type(\"number\").is_some());\n    }\n\n    #[test]\n    fn test_multiple_type_aliases() {\n        let mut env = TypeEnvironment::new();\n\n        let types = vec![\n            (\"Int\", PrimitiveType::Integer),\n            (\"Float\", PrimitiveType::Number),\n            (\"Bool\", PrimitiveType::Boolean),\n            (\"Str\", PrimitiveType::String),\n        ];\n\n        for (name, prim) in \u0026types {\n            let typ = Type::new(TypeKind::Primitive(*prim), Span::new(0, 0, 0, 0));\n            env.register_type_alias(name.to_string(), typ).unwrap();\n        }\n\n        for (name, _) in \u0026types {\n            assert!(env.lookup_type(name).is_some());\n        }\n    }\n\n    #[test]\n    fn test_type_not_found_returns_none() {\n        let env = TypeEnvironment::new();\n\n        assert!(env.lookup_type(\"UnknownType\").is_none());\n        assert!(env.lookup_type_alias(\"UnknownType\").is_none());\n        assert!(env.lookup_interface(\"UnknownType\").is_none());\n        assert!(env.get_generic_type_alias(\"UnknownType\").is_none());\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":356}},{"line":41,"address":[],"length":0,"stats":{"Line":712}},{"line":42,"address":[],"length":0,"stats":{"Line":712}},{"line":43,"address":[],"length":0,"stats":{"Line":712}},{"line":44,"address":[],"length":0,"stats":{"Line":712}},{"line":45,"address":[],"length":0,"stats":{"Line":1068}},{"line":46,"address":[],"length":0,"stats":{"Line":712}},{"line":47,"address":[],"length":0,"stats":{"Line":712}},{"line":48,"address":[],"length":0,"stats":{"Line":712}},{"line":49,"address":[],"length":0,"stats":{"Line":356}},{"line":50,"address":[],"length":0,"stats":{"Line":356}},{"line":53,"address":[],"length":0,"stats":{"Line":712}},{"line":54,"address":[],"length":0,"stats":{"Line":356}},{"line":58,"address":[],"length":0,"stats":{"Line":356}},{"line":59,"address":[],"length":0,"stats":{"Line":712}},{"line":62,"address":[],"length":0,"stats":{"Line":712}},{"line":63,"address":[],"length":0,"stats":{"Line":712}},{"line":64,"address":[],"length":0,"stats":{"Line":1068}},{"line":66,"address":[],"length":0,"stats":{"Line":712}},{"line":67,"address":[],"length":0,"stats":{"Line":712}},{"line":68,"address":[],"length":0,"stats":{"Line":1068}},{"line":70,"address":[],"length":0,"stats":{"Line":712}},{"line":71,"address":[],"length":0,"stats":{"Line":712}},{"line":72,"address":[],"length":0,"stats":{"Line":1068}},{"line":74,"address":[],"length":0,"stats":{"Line":712}},{"line":75,"address":[],"length":0,"stats":{"Line":712}},{"line":76,"address":[],"length":0,"stats":{"Line":1068}},{"line":78,"address":[],"length":0,"stats":{"Line":712}},{"line":79,"address":[],"length":0,"stats":{"Line":712}},{"line":80,"address":[],"length":0,"stats":{"Line":1068}},{"line":82,"address":[],"length":0,"stats":{"Line":712}},{"line":83,"address":[],"length":0,"stats":{"Line":712}},{"line":84,"address":[],"length":0,"stats":{"Line":1068}},{"line":86,"address":[],"length":0,"stats":{"Line":712}},{"line":87,"address":[],"length":0,"stats":{"Line":712}},{"line":88,"address":[],"length":0,"stats":{"Line":1068}},{"line":90,"address":[],"length":0,"stats":{"Line":712}},{"line":91,"address":[],"length":0,"stats":{"Line":712}},{"line":92,"address":[],"length":0,"stats":{"Line":1068}},{"line":94,"address":[],"length":0,"stats":{"Line":712}},{"line":95,"address":[],"length":0,"stats":{"Line":712}},{"line":96,"address":[],"length":0,"stats":{"Line":1068}},{"line":98,"address":[],"length":0,"stats":{"Line":712}},{"line":99,"address":[],"length":0,"stats":{"Line":712}},{"line":100,"address":[],"length":0,"stats":{"Line":1068}},{"line":105,"address":[],"length":0,"stats":{"Line":179}},{"line":106,"address":[],"length":0,"stats":{"Line":537}},{"line":107,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":708}},{"line":110,"address":[],"length":0,"stats":{"Line":177}},{"line":114,"address":[],"length":0,"stats":{"Line":44}},{"line":115,"address":[],"length":0,"stats":{"Line":132}},{"line":119,"address":[],"length":0,"stats":{"Line":29}},{"line":125,"address":[],"length":0,"stats":{"Line":87}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":56}},{"line":129,"address":[],"length":0,"stats":{"Line":28}},{"line":130,"address":[],"length":0,"stats":{"Line":28}},{"line":131,"address":[],"length":0,"stats":{"Line":28}},{"line":132,"address":[],"length":0,"stats":{"Line":28}},{"line":135,"address":[],"length":0,"stats":{"Line":28}},{"line":139,"address":[],"length":0,"stats":{"Line":42}},{"line":140,"address":[],"length":0,"stats":{"Line":126}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":143,"address":[],"length":0,"stats":{"Line":200}},{"line":144,"address":[],"length":0,"stats":{"Line":40}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":8}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":197}},{"line":159,"address":[],"length":0,"stats":{"Line":197}},{"line":160,"address":[],"length":0,"stats":{"Line":394}},{"line":161,"address":[],"length":0,"stats":{"Line":401}},{"line":162,"address":[],"length":0,"stats":{"Line":359}},{"line":166,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":6}},{"line":171,"address":[],"length":0,"stats":{"Line":9}},{"line":172,"address":[],"length":0,"stats":{"Line":27}},{"line":176,"address":[],"length":0,"stats":{"Line":7}},{"line":177,"address":[],"length":0,"stats":{"Line":21}},{"line":181,"address":[],"length":0,"stats":{"Line":4}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":4}},{"line":191,"address":[],"length":0,"stats":{"Line":15}},{"line":192,"address":[],"length":0,"stats":{"Line":45}},{"line":196,"address":[],"length":0,"stats":{"Line":8}},{"line":197,"address":[],"length":0,"stats":{"Line":24}},{"line":201,"address":[],"length":0,"stats":{"Line":4}},{"line":202,"address":[],"length":0,"stats":{"Line":16}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":4}},{"line":212,"address":[],"length":0,"stats":{"Line":12}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":3}},{"line":240,"address":[],"length":0,"stats":{"Line":6}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":245,"address":[],"length":0,"stats":{"Line":6}},{"line":248,"address":[],"length":0,"stats":{"Line":10}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":257,"address":[],"length":0,"stats":{"Line":27}},{"line":258,"address":[],"length":0,"stats":{"Line":81}},{"line":262,"address":[],"length":0,"stats":{"Line":64}},{"line":263,"address":[],"length":0,"stats":{"Line":34}},{"line":264,"address":[],"length":0,"stats":{"Line":64}},{"line":281,"address":[],"length":0,"stats":{"Line":22}},{"line":290,"address":[],"length":0,"stats":{"Line":132}},{"line":295,"address":[],"length":0,"stats":{"Line":1}},{"line":296,"address":[],"length":0,"stats":{"Line":1}}],"covered":107,"coverable":118},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","helpers","control_flow.rs"],"content":"//! Control flow analysis utilities\n//!\n//! This module provides utilities for analyzing control flow in TypedLua programs,\n//! including checking whether code paths always return or terminate.\n\nuse typedlua_parser::ast::expression::ExpressionKind;\nuse typedlua_parser::ast::statement::{Block, Statement};\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Check if a block always returns (has a return statement on all code paths).\n///\n/// This function recursively analyzes statements in a block to determine if\n/// every possible execution path ends with a return statement or other terminating\n/// statement (like throw).\n///\n/// # Parameters\n///\n/// - `block`: The block to analyze\n/// - `interner`: String interner for resolving function names\n///\n/// # Returns\n///\n/// Returns `true` if the block always returns on all code paths, `false` otherwise.\npub fn block_always_returns(block: \u0026Block, interner: \u0026StringInterner) -\u003e bool {\n    for stmt in \u0026block.statements {\n        if statement_always_returns(stmt, interner) {\n            return true;\n        }\n    }\n    false\n}\n\n/// Check if a statement always returns.\n///\n/// This function analyzes whether a statement will definitely result in a return\n/// or termination on all possible execution paths.\n///\n/// # Parameters\n///\n/// - `stmt`: The statement to analyze\n/// - `interner`: String interner for resolving function names\n///\n/// # Returns\n///\n/// Returns `true` if the statement always returns/terminates, `false` otherwise.\n///\n/// # Analyzed Statement Types\n///\n/// - **Return**: Always returns\n/// - **Throw**: Always terminates\n/// - **If**: Returns if both then and else branches return\n/// - **Try-catch**: Returns if finally returns, OR if try + all catches return\n/// - **Expression**: Returns if calling a known non-returning function (unreachable, error, throw)\npub fn statement_always_returns(stmt: \u0026Statement, interner: \u0026StringInterner) -\u003e bool {\n    match stmt {\n        Statement::Return(_) =\u003e true,\n        Statement::If(if_stmt) =\u003e {\n            // If statement always returns if both branches always return\n            let then_returns = block_always_returns(\u0026if_stmt.then_block, interner);\n            let else_returns = if_stmt\n                .else_block\n                .as_ref()\n                .map(|b| block_always_returns(b, interner))\n                .unwrap_or(false);\n            then_returns \u0026\u0026 else_returns\n        }\n        Statement::Try(try_stmt) =\u003e {\n            // Try-catch always returns if:\n            // 1. Finally block always returns (catches all paths), OR\n            // 2. Try block always returns AND all catch blocks always return\n            if let Some(ref finally) = try_stmt.finally_block {\n                if block_always_returns(finally, interner) {\n                    return true;\n                }\n            }\n\n            // Check try block and all catch blocks\n            let try_returns = block_always_returns(\u0026try_stmt.try_block, interner);\n            let all_catches_return = try_stmt\n                .catch_clauses\n                .iter()\n                .all(|catch| block_always_returns(\u0026catch.body, interner));\n\n            try_returns \u0026\u0026 all_catches_return \u0026\u0026 !try_stmt.catch_clauses.is_empty()\n        }\n        Statement::Throw(_) =\u003e true,\n        Statement::Expression(expr) =\u003e {\n            // Check if the expression is a call to a function that never returns\n            // (like unreachable(), error(), throw)\n            if let ExpressionKind::Call(callee, _, _) = \u0026expr.kind {\n                if let ExpressionKind::Identifier(string_id) = \u0026callee.kind {\n                    let name = interner.resolve(*string_id);\n                    name == \"unreachable\" || name == \"error\" || name == \"throw\"\n                } else {\n                    false\n                }\n            } else {\n                false\n            }\n        }\n        _ =\u003e false,\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":32}},{"line":25,"address":[],"length":0,"stats":{"Line":66}},{"line":26,"address":[],"length":0,"stats":{"Line":99}},{"line":27,"address":[],"length":0,"stats":{"Line":32}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":33}},{"line":55,"address":[],"length":0,"stats":{"Line":33}},{"line":56,"address":[],"length":0,"stats":{"Line":32}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":101,"address":[],"length":0,"stats":{"Line":1}}],"covered":8,"coverable":32},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","helpers","mod.rs"],"content":"//! Helper modules for the type checker\n//!\n//! This module contains extracted utility functions and helpers that are reusable\n//! and have clear separation of concerns from the main type checker logic.\n\npub mod control_flow;\npub mod type_utilities;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","helpers","type_utilities.rs"],"content":"//! Pure type utility functions\n//!\n//! This module contains pure utility functions for working with types that\n//! don't require access to type checker state.\n//!\n//! These functions are meant to be used by the type checker and other modules\n//! as part of the refactoring effort to reduce cognitive load.\n\n#![allow(dead_code)] // Functions will be used during type_checker.rs refactoring\n\nuse typedlua_parser::ast::expression::*;\nuse typedlua_parser::ast::statement::*;\nuse typedlua_parser::ast::types::*;\n\n/// Widens literal types to their base primitive types.\n///\n/// Converts literal types (e.g., `42`, `\"hello\"`, `true`, `nil`) to their base\n/// primitive types (`number`, `string`, `boolean`, `nil`). Non-literal types are\n/// returned unchanged.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// // 42  number\n/// // \"hello\"  string\n/// // true  boolean\n/// // nil  nil\n/// // number  number (unchanged)\n/// ```\npub fn widen_type(typ: Type) -\u003e Type {\n    match typ.kind {\n        TypeKind::Literal(Literal::Number(_)) | TypeKind::Literal(Literal::Integer(_)) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), typ.span)\n        }\n        TypeKind::Literal(Literal::String(_)) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::String), typ.span)\n        }\n        TypeKind::Literal(Literal::Boolean(_)) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::Boolean), typ.span)\n        }\n        TypeKind::Literal(Literal::Nil) =\u003e {\n            Type::new(TypeKind::Primitive(PrimitiveType::Nil), typ.span)\n        }\n        _ =\u003e typ,\n    }\n}\n\n/// Checks if a type is the boolean primitive type.\n///\n/// # Returns\n///\n/// `true` if the type is `boolean`, `false` otherwise.\npub fn is_boolean_type(typ: \u0026Type) -\u003e bool {\n    matches!(typ.kind, TypeKind::Primitive(PrimitiveType::Boolean))\n}\n\n/// Maps operator kinds to their Lua metamethod names.\n///\n/// # Examples\n///\n/// ```rust,ignore\n/// operator_kind_name(\u0026OperatorKind::Add) // \"__add\"\n/// operator_kind_name(\u0026OperatorKind::Subtract) // \"__sub\"\n/// operator_kind_name(\u0026OperatorKind::Index) // \"__index\"\n/// ```\npub fn operator_kind_name(op: \u0026OperatorKind) -\u003e String {\n    match op {\n        OperatorKind::Add =\u003e \"__add\",\n        OperatorKind::Subtract =\u003e \"__sub\",\n        OperatorKind::Multiply =\u003e \"__mul\",\n        OperatorKind::Divide =\u003e \"__div\",\n        OperatorKind::FloorDivide =\u003e \"__idiv\",\n        OperatorKind::Modulo =\u003e \"__mod\",\n        OperatorKind::Power =\u003e \"__pow\",\n        OperatorKind::Concatenate =\u003e \"__concat\",\n        OperatorKind::Equal =\u003e \"__eq\",\n        OperatorKind::NotEqual =\u003e \"__ne\",\n        OperatorKind::LessThan =\u003e \"__lt\",\n        OperatorKind::LessThanOrEqual =\u003e \"__le\",\n        OperatorKind::GreaterThan =\u003e \"__gt\",\n        OperatorKind::GreaterThanOrEqual =\u003e \"__ge\",\n        OperatorKind::Length =\u003e \"__len\",\n        OperatorKind::UnaryMinus =\u003e \"__unm\",\n        OperatorKind::BitwiseAnd =\u003e \"__band\",\n        OperatorKind::BitwiseOr =\u003e \"__bor\",\n        OperatorKind::BitwiseXor =\u003e \"__bxor\",\n        OperatorKind::ShiftLeft =\u003e \"__shl\",\n        OperatorKind::ShiftRight =\u003e \"__shr\",\n        OperatorKind::Index =\u003e \"__index\",\n        OperatorKind::NewIndex =\u003e \"__newindex\",\n        OperatorKind::Call =\u003e \"__call\",\n    }\n    .to_string()\n}\n\n/// Converts a type to a human-readable string representation for error messages.\n///\n/// This provides a simplified string representation of types for diagnostic output.\npub fn type_to_string(typ: \u0026Type) -\u003e String {\n    match \u0026typ.kind {\n        TypeKind::Primitive(prim) =\u003e format!(\"{:?}\", prim).to_lowercase(),\n        TypeKind::Literal(lit) =\u003e match lit {\n            Literal::String(s) =\u003e format!(\"\\\"{}\\\"\", s),\n            Literal::Number(n) =\u003e n.to_string(),\n            Literal::Integer(i) =\u003e i.to_string(),\n            Literal::Boolean(b) =\u003e b.to_string(),\n            Literal::Nil =\u003e \"nil\".to_string(),\n        },\n        TypeKind::Array(elem_type) =\u003e format!(\"{}[]\", type_to_string(elem_type)),\n        TypeKind::Tuple(types) =\u003e {\n            let type_strs: Vec\u003c_\u003e = types.iter().map(type_to_string).collect();\n            format!(\"[{}]\", type_strs.join(\", \"))\n        }\n        TypeKind::Union(types) =\u003e {\n            let type_strs: Vec\u003c_\u003e = types.iter().map(type_to_string).collect();\n            type_strs.join(\" | \")\n        }\n        TypeKind::Intersection(types) =\u003e {\n            let type_strs: Vec\u003c_\u003e = types.iter().map(type_to_string).collect();\n            type_strs.join(\" \u0026 \")\n        }\n        TypeKind::Nullable(inner) =\u003e format!(\"{}?\", type_to_string(inner)),\n        TypeKind::Function(_) =\u003e \"function\".to_string(),\n        TypeKind::Object(_) =\u003e \"object\".to_string(),\n        TypeKind::Reference(_) =\u003e \"type reference\".to_string(),\n        TypeKind::Infer(_) =\u003e \"infer type\".to_string(),\n        TypeKind::KeyOf(_) =\u003e \"keyof\".to_string(),\n        TypeKind::TypeQuery(_) =\u003e \"typeof\".to_string(),\n        TypeKind::IndexAccess(_, _) =\u003e \"indexed access type\".to_string(),\n        TypeKind::Conditional(_) =\u003e \"conditional type\".to_string(),\n        TypeKind::Mapped(_) =\u003e \"mapped type\".to_string(),\n        TypeKind::TemplateLiteral(_) =\u003e \"template literal type\".to_string(),\n        TypeKind::TypePredicate(_) =\u003e \"type predicate\".to_string(),\n        TypeKind::Parenthesized(inner) =\u003e type_to_string(inner),\n        TypeKind::Variadic(inner) =\u003e format!(\"...{}\", type_to_string(inner)),\n        TypeKind::Namespace(_) =\u003e \"namespace\".to_string(),\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    fn make_type(kind: TypeKind) -\u003e Type {\n        Type::new(kind, Span::default())\n    }\n\n    #[test]\n    fn test_widen_type_string_literal() {\n        let literal = make_type(TypeKind::Literal(Literal::String(\"hello\".to_string())));\n        let widened = widen_type(literal);\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_widen_type_number_literal() {\n        let literal = make_type(TypeKind::Literal(Literal::Number(42.0)));\n        let widened = widen_type(literal);\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_widen_type_boolean_literal() {\n        let literal = make_type(TypeKind::Literal(Literal::Boolean(true)));\n        let widened = widen_type(literal);\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_widen_type_non_literal_unchanged() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let widened = widen_type(number_type.clone());\n        assert!(matches!(\n            widened.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_is_boolean_type_true() {\n        let bool_type = make_type(TypeKind::Primitive(PrimitiveType::Boolean));\n        assert!(is_boolean_type(\u0026bool_type));\n    }\n\n    #[test]\n    fn test_is_boolean_type_false() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        assert!(!is_boolean_type(\u0026number_type));\n    }\n\n    #[test]\n    fn test_operator_kind_name() {\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Add), \"__add\");\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Subtract), \"__sub\");\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Index), \"__index\");\n        assert_eq!(operator_kind_name(\u0026OperatorKind::Call), \"__call\");\n    }\n\n    #[test]\n    fn test_type_to_string_primitives() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        assert_eq!(type_to_string(\u0026number_type), \"number\");\n\n        let string_type = make_type(TypeKind::Primitive(PrimitiveType::String));\n        assert_eq!(type_to_string(\u0026string_type), \"string\");\n    }\n\n    #[test]\n    fn test_type_to_string_literals() {\n        let str_literal = make_type(TypeKind::Literal(Literal::String(\"hello\".to_string())));\n        assert_eq!(type_to_string(\u0026str_literal), \"\\\"hello\\\"\");\n\n        let num_literal = make_type(TypeKind::Literal(Literal::Number(42.0)));\n        assert_eq!(type_to_string(\u0026num_literal), \"42\");\n    }\n\n    #[test]\n    fn test_type_to_string_array() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let array_type = make_type(TypeKind::Array(Box::new(number_type)));\n        assert_eq!(type_to_string(\u0026array_type), \"number[]\");\n    }\n\n    #[test]\n    fn test_type_to_string_union() {\n        let number_type = make_type(TypeKind::Primitive(PrimitiveType::Number));\n        let string_type = make_type(TypeKind::Primitive(PrimitiveType::String));\n        let union_type = make_type(TypeKind::Union(vec![number_type, string_type]));\n        assert_eq!(type_to_string(\u0026union_type), \"number | string\");\n    }\n}\n","traces":[{"line":30,"address":[],"length":0,"stats":{"Line":85}},{"line":31,"address":[],"length":0,"stats":{"Line":31}},{"line":33,"address":[],"length":0,"stats":{"Line":51}},{"line":36,"address":[],"length":0,"stats":{"Line":36}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":54}},{"line":53,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[],"length":0,"stats":{"Line":3}},{"line":66,"address":[],"length":0,"stats":{"Line":4}},{"line":67,"address":[],"length":0,"stats":{"Line":4}},{"line":68,"address":[],"length":0,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":1}},{"line":99,"address":[],"length":0,"stats":{"Line":9}},{"line":100,"address":[],"length":0,"stats":{"Line":9}},{"line":101,"address":[],"length":0,"stats":{"Line":15}},{"line":102,"address":[],"length":0,"stats":{"Line":4}},{"line":103,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":3}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":5}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[],"length":0,"stats":{"Line":1}},{"line":115,"address":[],"length":0,"stats":{"Line":5}},{"line":116,"address":[],"length":0,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}}],"covered":24,"coverable":69},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","lib.rs"],"content":"pub mod cli;\npub mod core;\npub mod helpers;\npub mod module_resolver;\npub mod phases;\npub mod state;\npub mod stdlib;\npub mod types;\npub mod utils;\npub mod visitors;\n\npub use core::type_checker::TypeChecker;\npub use core::type_compat::TypeCompatibility;\npub use core::type_environment::TypeEnvironment;\npub use state::TypeCheckerState;\npub use types::generics::{\n    build_substitutions, check_type_constraints, infer_type_arguments,\n    instantiate_function_declaration, instantiate_type,\n};\npub use types::utility_types::{\n    apply_utility_type, evaluate_conditional_type, evaluate_keyof, evaluate_mapped_type,\n    evaluate_template_literal_type,\n};\npub use utils::symbol_table::{\n    Scope, SerializableSymbol, SerializableSymbolTable, Symbol, SymbolKind, SymbolTable,\n};\npub use visitors::{narrow_type_from_condition, NarrowingContext};\n\nuse typedlua_parser::span::Span;\n\n/// Type checker error\n#[derive(Debug, Clone)]\npub struct TypeCheckError {\n    pub message: String,\n    pub span: Span,\n}\n\nimpl TypeCheckError {\n    pub fn new(message: impl Into\u003cString\u003e, span: Span) -\u003e Self {\n        Self {\n            message: message.into(),\n            span,\n        }\n    }\n}\n\nimpl std::fmt::Display for TypeCheckError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        write!(\n            f,\n            \"{} at {}:{}\",\n            self.message, self.span.line, self.span.column\n        )\n    }\n}\n\nimpl std::error::Error for TypeCheckError {}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":46}},{"line":41,"address":[],"length":0,"stats":{"Line":92}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}}],"covered":2,"coverable":5},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","dependency_graph.rs"],"content":"use super::error::{ModuleError, ModuleId};\nuse rustc_hash::{FxHashMap, FxHashSet};\n\n/// Dependency graph for module compilation ordering\n#[derive(Debug)]\npub struct DependencyGraph {\n    /// Adjacency list: module_id -\u003e dependencies\n    edges: FxHashMap\u003cModuleId, Vec\u003cModuleId\u003e\u003e,\n    /// All known modules\n    nodes: FxHashSet\u003cModuleId\u003e,\n}\n\nimpl DependencyGraph {\n    pub fn new() -\u003e Self {\n        Self {\n            edges: FxHashMap::default(),\n            nodes: FxHashSet::default(),\n        }\n    }\n\n    /// Add a module and its dependencies to the graph\n    pub fn add_module(\u0026mut self, id: ModuleId, dependencies: Vec\u003cModuleId\u003e) {\n        self.nodes.insert(id.clone());\n        for dep in \u0026dependencies {\n            self.nodes.insert(dep.clone());\n        }\n        self.edges.insert(id, dependencies);\n    }\n\n    /// Perform topological sort to determine compilation order\n    ///\n    /// Returns modules in dependency order (dependencies first)\n    /// or an error if a circular dependency is detected\n    pub fn topological_sort(\u0026self) -\u003e Result\u003cVec\u003cModuleId\u003e, ModuleError\u003e {\n        let mut sorted = Vec::new();\n        let mut visited = FxHashSet::default();\n        let mut visiting = FxHashSet::default();\n\n        for node in \u0026self.nodes {\n            if !visited.contains(node) {\n                self.visit(\n                    node,\n                    \u0026mut visited,\n                    \u0026mut visiting,\n                    \u0026mut sorted,\n                    \u0026mut Vec::new(),\n                )?;\n            }\n        }\n\n        Ok(sorted)\n    }\n\n    /// DFS visit for topological sort with cycle detection\n    fn visit(\n        \u0026self,\n        node: \u0026ModuleId,\n        visited: \u0026mut FxHashSet\u003cModuleId\u003e,\n        visiting: \u0026mut FxHashSet\u003cModuleId\u003e,\n        sorted: \u0026mut Vec\u003cModuleId\u003e,\n        path: \u0026mut Vec\u003cModuleId\u003e,\n    ) -\u003e Result\u003c(), ModuleError\u003e {\n        if visiting.contains(node) {\n            // Circular dependency detected - extract cycle from path\n            let cycle_start = path.iter().position(|n| n == node).unwrap();\n            let mut cycle: Vec\u003cModuleId\u003e = path[cycle_start..].to_vec();\n            cycle.push(node.clone());\n            return Err(ModuleError::CircularDependency { cycle });\n        }\n\n        if visited.contains(node) {\n            return Ok(());\n        }\n\n        visiting.insert(node.clone());\n        path.push(node.clone());\n\n        // Visit dependencies\n        if let Some(deps) = self.edges.get(node) {\n            for dep in deps {\n                self.visit(dep, visited, visiting, sorted, path)?;\n            }\n        }\n\n        path.pop();\n        visiting.remove(node);\n        visited.insert(node.clone());\n        sorted.push(node.clone());\n\n        Ok(())\n    }\n\n    /// Get direct dependencies of a module\n    pub fn get_dependencies(\u0026self, id: \u0026ModuleId) -\u003e Option\u003c\u0026Vec\u003cModuleId\u003e\u003e {\n        self.edges.get(id)\n    }\n\n    /// Check if the graph contains a module\n    pub fn contains(\u0026self, id: \u0026ModuleId) -\u003e bool {\n        self.nodes.contains(id)\n    }\n\n    /// Get all modules in the graph\n    pub fn modules(\u0026self) -\u003e impl Iterator\u003cItem = \u0026ModuleId\u003e {\n        self.nodes.iter()\n    }\n}\n\nimpl Default for DependencyGraph {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n\n    fn make_id(name: \u0026str) -\u003e ModuleId {\n        ModuleId::new(PathBuf::from(name))\n    }\n\n    #[test]\n    fn test_simple_topological_sort() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on b, b depends on c\n        graph.add_module(make_id(\"c\"), vec![]);\n        graph.add_module(make_id(\"b\"), vec![make_id(\"c\")]);\n        graph.add_module(make_id(\"a\"), vec![make_id(\"b\")]);\n\n        let sorted = graph.topological_sort().unwrap();\n\n        // c should come before b, b before a\n        let c_pos = sorted.iter().position(|id| id.as_str() == \"c\").unwrap();\n        let b_pos = sorted.iter().position(|id| id.as_str() == \"b\").unwrap();\n        let a_pos = sorted.iter().position(|id| id.as_str() == \"a\").unwrap();\n\n        assert!(c_pos \u003c b_pos);\n        assert!(b_pos \u003c a_pos);\n    }\n\n    #[test]\n    fn test_diamond_dependency() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on b and c, both b and c depend on d\n        graph.add_module(make_id(\"d\"), vec![]);\n        graph.add_module(make_id(\"b\"), vec![make_id(\"d\")]);\n        graph.add_module(make_id(\"c\"), vec![make_id(\"d\")]);\n        graph.add_module(make_id(\"a\"), vec![make_id(\"b\"), make_id(\"c\")]);\n\n        let sorted = graph.topological_sort().unwrap();\n\n        // d should come before b and c, both should come before a\n        let d_pos = sorted.iter().position(|id| id.as_str() == \"d\").unwrap();\n        let b_pos = sorted.iter().position(|id| id.as_str() == \"b\").unwrap();\n        let c_pos = sorted.iter().position(|id| id.as_str() == \"c\").unwrap();\n        let a_pos = sorted.iter().position(|id| id.as_str() == \"a\").unwrap();\n\n        assert!(d_pos \u003c b_pos);\n        assert!(d_pos \u003c c_pos);\n        assert!(b_pos \u003c a_pos);\n        assert!(c_pos \u003c a_pos);\n    }\n\n    #[test]\n    fn test_circular_dependency_detected() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on b, b depends on c, c depends on a (cycle)\n        graph.add_module(make_id(\"a\"), vec![make_id(\"b\")]);\n        graph.add_module(make_id(\"b\"), vec![make_id(\"c\")]);\n        graph.add_module(make_id(\"c\"), vec![make_id(\"a\")]);\n\n        let result = graph.topological_sort();\n\n        assert!(result.is_err());\n        if let Err(ModuleError::CircularDependency { cycle }) = result {\n            assert!(cycle.len() \u003e= 3);\n            // Verify cycle contains a, b, c\n            assert!(cycle.iter().any(|id| id.as_str() == \"a\"));\n            assert!(cycle.iter().any(|id| id.as_str() == \"b\"));\n            assert!(cycle.iter().any(|id| id.as_str() == \"c\"));\n        } else {\n            panic!(\"Expected CircularDependency error\");\n        }\n    }\n\n    #[test]\n    fn test_self_dependency() {\n        let mut graph = DependencyGraph::new();\n\n        // a depends on itself\n        graph.add_module(make_id(\"a\"), vec![make_id(\"a\")]);\n\n        let result = graph.topological_sort();\n\n        assert!(result.is_err());\n        if let Err(ModuleError::CircularDependency { cycle }) = result {\n            assert_eq!(cycle.len(), 2); // [a, a]\n            assert_eq!(cycle[0].as_str(), \"a\");\n        } else {\n            panic!(\"Expected CircularDependency error\");\n        }\n    }\n\n    #[test]\n    fn test_no_dependencies() {\n        let mut graph = DependencyGraph::new();\n\n        graph.add_module(make_id(\"a\"), vec![]);\n        graph.add_module(make_id(\"b\"), vec![]);\n        graph.add_module(make_id(\"c\"), vec![]);\n\n        let sorted = graph.topological_sort().unwrap();\n\n        assert_eq!(sorted.len(), 3);\n        // Order doesn't matter since there are no dependencies\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":5}},{"line":16,"address":[],"length":0,"stats":{"Line":5}},{"line":17,"address":[],"length":0,"stats":{"Line":5}},{"line":22,"address":[],"length":0,"stats":{"Line":14}},{"line":23,"address":[],"length":0,"stats":{"Line":56}},{"line":24,"address":[],"length":0,"stats":{"Line":44}},{"line":25,"address":[],"length":0,"stats":{"Line":30}},{"line":27,"address":[],"length":0,"stats":{"Line":56}},{"line":34,"address":[],"length":0,"stats":{"Line":5}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":37,"address":[],"length":0,"stats":{"Line":10}},{"line":39,"address":[],"length":0,"stats":{"Line":27}},{"line":40,"address":[],"length":0,"stats":{"Line":24}},{"line":41,"address":[],"length":0,"stats":{"Line":22}},{"line":42,"address":[],"length":0,"stats":{"Line":11}},{"line":43,"address":[],"length":0,"stats":{"Line":11}},{"line":44,"address":[],"length":0,"stats":{"Line":11}},{"line":45,"address":[],"length":0,"stats":{"Line":11}},{"line":46,"address":[],"length":0,"stats":{"Line":11}},{"line":51,"address":[],"length":0,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":21}},{"line":63,"address":[],"length":0,"stats":{"Line":63}},{"line":65,"address":[],"length":0,"stats":{"Line":12}},{"line":66,"address":[],"length":0,"stats":{"Line":8}},{"line":67,"address":[],"length":0,"stats":{"Line":8}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":57}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":56}},{"line":76,"address":[],"length":0,"stats":{"Line":56}},{"line":79,"address":[],"length":0,"stats":{"Line":42}},{"line":80,"address":[],"length":0,"stats":{"Line":30}},{"line":81,"address":[],"length":0,"stats":{"Line":74}},{"line":85,"address":[],"length":0,"stats":{"Line":20}},{"line":86,"address":[],"length":0,"stats":{"Line":30}},{"line":87,"address":[],"length":0,"stats":{"Line":40}},{"line":88,"address":[],"length":0,"stats":{"Line":40}},{"line":90,"address":[],"length":0,"stats":{"Line":10}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}}],"covered":39,"coverable":47},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","error.rs"],"content":"use std::fmt;\nuse std::path::PathBuf;\n\n/// Errors that can occur during module resolution\n#[derive(Debug, Clone)]\npub enum ModuleError {\n    /// Module not found despite searching multiple paths\n    NotFound {\n        source: String,\n        searched_paths: Vec\u003cPathBuf\u003e,\n    },\n\n    /// Circular dependency detected\n    CircularDependency { cycle: Vec\u003cModuleId\u003e },\n\n    /// Invalid module path\n    InvalidPath { source: String, reason: String },\n\n    /// I/O error during module resolution\n    IoError { path: PathBuf, message: String },\n\n    /// Module not yet compiled (dependency ordering issue)\n    NotCompiled { id: ModuleId },\n\n    /// Export not found in module\n    ExportNotFound {\n        module_id: ModuleId,\n        export_name: String,\n    },\n}\n\nimpl fmt::Display for ModuleError {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        match self {\n            ModuleError::NotFound {\n                source,\n                searched_paths,\n            } =\u003e {\n                writeln!(f, \"Cannot find module '{}'\", source)?;\n                writeln!(f, \"Searched paths:\")?;\n                for path in searched_paths {\n                    writeln!(f, \"  - {}\", path.display())?;\n                }\n                Ok(())\n            }\n            ModuleError::CircularDependency { cycle } =\u003e {\n                writeln!(f, \"Circular dependency detected:\")?;\n                for (i, id) in cycle.iter().enumerate() {\n                    if i == cycle.len() - 1 {\n                        writeln!(f, \"  {} -\u003e {} (cycle)\", id, cycle[0])?;\n                    } else {\n                        writeln!(f, \"  {} -\u003e\", id)?;\n                    }\n                }\n                Ok(())\n            }\n            ModuleError::InvalidPath { source, reason } =\u003e {\n                write!(f, \"Invalid module path '{}': {}\", source, reason)\n            }\n            ModuleError::IoError { path, message } =\u003e {\n                write!(f, \"I/O error reading '{}': {}\", path.display(), message)\n            }\n            ModuleError::NotCompiled { id } =\u003e {\n                write!(f, \"Module '{}' has not been compiled yet\", id)\n            }\n            ModuleError::ExportNotFound {\n                module_id,\n                export_name,\n            } =\u003e {\n                write!(\n                    f,\n                    \"Module '{}' does not export '{}'\",\n                    module_id, export_name\n                )\n            }\n        }\n    }\n}\n\nimpl std::error::Error for ModuleError {}\n\n/// Unique identifier for a module (canonicalized absolute path)\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\npub struct ModuleId(PathBuf);\n\nimpl ModuleId {\n    pub fn new(path: PathBuf) -\u003e Self {\n        Self(path)\n    }\n\n    pub fn path(\u0026self) -\u003e \u0026PathBuf {\n        \u0026self.0\n    }\n\n    pub fn as_str(\u0026self) -\u003e \u0026str {\n        self.0.to_str().unwrap_or(\"\u003cinvalid utf-8\u003e\")\n    }\n}\n\nimpl fmt::Display for ModuleId {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter\u003c'_\u003e) -\u003e fmt::Result {\n        write!(f, \"{}\", self.0.display())\n    }\n}\n\nimpl From\u003cPathBuf\u003e for ModuleId {\n    fn from(path: PathBuf) -\u003e Self {\n        Self(path)\n    }\n}\n\n/// Type of module based on file extension\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ModuleKind {\n    /// .tl file (TypedLua source)\n    Typed,\n    /// .d.tl file (Type declaration only)\n    Declaration,\n    /// .lua file (Plain Lua, policy-dependent)\n    PlainLua,\n}\n\nimpl ModuleKind {\n    pub fn from_extension(ext: \u0026str) -\u003e Option\u003cSelf\u003e {\n        match ext {\n            \"tl\" =\u003e Some(Self::Typed),\n            \"lua\" =\u003e Some(Self::PlainLua),\n            _ =\u003e {\n                // Check for .d.tl\n                if ext.ends_with(\".d.tl\") {\n                    Some(Self::Declaration)\n                } else {\n                    None\n                }\n            }\n        }\n    }\n\n    pub fn extension(\u0026self) -\u003e \u0026'static str {\n        match self {\n            Self::Typed =\u003e \"tl\",\n            Self::Declaration =\u003e \"d.tl\",\n            Self::PlainLua =\u003e \"lua\",\n        }\n    }\n}\n","traces":[{"line":33,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[],"length":0,"stats":{"Line":0}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":30}},{"line":88,"address":[],"length":0,"stats":{"Line":30}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":29}},{"line":96,"address":[],"length":0,"stats":{"Line":58}},{"line":101,"address":[],"length":0,"stats":{"Line":0}},{"line":102,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}}],"covered":8,"coverable":48},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","mod.rs"],"content":"pub mod dependency_graph;\npub mod error;\npub mod registry;\n\npub use dependency_graph::DependencyGraph;\npub use error::{ModuleError, ModuleId, ModuleKind};\npub use registry::{CompiledModule, ExportedSymbol, ModuleExports, ModuleRegistry, ModuleStatus};\n\nuse crate::cli::config::CompilerOptions;\nuse crate::cli::fs::FileSystem;\nuse std::path::{Path, PathBuf};\nuse std::sync::Arc;\n\n/// Normalize a path by removing . and .. components\nfn normalize_path(path: \u0026Path) -\u003e PathBuf {\n    let mut components = Vec::new();\n\n    for component in path.components() {\n        match component {\n            std::path::Component::Prefix(_) | std::path::Component::RootDir =\u003e {\n                components.push(component);\n            }\n            std::path::Component::CurDir =\u003e {\n                // Skip . components\n            }\n            std::path::Component::ParentDir =\u003e {\n                // Pop the last component for ..\n                if let Some(last) = components.last() {\n                    if !matches!(last, std::path::Component::ParentDir) {\n                        components.pop();\n                    } else {\n                        components.push(component);\n                    }\n                }\n            }\n            std::path::Component::Normal(_) =\u003e {\n                components.push(component);\n            }\n        }\n    }\n\n    components.iter().collect()\n}\n\n/// Configuration for module resolution\n#[derive(Debug, Clone)]\npub struct ModuleConfig {\n    /// Search paths for package-style imports\n    pub module_paths: Vec\u003cPathBuf\u003e,\n    /// Policy for handling plain .lua files\n    pub lua_file_policy: LuaFilePolicy,\n}\n\nimpl ModuleConfig {\n    pub fn from_compiler_options(options: \u0026CompilerOptions, base_dir: \u0026Path) -\u003e Self {\n        Self {\n            module_paths: vec![base_dir.to_path_buf(), base_dir.join(\"lua_modules\")],\n            lua_file_policy: if options.allow_non_typed_lua {\n                LuaFilePolicy::RequireDeclaration\n            } else {\n                LuaFilePolicy::Block\n            },\n        }\n    }\n}\n\n/// Policy for handling plain .lua file imports\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum LuaFilePolicy {\n    /// Require .d.tl declaration file\n    RequireDeclaration,\n    /// Block .lua imports entirely\n    Block,\n}\n\n/// Module resolver - handles module path resolution\npub struct ModuleResolver {\n    fs: Arc\u003cdyn FileSystem\u003e,\n    config: ModuleConfig,\n    base_dir: PathBuf,\n}\n\nimpl std::fmt::Debug for ModuleResolver {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        f.debug_struct(\"ModuleResolver\")\n            .field(\"config\", \u0026self.config)\n            .field(\"base_dir\", \u0026self.base_dir)\n            .finish_non_exhaustive()\n    }\n}\n\nimpl ModuleResolver {\n    pub fn new(fs: Arc\u003cdyn FileSystem\u003e, config: ModuleConfig, base_dir: PathBuf) -\u003e Self {\n        Self {\n            fs,\n            config,\n            base_dir,\n        }\n    }\n\n    /// Resolve an import source to a module ID\n    ///\n    /// Supports two resolution strategies:\n    /// 1. Relative paths: './file', '../dir/file'\n    /// 2. Package paths: 'foo.bar' (Lua-style)\n    pub fn resolve(\u0026self, source: \u0026str, from_file: \u0026Path) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // Determine resolution strategy based on source format\n        if source.starts_with(\"./\") || source.starts_with(\"../\") {\n            self.resolve_relative(source, from_file)\n        } else {\n            self.resolve_package(source)\n        }\n    }\n\n    /// Resolve a relative import (Node-style)\n    fn resolve_relative(\u0026self, source: \u0026str, from: \u0026Path) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        let from_dir = from.parent().ok_or_else(|| ModuleError::InvalidPath {\n            source: source.to_string(),\n            reason: format!(\"Cannot get parent directory of '{}'\", from.display()),\n        })?;\n\n        let target = from_dir.join(source);\n        let mut searched_paths = Vec::new();\n\n        // Try direct file with extensions\n        for ext in \u0026[\"tl\", \"d.tl\"] {\n            let path = target.with_extension(ext);\n            searched_paths.push(path.clone());\n            if self.fs.exists(\u0026path) {\n                return self.canonicalize(\u0026path);\n            }\n        }\n\n        // Try .lua file if policy allows\n        if matches!(\n            self.config.lua_file_policy,\n            LuaFilePolicy::RequireDeclaration\n        ) {\n            // Check for .d.tl declaration file first\n            let decl_path = target.with_extension(\"d.tl\");\n            if self.fs.exists(\u0026decl_path) {\n                return self.canonicalize(\u0026decl_path);\n            }\n\n            // Try .lua file (will require .d.tl at type-check time)\n            let lua_path = target.with_extension(\"lua\");\n            searched_paths.push(lua_path.clone());\n            if self.fs.exists(\u0026lua_path) {\n                return self.canonicalize(\u0026lua_path);\n            }\n        }\n\n        // Try as directory with index.tl\n        let index_path = target.join(\"index.tl\");\n        searched_paths.push(index_path.clone());\n        if self.fs.exists(\u0026index_path) {\n            return self.canonicalize(\u0026index_path);\n        }\n\n        Err(ModuleError::NotFound {\n            source: source.to_string(),\n            searched_paths,\n        })\n    }\n\n    /// Resolve a package import (Lua-style)\n    fn resolve_package(\u0026self, source: \u0026str) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // Convert \"foo.bar\"  \"foo/bar\"\n        let path = source.replace('.', \"/\");\n        let mut searched_paths = Vec::new();\n\n        // Search in configured module_paths\n        for search_path in \u0026self.config.module_paths {\n            let candidate = search_path.join(\u0026path);\n\n            // Try with extensions\n            if let Ok(resolved) = self.try_extensions(\u0026candidate, \u0026mut searched_paths) {\n                return Ok(resolved);\n            }\n\n            // Try as directory with index.tl\n            let index_path = candidate.join(\"index.tl\");\n            searched_paths.push(index_path.clone());\n            if self.fs.exists(\u0026index_path) {\n                return self.canonicalize(\u0026index_path);\n            }\n        }\n\n        Err(ModuleError::NotFound {\n            source: source.to_string(),\n            searched_paths,\n        })\n    }\n\n    /// Try multiple file extensions for a path\n    fn try_extensions(\n        \u0026self,\n        base: \u0026Path,\n        searched_paths: \u0026mut Vec\u003cPathBuf\u003e,\n    ) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // Try .tl first\n        let tl_path = base.with_extension(\"tl\");\n        searched_paths.push(tl_path.clone());\n        if self.fs.exists(\u0026tl_path) {\n            return self.canonicalize(\u0026tl_path);\n        }\n\n        // Try .d.tl\n        let dtl_path = PathBuf::from(format!(\"{}.d.tl\", base.display()));\n        searched_paths.push(dtl_path.clone());\n        if self.fs.exists(\u0026dtl_path) {\n            return self.canonicalize(\u0026dtl_path);\n        }\n\n        // Try .lua if policy allows\n        if matches!(\n            self.config.lua_file_policy,\n            LuaFilePolicy::RequireDeclaration\n        ) {\n            let lua_path = base.with_extension(\"lua\");\n            searched_paths.push(lua_path.clone());\n            if self.fs.exists(\u0026lua_path) {\n                return self.canonicalize(\u0026lua_path);\n            }\n        }\n\n        Err(ModuleError::NotFound {\n            source: base.display().to_string(),\n            searched_paths: Vec::new(),\n        })\n    }\n\n    /// Canonicalize a path to create a ModuleId\n    fn canonicalize(\u0026self, path: \u0026Path) -\u003e Result\u003cModuleId, ModuleError\u003e {\n        // For real file system, use canonicalize\n        // For mock file system, just use the path as-is\n        match path.canonicalize() {\n            Ok(canonical) =\u003e Ok(ModuleId::new(canonical)),\n            Err(_) =\u003e {\n                // Fallback for mock file system - use absolute path with normalization\n                let absolute = if path.is_absolute() {\n                    path.to_path_buf()\n                } else {\n                    self.base_dir.join(path)\n                };\n                // Normalize the path by removing . and .. components\n                let normalized = normalize_path(\u0026absolute);\n                Ok(ModuleId::new(normalized))\n            }\n        }\n    }\n\n    /// Get the module kind from a path\n    pub fn get_module_kind(\u0026self, path: \u0026Path) -\u003e Option\u003cModuleKind\u003e {\n        let path_str = path.to_str()?;\n        if path_str.ends_with(\".d.tl\") {\n            Some(ModuleKind::Declaration)\n        } else {\n            path.extension()\n                .and_then(|ext| ext.to_str())\n                .and_then(ModuleKind::from_extension)\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::fs::MockFileSystem;\n\n    fn make_test_fs() -\u003e Arc\u003cMockFileSystem\u003e {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/project/src/main.tl\", \"-- main\");\n        fs.add_file(\"/project/src/utils.tl\", \"-- utils\");\n        fs.add_file(\"/project/src/types.d.tl\", \"-- types\");\n        fs.add_file(\"/project/src/lib/index.tl\", \"-- lib\");\n        fs.add_file(\"/project/lua_modules/foo/bar.tl\", \"-- foo.bar\");\n        Arc::new(fs)\n    }\n\n    fn make_resolver(fs: Arc\u003cdyn FileSystem\u003e) -\u003e ModuleResolver {\n        let config = ModuleConfig {\n            module_paths: vec![\n                PathBuf::from(\"/project\"),\n                PathBuf::from(\"/project/lua_modules\"),\n            ],\n            lua_file_policy: LuaFilePolicy::RequireDeclaration,\n        };\n        ModuleResolver::new(fs, config, PathBuf::from(\"/project\"))\n    }\n\n    #[test]\n    fn test_resolve_relative_simple() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./utils\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"utils.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_relative_declaration() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./types\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"types.d.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_relative_index() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./lib\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"lib\"));\n        assert!(id.as_str().contains(\"index.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_package_style() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"foo.bar\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_ok());\n        let id = result.unwrap();\n        assert!(id.as_str().contains(\"foo\"));\n        assert!(id.as_str().contains(\"bar.tl\"));\n    }\n\n    #[test]\n    fn test_resolve_not_found() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let result = resolver.resolve(\"./nonexistent\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_err());\n\n        if let Err(ModuleError::NotFound {\n            source,\n            searched_paths,\n        }) = result\n        {\n            assert_eq!(source, \"./nonexistent\");\n            assert!(!searched_paths.is_empty());\n        } else {\n            panic!(\"Expected NotFound error\");\n        }\n    }\n\n    #[test]\n    fn test_module_kind_detection() {\n        let fs = make_test_fs();\n        let resolver = make_resolver(fs);\n\n        let tl_kind = resolver.get_module_kind(Path::new(\"test.tl\"));\n        assert_eq!(tl_kind, Some(ModuleKind::Typed));\n\n        let dtl_kind = resolver.get_module_kind(Path::new(\"test.d.tl\"));\n        assert_eq!(dtl_kind, Some(ModuleKind::Declaration));\n\n        let lua_kind = resolver.get_module_kind(Path::new(\"test.lua\"));\n        assert_eq!(lua_kind, Some(ModuleKind::PlainLua));\n    }\n\n    #[test]\n    fn test_lua_file_policy_block() {\n        let mut fs = MockFileSystem::new();\n        fs.add_file(\"/project/src/main.tl\", \"-- main\");\n        fs.add_file(\"/project/src/legacy.lua\", \"-- legacy\");\n        let fs = Arc::new(fs);\n\n        let config = ModuleConfig {\n            module_paths: vec![PathBuf::from(\"/project\")],\n            lua_file_policy: LuaFilePolicy::Block,\n        };\n        let resolver = ModuleResolver::new(fs, config, PathBuf::from(\"/project\"));\n\n        // Should not find .lua file when policy is Block\n        let result = resolver.resolve(\"./legacy\", Path::new(\"/project/src/main.tl\"));\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":15,"address":[],"length":0,"stats":{"Line":4}},{"line":16,"address":[],"length":0,"stats":{"Line":8}},{"line":18,"address":[],"length":0,"stats":{"Line":26}},{"line":19,"address":[],"length":0,"stats":{"Line":18}},{"line":20,"address":[],"length":0,"stats":{"Line":4}},{"line":21,"address":[],"length":0,"stats":{"Line":8}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":14}},{"line":37,"address":[],"length":0,"stats":{"Line":28}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":7}},{"line":106,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":14}},{"line":109,"address":[],"length":0,"stats":{"Line":20}},{"line":111,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":5}},{"line":117,"address":[],"length":0,"stats":{"Line":20}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":20}},{"line":123,"address":[],"length":0,"stats":{"Line":10}},{"line":126,"address":[],"length":0,"stats":{"Line":21}},{"line":127,"address":[],"length":0,"stats":{"Line":27}},{"line":128,"address":[],"length":0,"stats":{"Line":36}},{"line":129,"address":[],"length":0,"stats":{"Line":18}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":4}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":4}},{"line":147,"address":[],"length":0,"stats":{"Line":8}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":6}},{"line":155,"address":[],"length":0,"stats":{"Line":12}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":4}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":173,"address":[],"length":0,"stats":{"Line":4}},{"line":174,"address":[],"length":0,"stats":{"Line":6}},{"line":177,"address":[],"length":0,"stats":{"Line":7}},{"line":178,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":2}},{"line":183,"address":[],"length":0,"stats":{"Line":4}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":8}},{"line":204,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":3}},{"line":209,"address":[],"length":0,"stats":{"Line":6}},{"line":210,"address":[],"length":0,"stats":{"Line":4}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":1}},{"line":220,"address":[],"length":0,"stats":{"Line":3}},{"line":221,"address":[],"length":0,"stats":{"Line":4}},{"line":222,"address":[],"length":0,"stats":{"Line":2}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":1}},{"line":228,"address":[],"length":0,"stats":{"Line":2}},{"line":229,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":4}},{"line":237,"address":[],"length":0,"stats":{"Line":4}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":12}},{"line":242,"address":[],"length":0,"stats":{"Line":8}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":3}},{"line":255,"address":[],"length":0,"stats":{"Line":9}},{"line":256,"address":[],"length":0,"stats":{"Line":6}},{"line":257,"address":[],"length":0,"stats":{"Line":1}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":6}},{"line":261,"address":[],"length":0,"stats":{"Line":2}}],"covered":75,"coverable":100},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","module_resolver","registry.rs"],"content":"use super::error::{ModuleError, ModuleId};\nuse crate::{Symbol, SymbolKind, SymbolTable};\nuse indexmap::IndexMap;\nuse rustc_hash::FxHashMap;\nuse serde::{Deserialize, Serialize};\nuse std::sync::{Arc, RwLock};\nuse typedlua_parser::ast::Program;\n\n/// Status of a module in the compilation pipeline\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum ModuleStatus {\n    /// Module is parsed but not yet type-checked\n    Parsed,\n    /// Exports extracted but full type check not done\n    ExportsExtracted,\n    /// Module is fully type-checked\n    TypeChecked,\n}\n\n/// A compiled module with its AST, exports, and symbol table\n#[derive(Debug, Clone)]\npub struct CompiledModule {\n    pub id: ModuleId,\n    pub ast: Arc\u003cProgram\u003e,\n    pub exports: ModuleExports,\n    pub symbol_table: Arc\u003cSymbolTable\u003e,\n    pub status: ModuleStatus,\n}\n\n/// Exports from a module\n#[derive(Debug, Clone, Default, Serialize, Deserialize)]\npub struct ModuleExports {\n    /// Named exports: { foo, bar as baz }\n    /// IndexMap for deterministic ordering in serialized output and LSP responses\n    pub named: IndexMap\u003cString, ExportedSymbol\u003e,\n    /// Default export: export default expr\n    pub default: Option\u003cExportedSymbol\u003e,\n}\n\nimpl ModuleExports {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    pub fn add_named(\u0026mut self, name: String, symbol: ExportedSymbol) {\n        self.named.insert(name, symbol);\n    }\n\n    pub fn set_default(\u0026mut self, symbol: ExportedSymbol) {\n        self.default = Some(symbol);\n    }\n\n    pub fn get_named(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026ExportedSymbol\u003e {\n        self.named.get(name)\n    }\n\n    pub fn has_default(\u0026self) -\u003e bool {\n        self.default.is_some()\n    }\n}\n\n/// A symbol exported from a module\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExportedSymbol {\n    pub symbol: Symbol,\n    /// Whether this is a type-only export\n    pub is_type_only: bool,\n}\n\nimpl ExportedSymbol {\n    pub fn new(symbol: Symbol, is_type_only: bool) -\u003e Self {\n        Self {\n            symbol,\n            is_type_only,\n        }\n    }\n\n    /// Check if this symbol can be used at runtime\n    pub fn is_runtime(\u0026self) -\u003e bool {\n        !self.is_type_only\n            \u0026\u0026 !matches!(\n                self.symbol.kind,\n                SymbolKind::TypeAlias | SymbolKind::Interface\n            )\n    }\n}\n\n/// Global registry of all compiled modules\n#[derive(Debug)]\npub struct ModuleRegistry {\n    modules: RwLock\u003cFxHashMap\u003cModuleId, CompiledModule\u003e\u003e,\n}\n\nimpl ModuleRegistry {\n    pub fn new() -\u003e Self {\n        Self {\n            modules: RwLock::new(FxHashMap::default()),\n        }\n    }\n\n    /// Pre-populate registry from cached module data.\n    /// Used at startup to load type info for unchanged files so that\n    /// other files can resolve imports without re-type-checking.\n    pub fn register_from_cache(\n        \u0026self,\n        id: ModuleId,\n        exports: ModuleExports,\n        symbol_table: Arc\u003cSymbolTable\u003e,\n    ) {\n        let module = CompiledModule {\n            id: id.clone(),\n            ast: Arc::new(Program::new(vec![], Default::default())),\n            exports,\n            symbol_table,\n            status: ModuleStatus::TypeChecked,\n        };\n        self.modules.write().unwrap().insert(id, module);\n    }\n\n    /// Register a parsed module (before type checking)\n    pub fn register_parsed(\u0026self, id: ModuleId, ast: Arc\u003cProgram\u003e, symbol_table: Arc\u003cSymbolTable\u003e) {\n        let module = CompiledModule {\n            id: id.clone(),\n            ast,\n            exports: ModuleExports::new(),\n            symbol_table,\n            status: ModuleStatus::Parsed,\n        };\n\n        self.modules.write().unwrap().insert(id, module);\n    }\n\n    /// Register exports for a module (after export extraction)\n    pub fn register_exports(\n        \u0026self,\n        id: \u0026ModuleId,\n        exports: ModuleExports,\n    ) -\u003e Result\u003c(), ModuleError\u003e {\n        let mut modules = self.modules.write().unwrap();\n        let module = modules\n            .get_mut(id)\n            .ok_or_else(|| ModuleError::NotCompiled { id: id.clone() })?;\n\n        module.exports = exports;\n        module.status = ModuleStatus::ExportsExtracted;\n        Ok(())\n    }\n\n    /// Mark a module as fully type-checked\n    pub fn mark_checked(\u0026self, id: \u0026ModuleId) -\u003e Result\u003c(), ModuleError\u003e {\n        let mut modules = self.modules.write().unwrap();\n        let module = modules\n            .get_mut(id)\n            .ok_or_else(|| ModuleError::NotCompiled { id: id.clone() })?;\n\n        module.status = ModuleStatus::TypeChecked;\n        Ok(())\n    }\n\n    /// Get a module by ID\n    pub fn get_module(\u0026self, id: \u0026ModuleId) -\u003e Result\u003cCompiledModule, ModuleError\u003e {\n        self.modules\n            .read()\n            .unwrap()\n            .get(id)\n            .cloned()\n            .ok_or_else(|| ModuleError::NotCompiled { id: id.clone() })\n    }\n\n    /// Get exports from a module\n    pub fn get_exports(\u0026self, id: \u0026ModuleId) -\u003e Result\u003cModuleExports, ModuleError\u003e {\n        let module = self.get_module(id)?;\n        Ok(module.exports)\n    }\n\n    /// Get a specific named export from a module\n    pub fn get_named_export(\n        \u0026self,\n        id: \u0026ModuleId,\n        name: \u0026str,\n    ) -\u003e Result\u003cExportedSymbol, ModuleError\u003e {\n        let exports = self.get_exports(id)?;\n        exports\n            .get_named(name)\n            .cloned()\n            .ok_or_else(|| ModuleError::ExportNotFound {\n                module_id: id.clone(),\n                export_name: name.to_string(),\n            })\n    }\n\n    /// Check if a module exists in the registry\n    pub fn contains(\u0026self, id: \u0026ModuleId) -\u003e bool {\n        self.modules.read().unwrap().contains_key(id)\n    }\n\n    /// Get all registered modules\n    pub fn modules(\u0026self) -\u003e Vec\u003cModuleId\u003e {\n        self.modules.read().unwrap().keys().cloned().collect()\n    }\n\n    /// Get the status of a module\n    pub fn get_status(\u0026self, id: \u0026ModuleId) -\u003e Result\u003cModuleStatus, ModuleError\u003e {\n        let module = self.get_module(id)?;\n        Ok(module.status)\n    }\n}\n\nimpl Default for ModuleRegistry {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::path::PathBuf;\n    use typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\n    use typedlua_parser::span::Span;\n\n    fn make_test_type() -\u003e Type {\n        Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        )\n    }\n\n    fn make_test_symbol(name: \u0026str) -\u003e Symbol {\n        Symbol::new(\n            name.to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        )\n    }\n\n    #[test]\n    fn test_module_exports_named() {\n        let mut exports = ModuleExports::new();\n        let symbol = make_test_symbol(\"foo\");\n        exports.add_named(\"foo\".to_string(), ExportedSymbol::new(symbol, false));\n\n        assert!(exports.get_named(\"foo\").is_some());\n        assert!(exports.get_named(\"bar\").is_none());\n    }\n\n    #[test]\n    fn test_module_exports_default() {\n        let mut exports = ModuleExports::new();\n        let symbol = make_test_symbol(\"default\");\n        exports.set_default(ExportedSymbol::new(symbol, false));\n\n        assert!(exports.has_default());\n    }\n\n    #[test]\n    fn test_exported_symbol_is_runtime() {\n        let runtime_symbol = ExportedSymbol::new(make_test_symbol(\"foo\"), false);\n        assert!(runtime_symbol.is_runtime());\n\n        let type_only_symbol = ExportedSymbol::new(make_test_symbol(\"foo\"), true);\n        assert!(!type_only_symbol.is_runtime());\n\n        let mut type_alias_symbol = make_test_symbol(\"Foo\");\n        type_alias_symbol.kind = SymbolKind::TypeAlias;\n        let type_alias_export = ExportedSymbol::new(type_alias_symbol, false);\n        assert!(!type_alias_export.is_runtime());\n    }\n\n    #[test]\n    fn test_registry_register_and_get() {\n        let registry = ModuleRegistry::new();\n        let id = ModuleId::new(PathBuf::from(\"test.tl\"));\n        let ast = Arc::new(Program {\n            statements: vec![],\n            span: Span::new(0, 0, 0, 0),\n        });\n        let symbol_table = Arc::new(SymbolTable::new());\n\n        registry.register_parsed(id.clone(), ast.clone(), symbol_table);\n\n        let module = registry.get_module(\u0026id).unwrap();\n        assert_eq!(module.status, ModuleStatus::Parsed);\n    }\n\n    #[test]\n    fn test_registry_exports_workflow() {\n        let registry = ModuleRegistry::new();\n        let id = ModuleId::new(PathBuf::from(\"test.tl\"));\n        let ast = Arc::new(Program {\n            statements: vec![],\n            span: Span::new(0, 0, 0, 0),\n        });\n        let symbol_table = Arc::new(SymbolTable::new());\n\n        // Register as parsed\n        registry.register_parsed(id.clone(), ast, symbol_table);\n        assert_eq!(registry.get_status(\u0026id).unwrap(), ModuleStatus::Parsed);\n\n        // Add exports\n        let mut exports = ModuleExports::new();\n        exports.add_named(\n            \"foo\".to_string(),\n            ExportedSymbol::new(make_test_symbol(\"foo\"), false),\n        );\n        registry.register_exports(\u0026id, exports).unwrap();\n        assert_eq!(\n            registry.get_status(\u0026id).unwrap(),\n            ModuleStatus::ExportsExtracted\n        );\n\n        // Mark as checked\n        registry.mark_checked(\u0026id).unwrap();\n        assert_eq!(registry.get_status(\u0026id).unwrap(), ModuleStatus::TypeChecked);\n\n        // Verify exports\n        let named_export = registry.get_named_export(\u0026id, \"foo\").unwrap();\n        assert_eq!(named_export.symbol.name, \"foo\");\n    }\n}\n","traces":[{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":42,"address":[],"length":0,"stats":{"Line":8}},{"line":45,"address":[],"length":0,"stats":{"Line":2}},{"line":46,"address":[],"length":0,"stats":{"Line":8}},{"line":49,"address":[],"length":0,"stats":{"Line":1}},{"line":50,"address":[],"length":0,"stats":{"Line":2}},{"line":53,"address":[],"length":0,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":9}},{"line":57,"address":[],"length":0,"stats":{"Line":1}},{"line":58,"address":[],"length":0,"stats":{"Line":2}},{"line":71,"address":[],"length":0,"stats":{"Line":6}},{"line":79,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":81,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":2}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":97,"address":[],"length":0,"stats":{"Line":2}},{"line":104,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":123,"address":[],"length":0,"stats":{"Line":6}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":8}},{"line":134,"address":[],"length":0,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":4}},{"line":140,"address":[],"length":0,"stats":{"Line":3}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":4}},{"line":152,"address":[],"length":0,"stats":{"Line":3}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":1}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":5}},{"line":162,"address":[],"length":0,"stats":{"Line":15}},{"line":165,"address":[],"length":0,"stats":{"Line":5}},{"line":167,"address":[],"length":0,"stats":{"Line":5}},{"line":171,"address":[],"length":0,"stats":{"Line":1}},{"line":172,"address":[],"length":0,"stats":{"Line":4}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":177,"address":[],"length":0,"stats":{"Line":1}},{"line":182,"address":[],"length":0,"stats":{"Line":4}},{"line":183,"address":[],"length":0,"stats":{"Line":1}},{"line":184,"address":[],"length":0,"stats":{"Line":2}},{"line":186,"address":[],"length":0,"stats":{"Line":1}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":12}},{"line":205,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}}],"covered":51,"coverable":63},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","declaration_checking_phase.rs"],"content":"//! Declaration checking phase: Type alias, enum, interface, and class type checking\n//!\n//! This phase handles the checking of type declarations after they've been registered\n//! in the symbol table (by declaration_phase). It performs:\n//! - Type alias checking and registration\n//! - Enum declaration checking (simple and rich enums)\n//! - Interface declaration checking with inheritance\n//! - Class declaration checking (delegated to TypeChecker due to complexity)\n//!\n//! **Design Pattern**: Functions with explicit context parameters. For complex operations\n//! that need TypeChecker state, returns control to TypeChecker for further processing.\n\n#![allow(dead_code)]\n\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::visitors::{AccessControl, AccessControlVisitor, ClassMemberInfo, ClassMemberKind};\nuse crate::TypeCheckError;\nuse typedlua_parser::ast::expression::Literal;\nuse typedlua_parser::ast::statement::{\n    AccessModifier, ClassDeclaration, ClassMember, EnumDeclaration, InterfaceDeclaration,\n    InterfaceMember, TypeAliasDeclaration,\n};\nuse typedlua_parser::ast::types::{\n    ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind, TypeReference,\n};\nuse typedlua_parser::prelude::EnumValue;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Check a type alias declaration.\n///\n/// This function validates type alias declarations and registers them in the type environment.\n/// For generic type aliases, the raw type annotation is stored without evaluation.\n/// For non-generic aliases, the caller must evaluate the type before calling this function.\n///\n/// # Parameters\n///\n/// - `alias`: The type alias declaration to check\n/// - `type_env`: Mutable type environment for registration\n/// - `symbol_table`: Mutable symbol table for export tracking\n/// - `interner`: String interner for name resolution\n/// - `evaluated_type`: The evaluated type (for non-generic aliases, should be evaluated by caller)\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful, or an error if registration fails.\npub fn check_type_alias(\n    alias: \u0026TypeAliasDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n    evaluated_type: Option\u003cType\u003e,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    let alias_name = interner.resolve(alias.name.node).to_string();\n\n    // Check if this is a generic type alias\n    if let Some(type_params) = \u0026alias.type_parameters {\n        // For generic type aliases, store the raw type annotation without\n        // evaluating it  it may contain type parameters (e.g., keyof T)\n        // that can only be resolved when instantiated with concrete arguments.\n        type_env\n            .register_generic_type_alias(\n                alias_name.clone(),\n                type_params.clone(),\n                alias.type_annotation.clone(),\n            )\n            .map_err(|e| TypeCheckError::new(e, alias.span))?;\n    } else {\n        // Non-generic: use the evaluated type passed by caller\n        let typ_to_register = evaluated_type.ok_or_else(|| {\n            TypeCheckError::new(\n                \"Expected evaluated type for non-generic alias\".to_string(),\n                alias.span,\n            )\n        })?;\n        type_env\n            .register_type_alias(alias_name.clone(), typ_to_register.clone())\n            .map_err(|e| TypeCheckError::new(e, alias.span))?;\n    }\n\n    // Use raw annotation for the symbol table entry\n    let typ_to_register = alias.type_annotation.clone();\n\n    // Also register in symbol table for export extraction\n    let symbol = Symbol {\n        name: alias_name.clone(),\n        typ: typ_to_register,\n        kind: SymbolKind::TypeAlias,\n        span: alias.span,\n        is_exported: true,\n        references: Vec::new(),\n    };\n    let _ = symbol_table.declare(symbol);\n\n    Ok(())\n}\n\n/// Check an enum declaration.\n///\n/// This function handles simple enums (just variants with values) by registering them\n/// as union types of their literal values. For rich enums (with fields, constructor,\n/// or methods), it returns `Ok(true)` to indicate that the caller should handle it.\n///\n/// # Parameters\n///\n/// - `enum_decl`: The enum declaration to check\n/// - `type_env`: Mutable type environment for registration\n/// - `symbol_table`: Mutable symbol table for enum registration\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok(true)` if this is a rich enum that needs further checking by the caller,\n/// `Ok(false)` if it's a simple enum that was fully handled, or an error if checking fails.\npub fn check_enum_declaration(\n    enum_decl: \u0026EnumDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cbool, TypeCheckError\u003e {\n    let enum_name = interner.resolve(enum_decl.name.node).to_string();\n\n    // Register enum name as a symbol so it can be referenced as a value\n    let enum_ref_type = Type::new(\n        TypeKind::Reference(TypeReference {\n            name: enum_decl.name.clone(),\n            type_arguments: None,\n            span: enum_decl.span,\n        }),\n        enum_decl.span,\n    );\n    let enum_symbol = Symbol::new(\n        enum_name.clone(),\n        SymbolKind::Enum,\n        enum_ref_type,\n        enum_decl.span,\n    );\n    let _ = symbol_table.declare(enum_symbol);\n\n    // Check if this is a rich enum (has fields, constructor, or methods)\n    let is_rich_enum = !enum_decl.fields.is_empty()\n        || enum_decl.constructor.is_none()\n        || !enum_decl.methods.is_empty();\n\n    if is_rich_enum {\n        // Rich enum: caller should handle with check_rich_enum_declaration\n        return Ok(true);\n    }\n\n    // Simple enum: just variants with values\n    let variants: Vec\u003c_\u003e = enum_decl\n        .members\n        .iter()\n        .filter_map(|member| {\n            member.value.as_ref().map(|value| match value {\n                EnumValue::Number(n) =\u003e {\n                    Type::new(TypeKind::Literal(Literal::Number(*n)), member.span)\n                }\n                EnumValue::String(s) =\u003e {\n                    Type::new(TypeKind::Literal(Literal::String(s.clone())), member.span)\n                }\n            })\n        })\n        .collect();\n\n    let enum_type = if variants.is_empty() {\n        Type::new(TypeKind::Primitive(PrimitiveType::Number), enum_decl.span)\n    } else if variants.len() == 1 {\n        variants.into_iter().next().unwrap()\n    } else {\n        Type::new(TypeKind::Union(variants), enum_decl.span)\n    };\n\n    type_env\n        .register_type_alias(enum_name, enum_type)\n        .map_err(|e| TypeCheckError::new(e, enum_decl.span))?;\n\n    Ok(false)\n}\n\n/// Check an interface declaration.\n///\n/// This function handles interface type checking including generic interfaces, inheritance\n/// (extends), and member validation. It registers the interface with access control and\n/// the type environment.\n///\n/// For interfaces with default method bodies, this function returns the interface type\n/// and indicates that body checking is needed. The caller should type-check method bodies\n/// in the appropriate scope.\n///\n/// # Parameters\n///\n/// - `iface`: The interface declaration to check\n/// - `type_env`: Mutable type environment for interface registration\n/// - `symbol_table`: Mutable symbol table for interface symbols\n/// - `access_control`: Access control tracker for member registration\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok((has_default_bodies, interface_type))` where:\n/// - `has_default_bodies`: true if interface has methods with default implementations\n/// - `interface_type`: The constructed interface type for use in body checking\n///\n/// Returns an error if validation or registration fails.\npub fn check_interface_declaration(\n    iface: \u0026InterfaceDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    symbol_table: \u0026mut SymbolTable,\n    access_control: \u0026mut AccessControl,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(bool, Type), TypeCheckError\u003e {\n    let iface_name = interner.resolve(iface.name.node).to_string();\n\n    // Register interface with access control\n    access_control.register_class(\u0026iface_name, None);\n\n    // Register interface members for access control\n    for member in \u0026iface.members {\n        let member_info = match member {\n            InterfaceMember::Property(prop) =\u003e ClassMemberInfo {\n                name: interner.resolve(prop.name.node).to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Property {\n                    type_annotation: prop.type_annotation.clone(),\n                },\n                is_final: prop.is_readonly,\n            },\n            InterfaceMember::Method(method) =\u003e ClassMemberInfo {\n                name: interner.resolve(method.name.node).to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Method {\n                    parameters: method.parameters.clone(),\n                    return_type: Some(method.return_type.clone()),\n                    is_abstract: false,\n                },\n                is_final: false,\n            },\n            InterfaceMember::Index(_) =\u003e continue, // Skip index signatures\n        };\n        access_control.register_member(\u0026iface_name, member_info);\n    }\n\n    // Handle generic interfaces\n    if let Some(type_params) = \u0026iface.type_parameters {\n        // Generic interface - register type parameters for later instantiation\n        let param_names: Vec\u003cString\u003e = type_params\n            .iter()\n            .map(|tp| interner.resolve(tp.name.node).to_string())\n            .collect();\n        type_env.register_interface_type_params(iface_name.clone(), param_names);\n\n        // Create placeholder object type with interface members\n        let obj_type = Type::new(\n            TypeKind::Object(ObjectType {\n                members: iface\n                    .members\n                    .iter()\n                    .map(|member| match member {\n                        InterfaceMember::Property(prop) =\u003e ObjectTypeMember::Property(prop.clone()),\n                        InterfaceMember::Method(method) =\u003e ObjectTypeMember::Method(method.clone()),\n                        InterfaceMember::Index(index) =\u003e ObjectTypeMember::Index(index.clone()),\n                    })\n                    .collect(),\n                span: iface.span,\n            }),\n            iface.span,\n        );\n\n        type_env\n            .register_interface(iface_name.clone(), obj_type.clone())\n            .map_err(|e| TypeCheckError::new(e, iface.span))?;\n\n        // Register in symbol table\n        let symbol = Symbol {\n            name: iface_name,\n            typ: obj_type.clone(),\n            kind: SymbolKind::Interface,\n            span: iface.span,\n            is_exported: true,\n            references: Vec::new(),\n        };\n        let _ = symbol_table.declare(symbol);\n\n        // Generic interfaces don't have default method bodies to check\n        return Ok((false, obj_type));\n    }\n\n    // Non-generic interface - full checking with inheritance\n    let mut members: Vec\u003cObjectTypeMember\u003e = iface\n        .members\n        .iter()\n        .map(|member| match member {\n            InterfaceMember::Property(prop) =\u003e ObjectTypeMember::Property(prop.clone()),\n            InterfaceMember::Method(method) =\u003e ObjectTypeMember::Method(method.clone()),\n            InterfaceMember::Index(index) =\u003e ObjectTypeMember::Index(index.clone()),\n        })\n        .collect();\n\n    // Handle extends clause - merge parent interface members\n    for parent_type in \u0026iface.extends {\n        match \u0026parent_type.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                // Look up parent interface\n                let type_name = interner.resolve(type_ref.name.node);\n                if let Some(parent_iface) = type_env.get_interface(\u0026type_name) {\n                    if let TypeKind::Object(parent_obj) = \u0026parent_iface.kind {\n                        // Add parent members first (so they can be overridden)\n                        for parent_member in \u0026parent_obj.members {\n                            // Check if member is overridden in child\n                            let member_name = match parent_member {\n                                ObjectTypeMember::Property(p) =\u003e Some(\u0026p.name.node),\n                                ObjectTypeMember::Method(m) =\u003e Some(\u0026m.name.node),\n                                ObjectTypeMember::Index(_) =\u003e None,\n                            };\n\n                            if let Some(name) = member_name {\n                                let is_overridden = members.iter().any(|m| match m {\n                                    ObjectTypeMember::Property(p) =\u003e \u0026p.name.node == name,\n                                    ObjectTypeMember::Method(m) =\u003e \u0026m.name.node == name,\n                                    ObjectTypeMember::Index(_) =\u003e false,\n                                });\n\n                                if !is_overridden {\n                                    members.insert(0, parent_member.clone());\n                                }\n                            } else {\n                                // Index signatures are always inherited\n                                members.insert(0, parent_member.clone());\n                            }\n                        }\n                    }\n                } else {\n                    return Err(TypeCheckError::new(\n                        format!(\"Parent interface '{}' not found\", type_ref.name.node),\n                        iface.span,\n                    ));\n                }\n            }\n            _ =\u003e {\n                return Err(TypeCheckError::new(\n                    \"Interface can only extend other interfaces (type references)\",\n                    iface.span,\n                ));\n            }\n        }\n    }\n\n    // Create the interface type\n    let iface_type = Type::new(\n        TypeKind::Object(ObjectType {\n            members: members.clone(),\n            span: iface.span,\n        }),\n        iface.span,\n    );\n\n    // Validate interface members\n    super::validation_phase::validate_interface_members(\u0026members, iface.span)?;\n\n    // Register the interface\n    type_env\n        .register_interface(iface_name.clone(), iface_type.clone())\n        .map_err(|e| TypeCheckError::new(e, iface.span))?;\n\n    // Register in symbol table\n    let symbol = Symbol {\n        name: iface_name,\n        typ: iface_type.clone(),\n        kind: SymbolKind::Interface,\n        span: iface.span,\n        is_exported: true,\n        references: Vec::new(),\n    };\n    let _ = symbol_table.declare(symbol);\n\n    // Check if any methods have default bodies\n    let has_default_bodies = iface\n        .members\n        .iter()\n        .any(|m| matches!(m, InterfaceMember::Method(method) if method.body.is_some()));\n\n    Ok((has_default_bodies, iface_type))\n}\n\n/// Check a rich enum declaration with fields, constructor, and methods.\n///\n/// Rich enums have additional complexity beyond simple enums - they include fields,\n/// constructors, and methods. This function handles registration of all enum components\n/// with access control and type environment.\n///\n/// Returns the enum's self type which the caller should use for checking constructor\n/// and method bodies in the appropriate scope.\n///\n/// # Parameters\n///\n/// - `enum_decl`: The rich enum declaration to check\n/// - `type_env`: Mutable type environment for type registration\n/// - `access_control`: Access control tracker for member registration\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok(enum_self_type)` with the enum's type for body checking, or an error if\n/// registration or validation fails. The caller should use this type to check constructor\n/// and method bodies.\npub fn check_rich_enum_declaration(\n    enum_decl: \u0026EnumDeclaration,\n    type_env: \u0026mut TypeEnvironment,\n    access_control: \u0026mut AccessControl,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, TypeCheckError\u003e {\n    use rustc_hash::FxHashMap;\n\n    let enum_name = interner.resolve(enum_decl.name.node).to_string();\n\n    // Register rich enum with access control so its members can be tracked\n    access_control.register_class(\u0026enum_name, None);\n\n    // Register enum fields as members for access control\n    for field in \u0026enum_decl.fields {\n        let field_info = ClassMemberInfo {\n            name: interner.resolve(field.name.node).to_string(),\n            access: AccessModifier::Public,\n            _is_static: false,\n            kind: ClassMemberKind::Property {\n                type_annotation: field.type_annotation.clone(),\n            },\n            is_final: false,\n        };\n        access_control.register_member(\u0026enum_name, field_info);\n    }\n\n    let mut member_types = FxHashMap::default();\n    for (i, member) in enum_decl.members.iter().enumerate() {\n        let member_name_str = interner.resolve(member.name.node).to_string();\n        let member_type_name = format!(\"{}.{}\", enum_name, member_name_str);\n        let member_type = Type::new(\n            TypeKind::Literal(Literal::String(member_name_str.clone())),\n            member.span,\n        );\n        type_env\n            .register_type_alias(member_type_name, member_type.clone())\n            .map_err(|e| TypeCheckError::new(e, member.span))?;\n        member_types.insert(i, member_type.clone());\n\n        // Register enum variant as a static public property for member access\n        access_control.register_member(\n            \u0026enum_name,\n            ClassMemberInfo {\n                name: member_name_str,\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: member_type,\n                },\n                is_final: true,\n            },\n        );\n    }\n\n    // Register enum methods as members for access control\n    for method in \u0026enum_decl.methods {\n        let method_name = interner.resolve(method.name.node).to_string();\n        access_control.register_member(\n            \u0026enum_name,\n            ClassMemberInfo {\n                name: method_name,\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Method {\n                    parameters: method.parameters.clone(),\n                    return_type: method.return_type.clone(),\n                    is_abstract: false,\n                },\n                is_final: false,\n            },\n        );\n    }\n\n    let enum_type = Type::new(\n        TypeKind::Reference(TypeReference {\n            name: enum_decl.name.clone(),\n            type_arguments: None,\n            span: enum_decl.span,\n        }),\n        enum_decl.span,\n    );\n\n    type_env\n        .register_type_alias(enum_name, enum_type.clone())\n        .map_err(|e| TypeCheckError::new(e, enum_decl.span))?;\n\n    Ok(enum_type)\n}\n\n/// Register a class symbol and handle abstract class registration.\n///\n/// This is a focused function that handles the basic class registration in the symbol table\n/// and type environment. It does NOT handle members, inheritance, or other complex logic.\n///\n/// # Returns\n///\n/// Returns the class type for use in further checking.\npub fn register_class_symbol(\n    class_decl: \u0026typedlua_parser::ast::statement::ClassDeclaration,\n    symbol_table: \u0026mut SymbolTable,\n    type_env: \u0026mut TypeEnvironment,\n    class_type_params: \u0026mut rustc_hash::FxHashMap\u003c\n        String,\n        Vec\u003ctypedlua_parser::ast::statement::TypeParameter\u003e,\n    \u003e,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, TypeCheckError\u003e {\n    let class_name = interner.resolve(class_decl.name.node).to_string();\n\n    // Register the class name as a symbol in the symbol table so `new ClassName()` works\n    let class_type = Type::new(\n        TypeKind::Reference(TypeReference {\n            name: class_decl.name.clone(),\n            type_arguments: None,\n            span: class_decl.span,\n        }),\n        class_decl.span,\n    );\n    let class_symbol = Symbol::new(\n        class_name.clone(),\n        SymbolKind::Class,\n        class_type.clone(),\n        class_decl.span,\n    );\n    let _ = symbol_table.declare(class_symbol);\n\n    // Register abstract class\n    if class_decl.is_abstract {\n        type_env.register_abstract_class(class_name.clone());\n    }\n\n    // Store type parameters for this class (needed for generic override checking)\n    if let Some(type_params) = \u0026class_decl.type_parameters {\n        class_type_params.insert(class_name, type_params.clone());\n    }\n\n    Ok(class_type)\n}\n\n/// Extract class member information for access control registration.\n///\n/// This function processes all class members (properties, methods, getters, setters, operators)\n/// from the class declaration to build a list of ClassMemberInfo structures for\n/// access control registration.\n///\n/// # Parameters\n///\n/// - `class_decl`: The class declaration containing members\n/// - `interner`: String interner for resolving identifiers\n///\n/// # Returns\n///\n/// Returns a vector of ClassMemberInfo structures ready for access control registration.\n/// Note: Primary constructor properties must be added separately by the caller since\n/// they require special handling for `is_readonly` field mapping.\npub fn extract_class_member_infos(\n    class_decl: \u0026ClassDeclaration,\n    interner: \u0026StringInterner,\n) -\u003e Vec\u003cClassMemberInfo\u003e {\n    use crate::helpers::type_utilities::operator_kind_name;\n    let mut member_infos = Vec::new();\n\n    // Add regular class members\n    for member in \u0026class_decl.members {\n        match member {\n            ClassMember::Property(prop) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(prop.name.node).to_string(),\n                    access: prop.access.unwrap_or(AccessModifier::Public),\n                    _is_static: prop.is_static,\n                    kind: ClassMemberKind::Property {\n                        type_annotation: prop.type_annotation.clone(),\n                    },\n                    is_final: false,\n                });\n            }\n            ClassMember::Method(method) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(method.name.node).to_string(),\n                    access: method.access.unwrap_or(AccessModifier::Public),\n                    _is_static: method.is_static,\n                    kind: ClassMemberKind::Method {\n                        parameters: method.parameters.clone(),\n                        return_type: method.return_type.clone(),\n                        is_abstract: method.is_abstract,\n                    },\n                    is_final: method.is_final,\n                });\n            }\n            ClassMember::Getter(getter) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(getter.name.node).to_string(),\n                    access: getter.access.unwrap_or(AccessModifier::Public),\n                    _is_static: getter.is_static,\n                    kind: ClassMemberKind::Getter {\n                        return_type: getter.return_type.clone(),\n                    },\n                    is_final: false,\n                });\n            }\n            ClassMember::Setter(setter) =\u003e {\n                member_infos.push(ClassMemberInfo {\n                    name: interner.resolve(setter.name.node).to_string(),\n                    access: setter.access.unwrap_or(AccessModifier::Public),\n                    _is_static: setter.is_static,\n                    kind: ClassMemberKind::Setter {\n                        parameter_type: setter.parameter.type_annotation.clone().unwrap_or_else(\n                            || Type::new(TypeKind::Primitive(PrimitiveType::Unknown), setter.span),\n                        ),\n                    },\n                    is_final: false,\n                });\n            }\n            ClassMember::Constructor(_) =\u003e {\n                // Constructor doesn't have access modifiers for member access\n            }\n            ClassMember::Operator(op) =\u003e {\n                let op_name = operator_kind_name(\u0026op.operator);\n                member_infos.push(ClassMemberInfo {\n                    name: op_name,\n                    access: op.access.unwrap_or(AccessModifier::Public),\n                    _is_static: false,\n                    kind: ClassMemberKind::Operator {\n                        operator: op.operator,\n                        parameters: op.parameters.clone(),\n                        return_type: op.return_type.clone(),\n                    },\n                    is_final: false,\n                });\n            }\n        }\n    }\n\n    member_infos\n}\n\n/// Classify a class member error as critical or non-critical.\n///\n/// Critical errors should fail compilation immediately, while non-critical errors\n/// can be converted to warnings to prevent cascading failures.\n///\n/// # Parameters\n///\n/// - `error_message`: The error message to classify\n///\n/// # Returns\n///\n/// Returns `true` if the error is critical and should fail compilation, `false` otherwise.\npub fn is_critical_member_error(error_message: \u0026str) -\u003e bool {\n    (error_message.contains(\"Abstract method\") \u0026\u0026 error_message.contains(\"abstract class\"))\n        || error_message.contains(\"one constructor\")\n        || error_message.contains(\"Decorators require decorator features\")\n        || error_message.contains(\"Cannot override final method\")\n        || error_message.contains(\"is incompatible with parent\")\n        || error_message.contains(\"must implement abstract method\")\n        || error_message.contains(\"uses override but class\")\n        || error_message.contains(\"marked as override but parent class does not have this method\")\n        || error_message.contains(\"Return type mismatch\")\n        || error_message.contains(\"is private and only accessible\")\n        || error_message.contains(\"is protected and only accessible\")\n        || error_message.contains(\"operators can have 0 parameters\")\n        || error_message.contains(\"Binary operator must have exactly\")\n        || error_message.contains(\"Operator must have 0, 1, or 2\")\n        || error_message.contains(\"must have exactly 2 parameters\")\n        || error_message.contains(\"must return 'boolean'\")\n}\n\n/// Register class type parameters in the type environment.\n///\n/// Type parameters from a generic class declaration are registered as type aliases\n/// in the type environment, scoped to the class body. Any existing type aliases\n/// with the same name are removed first.\n///\n/// # Parameters\n///\n/// - `type_params`: Optional slice of type parameters from the class declaration\n/// - `type_env`: Mutable type environment for registration\n/// - `interner`: String interner for resolving parameter names\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful, or an error if registration fails.\npub fn register_class_type_parameters(\n    type_params: Option\u003c\u0026[typedlua_parser::ast::statement::TypeParameter]\u003e,\n    type_env: \u0026mut crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), crate::TypeCheckError\u003e {\n    if let Some(type_params) = type_params {\n        for type_param in type_params {\n            let param_name = interner.resolve(type_param.name.node).to_string();\n            let param_type = Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: type_param.name.clone(),\n                    type_arguments: None,\n                    span: type_param.span,\n                }),\n                type_param.span,\n            );\n\n            // Remove any existing type alias with this name (from a previous generic class)\n            // then register fresh. Type params are scoped to the class body.\n            type_env.remove_type_alias(\u0026param_name);\n            type_env\n                .register_type_alias(param_name, param_type)\n                .map_err(|e| crate::TypeCheckError::new(e, type_param.span))?;\n        }\n    }\n    Ok(())\n}\n\n/// Register class-implements relationships in type environment and access control.\n///\n/// This function extracts interface names from the class's implements clause and\n/// registers them with both the type environment (for type checking) and access\n/// control (for member lookup).\n///\n/// # Parameters\n///\n/// - `class_name`: Name of the class\n/// - `implements`: Vector of interface types that the class implements\n/// - `type_env`: Mutable type environment for registration\n/// - `access_control`: Mutable access control for member lookup\n/// - `interner`: String interner for resolving interface names\npub fn register_class_implements(\n    class_name: String,\n    implements: Vec\u003cType\u003e,\n    type_env: \u0026mut crate::core::type_environment::TypeEnvironment,\n    access_control: \u0026mut crate::visitors::AccessControl,\n    interner: \u0026StringInterner,\n) {\n    if implements.is_empty() {\n        return;\n    }\n\n    // Register with type environment for type checking\n    type_env.register_class_implements(class_name.clone(), implements.clone());\n\n    // Extract interface names and register with access control for member lookup\n    let interface_names: Vec\u003cString\u003e = implements\n        .iter()\n        .map(|t| {\n            // Extract the interface name from the type\n            match \u0026t.kind {\n                TypeKind::Reference(ref_type) =\u003e interner.resolve(ref_type.name.node).to_string(),\n                _ =\u003e format!(\"{:?}\", t),\n            }\n        })\n        .collect();\n    access_control.register_class_implements(\u0026class_name, interface_names);\n}\n\n/// Register function type parameters with duplicate checking.\n///\n/// This function validates that type parameters are unique and registers them\n/// in the type environment along with any constraints.\n///\n/// # Parameters\n///\n/// - `type_params`: Optional slice of type parameters from the function declaration\n/// - `type_env`: Mutable type environment for registration\n/// - `interner`: String interner for resolving parameter names\n///\n/// # Returns\n///\n/// Returns `Ok(())` if successful, or an error if duplicate parameters are found\n/// or registration fails.\npub fn register_function_type_parameters(\n    type_params: Option\u003c\u0026[typedlua_parser::ast::statement::TypeParameter]\u003e,\n    type_env: \u0026mut crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), crate::TypeCheckError\u003e {\n    let Some(type_params) = type_params else {\n        return Ok(());\n    };\n\n    // Check for duplicate type parameters\n    let mut seen_params = std::collections::HashSet::new();\n    for type_param in type_params {\n        let param_name = interner.resolve(type_param.name.node).to_string();\n        if !seen_params.insert(param_name.clone()) {\n            return Err(crate::TypeCheckError::new(\n                format!(\"Duplicate type parameter '{}'\", param_name),\n                type_param.span,\n            ));\n        }\n    }\n\n    // Register type parameters in type environment\n    for type_param in type_params {\n        let param_name = interner.resolve(type_param.name.node).to_string();\n        let param_type = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: type_param.name.clone(),\n                type_arguments: None,\n                span: type_param.span,\n            }),\n            type_param.span,\n        );\n\n        // Type parameters are treated as local types in the function scope\n        type_env.remove_type_alias(\u0026param_name);\n        type_env\n            .register_type_alias(param_name.clone(), param_type)\n            .map_err(|e| crate::TypeCheckError::new(e, type_param.span))?;\n\n        // Register constraint if present (e.g., T implements Identifiable)\n        if let Some(constraint) = \u0026type_param.constraint {\n            type_env.register_type_param_constraint(param_name, (**constraint).clone());\n        }\n    }\n\n    Ok(())\n}\n\n/// Instantiate a generic interface with type arguments.\n///\n/// For generic interfaces like `Comparable\u003cT\u003e`, this function takes the interface type\n/// and substitutes all type parameters with concrete type arguments, producing an\n/// instantiated interface like `Comparable\u003cnumber\u003e`.\n///\n/// This handles the complex nested type substitution required for generic interface\n/// implementation checking.\n///\n/// # Parameters\n///\n/// - `interface`: The generic interface type to instantiate\n/// - `type_args`: The type arguments to substitute\n/// - `interface_name`: Name of the interface for substitution context\n/// - `substitute_fn`: Callback to perform type argument substitution\n///\n/// # Returns\n///\n/// Returns the instantiated interface type with all type parameters replaced.\npub fn instantiate_generic_interface\u003cF\u003e(\n    interface: Type,\n    type_args: \u0026Vec\u003cType\u003e,\n    interface_name: \u0026str,\n    substitute_fn: F,\n) -\u003e Type\nwhere\n    F: Fn(\u0026Type, \u0026Vec\u003cType\u003e, \u0026str) -\u003e Type,\n{\n    let mut instantiated_iface = interface.clone();\n    if let TypeKind::Object(ref mut obj) = instantiated_iface.kind {\n        // Build substitution map from interface type params\n        // For generic interfaces, we stored the raw type with references to T\n        // We need to substitute T -\u003e type_arg for each type param\n        for member in \u0026mut obj.members {\n            match member {\n                ObjectTypeMember::Method(method) =\u003e {\n                    // Substitute return type\n                    method.return_type =\n                        substitute_fn(\u0026method.return_type, type_args, interface_name);\n                    // Substitute parameter types\n                    for param in \u0026mut method.parameters {\n                        if let Some(ref type_ann) = param.type_annotation {\n                            param.type_annotation =\n                                Some(substitute_fn(type_ann, type_args, interface_name));\n                        }\n                    }\n                }\n                ObjectTypeMember::Property(prop) =\u003e {\n                    prop.type_annotation =\n                        substitute_fn(\u0026prop.type_annotation, type_args, interface_name);\n                }\n                ObjectTypeMember::Index(_) =\u003e {}\n            }\n        }\n    }\n    instantiated_iface\n}\n","traces":[{"line":47,"address":[],"length":0,"stats":{"Line":173}},{"line":54,"address":[],"length":0,"stats":{"Line":692}},{"line":57,"address":[],"length":0,"stats":{"Line":199}},{"line":61,"address":[],"length":0,"stats":{"Line":26}},{"line":63,"address":[],"length":0,"stats":{"Line":52}},{"line":64,"address":[],"length":0,"stats":{"Line":52}},{"line":65,"address":[],"length":0,"stats":{"Line":52}},{"line":67,"address":[],"length":0,"stats":{"Line":26}},{"line":70,"address":[],"length":0,"stats":{"Line":441}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":147}},{"line":77,"address":[],"length":0,"stats":{"Line":735}},{"line":78,"address":[],"length":0,"stats":{"Line":151}},{"line":82,"address":[],"length":0,"stats":{"Line":516}},{"line":86,"address":[],"length":0,"stats":{"Line":516}},{"line":89,"address":[],"length":0,"stats":{"Line":172}},{"line":91,"address":[],"length":0,"stats":{"Line":172}},{"line":93,"address":[],"length":0,"stats":{"Line":344}},{"line":95,"address":[],"length":0,"stats":{"Line":172}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":176,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":37}},{"line":213,"address":[],"length":0,"stats":{"Line":148}},{"line":216,"address":[],"length":0,"stats":{"Line":148}},{"line":219,"address":[],"length":0,"stats":{"Line":323}},{"line":220,"address":[],"length":0,"stats":{"Line":285}},{"line":222,"address":[],"length":0,"stats":{"Line":460}},{"line":225,"address":[],"length":0,"stats":{"Line":115}},{"line":228,"address":[],"length":0,"stats":{"Line":115}},{"line":231,"address":[],"length":0,"stats":{"Line":108}},{"line":234,"address":[],"length":0,"stats":{"Line":27}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":568}},{"line":247,"address":[],"length":0,"stats":{"Line":39}},{"line":249,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":10}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":262,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":2}},{"line":267,"address":[],"length":0,"stats":{"Line":2}},{"line":269,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":2}},{"line":273,"address":[],"length":0,"stats":{"Line":10}},{"line":274,"address":[],"length":0,"stats":{"Line":2}},{"line":279,"address":[],"length":0,"stats":{"Line":6}},{"line":281,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":2}},{"line":285,"address":[],"length":0,"stats":{"Line":4}},{"line":288,"address":[],"length":0,"stats":{"Line":2}},{"line":292,"address":[],"length":0,"stats":{"Line":105}},{"line":293,"address":[],"length":0,"stats":{"Line":35}},{"line":295,"address":[],"length":0,"stats":{"Line":174}},{"line":296,"address":[],"length":0,"stats":{"Line":224}},{"line":297,"address":[],"length":0,"stats":{"Line":52}},{"line":298,"address":[],"length":0,"stats":{"Line":2}},{"line":303,"address":[],"length":0,"stats":{"Line":37}},{"line":304,"address":[],"length":0,"stats":{"Line":1}},{"line":305,"address":[],"length":0,"stats":{"Line":1}},{"line":307,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":3}},{"line":309,"address":[],"length":0,"stats":{"Line":2}},{"line":311,"address":[],"length":0,"stats":{"Line":3}},{"line":313,"address":[],"length":0,"stats":{"Line":2}},{"line":314,"address":[],"length":0,"stats":{"Line":2}},{"line":315,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[],"length":0,"stats":{"Line":2}},{"line":320,"address":[],"length":0,"stats":{"Line":4}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":2}},{"line":327,"address":[],"length":0,"stats":{"Line":3}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":35}},{"line":354,"address":[],"length":0,"stats":{"Line":70}},{"line":355,"address":[],"length":0,"stats":{"Line":35}},{"line":357,"address":[],"length":0,"stats":{"Line":35}},{"line":361,"address":[],"length":0,"stats":{"Line":105}},{"line":364,"address":[],"length":0,"stats":{"Line":35}},{"line":365,"address":[],"length":0,"stats":{"Line":175}},{"line":366,"address":[],"length":0,"stats":{"Line":39}},{"line":371,"address":[],"length":0,"stats":{"Line":102}},{"line":373,"address":[],"length":0,"stats":{"Line":34}},{"line":375,"address":[],"length":0,"stats":{"Line":34}},{"line":377,"address":[],"length":0,"stats":{"Line":68}},{"line":380,"address":[],"length":0,"stats":{"Line":68}},{"line":381,"address":[],"length":0,"stats":{"Line":34}},{"line":383,"address":[],"length":0,"stats":{"Line":138}},{"line":385,"address":[],"length":0,"stats":{"Line":34}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":447,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":476,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":43}},{"line":517,"address":[],"length":0,"stats":{"Line":172}},{"line":521,"address":[],"length":0,"stats":{"Line":43}},{"line":522,"address":[],"length":0,"stats":{"Line":129}},{"line":523,"address":[],"length":0,"stats":{"Line":43}},{"line":524,"address":[],"length":0,"stats":{"Line":43}},{"line":526,"address":[],"length":0,"stats":{"Line":43}},{"line":529,"address":[],"length":0,"stats":{"Line":86}},{"line":530,"address":[],"length":0,"stats":{"Line":43}},{"line":531,"address":[],"length":0,"stats":{"Line":86}},{"line":532,"address":[],"length":0,"stats":{"Line":43}},{"line":534,"address":[],"length":0,"stats":{"Line":86}},{"line":537,"address":[],"length":0,"stats":{"Line":47}},{"line":538,"address":[],"length":0,"stats":{"Line":12}},{"line":542,"address":[],"length":0,"stats":{"Line":55}},{"line":543,"address":[],"length":0,"stats":{"Line":24}},{"line":546,"address":[],"length":0,"stats":{"Line":43}},{"line":565,"address":[],"length":0,"stats":{"Line":41}},{"line":570,"address":[],"length":0,"stats":{"Line":82}},{"line":573,"address":[],"length":0,"stats":{"Line":169}},{"line":574,"address":[],"length":0,"stats":{"Line":64}},{"line":575,"address":[],"length":0,"stats":{"Line":46}},{"line":576,"address":[],"length":0,"stats":{"Line":69}},{"line":577,"address":[],"length":0,"stats":{"Line":92}},{"line":578,"address":[],"length":0,"stats":{"Line":92}},{"line":579,"address":[],"length":0,"stats":{"Line":46}},{"line":580,"address":[],"length":0,"stats":{"Line":23}},{"line":581,"address":[],"length":0,"stats":{"Line":23}},{"line":583,"address":[],"length":0,"stats":{"Line":23}},{"line":586,"address":[],"length":0,"stats":{"Line":56}},{"line":587,"address":[],"length":0,"stats":{"Line":84}},{"line":588,"address":[],"length":0,"stats":{"Line":112}},{"line":589,"address":[],"length":0,"stats":{"Line":112}},{"line":590,"address":[],"length":0,"stats":{"Line":56}},{"line":591,"address":[],"length":0,"stats":{"Line":28}},{"line":592,"address":[],"length":0,"stats":{"Line":84}},{"line":593,"address":[],"length":0,"stats":{"Line":56}},{"line":594,"address":[],"length":0,"stats":{"Line":28}},{"line":596,"address":[],"length":0,"stats":{"Line":28}},{"line":599,"address":[],"length":0,"stats":{"Line":4}},{"line":600,"address":[],"length":0,"stats":{"Line":6}},{"line":601,"address":[],"length":0,"stats":{"Line":8}},{"line":602,"address":[],"length":0,"stats":{"Line":8}},{"line":603,"address":[],"length":0,"stats":{"Line":4}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":605,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":2}},{"line":610,"address":[],"length":0,"stats":{"Line":2}},{"line":611,"address":[],"length":0,"stats":{"Line":4}},{"line":612,"address":[],"length":0,"stats":{"Line":6}},{"line":613,"address":[],"length":0,"stats":{"Line":6}},{"line":614,"address":[],"length":0,"stats":{"Line":2}},{"line":616,"address":[],"length":0,"stats":{"Line":6}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":623,"address":[],"length":0,"stats":{"Line":9}},{"line":626,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":637,"address":[],"length":0,"stats":{"Line":0}},{"line":643,"address":[],"length":0,"stats":{"Line":41}},{"line":658,"address":[],"length":0,"stats":{"Line":2}},{"line":659,"address":[],"length":0,"stats":{"Line":6}},{"line":660,"address":[],"length":0,"stats":{"Line":2}},{"line":661,"address":[],"length":0,"stats":{"Line":0}},{"line":662,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":666,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":43}},{"line":697,"address":[],"length":0,"stats":{"Line":49}},{"line":698,"address":[],"length":0,"stats":{"Line":18}},{"line":699,"address":[],"length":0,"stats":{"Line":24}},{"line":701,"address":[],"length":0,"stats":{"Line":6}},{"line":702,"address":[],"length":0,"stats":{"Line":18}},{"line":703,"address":[],"length":0,"stats":{"Line":6}},{"line":704,"address":[],"length":0,"stats":{"Line":6}},{"line":706,"address":[],"length":0,"stats":{"Line":6}},{"line":711,"address":[],"length":0,"stats":{"Line":18}},{"line":712,"address":[],"length":0,"stats":{"Line":6}},{"line":713,"address":[],"length":0,"stats":{"Line":18}},{"line":714,"address":[],"length":0,"stats":{"Line":6}},{"line":717,"address":[],"length":0,"stats":{"Line":43}},{"line":733,"address":[],"length":0,"stats":{"Line":42}},{"line":740,"address":[],"length":0,"stats":{"Line":84}},{"line":741,"address":[],"length":0,"stats":{"Line":38}},{"line":745,"address":[],"length":0,"stats":{"Line":24}},{"line":748,"address":[],"length":0,"stats":{"Line":12}},{"line":750,"address":[],"length":0,"stats":{"Line":8}},{"line":752,"address":[],"length":0,"stats":{"Line":4}},{"line":753,"address":[],"length":0,"stats":{"Line":16}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":16}},{"line":776,"address":[],"length":0,"stats":{"Line":60}},{"line":781,"address":[],"length":0,"stats":{"Line":73}},{"line":782,"address":[],"length":0,"stats":{"Line":47}},{"line":786,"address":[],"length":0,"stats":{"Line":26}},{"line":787,"address":[],"length":0,"stats":{"Line":45}},{"line":788,"address":[],"length":0,"stats":{"Line":64}},{"line":789,"address":[],"length":0,"stats":{"Line":48}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":45}},{"line":799,"address":[],"length":0,"stats":{"Line":64}},{"line":801,"address":[],"length":0,"stats":{"Line":16}},{"line":802,"address":[],"length":0,"stats":{"Line":48}},{"line":803,"address":[],"length":0,"stats":{"Line":16}},{"line":804,"address":[],"length":0,"stats":{"Line":16}},{"line":806,"address":[],"length":0,"stats":{"Line":16}},{"line":810,"address":[],"length":0,"stats":{"Line":48}},{"line":811,"address":[],"length":0,"stats":{"Line":16}},{"line":812,"address":[],"length":0,"stats":{"Line":64}},{"line":813,"address":[],"length":0,"stats":{"Line":16}},{"line":816,"address":[],"length":0,"stats":{"Line":18}},{"line":817,"address":[],"length":0,"stats":{"Line":4}},{"line":821,"address":[],"length":0,"stats":{"Line":13}},{"line":843,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":0}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":859,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":867,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":872,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":0}},{"line":875,"address":[],"length":0,"stats":{"Line":0}},{"line":879,"address":[],"length":0,"stats":{"Line":0}}],"covered":189,"coverable":333},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","declaration_phase.rs"],"content":"//! Declaration phase: Symbol registration and declaration handling\n//!\n//! This phase handles:\n//! - Registering function signatures in the symbol table\n//! - Declaring variables, constants, and type aliases\n//! - Declaring classes, interfaces, and enums\n//! - Tracking declarations for forward references\n//!\n//! **Design Pattern**: Stateless phase functions that take explicit context parameters.\n//! The phase focuses on DECLARING symbols (adding them to the symbol table) before\n//! full type checking occurs. This enables forward references and proper scope resolution.\n\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::TypeCheckError;\nuse typedlua_parser::ast::pattern::{ArrayPatternElement, Pattern};\nuse typedlua_parser::ast::statement::{\n    DeclareConstStatement, DeclareFunctionStatement, DeclareNamespaceStatement,\n    FunctionDeclaration, MethodSignature, PropertySignature, Statement,\n};\nuse typedlua_parser::ast::types::{\n    FunctionType, ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind,\n};\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Register a function signature in the symbol table.\n///\n/// This function creates a symbol for a function declaration based on its signature\n/// (name, parameters, return type, type parameters) and adds it to the symbol table.\n/// This allows the function to be referenced before its body is type-checked.\n///\n/// This is called during the declaration phase (PASS 1), before checking the function body.\n///\n/// # Validation\n///\n/// - Type predicate return types: Validates that the parameter name in a type predicate\n///   actually matches one of the function's parameters\n/// - Return type: Defaults to `void` if no return type is specified\n///\n/// # Parameters\n///\n/// - `decl`: The function declaration to register\n/// - `symbol_table`: Mutable symbol table to add the function symbol\n/// - `interner`: String interner for resolving the function name\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the function was successfully registered, or an error if\n/// validation fails or a symbol with the same name already exists in the current scope.\npub fn register_function_signature(\n    decl: \u0026FunctionDeclaration,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Validate type predicate return types\n    if let Some(return_type) = \u0026decl.return_type {\n        if let TypeKind::TypePredicate(predicate) = \u0026return_type.kind {\n            // Validate that the parameter name in the predicate matches one of the function parameters\n            let param_exists = decl.parameters.iter().any(|param| {\n                if let Pattern::Identifier(ident) = \u0026param.pattern {\n                    ident.node == predicate.parameter_name.node\n                } else {\n                    false\n                }\n            });\n\n            if !param_exists {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Type predicate parameter '{}' does not match any function parameter\",\n                        predicate.parameter_name.node\n                    ),\n                    predicate.span,\n                ));\n            }\n        }\n    }\n\n    // Create function type\n    let func_type =\n        Type::new(\n            TypeKind::Function(FunctionType {\n                type_parameters: decl.type_parameters.clone(),\n                parameters: decl.parameters.clone(),\n                return_type: Box::new(decl.return_type.clone().unwrap_or_else(|| {\n                    Type::new(TypeKind::Primitive(PrimitiveType::Void), decl.span)\n                })),\n                throws: decl.throws.clone(),\n                span: decl.span,\n            }),\n            decl.span,\n        );\n\n    // Declare function in symbol table\n    let symbol = Symbol::new(\n        interner.resolve(decl.name.node).to_string(),\n        SymbolKind::Function,\n        func_type,\n        decl.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, decl.span))\n}\n\n/// Declare symbols from a destructuring pattern.\n///\n/// This function recursively traverses a pattern (identifier, array destructuring,\n/// object destructuring, or-patterns) and declares each binding in the symbol table.\n///\n/// # Pattern Types\n///\n/// - **Identifier**: `let x: number` - declares `x`\n/// - **Array**: `let [a, b, ...rest] = array` - declares `a`, `b`, `rest`\n/// - **Object**: `let {x, y: z} = obj` - declares `x`, `z`\n/// - **Or-pattern**: `let (a | b) = value` - declares from first alternative\n/// - **Literals/Wildcards**: No declarations\n///\n/// # Parameters\n///\n/// - `pattern`: The pattern to extract bindings from\n/// - `typ`: The type to assign to the bindings\n/// - `kind`: Symbol kind (Variable, Const, etc.)\n/// - `span`: Source location for error reporting\n/// - `symbol_table`: Mutable symbol table\n/// - `interner`: String interner for resolving names\npub fn declare_pattern(\n    pattern: \u0026Pattern,\n    typ: Type,\n    kind: SymbolKind,\n    span: Span,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    match pattern {\n        Pattern::Identifier(ident) =\u003e {\n            let symbol = Symbol::new(interner.resolve(ident.node).to_string(), kind, typ, span);\n            symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, span))?;\n            Ok(())\n        }\n        Pattern::Array(array_pattern) =\u003e {\n            // Extract element type from array type\n            if let TypeKind::Array(elem_type) = \u0026typ.kind {\n                for elem in \u0026array_pattern.elements {\n                    match elem {\n                        ArrayPatternElement::Pattern(pat) =\u003e {\n                            declare_pattern(\n                                pat,\n                                (**elem_type).clone(),\n                                kind,\n                                span,\n                                symbol_table,\n                                interner,\n                            )?;\n                        }\n                        ArrayPatternElement::Rest(ident) =\u003e {\n                            // Rest gets array type\n                            let array_type = Type::new(TypeKind::Array(elem_type.clone()), span);\n                            let symbol = Symbol::new(\n                                interner.resolve(ident.node).to_string(),\n                                kind,\n                                array_type,\n                                span,\n                            );\n                            symbol_table\n                                .declare(symbol)\n                                .map_err(|e| TypeCheckError::new(e, span))?;\n                        }\n                        ArrayPatternElement::Hole =\u003e {\n                            // Holes don't declare symbols\n                        }\n                    }\n                }\n            } else {\n                return Err(TypeCheckError::new(\n                    \"Cannot destructure non-array type\",\n                    span,\n                ));\n            }\n            Ok(())\n        }\n        Pattern::Object(obj_pattern) =\u003e {\n            // Extract properties from object type\n            if let TypeKind::Object(obj_type) = \u0026typ.kind {\n                for prop_pattern in \u0026obj_pattern.properties {\n                    // Find matching property in type\n                    let prop_type = obj_type.members.iter().find_map(|member| {\n                        if let ObjectTypeMember::Property(prop) = member {\n                            if prop.name.node == prop_pattern.key.node {\n                                return Some(prop.type_annotation.clone());\n                            }\n                        }\n                        None\n                    });\n\n                    let prop_type = match prop_type {\n                        Some(t) =\u003e t,\n                        None =\u003e {\n                            return Err(TypeCheckError::new(\n                                format!(\n                                    \"Property '{}' does not exist on type\",\n                                    prop_pattern.key.node\n                                ),\n                                span,\n                            ));\n                        }\n                    };\n\n                    if let Some(value_pattern) = \u0026prop_pattern.value {\n                        declare_pattern(\n                            value_pattern,\n                            prop_type,\n                            kind,\n                            span,\n                            symbol_table,\n                            interner,\n                        )?;\n                    } else {\n                        // Shorthand: { x } means { x: x }\n                        let symbol = Symbol::new(\n                            interner.resolve(prop_pattern.key.node).to_string(),\n                            kind,\n                            prop_type,\n                            span,\n                        );\n                        symbol_table\n                            .declare(symbol)\n                            .map_err(|e| TypeCheckError::new(e, span))?;\n                    }\n                }\n            } else {\n                return Err(TypeCheckError::new(\n                    \"Cannot destructure non-object type\",\n                    span,\n                ));\n            }\n            Ok(())\n        }\n        Pattern::Literal(_, _) | Pattern::Wildcard(_) =\u003e {\n            // Literals and wildcards don't declare symbols\n            Ok(())\n        }\n        Pattern::Or(or_pattern) =\u003e {\n            // For or-patterns, all alternatives bind the same variables\n            // Declare from the first alternative\n            if let Some(first) = or_pattern.alternatives.first() {\n                declare_pattern(first, typ, kind, span, symbol_table, interner)?;\n            }\n            Ok(())\n        }\n    }\n}\n\n/// Register a `declare function` statement in the symbol table.\n///\n/// Ambient function declarations (using `declare function`) don't have bodies.\n/// They just register the function signature for type checking purposes.\npub fn register_declare_function(\n    func: \u0026DeclareFunctionStatement,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    let func_type = Type::new(\n        TypeKind::Function(FunctionType {\n            type_parameters: func.type_parameters.clone(),\n            parameters: func.parameters.clone(),\n            return_type: Box::new(func.return_type.clone()),\n            throws: func.throws.clone(),\n            span: func.span,\n        }),\n        func.span,\n    );\n\n    let symbol = Symbol::new(\n        interner.resolve(func.name.node).to_string(),\n        SymbolKind::Function,\n        func_type,\n        func.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, func.span))\n}\n\n/// Register a `declare const` statement in the symbol table.\n///\n/// Ambient constant declarations don't have initializers.\n/// They just register the constant name and type.\npub fn register_declare_const(\n    const_decl: \u0026DeclareConstStatement,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    let symbol = Symbol::new(\n        interner.resolve(const_decl.name.node).to_string(),\n        SymbolKind::Const,\n        const_decl.type_annotation.clone(),\n        const_decl.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, const_decl.span))\n}\n\n/// Register a `declare namespace` statement in the symbol table.\n///\n/// Namespace declarations create an object type containing all exported members.\n/// This allows `Namespace.member` access patterns.\npub fn register_declare_namespace(\n    ns: \u0026DeclareNamespaceStatement,\n    symbol_table: \u0026mut SymbolTable,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Create object type from namespace members\n    let members: Vec\u003c_\u003e = ns\n        .members\n        .iter()\n        .filter_map(|member| match member {\n            Statement::DeclareFunction(func) if func.is_export =\u003e {\n                Some(ObjectTypeMember::Method(MethodSignature {\n                    name: func.name.clone(),\n                    type_parameters: func.type_parameters.clone(),\n                    parameters: func.parameters.clone(),\n                    return_type: func.return_type.clone(),\n                    body: None,\n                    span: func.span,\n                }))\n            }\n            Statement::DeclareConst(const_decl) if const_decl.is_export =\u003e {\n                Some(ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: true, // Constants are readonly\n                    name: const_decl.name.clone(),\n                    is_optional: false,\n                    type_annotation: const_decl.type_annotation.clone(),\n                    span: const_decl.span,\n                }))\n            }\n            _ =\u003e None,\n        })\n        .collect();\n\n    let namespace_type = Type::new(\n        TypeKind::Object(ObjectType {\n            members,\n            span: ns.span,\n        }),\n        ns.span,\n    );\n\n    let symbol = Symbol::new(\n        interner.resolve(ns.name.node).to_string(),\n        SymbolKind::Const,\n        namespace_type,\n        ns.span,\n    );\n\n    symbol_table\n        .declare(symbol)\n        .map_err(|e| TypeCheckError::new(e, ns.span))\n}\n","traces":[{"line":50,"address":[],"length":0,"stats":{"Line":38}},{"line":56,"address":[],"length":0,"stats":{"Line":71}},{"line":57,"address":[],"length":0,"stats":{"Line":35}},{"line":59,"address":[],"length":0,"stats":{"Line":8}},{"line":60,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":2}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":2}},{"line":68,"address":[],"length":0,"stats":{"Line":2}},{"line":69,"address":[],"length":0,"stats":{"Line":2}},{"line":70,"address":[],"length":0,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":1}},{"line":73,"address":[],"length":0,"stats":{"Line":1}},{"line":80,"address":[],"length":0,"stats":{"Line":37}},{"line":83,"address":[],"length":0,"stats":{"Line":74}},{"line":84,"address":[],"length":0,"stats":{"Line":74}},{"line":85,"address":[],"length":0,"stats":{"Line":153}},{"line":86,"address":[],"length":0,"stats":{"Line":15}},{"line":88,"address":[],"length":0,"stats":{"Line":74}},{"line":89,"address":[],"length":0,"stats":{"Line":37}},{"line":91,"address":[],"length":0,"stats":{"Line":37}},{"line":96,"address":[],"length":0,"stats":{"Line":111}},{"line":97,"address":[],"length":0,"stats":{"Line":37}},{"line":98,"address":[],"length":0,"stats":{"Line":37}},{"line":99,"address":[],"length":0,"stats":{"Line":37}},{"line":102,"address":[],"length":0,"stats":{"Line":37}},{"line":103,"address":[],"length":0,"stats":{"Line":74}},{"line":104,"address":[],"length":0,"stats":{"Line":37}},{"line":128,"address":[],"length":0,"stats":{"Line":252}},{"line":136,"address":[],"length":0,"stats":{"Line":252}},{"line":137,"address":[],"length":0,"stats":{"Line":252}},{"line":138,"address":[],"length":0,"stats":{"Line":2016}},{"line":139,"address":[],"length":0,"stats":{"Line":252}},{"line":140,"address":[],"length":0,"stats":{"Line":504}},{"line":141,"address":[],"length":0,"stats":{"Line":256}},{"line":142,"address":[],"length":0,"stats":{"Line":251}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[],"length":0,"stats":{"Line":0}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":170,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":179,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":196,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":0}},{"line":204,"address":[],"length":0,"stats":{"Line":0}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":91}},{"line":267,"address":[],"length":0,"stats":{"Line":91}},{"line":268,"address":[],"length":0,"stats":{"Line":273}},{"line":269,"address":[],"length":0,"stats":{"Line":273}},{"line":270,"address":[],"length":0,"stats":{"Line":364}},{"line":271,"address":[],"length":0,"stats":{"Line":182}},{"line":272,"address":[],"length":0,"stats":{"Line":91}},{"line":274,"address":[],"length":0,"stats":{"Line":91}},{"line":278,"address":[],"length":0,"stats":{"Line":273}},{"line":279,"address":[],"length":0,"stats":{"Line":91}},{"line":280,"address":[],"length":0,"stats":{"Line":91}},{"line":281,"address":[],"length":0,"stats":{"Line":91}},{"line":284,"address":[],"length":0,"stats":{"Line":91}},{"line":285,"address":[],"length":0,"stats":{"Line":182}},{"line":286,"address":[],"length":0,"stats":{"Line":91}},{"line":293,"address":[],"length":0,"stats":{"Line":6}},{"line":299,"address":[],"length":0,"stats":{"Line":18}},{"line":300,"address":[],"length":0,"stats":{"Line":6}},{"line":301,"address":[],"length":0,"stats":{"Line":12}},{"line":302,"address":[],"length":0,"stats":{"Line":6}},{"line":305,"address":[],"length":0,"stats":{"Line":6}},{"line":306,"address":[],"length":0,"stats":{"Line":12}},{"line":307,"address":[],"length":0,"stats":{"Line":6}},{"line":314,"address":[],"length":0,"stats":{"Line":31}},{"line":320,"address":[],"length":0,"stats":{"Line":93}},{"line":321,"address":[],"length":0,"stats":{"Line":31}},{"line":323,"address":[],"length":0,"stats":{"Line":383}},{"line":324,"address":[],"length":0,"stats":{"Line":703}},{"line":325,"address":[],"length":0,"stats":{"Line":351}},{"line":326,"address":[],"length":0,"stats":{"Line":1053}},{"line":327,"address":[],"length":0,"stats":{"Line":1053}},{"line":328,"address":[],"length":0,"stats":{"Line":1053}},{"line":329,"address":[],"length":0,"stats":{"Line":1053}},{"line":330,"address":[],"length":0,"stats":{"Line":351}},{"line":331,"address":[],"length":0,"stats":{"Line":351}},{"line":334,"address":[],"length":0,"stats":{"Line":84}},{"line":335,"address":[],"length":0,"stats":{"Line":42}},{"line":336,"address":[],"length":0,"stats":{"Line":42}},{"line":337,"address":[],"length":0,"stats":{"Line":126}},{"line":338,"address":[],"length":0,"stats":{"Line":42}},{"line":339,"address":[],"length":0,"stats":{"Line":84}},{"line":340,"address":[],"length":0,"stats":{"Line":42}},{"line":343,"address":[],"length":0,"stats":{"Line":1}},{"line":348,"address":[],"length":0,"stats":{"Line":31}},{"line":349,"address":[],"length":0,"stats":{"Line":31}},{"line":350,"address":[],"length":0,"stats":{"Line":31}},{"line":352,"address":[],"length":0,"stats":{"Line":31}},{"line":356,"address":[],"length":0,"stats":{"Line":93}},{"line":357,"address":[],"length":0,"stats":{"Line":31}},{"line":358,"address":[],"length":0,"stats":{"Line":31}},{"line":359,"address":[],"length":0,"stats":{"Line":31}},{"line":362,"address":[],"length":0,"stats":{"Line":31}},{"line":363,"address":[],"length":0,"stats":{"Line":62}},{"line":364,"address":[],"length":0,"stats":{"Line":31}}],"covered":89,"coverable":153},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","inference_phase.rs"],"content":"//! Inference phase: Statement and expression type checking\n\nuse crate::TypeCheckError;\nuse typedlua_parser::ast::statement::{\n    ForStatement, IfStatement, RepeatStatement, ReturnStatement, WhileStatement,\n};\nuse typedlua_parser::span::Span;\n\n/// Check that a rethrow statement appears in a valid context (inside a catch block).\n///\n/// Rethrow can only be used within a catch clause to re-raise the caught exception.\n///\n/// # Parameters\n///\n/// - `in_catch_block`: Stack of catch block contexts (true if currently in a catch block)\n/// - `span`: Source span for error reporting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if valid (in a catch block), or an error if outside a catch block.\npub fn check_rethrow_statement(in_catch_block: \u0026[bool], span: Span) -\u003e Result\u003c(), TypeCheckError\u003e {\n    if in_catch_block.last() != Some(\u0026true) {\n        return Err(TypeCheckError::new(\n            \"rethrow can only be used outside of a catch block\",\n            span,\n        ));\n    }\n    Ok(())\n}\n\n/// Check an if statement structure.\n///\n/// This function validates the if statement structure and returns information\n/// about blocks that need type checking. The caller should check expressions\n/// and blocks with access to full TypeChecker state.\n///\n/// # Parameters\n///\n/// - `if_stmt`: The if statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the structure is valid. The caller should then:\n/// 1. Infer the condition expression type\n/// 2. Check the then block\n/// 3. Check else-if conditions and blocks\n/// 4. Check the else block if present\npub fn check_if_statement(_if_stmt: \u0026IfStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation only - caller handles expression/block checking\n    // If statement structure is already validated by parser\n    Ok(())\n}\n\n/// Check a while statement structure.\n///\n/// # Parameters\n///\n/// - `while_stmt`: The while statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())`. The caller should check the condition expression and body block.\npub fn check_while_statement(_while_stmt: \u0026WhileStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation only - caller handles expression/block checking\n    Ok(())\n}\n\n/// Check a for statement structure.\n///\n/// This validates for loop patterns (numeric and generic).\n///\n/// # Parameters\n///\n/// - `for_stmt`: The for statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())`. The caller should:\n/// 1. Enter new scope for loop variable\n/// 2. Infer iterator expression types\n/// 3. Declare loop variable(s)\n/// 4. Check the loop body\n/// 5. Exit scope\npub fn check_for_statement(_for_stmt: \u0026ForStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation - caller handles variable declaration and body checking\n    Ok(())\n}\n\n/// Check a repeat statement structure.\n///\n/// # Parameters\n///\n/// - `repeat_stmt`: The repeat statement to check\n///\n/// # Returns\n///\n/// Returns `Ok(())`. The caller should check the body block and condition expression.\npub fn check_repeat_statement(_repeat_stmt: \u0026RepeatStatement) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Structural validation only\n    Ok(())\n}\n\n/// Check a return statement structure and validate context.\n///\n/// This function validates that the return statement appears in a valid context\n/// (inside a function). The caller should handle type checking the return expression\n/// against the expected return type.\n///\n/// # Parameters\n///\n/// - `return_stmt`: The return statement to check\n/// - `current_function_return_type`: The expected return type of the enclosing function\n/// - `span`: Span for error reporting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if valid, or an error if the return statement is outside a function.\n/// The caller should then check the return expression type matches the function return type.\npub fn check_return_statement(\n    _return_stmt: \u0026ReturnStatement,\n    current_function_return_type: Option\u003c\u0026typedlua_parser::ast::types::Type\u003e,\n    span: Span,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Validate we're inside a function\n    if current_function_return_type.is_none() {\n        return Err(TypeCheckError::new(\n            \"Return statement outside function\",\n            span,\n        ));\n    }\n\n    // Caller should check the expression type against current_function_return_type\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    #[test]\n    fn test_check_rethrow_inside_catch() {\n        let span = Span::new(0, 10, 0, 10);\n        let in_catch = vec![true];\n        let result = check_rethrow_statement(\u0026in_catch, span);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_rethrow_outside_catch() {\n        let span = Span::new(0, 10, 0, 10);\n        let in_catch: Vec\u003cbool\u003e = vec![];\n        let result = check_rethrow_statement(\u0026in_catch, span);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_check_return_inside_function() {\n        let span = Span::new(0, 10, 0, 10);\n        let return_type = typedlua_parser::ast::types::Type::new(\n            typedlua_parser::ast::types::TypeKind::Primitive(\n                typedlua_parser::ast::types::PrimitiveType::Number,\n            ),\n            span,\n        );\n        let result = check_return_statement(\n            \u0026typedlua_parser::ast::statement::ReturnStatement {\n                values: Vec::new(),\n                span,\n            },\n            Some(\u0026return_type),\n            span,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_return_outside_function() {\n        let span = Span::new(0, 10, 0, 10);\n        let result = check_return_statement(\n            \u0026typedlua_parser::ast::statement::ReturnStatement {\n                values: Vec::new(),\n                span,\n            },\n            None,\n            span,\n        );\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_check_if_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let if_stmt = typedlua_parser::ast::statement::IfStatement {\n            condition: typedlua_parser::ast::expression::Expression {\n                kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                    typedlua_parser::ast::expression::Literal::Boolean(true),\n                ),\n                span,\n                annotated_type: None,\n                receiver_class: None,\n            },\n            then_block: typedlua_parser::ast::statement::Block {\n                statements: Vec::new(),\n                span,\n            },\n            else_ifs: Vec::new(),\n            else_block: None,\n            span,\n        };\n        let result = check_if_statement(\u0026if_stmt);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_while_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let while_stmt = typedlua_parser::ast::statement::WhileStatement {\n            condition: typedlua_parser::ast::expression::Expression {\n                kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                    typedlua_parser::ast::expression::Literal::Boolean(true),\n                ),\n                span,\n                annotated_type: None,\n                receiver_class: None,\n            },\n            body: typedlua_parser::ast::statement::Block {\n                statements: Vec::new(),\n                span,\n            },\n            span,\n        };\n        let result = check_while_statement(\u0026while_stmt);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_for_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let for_stmt = typedlua_parser::ast::statement::ForStatement::Numeric(Box::new(\n            typedlua_parser::ast::statement::ForNumeric {\n                variable: typedlua_parser::ast::Spanned::new(\n                    typedlua_parser::string_interner::StringId::from_u32(0),\n                    span,\n                ),\n                start: typedlua_parser::ast::expression::Expression {\n                    kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                        typedlua_parser::ast::expression::Literal::Number(1.0),\n                    ),\n                    span,\n                    annotated_type: None,\n                    receiver_class: None,\n                },\n                end: typedlua_parser::ast::expression::Expression {\n                    kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                        typedlua_parser::ast::expression::Literal::Number(10.0),\n                    ),\n                    span,\n                    annotated_type: None,\n                    receiver_class: None,\n                },\n                step: None,\n                body: typedlua_parser::ast::statement::Block {\n                    statements: Vec::new(),\n                    span,\n                },\n                span,\n            },\n        ));\n        let result = check_for_statement(\u0026for_stmt);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_repeat_statement() {\n        let span = Span::new(0, 10, 0, 10);\n        let repeat_stmt = typedlua_parser::ast::statement::RepeatStatement {\n            body: typedlua_parser::ast::statement::Block {\n                statements: Vec::new(),\n                span,\n            },\n            until: typedlua_parser::ast::expression::Expression {\n                kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                    typedlua_parser::ast::expression::Literal::Boolean(true),\n                ),\n                span,\n                annotated_type: None,\n                receiver_class: None,\n            },\n            span,\n        };\n        let result = check_repeat_statement(\u0026repeat_stmt);\n        assert!(result.is_ok());\n    }\n}\n","traces":[{"line":21,"address":[],"length":0,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":23,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":51,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":84,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[],"length":0,"stats":{"Line":1}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":100,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":2}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":1}},{"line":127,"address":[],"length":0,"stats":{"Line":1}},{"line":128,"address":[],"length":0,"stats":{"Line":1}},{"line":133,"address":[],"length":0,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","mod.rs"],"content":"//! Type checker phase modules\n//!\n//! This module contains the decomposed phases of type checking, extracted from\n//! the monolithic type_checker.rs to improve maintainability and reduce cognitive load.\n//!\n//! Each phase handles a specific aspect of type checking:\n//! - `module_phase`: Import/export resolution and module dependency tracking\n//! - `declaration_phase`: Symbol declaration and registration (PASS 1)\n//! - `declaration_checking_phase`: Type alias, enum, interface checking (PASS 2)\n//! - `validation_phase`: Type compatibility and validation checks\n//! - `inference_phase`: Statement and expression type inference\n\npub mod declaration_checking_phase;\npub mod declaration_phase;\npub mod inference_phase;\npub mod module_phase;\npub mod validation_phase;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","module_phase.rs"],"content":"//! Module phase: Import/export resolution and module dependency tracking\n//!\n//! This phase handles:\n//! - Extracting exports from a program (export declarations, export specifiers)\n//! - Resolving import statements and registering imported symbols\n//! - Tracking module dependencies for multi-module compilation\n//!\n//! **Design Pattern**: Stateless phase functions that take explicit context parameters\n//! rather than encapsulating state. This allows flexibility in how the type checker\n//! orchestrates phase execution.\n\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::module_resolver::{\n    ExportedSymbol, ModuleExports, ModuleId, ModuleRegistry, ModuleResolver,\n};\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::visitors::{AccessControl, AccessControlVisitor, ClassMemberInfo, ClassMemberKind};\nuse crate::TypeCheckError;\nuse std::path::PathBuf;\nuse std::sync::Arc;\nuse typedlua_parser::ast::pattern::Pattern;\nuse typedlua_parser::ast::statement::{ExportKind, ImportClause, ImportDeclaration, Statement};\nuse typedlua_parser::ast::types::{ObjectTypeMember, PrimitiveType, Type, TypeKind};\nuse typedlua_parser::ast::Program;\nuse typedlua_parser::prelude::AccessModifier;\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Extract all exported symbols from a program.\n///\n/// This function analyzes export statements in the AST and builds a `ModuleExports`\n/// structure containing all named and default exports. It handles:\n///\n/// - `export { foo, bar }` - Named exports of existing symbols\n/// - `export const x = 1` - Inline export declarations\n/// - `export default expr` - Default exports\n/// - `export { foo } from './other'` - Re-exports from other modules\n///\n/// # Parameters\n///\n/// - `program`: The AST program to extract exports from\n/// - `symbol_table`: Symbol table for looking up exported symbols\n/// - `interner`: String interner for resolving identifier names\n/// - `module_registry`: Optional registry for resolving re-exports (None if not using modules)\n/// - `module_resolver`: Optional resolver for finding source modules (None if not using modules)\n/// - `current_module_id`: Optional ID of the current module (None if not using modules)\n///\n/// # Returns\n///\n/// A `ModuleExports` structure containing all exports found in the program.\npub fn extract_exports(\n    program: \u0026Program,\n    symbol_table: \u0026SymbolTable,\n    interner: \u0026StringInterner,\n    module_registry: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026crate::module_resolver::ModuleId\u003e,\n) -\u003e ModuleExports {\n    let mut exports = ModuleExports::new();\n\n    for stmt in program.statements.iter() {\n        if let Statement::Export(export_decl) = stmt {\n            match \u0026export_decl.kind {\n                ExportKind::Declaration(decl) =\u003e {\n                    extract_declaration_export(decl, symbol_table, interner, \u0026mut exports);\n                }\n                ExportKind::Named { specifiers, source } =\u003e {\n                    for spec in specifiers {\n                        let local_name = interner.resolve(spec.local.node);\n                        let export_name = spec\n                            .exported\n                            .as_ref()\n                            .map(|e| interner.resolve(e.node))\n                            .unwrap_or_else(|| local_name.clone());\n\n                        // Check if this is a re-export from another module\n                        if let Some(source_path) = source {\n                            handle_reexport(\n                                \u0026local_name,\n                                \u0026export_name,\n                                source_path,\n                                module_registry,\n                                module_resolver,\n                                current_module_id,\n                                \u0026mut exports,\n                            );\n                        } else {\n                            // Local export - look up in symbol table\n                            if let Some(symbol) = symbol_table.lookup(\u0026local_name) {\n                                let is_type_only = matches!(\n                                    symbol.kind,\n                                    SymbolKind::TypeAlias | SymbolKind::Interface\n                                );\n                                exports.add_named(\n                                    export_name,\n                                    ExportedSymbol::new(symbol.clone(), is_type_only),\n                                );\n                            }\n                        }\n                    }\n                }\n                ExportKind::Default(_expr) =\u003e {\n                    // For default exports, create a synthetic symbol\n                    // Future: infer the type of the expression\n                    let default_symbol = Symbol {\n                        name: \"default\".to_string(),\n                        typ: Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            export_decl.span,\n                        ),\n                        kind: SymbolKind::Variable,\n                        span: export_decl.span,\n                        is_exported: true,\n                        references: Vec::new(),\n                    };\n                    exports.set_default(ExportedSymbol::new(default_symbol, false));\n                }\n            }\n        }\n    }\n\n    exports\n}\n\n/// Helper: Extract exports from an inline export declaration\nfn extract_declaration_export(\n    decl: \u0026Statement,\n    symbol_table: \u0026SymbolTable,\n    interner: \u0026StringInterner,\n    exports: \u0026mut ModuleExports,\n) {\n    match decl {\n        Statement::Variable(var_decl) =\u003e {\n            if let Pattern::Identifier(ident) = \u0026var_decl.pattern {\n                let ident_name = interner.resolve(ident.node);\n                if let Some(symbol) = symbol_table.lookup(\u0026ident_name) {\n                    exports.add_named(ident_name, ExportedSymbol::new(symbol.clone(), false));\n                }\n            }\n        }\n        Statement::Function(func_decl) =\u003e {\n            let func_name = interner.resolve(func_decl.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026func_name) {\n                exports.add_named(func_name, ExportedSymbol::new(symbol.clone(), false));\n            }\n        }\n        Statement::Class(class_decl) =\u003e {\n            let class_name = interner.resolve(class_decl.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026class_name) {\n                exports.add_named(class_name, ExportedSymbol::new(symbol.clone(), false));\n            }\n        }\n        Statement::TypeAlias(type_alias) =\u003e {\n            let alias_name = interner.resolve(type_alias.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026alias_name) {\n                exports.add_named(alias_name, ExportedSymbol::new(symbol.clone(), true));\n            }\n        }\n        Statement::Interface(interface_decl) =\u003e {\n            let interface_name = interner.resolve(interface_decl.name.node);\n            if let Some(symbol) = symbol_table.lookup(\u0026interface_name) {\n                exports.add_named(interface_name, ExportedSymbol::new(symbol.clone(), true));\n            }\n        }\n        _ =\u003e {}\n    }\n}\n\n/// Helper: Handle re-exports from another module\n#[allow(clippy::too_many_arguments)]\nfn handle_reexport(\n    local_name: \u0026str,\n    export_name: \u0026str,\n    source_path: \u0026str,\n    module_registry: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026std::sync::Arc\u003ccrate::module_resolver::ModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026crate::module_resolver::ModuleId\u003e,\n    exports: \u0026mut ModuleExports,\n) {\n    if let (Some(registry), Some(resolver), Some(current_id)) =\n        (module_registry, module_resolver, current_module_id)\n    {\n        if let Ok(source_module_id) = resolver.resolve(source_path, current_id.path()) {\n            if let Ok(source_exports) = registry.get_exports(\u0026source_module_id) {\n                if let Some(exported_sym) = source_exports.get_named(local_name) {\n                    exports.add_named(export_name.to_string(), exported_sym.clone());\n                }\n            }\n        }\n    }\n}\n\n/// Process an import statement and register imported symbols.\n///\n/// This function handles all import clause types:\n/// - Default imports: `import foo from './module'`\n/// - Named imports: `import { foo, bar } from './module'`\n/// - Type-only imports: `import type { Foo } from './module'`\n/// - Namespace imports: `import * as foo from './module'`\n/// - Mixed imports: `import foo, { bar } from './module'`\n///\n/// For type-only imports, symbols are registered in both the symbol table and type environment,\n/// and if the imported type is an interface/object, its members are registered in access control.\n///\n/// # Parameters\n///\n/// - `import`: The import declaration AST node\n/// - `symbol_table`: Mutable symbol table for declaring imported symbols\n/// - `type_env`: Mutable type environment for type-only imports\n/// - `access_control`: Mutable access control for interface/object member registration\n/// - `interner`: String interner for resolving names\n/// - `module_dependencies`: Vector to track import dependencies\n/// - `module_registry`, `module_resolver`, `current_module_id`: Optional module resolution components\n/// - `diagnostic_handler`: For reporting import resolution errors\n#[allow(clippy::too_many_arguments)]\npub fn check_import_statement(\n    import: \u0026ImportDeclaration,\n    symbol_table: \u0026mut SymbolTable,\n    type_env: \u0026mut TypeEnvironment,\n    access_control: \u0026mut AccessControl,\n    interner: \u0026StringInterner,\n    module_dependencies: \u0026mut Vec\u003cPathBuf\u003e,\n    module_registry: Option\u003c\u0026Arc\u003cModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026Arc\u003cModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026ModuleId\u003e,\n    diagnostic_handler: \u0026Arc\u003cdyn DiagnosticHandler\u003e,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    match \u0026import.clause {\n        ImportClause::Default(name) =\u003e {\n            let name_str = interner.resolve(name.node);\n            let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), import.span);\n            let symbol = Symbol::new(\n                name_str.to_string(),\n                SymbolKind::Variable,\n                any_type,\n                import.span,\n            );\n            symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, import.span))?;\n        }\n        ImportClause::Named(specifiers) =\u003e {\n            for spec in specifiers {\n                let name_str = interner.resolve(spec.imported.node);\n                let import_type = resolve_import_type(\n                    \u0026import.source,\n                    \u0026name_str,\n                    import.span,\n                    module_dependencies,\n                    module_registry,\n                    module_resolver,\n                    current_module_id,\n                    diagnostic_handler,\n                )?;\n\n                let symbol = Symbol::new(\n                    name_str.to_string(),\n                    SymbolKind::Variable,\n                    import_type,\n                    spec.span,\n                );\n                symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n            }\n        }\n        ImportClause::TypeOnly(specifiers) =\u003e {\n            for spec in specifiers {\n                let name_str = interner.resolve(spec.imported.node);\n                let import_type = resolve_import_type(\n                    \u0026import.source,\n                    \u0026name_str,\n                    import.span,\n                    module_dependencies,\n                    module_registry,\n                    module_resolver,\n                    current_module_id,\n                    diagnostic_handler,\n                )?;\n\n                // Register in symbol table\n                let symbol = Symbol::new(\n                    name_str.to_string(),\n                    SymbolKind::TypeAlias,\n                    import_type.clone(),\n                    spec.span,\n                );\n                symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n\n                // Also register in type_env\n                type_env\n                    .register_type_alias(name_str.to_string(), import_type.clone())\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n\n                // Register in access control if it's an object type\n                if let TypeKind::Object(obj_type) = \u0026import_type.kind {\n                    access_control.register_class(\u0026name_str, None);\n                    for member in \u0026obj_type.members {\n                        let member_info = match member {\n                            ObjectTypeMember::Property(prop) =\u003e ClassMemberInfo {\n                                name: interner.resolve(prop.name.node).to_string(),\n                                access: AccessModifier::Public,\n                                _is_static: false,\n                                kind: ClassMemberKind::Property {\n                                    type_annotation: prop.type_annotation.clone(),\n                                },\n                                is_final: prop.is_readonly,\n                            },\n                            ObjectTypeMember::Method(method) =\u003e ClassMemberInfo {\n                                name: interner.resolve(method.name.node).to_string(),\n                                access: AccessModifier::Public,\n                                _is_static: false,\n                                kind: ClassMemberKind::Method {\n                                    parameters: method.parameters.clone(),\n                                    return_type: Some(method.return_type.clone()),\n                                    is_abstract: false,\n                                },\n                                is_final: false,\n                            },\n                            ObjectTypeMember::Index(_) =\u003e continue,\n                        };\n                        access_control.register_member(\u0026name_str, member_info);\n                    }\n                }\n            }\n        }\n        ImportClause::Namespace(name) =\u003e {\n            let name_str = interner.resolve(name.node);\n            let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), import.span);\n            let symbol = Symbol::new(\n                name_str.to_string(),\n                SymbolKind::Variable,\n                any_type,\n                import.span,\n            );\n            symbol_table\n                .declare(symbol)\n                .map_err(|e| TypeCheckError::new(e, import.span))?;\n        }\n        ImportClause::Mixed { default, named } =\u003e {\n            // Handle default import\n            let default_name_str = interner.resolve(default.node);\n            let any_type = Type::new(TypeKind::Primitive(PrimitiveType::Unknown), import.span);\n            let default_symbol = Symbol::new(\n                default_name_str.to_string(),\n                SymbolKind::Variable,\n                any_type,\n                default.span,\n            );\n            symbol_table\n                .declare(default_symbol)\n                .map_err(|e| TypeCheckError::new(e, default.span))?;\n\n            // Handle named imports\n            for spec in named {\n                let name_str = interner.resolve(spec.imported.node);\n                let import_type = resolve_import_type(\n                    \u0026import.source,\n                    \u0026name_str,\n                    import.span,\n                    module_dependencies,\n                    module_registry,\n                    module_resolver,\n                    current_module_id,\n                    diagnostic_handler,\n                )?;\n\n                let symbol = Symbol::new(\n                    name_str.to_string(),\n                    SymbolKind::Variable,\n                    import_type,\n                    spec.span,\n                );\n                symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, spec.span))?;\n            }\n        }\n    }\n    Ok(())\n}\n\n/// Resolve the type of an imported symbol from a source module.\n///\n/// This function attempts to resolve the type of a symbol being imported from another module.\n/// If module resolution is configured and the source module is found, it looks up the symbol\n/// in the module's exports and returns its type. If resolution fails, it reports an error\n/// via the diagnostic handler and returns an Unknown type as a fallback.\n///\n/// Module dependencies are tracked by adding the resolved source module path to the dependencies vector.\n#[allow(clippy::too_many_arguments)]\nfn resolve_import_type(\n    source: \u0026str,\n    symbol_name: \u0026str,\n    span: Span,\n    module_dependencies: \u0026mut Vec\u003cPathBuf\u003e,\n    module_registry: Option\u003c\u0026Arc\u003cModuleRegistry\u003e\u003e,\n    module_resolver: Option\u003c\u0026Arc\u003cModuleResolver\u003e\u003e,\n    current_module_id: Option\u003c\u0026ModuleId\u003e,\n    diagnostic_handler: \u0026Arc\u003cdyn DiagnosticHandler\u003e,\n) -\u003e Result\u003cType, TypeCheckError\u003e {\n    if let (Some(registry), Some(resolver), Some(current_id)) =\n        (module_registry, module_resolver, current_module_id)\n    {\n        match resolver.resolve(source, current_id.path()) {\n            Ok(source_module_id) =\u003e {\n                // Track dependency\n                module_dependencies.push(source_module_id.path().to_path_buf());\n\n                match registry.get_exports(\u0026source_module_id) {\n                    Ok(source_exports) =\u003e {\n                        if let Some(exported_sym) = source_exports.get_named(symbol_name) {\n                            return Ok(exported_sym.symbol.typ.clone());\n                        }\n                    }\n                    Err(_) =\u003e {\n                        // Module exists but exports not available yet\n                    }\n                }\n            }\n            Err(e) =\u003e {\n                diagnostic_handler.error(\n                    span,\n                    \u0026format!(\"Failed to resolve module '{}': {}\", source, e),\n                );\n            }\n        }\n    } else {\n        diagnostic_handler.error(\n            span,\n            \u0026format!(\n                \"Module '{}' not found (module resolution not configured)\",\n                source\n            ),\n        );\n    }\n\n    // Fallback: return Unknown type\n    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::diagnostics::CollectingDiagnosticHandler;\n    use std::sync::Arc;\n\n    #[test]\n    fn test_extract_exports_empty() {\n        let program = typedlua_parser::ast::Program {\n            statements: Vec::new(),\n            span: Span::new(0, 0, 0, 0),\n        };\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let result = extract_exports(\u0026program, \u0026symbol_table, \u0026interner, None, None, None);\n        assert!(result.named.is_empty());\n        assert!(result.default.is_none());\n    }\n\n    #[test]\n    fn test_extract_exports_with_variable() {\n        let span = Span::new(0, 10, 0, 10);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n\n        let name_id = interner.intern(\"myVar\");\n        let symbol = crate::utils::symbol_table::Symbol::new(\n            \"myVar\".to_string(),\n            crate::utils::symbol_table::SymbolKind::Variable,\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n            span,\n        );\n        symbol_table.declare(symbol).unwrap();\n\n        let program = typedlua_parser::ast::Program {\n            statements: Vec::new(),\n            span,\n        };\n\n        let result = extract_exports(\u0026program, \u0026symbol_table, \u0026interner, None, None, None);\n        assert!(result.named.is_empty());\n    }\n\n    #[test]\n    fn test_check_import_statement_default() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let mut type_env = crate::core::type_environment::TypeEnvironment::new();\n        let mut access_control = crate::visitors::AccessControl::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let name_id = interner.intern(\"MyModule\");\n        let import = typedlua_parser::ast::statement::ImportDeclaration {\n            clause: typedlua_parser::ast::statement::ImportClause::Default(\n                typedlua_parser::ast::Spanned::new(name_id, span),\n            ),\n            source: \"./my_module.lua\".to_string(),\n            span,\n        };\n\n        let result = check_import_statement(\n            \u0026import,\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut access_control,\n            \u0026interner,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_resolve_import_type_no_resolver() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let result = resolve_import_type(\n            \"./unknown.lua\",\n            \"SomeType\",\n            span,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        // Should return Unknown type when no resolver configured\n        assert!(result.is_ok());\n        let resolved_type = result.unwrap();\n        assert!(matches!(\n            resolved_type.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_check_import_statement_named() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let mut type_env = crate::core::type_environment::TypeEnvironment::new();\n        let mut access_control = crate::visitors::AccessControl::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let import = typedlua_parser::ast::statement::ImportDeclaration {\n            clause: typedlua_parser::ast::statement::ImportClause::Named(vec![\n                typedlua_parser::ast::statement::ImportSpecifier {\n                    imported: typedlua_parser::ast::Spanned::new(interner.intern(\"foo\"), span),\n                    local: Some(typedlua_parser::ast::Spanned::new(\n                        interner.intern(\"foo\"),\n                        span,\n                    )),\n                    span,\n                },\n            ]),\n            source: \"./my_module.lua\".to_string(),\n            span,\n        };\n\n        let result = check_import_statement(\n            \u0026import,\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut access_control,\n            \u0026interner,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_import_statement_namespace() {\n        let span = Span::new(0, 10, 0, 10);\n        let handler: Arc\u003cdyn DiagnosticHandler\u003e = Arc::new(CollectingDiagnosticHandler::new());\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n        let mut type_env = crate::core::type_environment::TypeEnvironment::new();\n        let mut access_control = crate::visitors::AccessControl::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut module_dependencies: Vec\u003cPathBuf\u003e = Vec::new();\n\n        let import = typedlua_parser::ast::statement::ImportDeclaration {\n            clause: typedlua_parser::ast::statement::ImportClause::Namespace(\n                typedlua_parser::ast::Spanned::new(interner.intern(\"mylib\"), span),\n            ),\n            source: \"./my_module.lua\".to_string(),\n            span,\n        };\n\n        let result = check_import_statement(\n            \u0026import,\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut access_control,\n            \u0026interner,\n            \u0026mut module_dependencies,\n            None,\n            None,\n            None,\n            \u0026handler,\n        );\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_extract_declaration_export_function() {\n        let span = Span::new(0, 10, 0, 10);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut symbol_table = crate::utils::symbol_table::SymbolTable::new();\n\n        let func_name_id = interner.intern(\"myFunc\");\n        let symbol = crate::utils::symbol_table::Symbol::new(\n            \"myFunc\".to_string(),\n            crate::utils::symbol_table::SymbolKind::Function,\n            Type::new(TypeKind::Primitive(PrimitiveType::Number), span),\n            span,\n        );\n        symbol_table.declare(symbol).unwrap();\n\n        let program = typedlua_parser::ast::Program {\n            statements: Vec::new(),\n            span,\n        };\n\n        let result = extract_exports(\u0026program, \u0026symbol_table, \u0026interner, None, None, None);\n        assert!(result.named.is_empty());\n    }\n}\n","traces":[{"line":52,"address":[],"length":0,"stats":{"Line":3}},{"line":60,"address":[],"length":0,"stats":{"Line":6}},{"line":62,"address":[],"length":0,"stats":{"Line":6}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[],"length":0,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":103,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":3}},{"line":127,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":157,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[],"length":0,"stats":{"Line":0}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":0}},{"line":217,"address":[],"length":0,"stats":{"Line":3}},{"line":229,"address":[],"length":0,"stats":{"Line":3}},{"line":230,"address":[],"length":0,"stats":{"Line":1}},{"line":231,"address":[],"length":0,"stats":{"Line":4}},{"line":232,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":1}},{"line":236,"address":[],"length":0,"stats":{"Line":1}},{"line":237,"address":[],"length":0,"stats":{"Line":1}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":240,"address":[],"length":0,"stats":{"Line":2}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":244,"address":[],"length":0,"stats":{"Line":3}},{"line":245,"address":[],"length":0,"stats":{"Line":4}},{"line":247,"address":[],"length":0,"stats":{"Line":1}},{"line":248,"address":[],"length":0,"stats":{"Line":1}},{"line":249,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":1}},{"line":251,"address":[],"length":0,"stats":{"Line":1}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":253,"address":[],"length":0,"stats":{"Line":1}},{"line":254,"address":[],"length":0,"stats":{"Line":1}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":1}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":279,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":0}},{"line":307,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":0}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":1}},{"line":331,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":4}},{"line":334,"address":[],"length":0,"stats":{"Line":2}},{"line":335,"address":[],"length":0,"stats":{"Line":1}},{"line":336,"address":[],"length":0,"stats":{"Line":1}},{"line":337,"address":[],"length":0,"stats":{"Line":1}},{"line":339,"address":[],"length":0,"stats":{"Line":1}},{"line":340,"address":[],"length":0,"stats":{"Line":2}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":366,"address":[],"length":0,"stats":{"Line":0}},{"line":367,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":377,"address":[],"length":0,"stats":{"Line":0}},{"line":378,"address":[],"length":0,"stats":{"Line":0}},{"line":379,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":2}},{"line":405,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":6}},{"line":408,"address":[],"length":0,"stats":{"Line":0}},{"line":409,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":416,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":0}},{"line":427,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":6}},{"line":433,"address":[],"length":0,"stats":{"Line":4}},{"line":434,"address":[],"length":0,"stats":{"Line":2}},{"line":435,"address":[],"length":0,"stats":{"Line":2}},{"line":436,"address":[],"length":0,"stats":{"Line":2}},{"line":442,"address":[],"length":0,"stats":{"Line":4}}],"covered":53,"coverable":187},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","phases","validation_phase.rs"],"content":"//! Validation phase: Type compatibility and validation checks\n//!\n//! This phase handles:\n//! - Interface member validation (duplicate checking)\n//! - Index signature validation\n//! - Abstract method implementation verification\n//! - Method override validation (parameter/return type compatibility)\n//! - Decorator validation\n//!\n//! **Design Pattern**: Stateless phase functions that take explicit context parameters.\n\n#![allow(dead_code)]\n\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_compat::TypeCompatibility;\nuse crate::types::generics;\nuse crate::utils::symbol_table::SymbolTable;\nuse crate::visitors::{AccessControl, AccessControlVisitor, ClassMemberKind};\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse std::collections::HashSet;\nuse std::sync::Arc;\nuse typedlua_parser::ast::expression::Expression;\nuse typedlua_parser::ast::statement::{\n    ClassMember, Decorator, DecoratorExpression, IndexSignature, MethodDeclaration, TypeParameter,\n};\nuse typedlua_parser::ast::types::{ObjectTypeMember, Type};\nuse typedlua_parser::prelude::ClassDeclaration;\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Validate interface members for duplicate property names.\n///\n/// Interfaces cannot have duplicate property or method names.\n/// This function checks all members and returns an error if duplicates are found.\n///\n/// # Parameters\n///\n/// - `members`: The interface members to validate\n/// - `span`: Source span for error reporting\n///\n/// # Returns\n///\n/// Returns `Ok(())` if validation passes, or an error if duplicates are found.\npub fn validate_interface_members(\n    members: \u0026[ObjectTypeMember],\n    span: Span,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Check for duplicate property names\n    let mut seen_names = HashSet::new();\n\n    for member in members {\n        let name = match member {\n            ObjectTypeMember::Property(prop) =\u003e Some(\u0026prop.name.node),\n            ObjectTypeMember::Method(method) =\u003e Some(\u0026method.name.node),\n            ObjectTypeMember::Index(_) =\u003e None,\n        };\n\n        if let Some(name) = name {\n            if !seen_names.insert(*name) {\n                return Err(TypeCheckError::new(\n                    format!(\"Duplicate property '{}' in interface\", name),\n                    span,\n                ));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Validate that class properties conform to index signature constraints.\n///\n/// When a class has an index signature, all properties must have types that are\n/// assignable to the index signature's value type.\n///\n/// # Parameters\n///\n/// - `class_decl`: The class declaration to validate\n/// - `index_sig`: The index signature to check against\n/// - `interner`: String interner for resolving property names\n///\n/// # Returns\n///\n/// Returns `Ok(())` if validation passes, or an error if any property violates the constraint.\npub fn validate_index_signature(\n    class_decl: \u0026ClassDeclaration,\n    index_sig: \u0026IndexSignature,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    for member in \u0026class_decl.members {\n        if let ClassMember::Property(prop) = member {\n            // Check if property type is assignable to index signature value type\n            if !TypeCompatibility::is_assignable(\u0026prop.type_annotation, \u0026index_sig.value_type) {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Property '{}' is not assignable to index signature value type\",\n                        interner.resolve(prop.name.node)\n                    ),\n                    prop.span,\n                ));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check that a class implements all abstract methods from its parent class.\n///\n/// When a class extends a parent class with abstract methods, it must provide\n/// concrete implementations for all abstract methods. This function walks the\n/// inheritance chain to verify all abstract methods are implemented.\n///\n/// # Parameters\n///\n/// - `class_name`: The name of the class being validated\n/// - `parent_name`: The name of the parent class\n/// - `class_members`: The members of the child class\n/// - `access_control`: Access control visitor for checking parent members\n/// - `interner`: String interner for name resolution\n///\n/// # Returns\n///\n/// Returns `Ok(())` if all abstract methods are implemented, or an error otherwise.\npub fn check_abstract_methods_implemented(\n    class_name: \u0026str,\n    parent_name: \u0026str,\n    class_members: \u0026[ClassMember],\n    access_control: \u0026AccessControl,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    // Get the parent class members\n    if let Some(parent_members) = access_control.get_class_members(parent_name) {\n        for member in parent_members {\n            if let ClassMemberKind::Method {\n                is_abstract: true, ..\n            } = \u0026member.kind\n            {\n                // Check if this class implements the abstract method\n                let method_name = \u0026member.name;\n                let implemented = class_members.iter().any(|m| {\n                    if let ClassMember::Method(method) = m {\n                        method.name.node.as_u32() == interner.get_or_intern(method_name).as_u32()\n                    } else {\n                        false\n                    }\n                });\n\n                if !implemented {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Class '{}' must implement abstract method '{}' from parent class '{}'\",\n                            class_name, method_name, parent_name\n                        ),\n                        Span::dummy(),\n                    ));\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Validate decorators on a declaration.\n///\n/// This function checks:\n/// - Decorators are enabled in configuration\n/// - No duplicate decorators\n/// - Decorator expressions are valid\n///\n/// # Parameters\n///\n/// - `decorators`: The decorators to validate\n/// - `enable_decorators`: Whether decorators are enabled in configuration\n/// - `interner`: String interner for name resolution\n/// - `symbol_table`: Symbol table for checking decorator existence\n/// - `diagnostic_handler`: For reporting warnings\n/// - `infer_expression_type`: Callback to infer decorator argument types\n///\n/// # Returns\n///\n/// Returns `Ok(())` if validation passes, or an error if decorators are disabled\n/// or expressions are invalid.\npub fn check_decorators\u003cF\u003e(\n    decorators: \u0026mut [Decorator],\n    enable_decorators: bool,\n    interner: \u0026StringInterner,\n    symbol_table: \u0026SymbolTable,\n    diagnostic_handler: \u0026Arc\u003cdyn DiagnosticHandler\u003e,\n    mut infer_expression_type: F,\n) -\u003e Result\u003c(), TypeCheckError\u003e\nwhere\n    F: FnMut(\u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e,\n{\n    // Check if decorators are enabled\n    if !decorators.is_empty() \u0026\u0026 !enable_decorators {\n        return Err(TypeCheckError::new(\n            \"Decorators require decorator features to be enabled. Enable 'enableDecorators' in your configuration.\".to_string(),\n            decorators[0].span,\n        ));\n    }\n\n    // Check for duplicate decorators\n    let mut seen_decorators = HashSet::new();\n    for decorator in decorators.iter() {\n        // Get decorator name for comparison\n        let decorator_name = match \u0026decorator.expression {\n            DecoratorExpression::Identifier(name) =\u003e interner.resolve(name.node).to_string(),\n            DecoratorExpression::Call { callee, .. } =\u003e {\n                // For calls, use the callee name\n                if let DecoratorExpression::Identifier(name) = \u0026**callee {\n                    interner.resolve(name.node).to_string()\n                } else {\n                    continue; // Skip complex expressions\n                }\n            }\n            DecoratorExpression::Member { .. } =\u003e {\n                continue; // Skip member expressions for duplicate checking\n            }\n        };\n\n        if !seen_decorators.insert(decorator_name.clone()) {\n            diagnostic_handler.warning(\n                decorator.span,\n                \u0026format!(\"Duplicate decorator '@{}'\", decorator_name),\n            );\n        }\n    }\n\n    // Validate decorator expressions\n    for decorator in decorators.iter_mut() {\n        check_decorator_expression(\n            \u0026mut decorator.expression,\n            interner,\n            symbol_table,\n            \u0026mut infer_expression_type,\n        )?;\n    }\n\n    Ok(())\n}\n\n/// Check a decorator expression.\n///\n/// Validates that decorator identifiers, calls, and member expressions are well-formed.\n/// For decorator calls, type-checks all arguments.\n///\n/// # Parameters\n///\n/// - `expr`: The decorator expression to check\n/// - `interner`: String interner for name resolution\n/// - `symbol_table`: Symbol table for checking identifier existence\n/// - `infer_expression_type`: Callback to infer argument types\nfn check_decorator_expression\u003cF\u003e(\n    expr: \u0026mut DecoratorExpression,\n    interner: \u0026StringInterner,\n    symbol_table: \u0026SymbolTable,\n    infer_expression_type: \u0026mut F,\n) -\u003e Result\u003c(), TypeCheckError\u003e\nwhere\n    F: FnMut(\u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e,\n{\n    match expr {\n        DecoratorExpression::Identifier(name) =\u003e {\n            // Verify the decorator identifier exists (could be a function or imported decorator)\n            // For now, we allow any identifier - full validation would check it's a valid decorator function\n            let name_str = interner.resolve(name.node);\n            if symbol_table.lookup(\u0026name_str).is_none() {\n                // It's okay if it doesn't exist - it might be a built-in decorator like @readonly, @sealed\n                // We'll allow it through for now\n            }\n            Ok(())\n        }\n        DecoratorExpression::Call {\n            callee, arguments, ..\n        } =\u003e {\n            // Check the callee\n            check_decorator_expression(callee, interner, symbol_table, infer_expression_type)?;\n\n            // Type check all arguments\n            for arg in arguments.iter_mut() {\n                infer_expression_type(arg)?;\n            }\n\n            Ok(())\n        }\n        DecoratorExpression::Member { object, .. } =\u003e {\n            // Check the object part\n            check_decorator_expression(object, interner, symbol_table, infer_expression_type)?;\n            Ok(())\n        }\n    }\n}\n\n/// Check method override compatibility.\n///\n/// When a method is marked with the `override` keyword, this function validates:\n/// - The class has a parent class\n/// - The parent class has a method with the same name\n/// - The parent method is not marked `final`\n/// - Parameter types are compatible (contravariant)\n/// - Return types are compatible (covariant)\n/// - Generic parent types are properly instantiated\n///\n/// # Parameters\n///\n/// - `method`: The method declaration to check\n/// - `class_name`: Name of the class containing the method\n/// - `parent_name`: Name of the parent class\n/// - `parent_type_params`: Type parameters of the parent class (if generic)\n/// - `extends_type_args`: Type arguments in the extends clause\n/// - `access_control`: Access control visitor for checking parent members\n/// - `interner`: String interner for name resolution\n/// - `deep_resolve_type`: Callback to resolve type aliases\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the override is valid, or an error if validation fails.\n#[allow(clippy::too_many_arguments)]\npub fn check_method_override\u003cF\u003e(\n    method: \u0026MethodDeclaration,\n    class_name: \u0026str,\n    parent_name: Option\u003c\u0026String\u003e,\n    parent_type_params: Option\u003c\u0026Vec\u003cTypeParameter\u003e\u003e,\n    extends_type_args: Option\u003c\u0026Vec\u003cType\u003e\u003e,\n    access_control: \u0026AccessControl,\n    interner: \u0026StringInterner,\n    mut deep_resolve_type: F,\n) -\u003e Result\u003c(), TypeCheckError\u003e\nwhere\n    F: FnMut(\u0026Type) -\u003e Type,\n{\n    // Check if class has a parent\n    let parent_name = parent_name.ok_or_else(|| {\n        TypeCheckError::new(\n            format!(\n                \"Method '{}' uses override but class '{}' has no parent class\",\n                method.name.node, class_name\n            ),\n            method.span,\n        )\n    })?;\n\n    // Walk the inheritance chain to find the method and check if it's final\n    let method_name = interner.resolve(method.name.node);\n    let mut current_class = parent_name.clone();\n    let mut found_method = None;\n    let mut found_in_class = None;\n\n    loop {\n        if let Some(parent_members) = access_control.get_class_members(\u0026current_class) {\n            if let Some(parent_method) = parent_members.iter().find(|m| m.name == method_name) {\n                found_method = Some(parent_method);\n                found_in_class = Some(current_class.clone());\n                break;\n            }\n        }\n\n        // Get parent from access_control's hierarchy\n        let parent_name_opt = access_control.get_parent_class(\u0026current_class);\n        match parent_name_opt {\n            Some(next_parent) =\u003e current_class = next_parent,\n            None =\u003e break,\n        }\n    }\n\n    let parent_method = found_method.ok_or_else(|| {\n        TypeCheckError::new(\n            format!(\n                \"Method '{}' marked as override but parent class does not have this method\",\n                method_name\n            ),\n            method.span,\n        )\n    })?;\n\n    // Check if parent method is final anywhere in the inheritance chain\n    if parent_method.is_final {\n        return Err(TypeCheckError::new(\n            format!(\n                \"Cannot override final method {} from ancestor class {}\",\n                method.name.node,\n                found_in_class.unwrap()\n            ),\n            method.span,\n        ));\n    }\n\n    match \u0026parent_method.kind {\n        ClassMemberKind::Method {\n            parameters: parent_params,\n            return_type: parent_return,\n            ..\n        } =\u003e {\n            // Check parameter count\n            if method.parameters.len() != parent_params.len() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Method '{}' has {} parameters but overridden method has {} parameters\",\n                        method.name.node,\n                        method.parameters.len(),\n                        parent_params.len()\n                    ),\n                    method.span,\n                ));\n            }\n\n            // Check parameter types (contravariance)\n            for (i, (child_param, parent_param)) in method\n                .parameters\n                .iter()\n                .zip(parent_params.iter())\n                .enumerate()\n            {\n                let child_type = child_param.type_annotation.as_ref().ok_or_else(|| {\n                    TypeCheckError::new(\n                        format!(\n                            \"Override method '{}' parameter {} must have explicit type annotation\",\n                            method.name.node,\n                            i + 1\n                        ),\n                        child_param.span,\n                    )\n                })?;\n\n                let raw_parent_type = parent_param.type_annotation.as_ref().ok_or_else(|| {\n                    TypeCheckError::new(\n                        format!(\n                            \"Parent method '{}' parameter {} has no type annotation\",\n                            method.name.node,\n                            i + 1\n                        ),\n                        parent_param.span,\n                    )\n                })?;\n\n                // Instantiate parent type if the parent class is generic\n                let parent_type = if let (Some(type_params), Some(type_args)) =\n                    (parent_type_params, extends_type_args)\n                {\n                    generics::instantiate_type(raw_parent_type, type_params, type_args)\n                        .unwrap_or_else(|_| raw_parent_type.clone())\n                } else {\n                    raw_parent_type.clone()\n                };\n\n                // Deep-resolve both types for comparison\n                let resolved_child = deep_resolve_type(child_type);\n                let resolved_parent = deep_resolve_type(\u0026parent_type);\n\n                // Parameters are contravariant: parent type must be assignable to child type\n                // (child can accept a more specific type than parent)\n                if !TypeCompatibility::is_assignable(\u0026resolved_parent, \u0026resolved_child) {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Method '{}' parameter {} type is incompatible with parent parameter type\",\n                            method.name.node,\n                            i + 1\n                        ),\n                        child_param.span,\n                    ));\n                }\n            }\n\n            // Check return type (covariance)\n            if let Some(child_return) = \u0026method.return_type {\n                if let Some(raw_parent_ret) = parent_return {\n                    // Instantiate parent return type if generic\n                    let parent_ret = if let (Some(type_params), Some(type_args)) =\n                        (parent_type_params, extends_type_args)\n                    {\n                        generics::instantiate_type(raw_parent_ret, type_params, type_args)\n                            .unwrap_or_else(|_| raw_parent_ret.clone())\n                    } else {\n                        raw_parent_ret.clone()\n                    };\n\n                    let resolved_child_ret = deep_resolve_type(child_return);\n                    let resolved_parent_ret = deep_resolve_type(\u0026parent_ret);\n\n                    // Child return type must be assignable to parent return type\n                    if !TypeCompatibility::is_assignable(\u0026resolved_parent_ret, \u0026resolved_child_ret)\n                    {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Method '{}' return type is incompatible with parent return type\",\n                                method.name.node\n                            ),\n                            method.span,\n                        ));\n                    }\n                }\n            } else if parent_return.is_some() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Method '{}' must have return type to match parent method\",\n                        method.name.node\n                    ),\n                    method.span,\n                ));\n            }\n\n            Ok(())\n        }\n        _ =\u003e Err(TypeCheckError::new(\n            format!(\n                \"Cannot override '{}' - parent member is not a method\",\n                method.name.node\n            ),\n            method.span,\n        )),\n    }\n}\n\n/// Check if a class has circular inheritance.\n///\n/// Detects inheritance cycles like: A extends B, B extends C, C extends A.\n///\n/// # Parameters\n///\n/// - `class_name`: The class name to check for circular inheritance\n/// - `class_parents`: Map from class name to parent class name\n///\n/// # Returns\n///\n/// Returns `true` if a circular inheritance is detected, `false` otherwise.\npub fn has_circular_inheritance(\n    class_name: \u0026str,\n    class_parents: \u0026FxHashMap\u003cString, String\u003e,\n) -\u003e bool {\n    let mut visited = std::collections::HashSet::new();\n    let mut current = class_name.to_string();\n\n    visited.insert(current.clone());\n\n    while let Some(parent) = class_parents.get(\u0026current) {\n        if visited.contains(parent) {\n            return true; // Found a cycle\n        }\n        visited.insert(parent.clone());\n        current = parent.clone();\n    }\n\n    false\n}\n\n/// Check that a class properly implements an interface.\n///\n/// Validates that:\n/// - All required interface properties are present in the class\n/// - All required interface methods are implemented with compatible signatures\n/// - Index signatures are properly implemented\n///\n/// # Parameters\n///\n/// - `class_decl`: The class declaration to validate\n/// - `interface`: The interface type that the class claims to implement\n/// - `type_env`: Type environment for checking class implements relationships\n/// - `interner`: String interner for resolving names in error messages\n///\n/// # Returns\n///\n/// Returns `Ok(())` if the class properly implements the interface, or an error if validation fails.\npub fn check_class_implements_interface(\n    class_decl: \u0026ClassDeclaration,\n    interface: \u0026Type,\n    type_env: \u0026crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003c(), TypeCheckError\u003e {\n    use typedlua_parser::ast::statement::ClassMember;\n    use typedlua_parser::ast::types::{ObjectTypeMember, TypeKind};\n\n    if let TypeKind::Object(obj_type) = \u0026interface.kind {\n        for required_member in \u0026obj_type.members {\n            match required_member {\n                ObjectTypeMember::Property(req_prop) =\u003e {\n                    // Find matching property in class\n                    let found = class_decl.members.iter().any(|member| {\n                        if let ClassMember::Property(class_prop) = member {\n                            class_prop.name.node == req_prop.name.node\n                        } else {\n                            false\n                        }\n                    });\n\n                    if !found \u0026\u0026 !req_prop.is_optional {\n                        return Err(TypeCheckError::new(\n                            format!(\n                                \"Class '{}' does not implement required property '{}' from interface\",\n                                interner.resolve(class_decl.name.node),\n                                interner.resolve(req_prop.name.node)\n                            ),\n                            class_decl.span,\n                        ));\n                    }\n                }\n                ObjectTypeMember::Method(req_method) =\u003e {\n                    // Find matching method in class and validate signature\n                    let matching_method = class_decl.members.iter().find_map(|member| {\n                        if let ClassMember::Method(class_method) = member {\n                            if class_method.name.node == req_method.name.node {\n                                return Some(class_method);\n                            }\n                        }\n                        None\n                    });\n\n                    match matching_method {\n                        None =\u003e {\n                            if req_method.body.is_none() {\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Class '{}' does not implement required method '{}' from interface\",\n                                        interner.resolve(class_decl.name.node),\n                                        interner.resolve(req_method.name.node)\n                                    ),\n                                    class_decl.span,\n                                ));\n                            }\n                            // Method has default implementation in interface, okay\n                        }\n                        Some(class_method) =\u003e {\n                            // Check parameter count\n                            if class_method.parameters.len() != req_method.parameters.len() {\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Method '{}' has {} parameters but interface requires {}\",\n                                        interner.resolve(req_method.name.node),\n                                        class_method.parameters.len(),\n                                        req_method.parameters.len()\n                                    ),\n                                    class_method.span,\n                                ));\n                            }\n\n                            // Check parameter types\n                            for (i, (class_param, req_param)) in class_method\n                                .parameters\n                                .iter()\n                                .zip(req_method.parameters.iter())\n                                .enumerate()\n                            {\n                                if let (Some(class_type), Some(req_type)) =\n                                    (\u0026class_param.type_annotation, \u0026req_param.type_annotation)\n                                {\n                                    if !TypeCompatibility::is_assignable(class_type, req_type) {\n                                        return Err(TypeCheckError::new(\n                                            format!(\n                                                \"Method '{}' parameter {} has incompatible type\",\n                                                interner.resolve(req_method.name.node),\n                                                i\n                                            ),\n                                            class_method.span,\n                                        ));\n                                    }\n                                }\n                            }\n\n                            // Check return type (covariant: class return must be assignable to interface return)\n                            // MethodSignature has return_type: Type (not Option)\n                            // MethodDeclaration has return_type: Option\u003cType\u003e\n                            if let Some(class_return) = \u0026class_method.return_type {\n                                if !TypeCompatibility::is_assignable(\n                                    class_return,\n                                    \u0026req_method.return_type,\n                                ) \u0026\u0026 !check_implements_assignable(\n                                    class_return,\n                                    \u0026req_method.return_type,\n                                    type_env,\n                                    interner,\n                                ) {\n                                    return Err(TypeCheckError::new(\n                                        format!(\n                                            \"Method '{}' has incompatible return type\",\n                                            interner.resolve(req_method.name.node)\n                                        ),\n                                        class_method.span,\n                                    ));\n                                }\n                            } else {\n                                // Method has no return type annotation, but interface requires one\n                                return Err(TypeCheckError::new(\n                                    format!(\n                                        \"Method '{}' must have a return type annotation to match interface\",\n                                        interner.resolve(req_method.name.node)\n                                    ),\n                                    class_method.span,\n                                ));\n                            }\n                        }\n                    }\n                }\n                ObjectTypeMember::Index(index_sig) =\u003e {\n                    // Validate that all class properties are compatible with index signature\n                    validate_index_signature(class_decl, index_sig, interner)?;\n                }\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if source type is assignable to target type via implements relationship.\n///\n/// This handles covariance in interface implementation. For example, Box\u003cnumber\u003e is\n/// assignable to Storable\u003cnumber\u003e if Box implements Storable\u003cT\u003e.\n///\n/// # Parameters\n///\n/// - `source`: The source type to check\n/// - `target`: The target type to check against\n/// - `type_env`: Type environment for looking up class implements relationships\n/// - `interner`: String interner for resolving type names\n///\n/// # Returns\n///\n/// Returns `true` if source type implements target interface, `false` otherwise.\npub fn check_implements_assignable(\n    source: \u0026Type,\n    target: \u0026Type,\n    type_env: \u0026crate::core::type_environment::TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e bool {\n    use typedlua_parser::ast::types::TypeKind;\n\n    if let (TypeKind::Reference(s_ref), TypeKind::Reference(t_ref)) = (\u0026source.kind, \u0026target.kind) {\n        let source_name = interner.resolve(s_ref.name.node);\n        let target_name = interner.resolve(t_ref.name.node);\n\n        // Check if source class implements the target interface\n        if let Some(implements) = type_env.get_class_implements(\u0026source_name) {\n            for iface_type in implements {\n                if let TypeKind::Reference(iface_ref) = \u0026iface_type.kind {\n                    let iface_name = interner.resolve(iface_ref.name.node);\n                    if iface_name == target_name {\n                        // Interface name matches. For generic interfaces, check type arg\n                        // compatibility. The common case is pass-through type params:\n                        // class Box\u003cT\u003e implements Storable\u003cT\u003e means Box\u003cnumber\u003e -\u003e Storable\u003cnumber\u003e\n                        match (\u0026s_ref.type_arguments, \u0026t_ref.type_arguments) {\n                            (None, None) =\u003e return true,\n                            (Some(s_args), Some(t_args)) if s_args.len() == t_args.len() =\u003e {\n                                if s_args\n                                    .iter()\n                                    .zip(t_args.iter())\n                                    .all(|(s, t)| TypeCompatibility::is_assignable(s, t))\n                                {\n                                    return true;\n                                }\n                            }\n                            _ =\u003e {\n                                // Arity mismatch or partial generics - still allow if names match\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    false\n}\n\n/// Validate class inheritance - checks for final parent and circular inheritance.\n///\n/// This focused function validates that a class's inheritance is valid:\n/// - Parent class is not marked as final\n/// - No circular inheritance exists\n///\n/// # Returns\n///\n/// Returns Ok(parent_name) if inheritance is valid, or an error if validation fails.\npub fn validate_class_inheritance(\n    class_name: \u0026str,\n    extends_type: \u0026typedlua_parser::ast::types::Type,\n    access_control: \u0026crate::visitors::AccessControl,\n    class_parents: \u0026mut rustc_hash::FxHashMap\u003cString, String\u003e,\n    interner: \u0026typedlua_parser::string_interner::StringInterner,\n    span: typedlua_parser::span::Span,\n) -\u003e Result\u003cString, crate::TypeCheckError\u003e {\n    use typedlua_parser::ast::types::TypeKind;\n\n    if let TypeKind::Reference(type_ref) = \u0026extends_type.kind {\n        let parent_name = interner.resolve(type_ref.name.node).to_string();\n\n        // Check if parent class is final\n        if access_control.is_class_final(\u0026parent_name) {\n            return Err(crate::TypeCheckError::new(\n                format!(\"Cannot extend final class {}\", parent_name),\n                span,\n            ));\n        }\n\n        // Check for circular inheritance\n        class_parents.insert(class_name.to_string(), parent_name.clone());\n        if has_circular_inheritance(class_name, class_parents) {\n            return Err(crate::TypeCheckError::new(\n                format!(\n                    \"Circular inheritance detected: class '{}' inherits from itself through the inheritance chain\",\n                    class_name\n                ),\n                span,\n            ));\n        }\n\n        Ok(parent_name)\n    } else {\n        Err(crate::TypeCheckError::new(\n            \"Class can only extend another class (type reference)\",\n            span,\n        ))\n    }\n}\n","traces":[{"line":45,"address":[],"length":0,"stats":{"Line":35}},{"line":50,"address":[],"length":0,"stats":{"Line":70}},{"line":52,"address":[],"length":0,"stats":{"Line":315}},{"line":53,"address":[],"length":0,"stats":{"Line":280}},{"line":54,"address":[],"length":0,"stats":{"Line":226}},{"line":55,"address":[],"length":0,"stats":{"Line":52}},{"line":56,"address":[],"length":0,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":279}},{"line":60,"address":[],"length":0,"stats":{"Line":278}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":63,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":35}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":7}},{"line":134,"address":[],"length":0,"stats":{"Line":21}},{"line":135,"address":[],"length":0,"stats":{"Line":21}},{"line":138,"address":[],"length":0,"stats":{"Line":7}},{"line":141,"address":[],"length":0,"stats":{"Line":4}},{"line":142,"address":[],"length":0,"stats":{"Line":11}},{"line":143,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":10}},{"line":146,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":7}},{"line":186,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":216,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":265,"address":[],"length":0,"stats":{"Line":0}},{"line":266,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":337,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":355,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[],"length":0,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":0}},{"line":370,"address":[],"length":0,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":0}},{"line":385,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":0}},{"line":391,"address":[],"length":0,"stats":{"Line":0}},{"line":392,"address":[],"length":0,"stats":{"Line":0}},{"line":393,"address":[],"length":0,"stats":{"Line":0}},{"line":394,"address":[],"length":0,"stats":{"Line":0}},{"line":395,"address":[],"length":0,"stats":{"Line":0}},{"line":396,"address":[],"length":0,"stats":{"Line":0}},{"line":398,"address":[],"length":0,"stats":{"Line":0}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":0}},{"line":401,"address":[],"length":0,"stats":{"Line":0}},{"line":402,"address":[],"length":0,"stats":{"Line":0}},{"line":403,"address":[],"length":0,"stats":{"Line":0}},{"line":404,"address":[],"length":0,"stats":{"Line":0}},{"line":406,"address":[],"length":0,"stats":{"Line":0}},{"line":411,"address":[],"length":0,"stats":{"Line":0}},{"line":412,"address":[],"length":0,"stats":{"Line":0}},{"line":413,"address":[],"length":0,"stats":{"Line":0}},{"line":414,"address":[],"length":0,"stats":{"Line":0}},{"line":415,"address":[],"length":0,"stats":{"Line":0}},{"line":417,"address":[],"length":0,"stats":{"Line":0}},{"line":418,"address":[],"length":0,"stats":{"Line":0}},{"line":419,"address":[],"length":0,"stats":{"Line":0}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":440,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":443,"address":[],"length":0,"stats":{"Line":0}},{"line":444,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":475,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":481,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":512,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":7}},{"line":533,"address":[],"length":0,"stats":{"Line":14}},{"line":534,"address":[],"length":0,"stats":{"Line":21}},{"line":536,"address":[],"length":0,"stats":{"Line":28}},{"line":538,"address":[],"length":0,"stats":{"Line":38}},{"line":539,"address":[],"length":0,"stats":{"Line":24}},{"line":540,"address":[],"length":0,"stats":{"Line":0}},{"line":542,"address":[],"length":0,"stats":{"Line":32}},{"line":543,"address":[],"length":0,"stats":{"Line":24}},{"line":546,"address":[],"length":0,"stats":{"Line":7}},{"line":566,"address":[],"length":0,"stats":{"Line":4}},{"line":575,"address":[],"length":0,"stats":{"Line":8}},{"line":576,"address":[],"length":0,"stats":{"Line":11}},{"line":577,"address":[],"length":0,"stats":{"Line":4}},{"line":578,"address":[],"length":0,"stats":{"Line":1}},{"line":580,"address":[],"length":0,"stats":{"Line":4}},{"line":581,"address":[],"length":0,"stats":{"Line":2}},{"line":582,"address":[],"length":0,"stats":{"Line":1}},{"line":584,"address":[],"length":0,"stats":{"Line":0}},{"line":588,"address":[],"length":0,"stats":{"Line":1}},{"line":589,"address":[],"length":0,"stats":{"Line":0}},{"line":590,"address":[],"length":0,"stats":{"Line":0}},{"line":591,"address":[],"length":0,"stats":{"Line":0}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":3}},{"line":601,"address":[],"length":0,"stats":{"Line":11}},{"line":602,"address":[],"length":0,"stats":{"Line":4}},{"line":603,"address":[],"length":0,"stats":{"Line":2}},{"line":604,"address":[],"length":0,"stats":{"Line":2}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":3}},{"line":612,"address":[],"length":0,"stats":{"Line":2}},{"line":613,"address":[],"length":0,"stats":{"Line":2}},{"line":614,"address":[],"length":0,"stats":{"Line":2}},{"line":615,"address":[],"length":0,"stats":{"Line":2}},{"line":616,"address":[],"length":0,"stats":{"Line":4}},{"line":617,"address":[],"length":0,"stats":{"Line":3}},{"line":619,"address":[],"length":0,"stats":{"Line":1}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":626,"address":[],"length":0,"stats":{"Line":6}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":639,"address":[],"length":0,"stats":{"Line":8}},{"line":640,"address":[],"length":0,"stats":{"Line":2}},{"line":641,"address":[],"length":0,"stats":{"Line":2}},{"line":642,"address":[],"length":0,"stats":{"Line":4}},{"line":643,"address":[],"length":0,"stats":{"Line":2}},{"line":645,"address":[],"length":0,"stats":{"Line":4}},{"line":646,"address":[],"length":0,"stats":{"Line":4}},{"line":648,"address":[],"length":0,"stats":{"Line":4}},{"line":649,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":655,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":4}},{"line":665,"address":[],"length":0,"stats":{"Line":4}},{"line":666,"address":[],"length":0,"stats":{"Line":2}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":668,"address":[],"length":0,"stats":{"Line":2}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":675,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":684,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":695,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":703,"address":[],"length":0,"stats":{"Line":3}},{"line":721,"address":[],"length":0,"stats":{"Line":16}},{"line":729,"address":[],"length":0,"stats":{"Line":32}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":735,"address":[],"length":0,"stats":{"Line":0}},{"line":736,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":16}},{"line":775,"address":[],"length":0,"stats":{"Line":8}},{"line":785,"address":[],"length":0,"stats":{"Line":16}},{"line":786,"address":[],"length":0,"stats":{"Line":32}},{"line":789,"address":[],"length":0,"stats":{"Line":24}},{"line":790,"address":[],"length":0,"stats":{"Line":2}},{"line":791,"address":[],"length":0,"stats":{"Line":2}},{"line":792,"address":[],"length":0,"stats":{"Line":1}},{"line":797,"address":[],"length":0,"stats":{"Line":42}},{"line":798,"address":[],"length":0,"stats":{"Line":21}},{"line":799,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":801,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":7}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}}],"covered":81,"coverable":309},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","state","mod.rs"],"content":"//! Type checker state management\n//!\n//! This module provides the shared state structure for the type checker,\n//! enabling better modularity and testability.\n\npub mod stdlib_loader;\npub mod type_checker_state;\n\npub use type_checker_state::TypeCheckerState;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","state","stdlib_loader.rs"],"content":"//! Standard library parsing for the type checker\n//!\n//! This module provides functionality to parse TypedLua standard library\n//! definition files into AST programs. The caller is responsible for\n//! processing the statements (e.g., type checking, populating symbol tables).\n\nuse crate::cli::config::LuaVersion;\nuse crate::cli::diagnostics::CollectingDiagnosticHandler;\nuse std::sync::Arc;\nuse typedlua_parser::ast::Program;\nuse typedlua_parser::lexer::Lexer;\nuse typedlua_parser::parser::Parser;\nuse typedlua_parser::string_interner::{CommonIdentifiers, StringInterner};\n\n/// Parses the standard library definition files for the specified Lua version.\n///\n/// This function reads and parses all stdlib files for the given Lua version,\n/// returning the parsed AST programs. The caller is responsible for processing\n/// these programs (e.g., type checking statements, populating symbol tables).\n///\n/// # Separation of Concerns\n///\n/// This function focuses solely on parsing stdlib files into AST. It does not:\n/// - Perform type checking\n/// - Populate symbol tables\n/// - Register types or symbols\n///\n/// This separation allows the stdlib parser to be:\n/// - Independently testable\n/// - Reusable in different contexts (e.g., LSP, static analysis tools)\n/// - Free from coupling to type checker internals\n///\n/// # Arguments\n///\n/// * `target_version` - The Lua version to parse stdlib for (5.1, 5.2, 5.3, or 5.4)\n/// * `interner` - String interner for parsing identifiers\n/// * `common` - Common identifiers for parsing\n///\n/// # Returns\n///\n/// Returns `Ok(Vec\u003cProgram\u003e)` containing the parsed stdlib programs, or an error\n/// message if parsing failed.\n///\n/// # Example\n///\n/// ```rust,ignore\n/// use typedlua_typechecker::state::stdlib_loader;\n/// use typedlua_typechecker::config::LuaVersion;\n///\n/// let (interner, common) = StringInterner::new_with_common_identifiers();\n/// let programs = stdlib_loader::parse_stdlib_files(\n///     LuaVersion::Lua54,\n///     \u0026interner,\n///     \u0026common\n/// )?;\n///\n/// // Process the programs as needed\n/// for mut program in programs {\n///     for statement in \u0026mut program.statements {\n///         // Check statement, register types, etc.\n///     }\n/// }\n/// ```\npub fn parse_stdlib_files(\n    target_version: LuaVersion,\n    interner: \u0026StringInterner,\n    common: \u0026CommonIdentifiers,\n) -\u003e Result\u003cVec\u003cProgram\u003e, String\u003e {\n    use crate::stdlib;\n\n    let stdlib_files = stdlib::get_all_stdlib(target_version);\n    let mut programs = Vec::with_capacity(stdlib_files.len());\n\n    for (filename, source) in stdlib_files {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let mut lexer = Lexer::new(source, handler.clone(), interner);\n        let tokens = lexer\n            .tokenize()\n            .map_err(|e| format!(\"Failed to lex {}: {:?}\", filename, e))?;\n\n        let mut parser = Parser::new(tokens, handler.clone(), interner, common);\n        let program = parser\n            .parse()\n            .map_err(|e| format!(\"Failed to parse {}: {:?}\", filename, e))?;\n\n        programs.push(program);\n    }\n\n    Ok(programs)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::config::LuaVersion;\n    use typedlua_parser::string_interner::StringInterner;\n\n    #[test]\n    fn test_parse_stdlib_lua51() {\n        let (interner, common) = StringInterner::new_with_common_identifiers();\n\n        let result = parse_stdlib_files(LuaVersion::Lua51, \u0026interner, \u0026common);\n\n        assert!(result.is_ok());\n        let programs = result.unwrap();\n        assert!(\n            !programs.is_empty(),\n            \"Should parse at least one stdlib file\"\n        );\n\n        // Verify programs have statements\n        let total_statements: usize = programs.iter().map(|p| p.statements.len()).sum();\n        assert!(\n            total_statements \u003e 0,\n            \"Stdlib should contain type definitions\"\n        );\n    }\n\n    #[test]\n    fn test_parse_stdlib_all_versions() {\n        let versions = vec![\n            LuaVersion::Lua51,\n            LuaVersion::Lua52,\n            LuaVersion::Lua53,\n            LuaVersion::Lua54,\n        ];\n\n        for version in versions {\n            let (interner, common) = StringInterner::new_with_common_identifiers();\n\n            let result = parse_stdlib_files(version, \u0026interner, \u0026common);\n\n            assert!(\n                result.is_ok(),\n                \"Failed to parse stdlib for version {:?}\",\n                version\n            );\n\n            let programs = result.unwrap();\n            assert!(\n                !programs.is_empty(),\n                \"Should parse at least one stdlib file for {:?}\",\n                version\n            );\n        }\n    }\n\n    #[test]\n    fn test_parse_stdlib_returns_valid_programs() {\n        let (interner, common) = StringInterner::new_with_common_identifiers();\n        let programs = parse_stdlib_files(LuaVersion::Lua54, \u0026interner, \u0026common).unwrap();\n\n        // Verify each program is valid\n        for program in programs {\n            // Programs should have statements (stdlib definitions)\n            assert!(\n                !program.statements.is_empty(),\n                \"Each stdlib file should have declarations\"\n            );\n        }\n    }\n}\n","traces":[{"line":64,"address":[],"length":0,"stats":{"Line":9}},{"line":71,"address":[],"length":0,"stats":{"Line":27}},{"line":72,"address":[],"length":0,"stats":{"Line":36}},{"line":74,"address":[],"length":0,"stats":{"Line":90}},{"line":75,"address":[],"length":0,"stats":{"Line":81}},{"line":76,"address":[],"length":0,"stats":{"Line":135}},{"line":77,"address":[],"length":0,"stats":{"Line":54}},{"line":79,"address":[],"length":0,"stats":{"Line":27}},{"line":81,"address":[],"length":0,"stats":{"Line":162}},{"line":82,"address":[],"length":0,"stats":{"Line":54}},{"line":84,"address":[],"length":0,"stats":{"Line":27}},{"line":86,"address":[],"length":0,"stats":{"Line":81}},{"line":89,"address":[],"length":0,"stats":{"Line":9}}],"covered":13,"coverable":13},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","state","type_checker_state.rs"],"content":"//! Type checker state module\n//!\n//! This module contains the shared state structure for the type checker,\n//! extracted from the monolithic TypeChecker to enable better modularity\n//! and testability.\n\nuse std::collections::HashSet;\nuse std::path::PathBuf;\nuse std::sync::Arc;\n\nuse rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::TypeParameter;\nuse typedlua_parser::string_interner::{CommonIdentifiers, StringInterner};\n\nuse crate::cli::config::CompilerOptions;\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::module_resolver::{ModuleId, ModuleRegistry, ModuleResolver};\nuse crate::utils::symbol_table::SymbolTable;\nuse crate::visitors::{AccessControl, TypeNarrower};\nuse typedlua_parser::ast::types::Type;\n\n/// Shared state for the type checker\n///\n/// This struct contains all the mutable state that was previously embedded\n/// directly in TypeChecker. Extracting it enables:\n/// - Better testability (state can be created independently)\n/// - Phase-based decomposition (different phases can share state)\n/// - Reduced cognitive load (state is separated from logic)\npub struct TypeCheckerState\u003c'a\u003e {\n    /// Symbol table for tracking variable and type declarations\n    pub symbol_table: SymbolTable,\n    /// Type environment for type checking and inference\n    pub type_env: TypeEnvironment,\n    /// Current function's return type (for return statement validation)\n    pub current_function_return_type: Option\u003cType\u003e,\n    /// Type narrowing state for control flow analysis\n    pub narrowing: TypeNarrower,\n    /// Access control for class inheritance and visibility\n    pub access_control: AccessControl,\n    /// Compiler options (target version, optimization level, etc.)\n    pub options: CompilerOptions,\n    /// Diagnostic handler for reporting errors and warnings\n    pub diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n    /// String interner for efficient string handling\n    pub interner: \u0026'a StringInterner,\n    /// Common identifiers (keywords, built-in types, etc.)\n    pub common: \u0026'a CommonIdentifiers,\n    /// Module registry for multi-module compilation\n    pub module_registry: Option\u003cArc\u003cModuleRegistry\u003e\u003e,\n    /// Current module ID\n    pub current_module_id: Option\u003cModuleId\u003e,\n    /// Module resolver for import path resolution\n    pub module_resolver: Option\u003cArc\u003cModuleResolver\u003e\u003e,\n    /// Track module dependencies for cache invalidation\n    pub module_dependencies: Vec\u003cPathBuf\u003e,\n    /// Stack tracking whether we're inside a catch block (for rethrow validation)\n    pub in_catch_block: Vec\u003cbool\u003e,\n    /// Current namespace path for this module\n    pub current_namespace: Option\u003cVec\u003cString\u003e\u003e,\n    /// Type parameters for each generic class (needed for override checking)\n    pub class_type_params: FxHashMap\u003cString, Vec\u003cTypeParameter\u003e\u003e,\n    /// Track class inheritance for circular dependency detection\n    pub class_parents: FxHashMap\u003cString, String\u003e,\n    /// Track exported names to detect duplicates\n    pub exported_names: HashSet\u003cString\u003e,\n}\n\nimpl\u003c'a\u003e TypeCheckerState\u003c'a\u003e {\n    /// Create a new type checker state with default values\n    pub fn new(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a StringInterner,\n        common: \u0026'a CommonIdentifiers,\n    ) -\u003e Self {\n        Self {\n            symbol_table: SymbolTable::new(),\n            type_env: TypeEnvironment::new(),\n            current_function_return_type: None,\n            narrowing: TypeNarrower::new(),\n            access_control: AccessControl::new(),\n            options: CompilerOptions::default(),\n            diagnostic_handler,\n            interner,\n            common,\n            module_registry: None,\n            current_module_id: None,\n            module_resolver: None,\n            module_dependencies: Vec::new(),\n            in_catch_block: Vec::new(),\n            current_namespace: None,\n            class_type_params: FxHashMap::default(),\n            class_parents: FxHashMap::default(),\n            exported_names: HashSet::new(),\n        }\n    }\n\n    /// Create a new type checker state with module support\n    pub fn new_with_module_support(\n        diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e,\n        interner: \u0026'a StringInterner,\n        common: \u0026'a CommonIdentifiers,\n        module_registry: Arc\u003cModuleRegistry\u003e,\n        current_module_id: ModuleId,\n        module_resolver: Arc\u003cModuleResolver\u003e,\n    ) -\u003e Self {\n        let mut state = Self::new(diagnostic_handler, interner, common);\n        state.module_registry = Some(module_registry);\n        state.current_module_id = Some(current_module_id);\n        state.module_resolver = Some(module_resolver);\n        state\n    }\n\n    /// Get the current module ID as a string reference\n    pub fn current_module_id_str(\u0026self) -\u003e Option\u003c\u0026str\u003e {\n        self.current_module_id.as_ref().map(|id| id.as_str())\n    }\n\n    /// Check if we're currently inside a catch block\n    pub fn is_in_catch_block(\u0026self) -\u003e bool {\n        self.in_catch_block.last().copied().unwrap_or(false)\n    }\n\n    /// Push a new catch block context\n    pub fn push_catch_block(\u0026mut self, in_catch: bool) {\n        self.in_catch_block.push(in_catch);\n    }\n\n    /// Pop the current catch block context\n    pub fn pop_catch_block(\u0026mut self) {\n        self.in_catch_block.pop();\n    }\n\n    /// Get the full namespace path as a string\n    pub fn namespace_path(\u0026self) -\u003e String {\n        match \u0026self.current_namespace {\n            Some(parts) =\u003e parts.join(\".\"),\n            None =\u003e String::new(),\n        }\n    }\n\n    /// Check if a class is already registered\n    pub fn has_class(\u0026self, name: \u0026str) -\u003e bool {\n        self.class_parents.contains_key(name) || self.class_type_params.contains_key(name)\n    }\n\n    /// Get the parent class for a given class\n    pub fn get_parent_class(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026str\u003e {\n        self.class_parents.get(class_name).map(|s| s.as_str())\n    }\n\n    /// Register a class with its parent\n    pub fn register_class(\u0026mut self, name: String, parent: Option\u003cString\u003e) {\n        if let Some(parent_name) = parent {\n            self.class_parents.insert(name, parent_name);\n        }\n    }\n\n    /// Check if a name is already exported\n    pub fn is_exported(\u0026self, name: \u0026str) -\u003e bool {\n        self.exported_names.contains(name)\n    }\n\n    /// Mark a name as exported\n    pub fn mark_exported(\u0026mut self, name: String) -\u003e bool {\n        self.exported_names.insert(name)\n    }\n\n    /// Add a module dependency\n    pub fn add_dependency(\u0026mut self, path: PathBuf) {\n        if !self.module_dependencies.contains(\u0026path) {\n            self.module_dependencies.push(path);\n        }\n    }\n\n    /// Get all module dependencies\n    pub fn get_dependencies(\u0026self) -\u003e \u0026[PathBuf] {\n        \u0026self.module_dependencies\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::cli::diagnostics::CollectingDiagnosticHandler;\n    use std::sync::Arc;\n    use typedlua_parser::string_interner::StringInterner;\n\n    fn create_test_state() -\u003e TypeCheckerState\u003c'static\u003e {\n        let handler = Arc::new(CollectingDiagnosticHandler::new());\n        let (interner, common) = StringInterner::new_with_common_identifiers();\n        // Leak the interner to get a 'static reference for tests\n        let interner = Box::leak(Box::new(interner));\n        let common = Box::leak(Box::new(common));\n        TypeCheckerState::new(handler, interner, common)\n    }\n\n    #[test]\n    fn test_state_creation() {\n        let state = create_test_state();\n        assert!(state.current_function_return_type.is_none());\n        assert!(state.module_registry.is_none());\n        assert!(state.current_module_id.is_none());\n    }\n\n    #[test]\n    fn test_catch_block_tracking() {\n        let mut state = create_test_state();\n        assert!(!state.is_in_catch_block());\n\n        state.push_catch_block(true);\n        assert!(state.is_in_catch_block());\n\n        state.push_catch_block(false);\n        assert!(!state.is_in_catch_block());\n\n        state.pop_catch_block();\n        assert!(state.is_in_catch_block());\n\n        state.pop_catch_block();\n        assert!(!state.is_in_catch_block());\n    }\n\n    #[test]\n    fn test_class_registration() {\n        let mut state = create_test_state();\n        assert!(!state.has_class(\"MyClass\"));\n\n        state.register_class(\"MyClass\".to_string(), Some(\"ParentClass\".to_string()));\n        assert!(state.has_class(\"MyClass\"));\n        assert_eq!(state.get_parent_class(\"MyClass\"), Some(\"ParentClass\"));\n    }\n\n    #[test]\n    fn test_export_tracking() {\n        let mut state = create_test_state();\n        assert!(!state.is_exported(\"foo\"));\n\n        assert!(state.mark_exported(\"foo\".to_string()));\n        assert!(state.is_exported(\"foo\"));\n\n        // Second insert should return false (already exists)\n        assert!(!state.mark_exported(\"foo\".to_string()));\n    }\n\n    #[test]\n    fn test_dependencies() {\n        let mut state = create_test_state();\n        assert!(state.get_dependencies().is_empty());\n\n        state.add_dependency(PathBuf::from(\"/path/to/module.lua\"));\n        assert_eq!(state.get_dependencies().len(), 1);\n\n        // Duplicate should not be added\n        state.add_dependency(PathBuf::from(\"/path/to/module.lua\"));\n        assert_eq!(state.get_dependencies().len(), 1);\n    }\n}\n","traces":[{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":77,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":10}},{"line":80,"address":[],"length":0,"stats":{"Line":10}},{"line":81,"address":[],"length":0,"stats":{"Line":10}},{"line":82,"address":[],"length":0,"stats":{"Line":10}},{"line":89,"address":[],"length":0,"stats":{"Line":10}},{"line":90,"address":[],"length":0,"stats":{"Line":10}},{"line":92,"address":[],"length":0,"stats":{"Line":10}},{"line":93,"address":[],"length":0,"stats":{"Line":5}},{"line":94,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":5}},{"line":121,"address":[],"length":0,"stats":{"Line":15}},{"line":125,"address":[],"length":0,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":6}},{"line":130,"address":[],"length":0,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":9}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":154,"address":[],"length":0,"stats":{"Line":3}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":2}},{"line":161,"address":[],"length":0,"stats":{"Line":6}},{"line":165,"address":[],"length":0,"stats":{"Line":2}},{"line":166,"address":[],"length":0,"stats":{"Line":6}},{"line":170,"address":[],"length":0,"stats":{"Line":2}},{"line":171,"address":[],"length":0,"stats":{"Line":5}},{"line":172,"address":[],"length":0,"stats":{"Line":2}},{"line":177,"address":[],"length":0,"stats":{"Line":3}},{"line":178,"address":[],"length":0,"stats":{"Line":3}}],"covered":33,"coverable":45},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","stdlib","mod.rs"],"content":"// Standard library type definitions embedded at compile time\n\nuse crate::cli::config::LuaVersion;\n\n/// Builtin global functions (available in all Lua versions)\npub const BUILTINS: \u0026str = include_str!(\"builtins.d.tl\");\n\n/// Lua 5.1 standard library\npub const LUA51: \u0026str = include_str!(\"lua51.d.tl\");\n\n/// Lua 5.2 standard library\npub const LUA52: \u0026str = include_str!(\"lua52.d.tl\");\n\n/// Lua 5.3 standard library\npub const LUA53: \u0026str = include_str!(\"lua53.d.tl\");\n\n/// Lua 5.4 standard library\npub const LUA54: \u0026str = include_str!(\"lua54.d.tl\");\n\n/// Reflection runtime module (available in all Lua versions)\npub const REFLECTION: \u0026str = include_str!(\"reflection.d.tl\");\n\n/// Get the appropriate stdlib content based on Lua version\npub fn get_stdlib(version: LuaVersion) -\u003e \u0026'static str {\n    match version {\n        LuaVersion::Lua51 =\u003e LUA51,\n        LuaVersion::Lua52 =\u003e LUA52,\n        LuaVersion::Lua53 =\u003e LUA53,\n        LuaVersion::Lua54 =\u003e LUA54,\n    }\n}\n\n/// Get all stdlib sources (builtins + version-specific + reflection)\npub fn get_all_stdlib(version: LuaVersion) -\u003e Vec\u003c(\u0026'static str, \u0026'static str)\u003e {\n    vec![\n        (\"builtins.d.tl\", BUILTINS),\n        (\n            match version {\n                LuaVersion::Lua51 =\u003e \"lua51.d.tl\",\n                LuaVersion::Lua52 =\u003e \"lua52.d.tl\",\n                LuaVersion::Lua53 =\u003e \"lua53.d.tl\",\n                LuaVersion::Lua54 =\u003e \"lua54.d.tl\",\n            },\n            get_stdlib(version),\n        ),\n        (\"reflection.d.tl\", REFLECTION),\n    ]\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_builtins_embedded() {\n        assert!(!BUILTINS.is_empty());\n        assert!(BUILTINS.contains(\"declare function print\"));\n        assert!(BUILTINS.contains(\"declare function type\"));\n    }\n\n    #[test]\n    fn test_lua51_embedded() {\n        assert!(!LUA51.is_empty());\n        assert!(LUA51.contains(\"declare namespace string\"));\n        assert!(LUA51.contains(\"declare namespace table\"));\n    }\n\n    #[test]\n    fn test_lua52_embedded() {\n        assert!(!LUA52.is_empty());\n        assert!(LUA52.contains(\"declare namespace bit32\"));\n        assert!(!LUA52.contains(\"table.maxn\")); // Removed in 5.2\n    }\n\n    #[test]\n    fn test_lua53_embedded() {\n        assert!(!LUA53.is_empty());\n        assert!(LUA53.contains(\"declare namespace utf8\"));\n        assert!(!LUA53.contains(\"declare namespace bit32\")); // Removed in 5.3\n    }\n\n    #[test]\n    fn test_lua54_embedded() {\n        assert!(!LUA54.is_empty());\n        assert!(LUA54.contains(\"declare function warn\"));\n        assert!(LUA54.contains(\"declare namespace coroutine\"));\n        assert!(LUA54.contains(\"export function close\")); // coroutine.close\n    }\n\n    #[test]\n    fn test_get_stdlib() {\n        assert_eq!(get_stdlib(LuaVersion::Lua51), LUA51);\n        assert_eq!(get_stdlib(LuaVersion::Lua52), LUA52);\n        assert_eq!(get_stdlib(LuaVersion::Lua53), LUA53);\n        assert_eq!(get_stdlib(LuaVersion::Lua54), LUA54);\n    }\n\n    #[test]\n    fn test_get_all_stdlib() {\n        let stdlib = get_all_stdlib(LuaVersion::Lua54);\n        assert_eq!(stdlib.len(), 3);\n        assert_eq!(stdlib[0].0, \"builtins.d.tl\");\n        assert_eq!(stdlib[1].0, \"lua54.d.tl\");\n        assert_eq!(stdlib[2].0, \"reflection.d.tl\");\n    }\n}\n","traces":[{"line":24,"address":[],"length":0,"stats":{"Line":14}},{"line":25,"address":[],"length":0,"stats":{"Line":14}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":27,"address":[],"length":0,"stats":{"Line":2}},{"line":28,"address":[],"length":0,"stats":{"Line":2}},{"line":29,"address":[],"length":0,"stats":{"Line":7}},{"line":34,"address":[],"length":0,"stats":{"Line":10}},{"line":35,"address":[],"length":0,"stats":{"Line":10}},{"line":36,"address":[],"length":0,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":10}},{"line":39,"address":[],"length":0,"stats":{"Line":2}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":41,"address":[],"length":0,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":6}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":10}}],"covered":16,"coverable":16},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","types","generics.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::TypeParameter;\nuse typedlua_parser::ast::types::{Type, TypeKind, TypeReference};\nuse typedlua_parser::string_interner::StringId;\n\n#[cfg(test)]\nuse typedlua_parser::span::Span;\n\n/// Substitutes type parameters with concrete types in a type\npub fn instantiate_type(\n    typ: \u0026Type,\n    type_params: \u0026[TypeParameter],\n    type_args: \u0026[Type],\n) -\u003e Result\u003cType, String\u003e {\n    if type_params.len() != type_args.len() {\n        return Err(format!(\n            \"Expected {} type arguments, but got {}\",\n            type_params.len(),\n            type_args.len()\n        ));\n    }\n\n    // Build substitution map\n    let mut substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n    for (param, arg) in type_params.iter().zip(type_args.iter()) {\n        substitutions.insert(param.name.node, arg.clone());\n    }\n\n    substitute_type(typ, \u0026substitutions)\n}\n\n/// Recursively substitute type parameters in a type\nfn substitute_type(typ: \u0026Type, substitutions: \u0026FxHashMap\u003cStringId, Type\u003e) -\u003e Result\u003cType, String\u003e {\n    match \u0026typ.kind {\n        // If this is a type reference that matches a type parameter, substitute it\n        TypeKind::Reference(type_ref) =\u003e {\n            let name = type_ref.name.node;\n\n            // Check if this is a type parameter\n            if let Some(substituted) = substitutions.get(\u0026name) {\n                // Apply type arguments if present (e.g., for higher-kinded types)\n                if let Some(ref args) = type_ref.type_arguments {\n                    // This would be a higher-kinded type - not common, but we should handle it\n                    // For now, just return an error\n                    if !args.is_empty() {\n                        return Err(format!(\n                            \"Type parameter {:?} cannot have type arguments\",\n                            name\n                        ));\n                    }\n                }\n                Ok(substituted.clone())\n            } else {\n                // Not a type parameter - recursively substitute in type arguments\n                if let Some(ref args) = type_ref.type_arguments {\n                    let substituted_args: Result\u003cVec\u003c_\u003e, _\u003e = args\n                        .iter()\n                        .map(|arg| substitute_type(arg, substitutions))\n                        .collect();\n\n                    Ok(Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: type_ref.name.clone(),\n                            type_arguments: Some(substituted_args?),\n                            span: type_ref.span,\n                        }),\n                        typ.span,\n                    ))\n                } else {\n                    Ok(typ.clone())\n                }\n            }\n        }\n\n        // Array type: substitute element type\n        TypeKind::Array(elem) =\u003e {\n            let substituted_elem = substitute_type(elem, substitutions)?;\n            Ok(Type::new(\n                TypeKind::Array(Box::new(substituted_elem)),\n                typ.span,\n            ))\n        }\n\n        // Tuple type: substitute each element\n        TypeKind::Tuple(elems) =\u003e {\n            let substituted_elems: Result\u003cVec\u003c_\u003e, _\u003e = elems\n                .iter()\n                .map(|elem| substitute_type(elem, substitutions))\n                .collect();\n\n            Ok(Type::new(TypeKind::Tuple(substituted_elems?), typ.span))\n        }\n\n        // Union type: substitute each member\n        TypeKind::Union(members) =\u003e {\n            let substituted_members: Result\u003cVec\u003c_\u003e, _\u003e = members\n                .iter()\n                .map(|member| substitute_type(member, substitutions))\n                .collect();\n\n            Ok(Type::new(TypeKind::Union(substituted_members?), typ.span))\n        }\n\n        // Intersection type: substitute each member\n        TypeKind::Intersection(members) =\u003e {\n            let substituted_members: Result\u003cVec\u003c_\u003e, _\u003e = members\n                .iter()\n                .map(|member| substitute_type(member, substitutions))\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Intersection(substituted_members?),\n                typ.span,\n            ))\n        }\n\n        // Function type: substitute parameter and return types\n        TypeKind::Function(func_type) =\u003e {\n            use typedlua_parser::ast::statement::Parameter;\n\n            let substituted_params: Result\u003cVec\u003cParameter\u003e, String\u003e = func_type\n                .parameters\n                .iter()\n                .map(|param| {\n                    if let Some(ref type_ann) = param.type_annotation {\n                        let substituted = substitute_type(type_ann, substitutions)?;\n                        Ok(Parameter {\n                            pattern: param.pattern.clone(),\n                            type_annotation: Some(substituted),\n                            default: param.default.clone(),\n                            is_rest: param.is_rest,\n                            is_optional: param.is_optional,\n                            span: param.span,\n                        })\n                    } else {\n                        Ok(param.clone())\n                    }\n                })\n                .collect();\n\n            let substituted_return = substitute_type(\u0026func_type.return_type, substitutions)?;\n\n            Ok(Type::new(\n                TypeKind::Function(typedlua_parser::ast::types::FunctionType {\n                    type_parameters: None, // Type parameters are gone after substitution\n                    parameters: substituted_params?,\n                    return_type: Box::new(substituted_return),\n                    throws: func_type.throws.clone(),\n                    span: func_type.span,\n                }),\n                typ.span,\n            ))\n        }\n\n        // Nullable type: substitute inner type\n        TypeKind::Nullable(inner) =\u003e {\n            let substituted_inner = substitute_type(inner, substitutions)?;\n            Ok(Type::new(\n                TypeKind::Nullable(Box::new(substituted_inner)),\n                typ.span,\n            ))\n        }\n\n        // Parenthesized type: substitute inner type\n        TypeKind::Parenthesized(inner) =\u003e {\n            let substituted_inner = substitute_type(inner, substitutions)?;\n            Ok(Type::new(\n                TypeKind::Parenthesized(Box::new(substituted_inner)),\n                typ.span,\n            ))\n        }\n\n        // Object type: substitute property type annotations\n        TypeKind::Object(obj_type) =\u003e {\n            use typedlua_parser::ast::statement::{MethodSignature, PropertySignature};\n            use typedlua_parser::ast::types::ObjectTypeMember;\n\n            let mut substituted_members: Vec\u003cObjectTypeMember\u003e = Vec::new();\n            for member in \u0026obj_type.members {\n                let substituted = match member {\n                    ObjectTypeMember::Property(prop) =\u003e {\n                        let substituted_type =\n                            substitute_type(\u0026prop.type_annotation, substitutions)?;\n                        ObjectTypeMember::Property(PropertySignature {\n                            type_annotation: substituted_type,\n                            ..prop.clone()\n                        })\n                    }\n                    ObjectTypeMember::Method(method) =\u003e {\n                        // For methods, substitute the return type\n                        // Note: method parameters are handled separately during function type checking\n                        let substituted_return =\n                            substitute_type(\u0026method.return_type, substitutions)?;\n\n                        ObjectTypeMember::Method(MethodSignature {\n                            return_type: substituted_return,\n                            ..method.clone()\n                        })\n                    }\n                    ObjectTypeMember::Index(index) =\u003e {\n                        // Index signatures have key_type and value_type\n                        // key_type is IndexKeyType (String or Number), not Type\n                        let substituted_value = substitute_type(\u0026index.value_type, substitutions)?;\n\n                        ObjectTypeMember::Index(typedlua_parser::ast::statement::IndexSignature {\n                            value_type: substituted_value,\n                            ..index.clone()\n                        })\n                    }\n                };\n                substituted_members.push(substituted);\n            }\n\n            Ok(Type::new(\n                TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                    members: substituted_members,\n                    ..obj_type.clone()\n                }),\n                typ.span,\n            ))\n        }\n\n        // Conditional types, mapped types, etc. would need similar handling\n        // For now, just clone types that don't contain type parameters\n        _ =\u003e Ok(typ.clone()),\n    }\n}\n\n/// Check if type arguments satisfy type parameter constraints\npub fn check_type_constraints(\n    type_params: \u0026[TypeParameter],\n    type_args: \u0026[Type],\n) -\u003e Result\u003c(), String\u003e {\n    if type_params.len() != type_args.len() {\n        return Err(format!(\n            \"Expected {} type arguments, but got {}\",\n            type_params.len(),\n            type_args.len()\n        ));\n    }\n\n    for (param, arg) in type_params.iter().zip(type_args.iter()) {\n        if let Some(ref constraint) = param.constraint {\n            // Check if arg is assignable to constraint\n            // This is a simplified check - a real implementation would use TypeCompatibility\n            // For now, we'll just do a basic check\n            if !is_type_compatible(arg, constraint) {\n                return Err(format!(\n                    \"Type argument does not satisfy constraint for parameter '{}'\",\n                    param.name.node\n                ));\n            }\n        }\n    }\n\n    Ok(())\n}\n\n/// Check if a type is compatible with a constraint\n/// Uses the TypeCompatibility module for proper checking\nfn is_type_compatible(arg: \u0026Type, constraint: \u0026Type) -\u003e bool {\n    use crate::core::type_compat::TypeCompatibility;\n    TypeCompatibility::is_assignable(arg, constraint)\n}\n\n/// Infer type arguments for a generic function from argument types\n/// Returns a map from type parameter name to inferred type\npub fn infer_type_arguments(\n    type_params: \u0026[TypeParameter],\n    function_params: \u0026[typedlua_parser::ast::statement::Parameter],\n    arg_types: \u0026[Type],\n) -\u003e Result\u003cVec\u003cType\u003e, String\u003e {\n    if function_params.len() != arg_types.len() {\n        return Err(format!(\n            \"Expected {} arguments, got {}\",\n            function_params.len(),\n            arg_types.len()\n        ));\n    }\n\n    let mut inferred: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n\n    // For each parameter-argument pair, try to infer type arguments\n    for (param, arg_type) in function_params.iter().zip(arg_types.iter()) {\n        if let Some(param_type) = \u0026param.type_annotation {\n            infer_from_types(param_type, arg_type, \u0026mut inferred)?;\n        }\n    }\n\n    // Build result vector in the same order as type parameters\n    type_params\n        .iter()\n        .map(|type_param| {\n            inferred\n                .get(\u0026type_param.name.node)\n                .cloned()\n                .or_else(|| type_param.default.as_ref().map(|d| (**d).clone()))\n                .ok_or_else(|| {\n                    format!(\n                        \"Could not infer type argument for parameter '{:?}'\",\n                        type_param.name.node\n                    )\n                })\n        })\n        .collect()\n}\n\n/// Helper to infer type arguments by matching param_type pattern against arg_type\nfn infer_from_types(\n    param_type: \u0026Type,\n    arg_type: \u0026Type,\n    inferred: \u0026mut FxHashMap\u003cStringId, Type\u003e,\n) -\u003e Result\u003c(), String\u003e {\n    match \u0026param_type.kind {\n        // If parameter is a type reference (e.g., T), and it's a type parameter\n        TypeKind::Reference(type_ref) if type_ref.type_arguments.is_none() =\u003e {\n            // This might be a type parameter - record the inference\n            let param_name = type_ref.name.node;\n\n            // Check if we already inferred this type parameter\n            if let Some(existing) = inferred.get(\u0026param_name) {\n                // Verify they match (simplified - should use proper type equality)\n                if !types_equal(existing, arg_type) {\n                    return Err(format!(\n                        \"Conflicting type inference for parameter '{:?}'\",\n                        param_name\n                    ));\n                }\n            } else {\n                inferred.insert(param_name, arg_type.clone());\n            }\n            Ok(())\n        }\n\n        // If parameter is Array\u003cT\u003e, and argument is Array\u003cU\u003e, infer T = U\n        TypeKind::Array(elem_param) =\u003e {\n            if let TypeKind::Array(elem_arg) = \u0026arg_type.kind {\n                infer_from_types(elem_param, elem_arg, inferred)\n            } else {\n                Ok(()) // Type mismatch, but don't error during inference\n            }\n        }\n\n        // If parameter is a generic type application like Map\u003cK, V\u003e\n        TypeKind::Reference(type_ref) if type_ref.type_arguments.is_some() =\u003e {\n            if let TypeKind::Reference(arg_ref) = \u0026arg_type.kind {\n                // Names should match\n                if type_ref.name.node == arg_ref.name.node {\n                    if let (Some(param_args), Some(arg_args)) =\n                        (\u0026type_ref.type_arguments, \u0026arg_ref.type_arguments)\n                    {\n                        // Infer from each type argument pair\n                        for (p, a) in param_args.iter().zip(arg_args.iter()) {\n                            infer_from_types(p, a, inferred)?;\n                        }\n                    }\n                }\n            }\n            Ok(())\n        }\n\n        // For other types, no inference needed\n        _ =\u003e Ok(()),\n    }\n}\n\n/// Simple type equality check (simplified)\nfn types_equal(t1: \u0026Type, t2: \u0026Type) -\u003e bool {\n    // Simplified - just check if both are the same primitive\n    match (\u0026t1.kind, \u0026t2.kind) {\n        (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) =\u003e p1 == p2,\n        (TypeKind::Reference(r1), TypeKind::Reference(r2)) =\u003e r1.name.node == r2.name.node,\n        _ =\u003e false, // For now, consider other types as not equal\n    }\n}\n\n// =============================================================================\n// Body Instantiation Functions for Generic Specialization\n// =============================================================================\n\n/// Build a substitution map from type parameters and type arguments\npub fn build_substitutions(\n    type_params: \u0026[TypeParameter],\n    type_args: \u0026[Type],\n) -\u003e Result\u003cFxHashMap\u003cStringId, Type\u003e, String\u003e {\n    if type_params.len() != type_args.len() {\n        return Err(format!(\n            \"Expected {} type arguments, but got {}\",\n            type_params.len(),\n            type_args.len()\n        ));\n    }\n\n    let mut substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n    for (param, arg) in type_params.iter().zip(type_args.iter()) {\n        substitutions.insert(param.name.node, arg.clone());\n    }\n    Ok(substitutions)\n}\n\n/// Instantiate a block with type substitutions\n/// Clones the block and substitutes type annotations in all statements\npub fn instantiate_block(\n    block: \u0026typedlua_parser::ast::statement::Block,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::Block {\n    use typedlua_parser::ast::statement::Block;\n\n    Block {\n        statements: block\n            .statements\n            .iter()\n            .map(|stmt| instantiate_statement(stmt, substitutions))\n            .collect(),\n        span: block.span,\n    }\n}\n\n/// Instantiate a statement with type substitutions\npub fn instantiate_statement(\n    stmt: \u0026typedlua_parser::ast::statement::Statement,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::Statement {\n    use typedlua_parser::ast::statement::{\n        ElseIf, ForGeneric, ForNumeric, ForStatement, IfStatement, RepeatStatement,\n        ReturnStatement, Statement, ThrowStatement, VariableDeclaration, WhileStatement,\n    };\n\n    match stmt {\n        Statement::Variable(var_decl) =\u003e Statement::Variable(VariableDeclaration {\n            kind: var_decl.kind,\n            pattern: var_decl.pattern.clone(),\n            type_annotation: var_decl\n                .type_annotation\n                .as_ref()\n                .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n            initializer: instantiate_expression(\u0026var_decl.initializer, substitutions),\n            span: var_decl.span,\n        }),\n\n        Statement::Function(func_decl) =\u003e {\n            Statement::Function(instantiate_function_declaration(func_decl, substitutions))\n        }\n\n        Statement::Expression(expr) =\u003e {\n            Statement::Expression(instantiate_expression(expr, substitutions))\n        }\n\n        Statement::Return(ret) =\u003e Statement::Return(ReturnStatement {\n            values: ret\n                .values\n                .iter()\n                .map(|e| instantiate_expression(e, substitutions))\n                .collect(),\n            span: ret.span,\n        }),\n\n        Statement::If(if_stmt) =\u003e Statement::If(IfStatement {\n            condition: instantiate_expression(\u0026if_stmt.condition, substitutions),\n            then_block: instantiate_block(\u0026if_stmt.then_block, substitutions),\n            else_ifs: if_stmt\n                .else_ifs\n                .iter()\n                .map(|elif| ElseIf {\n                    condition: instantiate_expression(\u0026elif.condition, substitutions),\n                    block: instantiate_block(\u0026elif.block, substitutions),\n                    span: elif.span,\n                })\n                .collect(),\n            else_block: if_stmt\n                .else_block\n                .as_ref()\n                .map(|b| instantiate_block(b, substitutions)),\n            span: if_stmt.span,\n        }),\n\n        Statement::While(while_stmt) =\u003e Statement::While(WhileStatement {\n            condition: instantiate_expression(\u0026while_stmt.condition, substitutions),\n            body: instantiate_block(\u0026while_stmt.body, substitutions),\n            span: while_stmt.span,\n        }),\n\n        Statement::For(for_stmt) =\u003e Statement::For(Box::new(match for_stmt.as_ref() {\n            ForStatement::Numeric(num) =\u003e ForStatement::Numeric(Box::new(ForNumeric {\n                variable: num.variable.clone(),\n                start: instantiate_expression(\u0026num.start, substitutions),\n                end: instantiate_expression(\u0026num.end, substitutions),\n                step: num\n                    .step\n                    .as_ref()\n                    .map(|e| instantiate_expression(e, substitutions)),\n                body: instantiate_block(\u0026num.body, substitutions),\n                span: num.span,\n            })),\n            ForStatement::Generic(gen) =\u003e ForStatement::Generic(ForGeneric {\n                variables: gen.variables.clone(),\n                iterators: gen\n                    .iterators\n                    .iter()\n                    .map(|e| instantiate_expression(e, substitutions))\n                    .collect(),\n                body: instantiate_block(\u0026gen.body, substitutions),\n                span: gen.span,\n            }),\n        })),\n\n        Statement::Repeat(repeat) =\u003e Statement::Repeat(RepeatStatement {\n            body: instantiate_block(\u0026repeat.body, substitutions),\n            until: instantiate_expression(\u0026repeat.until, substitutions),\n            span: repeat.span,\n        }),\n\n        Statement::Block(block) =\u003e Statement::Block(instantiate_block(block, substitutions)),\n\n        Statement::Throw(throw) =\u003e Statement::Throw(ThrowStatement {\n            expression: instantiate_expression(\u0026throw.expression, substitutions),\n            span: throw.span,\n        }),\n\n        // Statements that don't contain type parameters or are complex - clone as-is\n        Statement::Break(span) =\u003e Statement::Break(*span),\n        Statement::Continue(span) =\u003e Statement::Continue(*span),\n        Statement::Rethrow(span) =\u003e Statement::Rethrow(*span),\n        Statement::Class(class_decl) =\u003e Statement::Class(class_decl.clone()),\n        Statement::Interface(iface) =\u003e Statement::Interface(iface.clone()),\n        Statement::TypeAlias(alias) =\u003e Statement::TypeAlias(alias.clone()),\n        Statement::Enum(enum_decl) =\u003e Statement::Enum(enum_decl.clone()),\n        Statement::Import(import) =\u003e Statement::Import(import.clone()),\n        Statement::Export(export) =\u003e Statement::Export(export.clone()),\n        Statement::Try(try_stmt) =\u003e Statement::Try(try_stmt.clone()),\n        Statement::Namespace(ns) =\u003e Statement::Namespace(ns.clone()),\n        Statement::DeclareFunction(df) =\u003e Statement::DeclareFunction(df.clone()),\n        Statement::DeclareNamespace(dn) =\u003e Statement::DeclareNamespace(dn.clone()),\n        Statement::DeclareType(dt) =\u003e Statement::DeclareType(dt.clone()),\n        Statement::DeclareInterface(di) =\u003e Statement::DeclareInterface(di.clone()),\n        Statement::DeclareConst(dc) =\u003e Statement::DeclareConst(dc.clone()),\n        Statement::Label(l) =\u003e Statement::Label(l.clone()),\n        Statement::Goto(g) =\u003e Statement::Goto(g.clone()),\n    }\n}\n\n/// Instantiate a function declaration with type substitutions\npub fn instantiate_function_declaration(\n    func: \u0026typedlua_parser::ast::statement::FunctionDeclaration,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::FunctionDeclaration {\n    typedlua_parser::ast::statement::FunctionDeclaration {\n        name: func.name.clone(),\n        type_parameters: None, // Remove type parameters after specialization\n        parameters: func\n            .parameters\n            .iter()\n            .map(|p| instantiate_parameter(p, substitutions))\n            .collect(),\n        return_type: func\n            .return_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        body: instantiate_block(\u0026func.body, substitutions),\n        throws: func.throws.clone(),\n        span: func.span,\n    }\n}\n\n/// Instantiate a parameter with type substitutions\npub fn instantiate_parameter(\n    param: \u0026typedlua_parser::ast::statement::Parameter,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::statement::Parameter {\n    typedlua_parser::ast::statement::Parameter {\n        pattern: param.pattern.clone(),\n        type_annotation: param\n            .type_annotation\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        default: param\n            .default\n            .as_ref()\n            .map(|e| instantiate_expression(e, substitutions)),\n        is_rest: param.is_rest,\n        is_optional: param.is_optional,\n        span: param.span,\n    }\n}\n\n/// Instantiate an expression with type substitutions\npub fn instantiate_expression(\n    expr: \u0026typedlua_parser::ast::expression::Expression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::Expression {\n    use typedlua_parser::ast::expression::{Expression, ExpressionKind};\n\n    let new_kind = match \u0026expr.kind {\n        ExpressionKind::Literal(lit) =\u003e ExpressionKind::Literal(lit.clone()),\n        ExpressionKind::Identifier(id) =\u003e ExpressionKind::Identifier(*id),\n\n        ExpressionKind::Binary(op, left, right) =\u003e ExpressionKind::Binary(\n            *op,\n            Box::new(instantiate_expression(left, substitutions)),\n            Box::new(instantiate_expression(right, substitutions)),\n        ),\n\n        ExpressionKind::Unary(op, operand) =\u003e ExpressionKind::Unary(\n            *op,\n            Box::new(instantiate_expression(operand, substitutions)),\n        ),\n\n        ExpressionKind::Assignment(target, op, value) =\u003e ExpressionKind::Assignment(\n            Box::new(instantiate_expression(target, substitutions)),\n            *op,\n            Box::new(instantiate_expression(value, substitutions)),\n        ),\n\n        ExpressionKind::Call(callee, args, type_args) =\u003e ExpressionKind::Call(\n            Box::new(instantiate_expression(callee, substitutions)),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::MethodCall(obj, method, args, type_args) =\u003e ExpressionKind::MethodCall(\n            Box::new(instantiate_expression(obj, substitutions)),\n            method.clone(),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::Member(obj, member) =\u003e ExpressionKind::Member(\n            Box::new(instantiate_expression(obj, substitutions)),\n            member.clone(),\n        ),\n\n        ExpressionKind::Index(obj, index) =\u003e ExpressionKind::Index(\n            Box::new(instantiate_expression(obj, substitutions)),\n            Box::new(instantiate_expression(index, substitutions)),\n        ),\n\n        ExpressionKind::Array(elements) =\u003e ExpressionKind::Array(\n            elements\n                .iter()\n                .map(|elem| instantiate_array_element(elem, substitutions))\n                .collect(),\n        ),\n\n        ExpressionKind::Object(props) =\u003e ExpressionKind::Object(\n            props\n                .iter()\n                .map(|prop| instantiate_object_property(prop, substitutions))\n                .collect(),\n        ),\n\n        ExpressionKind::Function(func) =\u003e {\n            ExpressionKind::Function(instantiate_function_expression(func, substitutions))\n        }\n\n        ExpressionKind::Arrow(arrow) =\u003e {\n            ExpressionKind::Arrow(instantiate_arrow_function(arrow, substitutions))\n        }\n\n        ExpressionKind::Conditional(cond, then_expr, else_expr) =\u003e ExpressionKind::Conditional(\n            Box::new(instantiate_expression(cond, substitutions)),\n            Box::new(instantiate_expression(then_expr, substitutions)),\n            Box::new(instantiate_expression(else_expr, substitutions)),\n        ),\n\n        ExpressionKind::Pipe(left, right) =\u003e ExpressionKind::Pipe(\n            Box::new(instantiate_expression(left, substitutions)),\n            Box::new(instantiate_expression(right, substitutions)),\n        ),\n\n        ExpressionKind::Match(match_expr) =\u003e {\n            ExpressionKind::Match(instantiate_match_expression(match_expr, substitutions))\n        }\n\n        ExpressionKind::Parenthesized(inner) =\u003e {\n            ExpressionKind::Parenthesized(Box::new(instantiate_expression(inner, substitutions)))\n        }\n\n        ExpressionKind::TypeAssertion(expr_inner, typ) =\u003e ExpressionKind::TypeAssertion(\n            Box::new(instantiate_expression(expr_inner, substitutions)),\n            substitute_type(typ, substitutions).unwrap_or_else(|_| typ.clone()),\n        ),\n\n        ExpressionKind::OptionalMember(obj, member) =\u003e ExpressionKind::OptionalMember(\n            Box::new(instantiate_expression(obj, substitutions)),\n            member.clone(),\n        ),\n\n        ExpressionKind::OptionalIndex(obj, index) =\u003e ExpressionKind::OptionalIndex(\n            Box::new(instantiate_expression(obj, substitutions)),\n            Box::new(instantiate_expression(index, substitutions)),\n        ),\n\n        ExpressionKind::OptionalCall(callee, args, type_args) =\u003e ExpressionKind::OptionalCall(\n            Box::new(instantiate_expression(callee, substitutions)),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::OptionalMethodCall(obj, method, args, type_args) =\u003e {\n            ExpressionKind::OptionalMethodCall(\n                Box::new(instantiate_expression(obj, substitutions)),\n                method.clone(),\n                args.iter()\n                    .map(|a| instantiate_argument(a, substitutions))\n                    .collect(),\n                type_args.as_ref().map(|tas| {\n                    tas.iter()\n                        .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                        .collect()\n                }),\n            )\n        }\n\n        ExpressionKind::Template(template) =\u003e {\n            ExpressionKind::Template(instantiate_template_literal(template, substitutions))\n        }\n\n        ExpressionKind::New(callee, args, type_args) =\u003e ExpressionKind::New(\n            Box::new(instantiate_expression(callee, substitutions)),\n            args.iter()\n                .map(|a| instantiate_argument(a, substitutions))\n                .collect(),\n            type_args.as_ref().map(|tas| {\n                tas.iter()\n                    .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone()))\n                    .collect()\n            }),\n        ),\n\n        ExpressionKind::Try(try_expr) =\u003e {\n            ExpressionKind::Try(instantiate_try_expression(try_expr, substitutions))\n        }\n\n        ExpressionKind::ErrorChain(left, right) =\u003e ExpressionKind::ErrorChain(\n            Box::new(instantiate_expression(left, substitutions)),\n            Box::new(instantiate_expression(right, substitutions)),\n        ),\n\n        // Simple expression kinds - clone as-is\n        ExpressionKind::SelfKeyword =\u003e ExpressionKind::SelfKeyword,\n        ExpressionKind::SuperKeyword =\u003e ExpressionKind::SuperKeyword,\n    };\n\n    Expression {\n        kind: new_kind,\n        span: expr.span,\n        annotated_type: expr\n            .annotated_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        receiver_class: expr.receiver_class.clone(),\n    }\n}\n\n/// Helper to instantiate an argument\nfn instantiate_argument(\n    arg: \u0026typedlua_parser::ast::expression::Argument,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::Argument {\n    typedlua_parser::ast::expression::Argument {\n        value: instantiate_expression(\u0026arg.value, substitutions),\n        is_spread: arg.is_spread,\n        span: arg.span,\n    }\n}\n\n/// Helper to instantiate an array element\nfn instantiate_array_element(\n    elem: \u0026typedlua_parser::ast::expression::ArrayElement,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::ArrayElement {\n    use typedlua_parser::ast::expression::ArrayElement;\n    match elem {\n        ArrayElement::Expression(e) =\u003e {\n            ArrayElement::Expression(instantiate_expression(e, substitutions))\n        }\n        ArrayElement::Spread(e) =\u003e ArrayElement::Spread(instantiate_expression(e, substitutions)),\n    }\n}\n\n/// Helper to instantiate an object property\nfn instantiate_object_property(\n    prop: \u0026typedlua_parser::ast::expression::ObjectProperty,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::ObjectProperty {\n    use typedlua_parser::ast::expression::ObjectProperty;\n    match prop {\n        ObjectProperty::Property { key, value, span } =\u003e ObjectProperty::Property {\n            key: key.clone(),\n            value: Box::new(instantiate_expression(value, substitutions)),\n            span: *span,\n        },\n        ObjectProperty::Computed { key, value, span } =\u003e ObjectProperty::Computed {\n            key: Box::new(instantiate_expression(key, substitutions)),\n            value: Box::new(instantiate_expression(value, substitutions)),\n            span: *span,\n        },\n        ObjectProperty::Spread { value, span } =\u003e ObjectProperty::Spread {\n            value: Box::new(instantiate_expression(value, substitutions)),\n            span: *span,\n        },\n    }\n}\n\n/// Helper to instantiate a function expression\nfn instantiate_function_expression(\n    func: \u0026typedlua_parser::ast::expression::FunctionExpression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::FunctionExpression {\n    typedlua_parser::ast::expression::FunctionExpression {\n        type_parameters: None, // Remove type parameters after specialization\n        parameters: func\n            .parameters\n            .iter()\n            .map(|p| instantiate_parameter(p, substitutions))\n            .collect(),\n        return_type: func\n            .return_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        body: instantiate_block(\u0026func.body, substitutions),\n        span: func.span,\n    }\n}\n\n/// Helper to instantiate an arrow function\nfn instantiate_arrow_function(\n    arrow: \u0026typedlua_parser::ast::expression::ArrowFunction,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::ArrowFunction {\n    use typedlua_parser::ast::expression::{ArrowBody, ArrowFunction};\n    ArrowFunction {\n        parameters: arrow\n            .parameters\n            .iter()\n            .map(|p| instantiate_parameter(p, substitutions))\n            .collect(),\n        return_type: arrow\n            .return_type\n            .as_ref()\n            .map(|t| substitute_type(t, substitutions).unwrap_or_else(|_| t.clone())),\n        body: match \u0026arrow.body {\n            ArrowBody::Expression(e) =\u003e {\n                ArrowBody::Expression(Box::new(instantiate_expression(e.as_ref(), substitutions)))\n            }\n            ArrowBody::Block(b) =\u003e ArrowBody::Block(instantiate_block(b, substitutions)),\n        },\n        span: arrow.span,\n    }\n}\n\n/// Helper to instantiate a template literal\nfn instantiate_template_literal(\n    template: \u0026typedlua_parser::ast::expression::TemplateLiteral,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::TemplateLiteral {\n    use typedlua_parser::ast::expression::{TemplateLiteral, TemplatePart};\n    TemplateLiteral {\n        parts: template\n            .parts\n            .iter()\n            .map(|part| match part {\n                TemplatePart::String(s) =\u003e TemplatePart::String(s.clone()),\n                TemplatePart::Expression(e) =\u003e {\n                    TemplatePart::Expression(Box::new(instantiate_expression(e, substitutions)))\n                }\n            })\n            .collect(),\n        span: template.span,\n    }\n}\n\n/// Helper to instantiate a match expression\nfn instantiate_match_expression(\n    match_expr: \u0026typedlua_parser::ast::expression::MatchExpression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::MatchExpression {\n    use typedlua_parser::ast::expression::{MatchArm, MatchArmBody, MatchExpression};\n    MatchExpression {\n        value: Box::new(instantiate_expression(\u0026match_expr.value, substitutions)),\n        arms: match_expr\n            .arms\n            .iter()\n            .map(|arm| MatchArm {\n                pattern: arm.pattern.clone(),\n                guard: arm\n                    .guard\n                    .as_ref()\n                    .map(|e| instantiate_expression(e, substitutions)),\n                body: match \u0026arm.body {\n                    MatchArmBody::Expression(e) =\u003e {\n                        MatchArmBody::Expression(Box::new(instantiate_expression(e, substitutions)))\n                    }\n                    MatchArmBody::Block(b) =\u003e {\n                        MatchArmBody::Block(instantiate_block(b, substitutions))\n                    }\n                },\n                span: arm.span,\n            })\n            .collect(),\n        span: match_expr.span,\n    }\n}\n\n/// Helper to instantiate a try expression\nfn instantiate_try_expression(\n    try_expr: \u0026typedlua_parser::ast::expression::TryExpression,\n    substitutions: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e typedlua_parser::ast::expression::TryExpression {\n    typedlua_parser::ast::expression::TryExpression {\n        expression: Box::new(instantiate_expression(\u0026try_expr.expression, substitutions)),\n        catch_variable: try_expr.catch_variable.clone(),\n        catch_expression: Box::new(instantiate_expression(\n            \u0026try_expr.catch_expression,\n            substitutions,\n        )),\n        span: try_expr.span,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::types::{PrimitiveType, TypeKind};\n    use typedlua_parser::ast::Spanned;\n\n    #[test]\n    fn test_instantiate_simple_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Type reference T\n        let type_ref_t = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n\n        // Type argument: number\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Instantiate T with number\n        let result = instantiate_type(\n            \u0026type_ref_t,\n            \u0026[type_param],\n            std::slice::from_ref(\u0026number_type),\n        )\n        .unwrap();\n\n        // Result should be number\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_array_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Array\u003cT\u003e\n        let array_t = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            ))),\n            span,\n        );\n\n        // Type argument: string\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        // Instantiate Array\u003cT\u003e with string\n        let result = instantiate_type(\u0026array_t, \u0026[type_param], \u0026[string_type]).unwrap();\n\n        // Result should be Array\u003cstring\u003e\n        match \u0026result.kind {\n            TypeKind::Array(elem) =\u003e {\n                assert!(matches!(\n                    elem.kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected array type\"),\n        }\n    }\n\n    #[test]\n    fn test_wrong_number_of_type_args() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_ref_t = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        // Try to instantiate with wrong number of type arguments\n        let result = instantiate_type(\u0026type_ref_t, \u0026[type_param], \u0026[number_type, string_type]);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_infer_type_arguments_simple() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let _x_id = interner.intern(\"x\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Function parameter: (value: T)\n        let value_id = interner.intern(\"value\");\n        let func_param = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(value_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        // Argument type: number\n        let arg_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Infer type arguments\n        let result = infer_type_arguments(\u0026[type_param], \u0026[func_param], \u0026[arg_type]);\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 1);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_array() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let values_id = interner.intern(\"values\");\n\n        // Type parameter T\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Function parameter: (values: Array\u003cT\u003e)\n        let func_param = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(values_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Array(Box::new(Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ))),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        // Argument type: Array\u003cstring\u003e\n        let arg_type = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            span,\n        );\n\n        // Infer type arguments\n        let result = infer_type_arguments(\u0026[type_param], \u0026[func_param], \u0026[arg_type]);\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 1);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_check_constraints_pass() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T extends number\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        // Type argument: number (should satisfy constraint)\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = check_type_constraints(\u0026[type_param], \u0026[number_type]);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_constraints_fail() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        // Type parameter T extends number\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        // Type argument: string (should NOT satisfy constraint)\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = check_type_constraints(\u0026[type_param], \u0026[string_type]);\n        assert!(result.is_err());\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Tests\n    // ========================================================================\n\n    #[test]\n    fn test_build_substitutions_success() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result =\n            build_substitutions(\u0026[type_param_t, type_param_u], \u0026[number_type, string_type]);\n        assert!(result.is_ok());\n\n        let substitutions = result.unwrap();\n        assert_eq!(substitutions.len(), 2);\n        assert!(substitutions.contains_key(\u0026t_id));\n        assert!(substitutions.contains_key(\u0026u_id));\n    }\n\n    #[test]\n    fn test_build_substitutions_wrong_count() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Provide wrong number of type arguments\n        let result = build_substitutions(std::slice::from_ref(\u0026type_param), \u0026[]);\n        assert!(result.is_err());\n\n        let result = build_substitutions(\u0026[type_param], \u0026[number_type.clone(), number_type]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_instantiate_tuple_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Tuple\u003cT, U\u003e\n        let tuple_type = Type::new(\n            TypeKind::Tuple(vec![\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(u_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n            ]),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\n            \u0026tuple_type,\n            \u0026[type_param_t, type_param_u],\n            \u0026[number_type, string_type],\n        )\n        .unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Tuple(elems) =\u003e {\n                assert_eq!(elems.len(), 2);\n                assert!(matches!(\n                    elems[0].kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n                assert!(matches!(\n                    elems[1].kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected tuple type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_union_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Union\u003cT, nil\u003e\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), span),\n            ]),\n            span,\n        );\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\u0026union_type, \u0026[type_param], \u0026[string_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Union(members) =\u003e {\n                assert_eq!(members.len(), 2);\n                assert!(matches!(\n                    members[0].kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n                assert!(matches!(\n                    members[1].kind,\n                    TypeKind::Primitive(PrimitiveType::Nil)\n                ));\n            }\n            _ =\u003e panic!(\"Expected union type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_function_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let param_id = interner.intern(\"x\");\n        let func_type = Type::new(\n            TypeKind::Function(typedlua_parser::ast::types::FunctionType {\n                type_parameters: None,\n                parameters: vec![Parameter {\n                    pattern: Pattern::Identifier(Spanned::new(param_id, span)),\n                    type_annotation: Some(Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: Spanned::new(t_id, span),\n                            type_arguments: None,\n                            span,\n                        }),\n                        span,\n                    )),\n                    default: None,\n                    is_rest: false,\n                    is_optional: false,\n                    span,\n                }],\n                return_type: Box::new(Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                )),\n                throws: None,\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026func_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Function(func) =\u003e {\n                assert_eq!(func.parameters.len(), 1);\n                assert!(func.type_parameters.is_none());\n                // Parameter type should be number\n                assert!(func.parameters[0].type_annotation.is_some());\n                assert!(matches!(\n                    func.parameters[0].type_annotation.as_ref().unwrap().kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n                // Return type should be number\n                assert!(matches!(\n                    func.return_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n            }\n            _ =\u003e panic!(\"Expected function type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_nullable_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Nullable\u003cT\u003e\n        let nullable_type = Type::new(\n            TypeKind::Nullable(Box::new(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            ))),\n            span,\n        );\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\u0026nullable_type, \u0026[type_param], \u0026[string_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Nullable(inner) =\u003e {\n                assert!(matches!(\n                    inner.kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected nullable type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_nested_generic() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Array\u003cArray\u003cT\u003e\u003e\n        let nested_array = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Array(Box::new(Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ))),\n                span,\n            ))),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026nested_array, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Array(outer) =\u003e match \u0026outer.kind {\n                TypeKind::Array(inner) =\u003e {\n                    assert!(matches!(\n                        inner.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                }\n                _ =\u003e panic!(\"Expected nested array\"),\n            },\n            _ =\u003e panic!(\"Expected array type\"),\n        }\n    }\n\n    #[test]\n    fn test_infer_type_arguments_multiple_params() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Function parameters: (a: T, b: U)\n        let a_id = interner.intern(\"a\");\n        let b_id = interner.intern(\"b\");\n\n        let param_a = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(a_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let param_b = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(b_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(u_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = infer_type_arguments(\n            \u0026[type_param_t, type_param_u],\n            \u0026[param_a, param_b],\n            \u0026[number_type, string_type],\n        );\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 2);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n        assert!(matches!(\n            inferred[1].kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_with_default() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Type parameter U with default: string\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            span,\n        };\n\n        // Only one function parameter using T\n        let a_id = interner.intern(\"a\");\n        let param_a = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(a_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Infer with only one argument - U should use default\n        let result =\n            infer_type_arguments(\u0026[type_param_t, type_param_u], \u0026[param_a], \u0026[number_type]);\n\n        assert!(result.is_ok());\n        let inferred = result.unwrap();\n        assert_eq!(inferred.len(), 2);\n        assert!(matches!(\n            inferred[0].kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n        assert!(matches!(\n            inferred[1].kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_wrong_arg_count() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let a_id = interner.intern(\"a\");\n        let param_a = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(a_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        // Wrong number of arguments\n        let result = infer_type_arguments(\n            std::slice::from_ref(\u0026type_param),\n            std::slice::from_ref(\u0026param_a),\n            \u0026[],\n        );\n        assert!(result.is_err());\n\n        let result = infer_type_arguments(\n            \u0026[type_param],\n            \u0026[param_a],\n            \u0026[number_type.clone(), number_type],\n        );\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_instantiate_block_empty() {\n        let span = Span::new(0, 0, 0, 0);\n        let block = typedlua_parser::ast::statement::Block {\n            statements: vec![],\n            span,\n        };\n\n        let substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        let result = instantiate_block(\u0026block, \u0026substitutions);\n\n        assert!(result.statements.is_empty());\n    }\n\n    #[test]\n    fn test_instantiate_expression_literal() {\n        let span = Span::new(0, 0, 0, 0);\n        let expr = typedlua_parser::ast::expression::Expression {\n            kind: typedlua_parser::ast::expression::ExpressionKind::Literal(\n                typedlua_parser::ast::expression::Literal::Number(42.0),\n            ),\n            span,\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        let result = instantiate_expression(\u0026expr, \u0026substitutions);\n\n        assert!(matches!(\n            result.kind,\n            typedlua_parser::ast::expression::ExpressionKind::Literal(\n                typedlua_parser::ast::expression::Literal::Number(42.0)\n            )\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_parameter_with_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        use typedlua_parser::ast::pattern::Pattern;\n\n        let x_id = interner.intern(\"x\");\n        let param = typedlua_parser::ast::statement::Parameter {\n            pattern: Pattern::Identifier(Spanned::new(x_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let mut substitutions: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        substitutions.insert(t_id, number_type);\n\n        let result = instantiate_parameter(\u0026param, \u0026substitutions);\n\n        assert!(result.type_annotation.is_some());\n        assert!(matches!(\n            result.type_annotation.unwrap().kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_instantiate_parenthesized_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Parenthesized\u003cT\u003e\n        let parenthesized_type = Type::new(\n            TypeKind::Parenthesized(Box::new(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            ))),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026parenthesized_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Parenthesized(inner) =\u003e {\n                assert!(matches!(\n                    inner.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n            }\n            _ =\u003e panic!(\"Expected parenthesized type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_intersection_type() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Intersection\u003cT, U\u003e\n        let intersection_type = Type::new(\n            TypeKind::Intersection(vec![\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(t_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n                Type::new(\n                    TypeKind::Reference(TypeReference {\n                        name: Spanned::new(u_id, span),\n                        type_arguments: None,\n                        span,\n                    }),\n                    span,\n                ),\n            ]),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = instantiate_type(\n            \u0026intersection_type,\n            \u0026[type_param_t, type_param_u],\n            \u0026[number_type, string_type],\n        )\n        .unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Intersection(members) =\u003e {\n                assert_eq!(members.len(), 2);\n                assert!(matches!(\n                    members[0].kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                ));\n                assert!(matches!(\n                    members[1].kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                ));\n            }\n            _ =\u003e panic!(\"Expected intersection type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_object_type_with_property() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let value_id = interner.intern(\"value\");\n\n        let obj_type = Type::new(\n            TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                members: vec![typedlua_parser::ast::types::ObjectTypeMember::Property(\n                    typedlua_parser::ast::statement::PropertySignature {\n                        name: Spanned::new(value_id, span),\n                        type_annotation: Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: Spanned::new(t_id, span),\n                                type_arguments: None,\n                                span,\n                            }),\n                            span,\n                        ),\n                        is_readonly: false,\n                        is_optional: false,\n                        span,\n                    },\n                )],\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026obj_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Object(obj) =\u003e {\n                assert_eq!(obj.members.len(), 1);\n                if let typedlua_parser::ast::types::ObjectTypeMember::Property(prop) =\n                    \u0026obj.members[0]\n                {\n                    assert!(matches!(\n                        prop.type_annotation.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                } else {\n                    panic!(\"Expected property member\");\n                }\n            }\n            _ =\u003e panic!(\"Expected object type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_object_type_with_method() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let method_id = interner.intern(\"getValue\");\n\n        let obj_type = Type::new(\n            TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                members: vec![typedlua_parser::ast::types::ObjectTypeMember::Method(\n                    typedlua_parser::ast::statement::MethodSignature {\n                        name: Spanned::new(method_id, span),\n                        type_parameters: None,\n                        parameters: vec![],\n                        return_type: Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: Spanned::new(t_id, span),\n                                type_arguments: None,\n                                span,\n                            }),\n                            span,\n                        ),\n                        body: None,\n                        span,\n                    },\n                )],\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026obj_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Object(obj) =\u003e {\n                assert_eq!(obj.members.len(), 1);\n                if let typedlua_parser::ast::types::ObjectTypeMember::Method(method) =\n                    \u0026obj.members[0]\n                {\n                    assert!(matches!(\n                        method.return_type.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                } else {\n                    panic!(\"Expected method member\");\n                }\n            }\n            _ =\u003e panic!(\"Expected object type\"),\n        }\n    }\n\n    #[test]\n    fn test_instantiate_object_type_with_index_signature() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let key_id = interner.intern(\"key\");\n\n        let obj_type = Type::new(\n            TypeKind::Object(typedlua_parser::ast::types::ObjectType {\n                members: vec![typedlua_parser::ast::types::ObjectTypeMember::Index(\n                    typedlua_parser::ast::statement::IndexSignature {\n                        key_name: Spanned::new(key_id, span),\n                        key_type: typedlua_parser::ast::statement::IndexKeyType::String,\n                        value_type: Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: Spanned::new(t_id, span),\n                                type_arguments: None,\n                                span,\n                            }),\n                            span,\n                        ),\n                        span,\n                    },\n                )],\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026obj_type, \u0026[type_param], \u0026[number_type]).unwrap();\n\n        match \u0026result.kind {\n            TypeKind::Object(obj) =\u003e {\n                assert_eq!(obj.members.len(), 1);\n                if let typedlua_parser::ast::types::ObjectTypeMember::Index(idx) = \u0026obj.members[0] {\n                    assert!(matches!(\n                        idx.value_type.kind,\n                        TypeKind::Primitive(PrimitiveType::Number)\n                    ));\n                } else {\n                    panic!(\"Expected index member\");\n                }\n            }\n            _ =\u003e panic!(\"Expected object type\"),\n        }\n    }\n\n    #[test]\n    fn test_substitute_type_with_type_args_error() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        // Type reference T with type arguments (should error)\n        let type_ref_with_args = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: Some(vec![Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    span,\n                )]),\n                span,\n            }),\n            span,\n        );\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026type_ref_with_args, \u0026[type_param], \u0026[number_type]);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_instantiate_type_primitive() {\n        let span = Span::new(0, 0, 0, 0);\n\n        let primitive_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n\n        let result = instantiate_type(\u0026primitive_type, \u0026[], \u0026[]);\n\n        assert!(result.is_ok());\n        assert!(matches!(\n            result.unwrap().kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_check_type_constraints_with_multiple_params() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result =\n            check_type_constraints(\u0026[type_param_t, type_param_u], \u0026[number_type, string_type]);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_check_type_constraints_second_param_fails() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let u_id = interner.intern(\"U\");\n\n        let type_param_t = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let type_param_u = TypeParameter {\n            name: Spanned::new(u_id, span),\n            constraint: Some(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                span,\n            ))),\n            default: None,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let boolean_type = Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span);\n\n        let result =\n            check_type_constraints(\u0026[type_param_t, type_param_u], \u0026[number_type, boolean_type]);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_infer_from_types_array_mismatch() {\n        let span = Span::new(0, 0, 0, 0);\n\n        let param_type = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                span,\n            ))),\n            span,\n        );\n\n        let arg_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let mut inferred: FxHashMap\u003cStringId, Type\u003e = FxHashMap::default();\n        let result = infer_from_types(\u0026param_type, \u0026arg_type, \u0026mut inferred);\n\n        assert!(result.is_ok());\n        assert!(inferred.is_empty());\n    }\n\n    #[test]\n    fn test_types_equal_primitives() {\n        let span = Span::new(0, 0, 0, 0);\n\n        let num1 = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let num2 = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let str_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        assert!(types_equal(\u0026num1, \u0026num2));\n        assert!(!types_equal(\u0026num1, \u0026str_type));\n    }\n\n    #[test]\n    fn test_types_equal_references() {\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n\n        let ref1 = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n        let ref2 = Type::new(\n            TypeKind::Reference(TypeReference {\n                name: Spanned::new(t_id, span),\n                type_arguments: None,\n                span,\n            }),\n            span,\n        );\n\n        assert!(types_equal(\u0026ref1, \u0026ref2));\n    }\n\n    #[test]\n    fn test_infer_type_arguments_conflict() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n\n        let span = Span::new(0, 0, 0, 0);\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let t_id = interner.intern(\"T\");\n        let x_id = interner.intern(\"x\");\n\n        let type_param = TypeParameter {\n            name: Spanned::new(t_id, span),\n            constraint: None,\n            default: None,\n            span,\n        };\n\n        let param = Parameter {\n            pattern: Pattern::Identifier(Spanned::new(x_id, span)),\n            type_annotation: Some(Type::new(\n                TypeKind::Reference(TypeReference {\n                    name: Spanned::new(t_id, span),\n                    type_arguments: None,\n                    span,\n                }),\n                span,\n            )),\n            default: None,\n            is_rest: false,\n            is_optional: false,\n            span,\n        };\n\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), span);\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), span);\n\n        let result = infer_type_arguments(\u0026[type_param], \u0026[param], \u0026[number_type, string_type]);\n        assert!(result.is_err());\n    }\n}\n","traces":[{"line":10,"address":[],"length":0,"stats":{"Line":31}},{"line":15,"address":[],"length":0,"stats":{"Line":93}},{"line":16,"address":[],"length":0,"stats":{"Line":2}},{"line":17,"address":[],"length":0,"stats":{"Line":2}},{"line":18,"address":[],"length":0,"stats":{"Line":3}},{"line":19,"address":[],"length":0,"stats":{"Line":1}},{"line":24,"address":[],"length":0,"stats":{"Line":90}},{"line":25,"address":[],"length":0,"stats":{"Line":258}},{"line":26,"address":[],"length":0,"stats":{"Line":144}},{"line":29,"address":[],"length":0,"stats":{"Line":90}},{"line":33,"address":[],"length":0,"stats":{"Line":66}},{"line":34,"address":[],"length":0,"stats":{"Line":66}},{"line":36,"address":[],"length":0,"stats":{"Line":34}},{"line":37,"address":[],"length":0,"stats":{"Line":68}},{"line":40,"address":[],"length":0,"stats":{"Line":101}},{"line":42,"address":[],"length":0,"stats":{"Line":34}},{"line":45,"address":[],"length":0,"stats":{"Line":1}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":1}},{"line":52,"address":[],"length":0,"stats":{"Line":32}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":56,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":67,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[],"length":0,"stats":{"Line":4}},{"line":77,"address":[],"length":0,"stats":{"Line":16}},{"line":78,"address":[],"length":0,"stats":{"Line":8}},{"line":79,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":6}},{"line":88,"address":[],"length":0,"stats":{"Line":14}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":2}},{"line":96,"address":[],"length":0,"stats":{"Line":6}},{"line":98,"address":[],"length":0,"stats":{"Line":14}},{"line":101,"address":[],"length":0,"stats":{"Line":6}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[],"length":0,"stats":{"Line":3}},{"line":108,"address":[],"length":0,"stats":{"Line":7}},{"line":111,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":1}},{"line":113,"address":[],"length":0,"stats":{"Line":1}},{"line":118,"address":[],"length":0,"stats":{"Line":2}},{"line":121,"address":[],"length":0,"stats":{"Line":6}},{"line":122,"address":[],"length":0,"stats":{"Line":2}},{"line":124,"address":[],"length":0,"stats":{"Line":4}},{"line":125,"address":[],"length":0,"stats":{"Line":4}},{"line":126,"address":[],"length":0,"stats":{"Line":8}},{"line":127,"address":[],"length":0,"stats":{"Line":2}},{"line":128,"address":[],"length":0,"stats":{"Line":6}},{"line":129,"address":[],"length":0,"stats":{"Line":4}},{"line":130,"address":[],"length":0,"stats":{"Line":6}},{"line":131,"address":[],"length":0,"stats":{"Line":4}},{"line":132,"address":[],"length":0,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":2}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":8}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":2}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":147,"address":[],"length":0,"stats":{"Line":4}},{"line":148,"address":[],"length":0,"stats":{"Line":4}},{"line":149,"address":[],"length":0,"stats":{"Line":2}},{"line":151,"address":[],"length":0,"stats":{"Line":2}},{"line":156,"address":[],"length":0,"stats":{"Line":1}},{"line":157,"address":[],"length":0,"stats":{"Line":4}},{"line":158,"address":[],"length":0,"stats":{"Line":2}},{"line":159,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":1}},{"line":166,"address":[],"length":0,"stats":{"Line":4}},{"line":167,"address":[],"length":0,"stats":{"Line":2}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":11}},{"line":178,"address":[],"length":0,"stats":{"Line":33}},{"line":179,"address":[],"length":0,"stats":{"Line":39}},{"line":180,"address":[],"length":0,"stats":{"Line":28}},{"line":181,"address":[],"length":0,"stats":{"Line":12}},{"line":182,"address":[],"length":0,"stats":{"Line":12}},{"line":183,"address":[],"length":0,"stats":{"Line":36}},{"line":184,"address":[],"length":0,"stats":{"Line":12}},{"line":185,"address":[],"length":0,"stats":{"Line":24}},{"line":186,"address":[],"length":0,"stats":{"Line":12}},{"line":189,"address":[],"length":0,"stats":{"Line":1}},{"line":192,"address":[],"length":0,"stats":{"Line":1}},{"line":193,"address":[],"length":0,"stats":{"Line":3}},{"line":195,"address":[],"length":0,"stats":{"Line":1}},{"line":196,"address":[],"length":0,"stats":{"Line":2}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":203,"address":[],"length":0,"stats":{"Line":4}},{"line":205,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":2}},{"line":207,"address":[],"length":0,"stats":{"Line":1}},{"line":211,"address":[],"length":0,"stats":{"Line":42}},{"line":214,"address":[],"length":0,"stats":{"Line":22}},{"line":215,"address":[],"length":0,"stats":{"Line":11}},{"line":216,"address":[],"length":0,"stats":{"Line":22}},{"line":217,"address":[],"length":0,"stats":{"Line":11}},{"line":219,"address":[],"length":0,"stats":{"Line":11}},{"line":225,"address":[],"length":0,"stats":{"Line":8}},{"line":230,"address":[],"length":0,"stats":{"Line":4}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":32}},{"line":243,"address":[],"length":0,"stats":{"Line":12}},{"line":247,"address":[],"length":0,"stats":{"Line":12}},{"line":248,"address":[],"length":0,"stats":{"Line":2}},{"line":249,"address":[],"length":0,"stats":{"Line":2}},{"line":250,"address":[],"length":0,"stats":{"Line":2}},{"line":256,"address":[],"length":0,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":6}},{"line":263,"address":[],"length":0,"stats":{"Line":18}},{"line":268,"address":[],"length":0,"stats":{"Line":12}},{"line":273,"address":[],"length":0,"stats":{"Line":36}},{"line":274,"address":[],"length":0,"stats":{"Line":6}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":276,"address":[],"length":0,"stats":{"Line":9}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":281,"address":[],"length":0,"stats":{"Line":27}},{"line":284,"address":[],"length":0,"stats":{"Line":67}},{"line":285,"address":[],"length":0,"stats":{"Line":22}},{"line":286,"address":[],"length":0,"stats":{"Line":44}},{"line":291,"address":[],"length":0,"stats":{"Line":9}},{"line":293,"address":[],"length":0,"stats":{"Line":21}},{"line":294,"address":[],"length":0,"stats":{"Line":12}},{"line":295,"address":[],"length":0,"stats":{"Line":24}},{"line":296,"address":[],"length":0,"stats":{"Line":12}},{"line":297,"address":[],"length":0,"stats":{"Line":17}},{"line":298,"address":[],"length":0,"stats":{"Line":12}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":300,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":13}},{"line":314,"address":[],"length":0,"stats":{"Line":0}},{"line":316,"address":[],"length":0,"stats":{"Line":44}},{"line":318,"address":[],"length":0,"stats":{"Line":22}},{"line":321,"address":[],"length":0,"stats":{"Line":22}},{"line":323,"address":[],"length":0,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[],"length":0,"stats":{"Line":44}},{"line":332,"address":[],"length":0,"stats":{"Line":11}},{"line":336,"address":[],"length":0,"stats":{"Line":2}},{"line":337,"address":[],"length":0,"stats":{"Line":3}},{"line":338,"address":[],"length":0,"stats":{"Line":4}},{"line":340,"address":[],"length":0,"stats":{"Line":1}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":349,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":353,"address":[],"length":0,"stats":{"Line":0}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":368,"address":[],"length":0,"stats":{"Line":3}},{"line":370,"address":[],"length":0,"stats":{"Line":6}},{"line":371,"address":[],"length":0,"stats":{"Line":6}},{"line":372,"address":[],"length":0,"stats":{"Line":3}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":3}},{"line":386,"address":[],"length":0,"stats":{"Line":9}},{"line":387,"address":[],"length":0,"stats":{"Line":4}},{"line":388,"address":[],"length":0,"stats":{"Line":4}},{"line":389,"address":[],"length":0,"stats":{"Line":6}},{"line":390,"address":[],"length":0,"stats":{"Line":2}},{"line":394,"address":[],"length":0,"stats":{"Line":3}},{"line":395,"address":[],"length":0,"stats":{"Line":11}},{"line":396,"address":[],"length":0,"stats":{"Line":8}},{"line":398,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":1}},{"line":410,"address":[],"length":0,"stats":{"Line":1}},{"line":415,"address":[],"length":0,"stats":{"Line":1}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":430,"address":[],"length":0,"stats":{"Line":0}},{"line":431,"address":[],"length":0,"stats":{"Line":0}},{"line":432,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":434,"address":[],"length":0,"stats":{"Line":0}},{"line":435,"address":[],"length":0,"stats":{"Line":0}},{"line":436,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":441,"address":[],"length":0,"stats":{"Line":0}},{"line":442,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":446,"address":[],"length":0,"stats":{"Line":0}},{"line":449,"address":[],"length":0,"stats":{"Line":0}},{"line":450,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":0}},{"line":452,"address":[],"length":0,"stats":{"Line":0}},{"line":453,"address":[],"length":0,"stats":{"Line":0}},{"line":454,"address":[],"length":0,"stats":{"Line":0}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":461,"address":[],"length":0,"stats":{"Line":0}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":463,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":470,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":0}},{"line":472,"address":[],"length":0,"stats":{"Line":0}},{"line":473,"address":[],"length":0,"stats":{"Line":0}},{"line":474,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":480,"address":[],"length":0,"stats":{"Line":0}},{"line":483,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":0}},{"line":485,"address":[],"length":0,"stats":{"Line":0}},{"line":486,"address":[],"length":0,"stats":{"Line":0}},{"line":487,"address":[],"length":0,"stats":{"Line":0}},{"line":488,"address":[],"length":0,"stats":{"Line":0}},{"line":489,"address":[],"length":0,"stats":{"Line":0}},{"line":490,"address":[],"length":0,"stats":{"Line":0}},{"line":491,"address":[],"length":0,"stats":{"Line":0}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":495,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":0}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":498,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":502,"address":[],"length":0,"stats":{"Line":0}},{"line":503,"address":[],"length":0,"stats":{"Line":0}},{"line":507,"address":[],"length":0,"stats":{"Line":0}},{"line":508,"address":[],"length":0,"stats":{"Line":0}},{"line":509,"address":[],"length":0,"stats":{"Line":0}},{"line":510,"address":[],"length":0,"stats":{"Line":0}},{"line":513,"address":[],"length":0,"stats":{"Line":0}},{"line":515,"address":[],"length":0,"stats":{"Line":0}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":526,"address":[],"length":0,"stats":{"Line":0}},{"line":527,"address":[],"length":0,"stats":{"Line":0}},{"line":528,"address":[],"length":0,"stats":{"Line":0}},{"line":529,"address":[],"length":0,"stats":{"Line":0}},{"line":530,"address":[],"length":0,"stats":{"Line":0}},{"line":531,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":0}},{"line":533,"address":[],"length":0,"stats":{"Line":0}},{"line":534,"address":[],"length":0,"stats":{"Line":0}},{"line":535,"address":[],"length":0,"stats":{"Line":0}},{"line":536,"address":[],"length":0,"stats":{"Line":0}},{"line":537,"address":[],"length":0,"stats":{"Line":0}},{"line":538,"address":[],"length":0,"stats":{"Line":0}},{"line":543,"address":[],"length":0,"stats":{"Line":0}},{"line":548,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":0}},{"line":555,"address":[],"length":0,"stats":{"Line":0}},{"line":559,"address":[],"length":0,"stats":{"Line":0}},{"line":560,"address":[],"length":0,"stats":{"Line":0}},{"line":561,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":1}},{"line":571,"address":[],"length":0,"stats":{"Line":2}},{"line":572,"address":[],"length":0,"stats":{"Line":1}},{"line":576,"address":[],"length":0,"stats":{"Line":1}},{"line":580,"address":[],"length":0,"stats":{"Line":1}},{"line":581,"address":[],"length":0,"stats":{"Line":1}},{"line":582,"address":[],"length":0,"stats":{"Line":1}},{"line":587,"address":[],"length":0,"stats":{"Line":1}},{"line":593,"address":[],"length":0,"stats":{"Line":2}},{"line":594,"address":[],"length":0,"stats":{"Line":2}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":598,"address":[],"length":0,"stats":{"Line":0}},{"line":599,"address":[],"length":0,"stats":{"Line":0}},{"line":600,"address":[],"length":0,"stats":{"Line":0}},{"line":604,"address":[],"length":0,"stats":{"Line":0}},{"line":605,"address":[],"length":0,"stats":{"Line":0}},{"line":609,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":0}},{"line":611,"address":[],"length":0,"stats":{"Line":0}},{"line":615,"address":[],"length":0,"stats":{"Line":0}},{"line":616,"address":[],"length":0,"stats":{"Line":0}},{"line":617,"address":[],"length":0,"stats":{"Line":0}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":619,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":0}},{"line":621,"address":[],"length":0,"stats":{"Line":0}},{"line":622,"address":[],"length":0,"stats":{"Line":0}},{"line":627,"address":[],"length":0,"stats":{"Line":0}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":629,"address":[],"length":0,"stats":{"Line":0}},{"line":630,"address":[],"length":0,"stats":{"Line":0}},{"line":631,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":0}},{"line":633,"address":[],"length":0,"stats":{"Line":0}},{"line":634,"address":[],"length":0,"stats":{"Line":0}},{"line":635,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":0}},{"line":641,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":646,"address":[],"length":0,"stats":{"Line":0}},{"line":650,"address":[],"length":0,"stats":{"Line":0}},{"line":651,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":0}},{"line":653,"address":[],"length":0,"stats":{"Line":0}},{"line":657,"address":[],"length":0,"stats":{"Line":0}},{"line":658,"address":[],"length":0,"stats":{"Line":0}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":660,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":667,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":672,"address":[],"length":0,"stats":{"Line":0}},{"line":673,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":691,"address":[],"length":0,"stats":{"Line":0}},{"line":692,"address":[],"length":0,"stats":{"Line":0}},{"line":696,"address":[],"length":0,"stats":{"Line":0}},{"line":697,"address":[],"length":0,"stats":{"Line":0}},{"line":701,"address":[],"length":0,"stats":{"Line":0}},{"line":702,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":707,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":710,"address":[],"length":0,"stats":{"Line":0}},{"line":711,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":713,"address":[],"length":0,"stats":{"Line":0}},{"line":717,"address":[],"length":0,"stats":{"Line":0}},{"line":719,"address":[],"length":0,"stats":{"Line":0}},{"line":720,"address":[],"length":0,"stats":{"Line":0}},{"line":721,"address":[],"length":0,"stats":{"Line":0}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":723,"address":[],"length":0,"stats":{"Line":0}},{"line":724,"address":[],"length":0,"stats":{"Line":0}},{"line":725,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":0}},{"line":727,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":0}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":0}},{"line":754,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":759,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":1}},{"line":765,"address":[],"length":0,"stats":{"Line":1}},{"line":769,"address":[],"length":0,"stats":{"Line":2}},{"line":774,"address":[],"length":0,"stats":{"Line":0}},{"line":779,"address":[],"length":0,"stats":{"Line":0}},{"line":780,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":786,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":792,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":795,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":807,"address":[],"length":0,"stats":{"Line":0}},{"line":808,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":813,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":818,"address":[],"length":0,"stats":{"Line":0}},{"line":824,"address":[],"length":0,"stats":{"Line":0}},{"line":830,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":860,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":877,"address":[],"length":0,"stats":{"Line":0}},{"line":887,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":898,"address":[],"length":0,"stats":{"Line":0}},{"line":899,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":935,"address":[],"length":0,"stats":{"Line":0}}],"covered":175,"coverable":425},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","types","mod.rs"],"content":"pub mod generics;\npub mod utility_types;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","types","utility_types.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::expression::Literal;\nuse typedlua_parser::ast::statement::{IndexKeyType, PropertySignature};\nuse typedlua_parser::ast::types::{\n    MappedType, MappedTypeModifier, ObjectType, ObjectTypeMember, PrimitiveType, Type, TypeKind,\n};\nuse typedlua_parser::ast::Ident;\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\nuse crate::core::type_environment::TypeEnvironment;\n\n/// Apply a utility type transformation\npub fn apply_utility_type(\n    name: \u0026str,\n    type_args: \u0026[Type],\n    span: Span,\n    interner: \u0026StringInterner,\n    common_ids: \u0026typedlua_parser::string_interner::CommonIdentifiers,\n) -\u003e Result\u003cType, String\u003e {\n    match name {\n        \"Partial\" =\u003e partial(type_args, span),\n        \"Required\" =\u003e required(type_args, span),\n        \"Readonly\" =\u003e readonly(type_args, span),\n        \"Record\" =\u003e record(type_args, span, interner, common_ids),\n        \"Pick\" =\u003e pick(type_args, span, interner),\n        \"Omit\" =\u003e omit(type_args, span, interner),\n        \"Exclude\" =\u003e exclude(type_args, span),\n        \"Extract\" =\u003e extract(type_args, span),\n        \"NonNilable\" =\u003e non_nilable(type_args, span),\n        \"Nilable\" =\u003e nilable(type_args, span),\n        \"ReturnType\" =\u003e return_type(type_args, span),\n        \"Parameters\" =\u003e parameters(type_args, span),\n        _ =\u003e Err(format!(\"Unknown utility type: {}\", name)),\n    }\n}\n\n/// Partial\u003cT\u003e - Makes all properties in T optional\nfn partial(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Partial\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            let new_members = obj\n                .members\n                .iter()\n                .map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                is_readonly: prop.is_readonly,\n                                name: prop.name.clone(),\n                                is_optional: true, // Make optional\n                                type_annotation: prop.type_annotation.clone(),\n                                span: prop.span,\n                            })\n                        }\n                        // Methods and index signatures remain unchanged\n                        other =\u003e other.clone(),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Partial\u003cT\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Required\u003cT\u003e - Makes all properties in T required (non-optional)\nfn required(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Required\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            let new_members = obj\n                .members\n                .iter()\n                .map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                is_readonly: prop.is_readonly,\n                                name: prop.name.clone(),\n                                is_optional: false, // Make required\n                                type_annotation: prop.type_annotation.clone(),\n                                span: prop.span,\n                            })\n                        }\n                        other =\u003e other.clone(),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Required\u003cT\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Readonly\u003cT\u003e - Makes all properties in T readonly\nfn readonly(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Readonly\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            let new_members = obj\n                .members\n                .iter()\n                .map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            ObjectTypeMember::Property(PropertySignature {\n                                is_readonly: true, // Make readonly\n                                name: prop.name.clone(),\n                                is_optional: prop.is_optional,\n                                type_annotation: prop.type_annotation.clone(),\n                                span: prop.span,\n                            })\n                        }\n                        other =\u003e other.clone(),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        TypeKind::Array(_) =\u003e {\n            // For arrays, we can wrap in a readonly wrapper\n            // but for now, just return the same array (Lua doesn't enforce readonly)\n            Ok(typ.clone())\n        }\n        _ =\u003e Err(\"Readonly\u003cT\u003e requires T to be an object or array type\".to_string()),\n    }\n}\n\n/// Record\u003cK, V\u003e - Constructs an object type with keys of type K and values of type V\nfn record(\n    type_args: \u0026[Type],\n    span: Span,\n    _interner: \u0026StringInterner,\n    common_ids: \u0026typedlua_parser::string_interner::CommonIdentifiers,\n) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Record\u003cK, V\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let key_type = \u0026type_args[0];\n    let value_type = \u0026type_args[1];\n\n    // Validate key type is string or number and determine IndexKeyType\n    let index_key_type = match \u0026key_type.kind {\n        TypeKind::Primitive(PrimitiveType::String) | TypeKind::Literal(Literal::String(_)) =\u003e {\n            IndexKeyType::String\n        }\n        TypeKind::Primitive(PrimitiveType::Number)\n        | TypeKind::Primitive(PrimitiveType::Integer)\n        | TypeKind::Literal(Literal::Number(_)) =\u003e IndexKeyType::Number,\n        TypeKind::Union(types) =\u003e {\n            // Check if all union members are string literals\n            if types\n                .iter()\n                .all(|t| matches!(t.kind, TypeKind::Literal(Literal::String(_))))\n            {\n                IndexKeyType::String\n            } else {\n                return Err(\n                    \"Record\u003cK, V\u003e requires K to be string, number, or a union of string literals\"\n                        .to_string(),\n                );\n            }\n        }\n        _ =\u003e {\n            return Err(\n                \"Record\u003cK, V\u003e requires K to be string, number, or a union of string literals\"\n                    .to_string(),\n            )\n        }\n    };\n\n    // Create an object type with an index signature\n    use typedlua_parser::ast::statement::IndexSignature;\n    use typedlua_parser::ast::Ident;\n\n    let key_id = common_ids.key;\n    let index_sig = IndexSignature {\n        key_name: Ident::new(key_id, span),\n        key_type: index_key_type,\n        value_type: value_type.clone(),\n        span,\n    };\n\n    Ok(Type::new(\n        TypeKind::Object(ObjectType {\n            members: vec![ObjectTypeMember::Index(index_sig)],\n            span,\n        }),\n        span,\n    ))\n}\n\n/// Pick\u003cT, K\u003e - Picks a subset of properties from T\nfn pick(type_args: \u0026[Type], span: Span, interner: \u0026StringInterner) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Pick\u003cT, K\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let keys = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            // Extract the property names to pick\n            let keys_to_pick = extract_string_literal_keys(keys)?;\n\n            let new_members: Vec\u003cObjectTypeMember\u003e = obj\n                .members\n                .iter()\n                .filter_map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            // Use interner to resolve StringId to actual string value\n                            let prop_name = interner.resolve(prop.name.node);\n                            if keys_to_pick.contains(\u0026prop_name) {\n                                Some(member.clone())\n                            } else {\n                                None\n                            }\n                        }\n                        // Don't pick methods or index signatures\n                        _ =\u003e None,\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Pick\u003cT, K\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Omit\u003cT, K\u003e - Omits properties from T\nfn omit(type_args: \u0026[Type], span: Span, interner: \u0026StringInterner) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Omit\u003cT, K\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let keys = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Object(obj) =\u003e {\n            // Extract the property names to omit\n            let keys_to_omit = extract_string_literal_keys(keys)?;\n\n            let new_members: Vec\u003cObjectTypeMember\u003e = obj\n                .members\n                .iter()\n                .filter_map(|member| {\n                    match member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            // Use interner to resolve StringId to actual string value\n                            let prop_name = interner.resolve(prop.name.node);\n                            if !keys_to_omit.contains(\u0026prop_name) {\n                                Some(member.clone())\n                            } else {\n                                None\n                            }\n                        }\n                        // Keep methods and index signatures\n                        other =\u003e Some(other.clone()),\n                    }\n                })\n                .collect();\n\n            Ok(Type::new(\n                TypeKind::Object(ObjectType {\n                    members: new_members,\n                    span,\n                }),\n                span,\n            ))\n        }\n        _ =\u003e Err(\"Omit\u003cT, K\u003e requires T to be an object type\".to_string()),\n    }\n}\n\n/// Exclude\u003cT, U\u003e - Excludes types from a union T that are assignable to U\nfn exclude(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Exclude\u003cT, U\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let exclude_type = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let remaining: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !is_assignable_to(t, exclude_type))\n                .cloned()\n                .collect();\n\n            if remaining.is_empty() {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else if remaining.len() == 1 {\n                Ok(remaining[0].clone())\n            } else {\n                Ok(Type::new(TypeKind::Union(remaining), span))\n            }\n        }\n        _ =\u003e {\n            // If T is not a union, check if it's assignable to U\n            if is_assignable_to(typ, exclude_type) {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else {\n                Ok(typ.clone())\n            }\n        }\n    }\n}\n\n/// Extract\u003cT, U\u003e - Extracts types from a union T that are assignable to U\nfn extract(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 2 {\n        return Err(format!(\n            \"Extract\u003cT, U\u003e expects 2 type arguments, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n    let extract_type = \u0026type_args[1];\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let extracted: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| is_assignable_to(t, extract_type))\n                .cloned()\n                .collect();\n\n            if extracted.is_empty() {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else if extracted.len() == 1 {\n                Ok(extracted[0].clone())\n            } else {\n                Ok(Type::new(TypeKind::Union(extracted), span))\n            }\n        }\n        _ =\u003e {\n            // If T is not a union, check if it's assignable to U\n            if is_assignable_to(typ, extract_type) {\n                Ok(typ.clone())\n            } else {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            }\n        }\n    }\n}\n\n/// NonNilable\u003cT\u003e - Removes nil and void from a type\nfn non_nilable(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"NonNilable\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let non_nil: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !is_nil_or_void(t))\n                .cloned()\n                .collect();\n\n            if non_nil.is_empty() {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else if non_nil.len() == 1 {\n                Ok(non_nil[0].clone())\n            } else {\n                Ok(Type::new(TypeKind::Union(non_nil), span))\n            }\n        }\n        TypeKind::Nullable(inner) =\u003e Ok((**inner).clone()),\n        _ =\u003e {\n            if is_nil_or_void(typ) {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n            } else {\n                Ok(typ.clone())\n            }\n        }\n    }\n}\n\n/// Nilable\u003cT\u003e - Adds nil to a type (equivalent to T | nil)\nfn nilable(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Nilable\u003cT\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    // Check if it's already nilable\n    if is_nil_or_void(typ) {\n        return Ok(typ.clone());\n    }\n\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            // Check if nil is already in the union\n            if types.iter().any(is_nil_or_void) {\n                Ok(typ.clone())\n            } else {\n                let mut new_types = types.clone();\n                new_types.push(Type::new(TypeKind::Primitive(PrimitiveType::Nil), span));\n                Ok(Type::new(TypeKind::Union(new_types), span))\n            }\n        }\n        TypeKind::Nullable(_) =\u003e {\n            // Already nullable\n            Ok(typ.clone())\n        }\n        _ =\u003e Ok(Type::new(\n            TypeKind::Union(vec![\n                typ.clone(),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), span),\n            ]),\n            span,\n        )),\n    }\n}\n\n/// ReturnType\u003cF\u003e - Extracts the return type from a function type\nfn return_type(type_args: \u0026[Type], _span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"ReturnType\u003cF\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    match \u0026typ.kind {\n        TypeKind::Function(ref func) =\u003e Ok((*func.return_type).clone()),\n        _ =\u003e Err(\"ReturnType\u003cF\u003e requires F to be a function type\".to_string()),\n    }\n}\n\n/// Parameters\u003cF\u003e - Extracts parameter types from a function as a tuple\nfn parameters(type_args: \u0026[Type], span: Span) -\u003e Result\u003cType, String\u003e {\n    if type_args.len() != 1 {\n        return Err(format!(\n            \"Parameters\u003cF\u003e expects 1 type argument, got {}\",\n            type_args.len()\n        ));\n    }\n\n    let typ = \u0026type_args[0];\n\n    match \u0026typ.kind {\n        TypeKind::Function(ref func) =\u003e {\n            let param_types: Vec\u003cType\u003e = func\n                .parameters\n                .iter()\n                .filter_map(|p| p.type_annotation.clone())\n                .collect();\n\n            Ok(Type::new(TypeKind::Tuple(param_types), span))\n        }\n        _ =\u003e Err(\"Parameters\u003cF\u003e requires F to be a function type\".to_string()),\n    }\n}\n\n/// Evaluate a mapped type: { [K in T]: V }\n/// Transforms the mapped type into a concrete object type\npub fn evaluate_mapped_type(\n    mapped: \u0026MappedType,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, String\u003e {\n    // Resolve the 'in' type if it's a KeyOf expression\n    let in_type_resolved = match \u0026mapped.in_type.kind {\n        TypeKind::KeyOf(operand) =\u003e {\n            // Evaluate keyof to get the union of string literals\n            evaluate_keyof(operand, type_env, interner)?\n        }\n        _ =\u003e (*mapped.in_type).clone(),\n    };\n\n    // Extract the keys from the resolved 'in' clause\n    let keys = extract_keys_from_type(\u0026in_type_resolved, type_env, interner)?;\n\n    let members: Vec\u003c_\u003e = keys\n        .iter()\n        .map(|key| {\n            let key_id = interner.intern(key);\n\n            // Determine readonly status based on modifier\n            let is_readonly = match mapped.readonly_modifier {\n                MappedTypeModifier::Add =\u003e true,\n                MappedTypeModifier::Remove =\u003e false,\n                MappedTypeModifier::None =\u003e false,\n            };\n\n            // Determine optional status based on modifier\n            let is_optional = match mapped.optional_modifier {\n                MappedTypeModifier::Add =\u003e true,\n                MappedTypeModifier::Remove =\u003e false,\n                MappedTypeModifier::None =\u003e false,\n            };\n\n            ObjectTypeMember::Property(PropertySignature {\n                is_readonly,\n                name: Ident::new(key_id, mapped.span),\n                is_optional,\n                type_annotation: (*mapped.value_type).clone(),\n                span: mapped.span,\n            })\n        })\n        .collect();\n\n    Ok(Type::new(\n        TypeKind::Object(ObjectType {\n            members,\n            span: mapped.span,\n        }),\n        mapped.span,\n    ))\n}\n\n/// Evaluate keyof operator - extracts property names from an object type\npub fn evaluate_keyof(\n    typ: \u0026Type,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, String\u003e {\n    // Resolve type reference first\n    let resolved_type = match \u0026typ.kind {\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = interner.resolve(type_ref.name.node);\n            match type_env.lookup_type(\u0026type_name) {\n                Some(t) =\u003e t.clone(),\n                None =\u003e return Err(format!(\"Type '{}' not found\", type_name)),\n            }\n        }\n        _ =\u003e typ.clone(),\n    };\n\n    match \u0026resolved_type.kind {\n        TypeKind::Object(obj) =\u003e {\n            let keys: Vec\u003c_\u003e = obj\n                .members\n                .iter()\n                .filter_map(|member| match member {\n                    ObjectTypeMember::Property(prop) =\u003e Some(Type::new(\n                        TypeKind::Literal(Literal::String(prop.name.node.to_string())),\n                        prop.span,\n                    )),\n                    ObjectTypeMember::Method(method) =\u003e Some(Type::new(\n                        TypeKind::Literal(Literal::String(method.name.node.to_string())),\n                        method.span,\n                    )),\n                    // Index signatures don't contribute to keyof\n                    ObjectTypeMember::Index(_) =\u003e None,\n                })\n                .collect();\n\n            if keys.is_empty() {\n                Ok(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if keys.len() == 1 {\n                Ok(keys.into_iter().next().unwrap())\n            } else {\n                Ok(Type::new(TypeKind::Union(keys), resolved_type.span))\n            }\n        }\n        _ =\u003e Err(format!(\n            \"keyof requires an object type, got {:?}\",\n            resolved_type.kind\n        )),\n    }\n}\n\n/// Evaluate a conditional type: T extends U ? X : Y\n/// Also handles infer keyword: T extends Array\u003cinfer U\u003e ? U : never\npub fn evaluate_conditional_type(\n    conditional: \u0026typedlua_parser::ast::types::ConditionalType,\n    type_env: \u0026TypeEnvironment,\n) -\u003e Result\u003cType, String\u003e {\n    use crate::core::type_compat::TypeCompatibility;\n    use rustc_hash::FxHashMap;\n\n    // Check if check_type extends extends_type\n    let check_type = \u0026conditional.check_type;\n    let extends_type = \u0026conditional.extends_type;\n\n    // Check if extends_type contains infer - if so, we need pattern matching\n    let mut inferred_types: FxHashMap\u003cString, Type\u003e = FxHashMap::default();\n    let has_infer = contains_infer(extends_type);\n\n    if has_infer {\n        // Try to match check_type against extends_type pattern and extract inferred types\n        if try_match_and_infer(check_type, extends_type, \u0026mut inferred_types, type_env) {\n            // Match succeeded - evaluate true branch with inferred types\n            return substitute_inferred_types(\u0026conditional.true_type, \u0026inferred_types);\n        } else {\n            // Match failed - return false branch\n            return Ok((*conditional.false_type).clone());\n        }\n    }\n\n    // Handle distributive conditional types\n    // If check_type is a union, distribute the conditional over each member\n    if let TypeKind::Union(union_types) = \u0026check_type.kind {\n        let result_types: Vec\u003c_\u003e = union_types\n            .iter()\n            .map(|member_type| {\n                // Create a new conditional for each union member\n                let member_conditional = typedlua_parser::ast::types::ConditionalType {\n                    check_type: Box::new(member_type.clone()),\n                    extends_type: conditional.extends_type.clone(),\n                    true_type: conditional.true_type.clone(),\n                    false_type: conditional.false_type.clone(),\n                    span: conditional.span,\n                };\n\n                evaluate_conditional_type(\u0026member_conditional, type_env)\n            })\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()?;\n\n        // If all results are the same, return just one\n        // Otherwise, return a union\n        if result_types.len() == 1 {\n            return Ok(result_types.into_iter().next().unwrap());\n        }\n\n        // Check if all types are the same (simplified check)\n        let all_same = result_types\n            .windows(2)\n            .all(|w| types_structurally_equal(\u0026w[0], \u0026w[1]));\n\n        if all_same {\n            return Ok(result_types.into_iter().next().unwrap());\n        }\n\n        return Ok(Type::new(TypeKind::Union(result_types), conditional.span));\n    }\n\n    // Resolve type references for comparison\n    let resolved_check = resolve_type_reference(check_type, type_env);\n    let resolved_extends = resolve_type_reference(extends_type, type_env);\n\n    // Check assignability: does check_type extend extends_type?\n    if TypeCompatibility::is_assignable(\u0026resolved_check, \u0026resolved_extends) {\n        Ok((*conditional.true_type).clone())\n    } else {\n        Ok((*conditional.false_type).clone())\n    }\n}\n\n/// Helper to resolve type references\nfn resolve_type_reference(typ: \u0026Type, type_env: \u0026TypeEnvironment) -\u003e Type {\n    match \u0026typ.kind {\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = type_ref.name.node.to_string();\n            match type_env.lookup_type(\u0026type_name) {\n                Some(t) =\u003e t.clone(),\n                None =\u003e typ.clone(), // Can't resolve, use as-is\n            }\n        }\n        _ =\u003e typ.clone(),\n    }\n}\n\n/// Helper to check if two types are structurally equal (simplified)\nfn types_structurally_equal(t1: \u0026Type, t2: \u0026Type) -\u003e bool {\n    match (\u0026t1.kind, \u0026t2.kind) {\n        (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) =\u003e p1 == p2,\n        (TypeKind::Literal(l1), TypeKind::Literal(l2)) =\u003e l1 == l2,\n        (TypeKind::Reference(r1), TypeKind::Reference(r2)) =\u003e r1.name.node == r2.name.node,\n        (TypeKind::Array(a1), TypeKind::Array(a2)) =\u003e types_structurally_equal(a1, a2),\n        _ =\u003e false,\n    }\n}\n\n/// Check if a type contains an infer keyword\nfn contains_infer(typ: \u0026Type) -\u003e bool {\n    match \u0026typ.kind {\n        TypeKind::Infer(_) =\u003e true,\n        TypeKind::Array(elem) =\u003e contains_infer(elem),\n        TypeKind::Union(types) | TypeKind::Intersection(types) | TypeKind::Tuple(types) =\u003e {\n            types.iter().any(contains_infer)\n        }\n        TypeKind::Function(func) =\u003e {\n            func.parameters\n                .iter()\n                .any(|p| p.type_annotation.as_ref().is_some_and(contains_infer))\n                || contains_infer(\u0026func.return_type)\n        }\n        TypeKind::Reference(type_ref) =\u003e type_ref\n            .type_arguments\n            .as_ref()\n            .is_some_and(|args| args.iter().any(contains_infer)),\n        _ =\u003e false,\n    }\n}\n\n/// Try to match a check_type against a pattern (extends_type) and extract inferred types\nfn try_match_and_infer(\n    check_type: \u0026Type,\n    pattern: \u0026Type,\n    inferred: \u0026mut FxHashMap\u003cString, Type\u003e,\n    type_env: \u0026TypeEnvironment,\n) -\u003e bool {\n    match \u0026pattern.kind {\n        // If pattern is `infer R`, capture the check_type as R\n        TypeKind::Infer(name) =\u003e {\n            inferred.insert(name.node.to_string(), check_type.clone());\n            true\n        }\n\n        // Array pattern: T[] matches against Array\u003cU\u003e\n        TypeKind::Array(pattern_elem) =\u003e {\n            if let TypeKind::Array(check_elem) = \u0026check_type.kind {\n                try_match_and_infer(check_elem, pattern_elem, inferred, type_env)\n            } else {\n                false\n            }\n        }\n\n        // Type reference with type arguments: Foo\u003cinfer R\u003e\n        TypeKind::Reference(pattern_ref) =\u003e {\n            // Resolve check_type if it's a reference\n            let resolved_check = resolve_type_reference(check_type, type_env);\n\n            if let TypeKind::Reference(check_ref) = \u0026resolved_check.kind {\n                // Names must match\n                if pattern_ref.name.node != check_ref.name.node {\n                    return false;\n                }\n\n                // Match type arguments\n                match (\u0026pattern_ref.type_arguments, \u0026check_ref.type_arguments) {\n                    (Some(pattern_args), Some(check_args)) =\u003e {\n                        if pattern_args.len() != check_args.len() {\n                            return false;\n                        }\n                        pattern_args\n                            .iter()\n                            .zip(check_args.iter())\n                            .all(|(p, c)| try_match_and_infer(c, p, inferred, type_env))\n                    }\n                    (None, None) =\u003e true,\n                    _ =\u003e false,\n                }\n            } else {\n                false\n            }\n        }\n\n        // Function type pattern\n        TypeKind::Function(pattern_func) =\u003e {\n            if let TypeKind::Function(check_func) = \u0026check_type.kind {\n                // Match parameters\n                if pattern_func.parameters.len() != check_func.parameters.len() {\n                    return false;\n                }\n\n                let params_match = pattern_func\n                    .parameters\n                    .iter()\n                    .zip(check_func.parameters.iter())\n                    .all(|(p_param, c_param)| {\n                        match (\u0026p_param.type_annotation, \u0026c_param.type_annotation) {\n                            (Some(p_type), Some(c_type)) =\u003e {\n                                try_match_and_infer(c_type, p_type, inferred, type_env)\n                            }\n                            _ =\u003e true,\n                        }\n                    });\n\n                params_match\n                    \u0026\u0026 try_match_and_infer(\n                        \u0026check_func.return_type,\n                        \u0026pattern_func.return_type,\n                        inferred,\n                        type_env,\n                    )\n            } else {\n                false\n            }\n        }\n\n        // Tuple pattern\n        TypeKind::Tuple(pattern_types) =\u003e {\n            if let TypeKind::Tuple(check_types) = \u0026check_type.kind {\n                if pattern_types.len() != check_types.len() {\n                    return false;\n                }\n                pattern_types\n                    .iter()\n                    .zip(check_types.iter())\n                    .all(|(p, c)| try_match_and_infer(c, p, inferred, type_env))\n            } else {\n                false\n            }\n        }\n\n        // For other patterns, just check type equality\n        _ =\u003e {\n            use crate::core::type_compat::TypeCompatibility;\n            TypeCompatibility::is_assignable(check_type, pattern)\n        }\n    }\n}\n\n/// Substitute inferred type variables in a type\nfn substitute_inferred_types(\n    typ: \u0026Type,\n    inferred: \u0026FxHashMap\u003cString, Type\u003e,\n) -\u003e Result\u003cType, String\u003e {\n    match \u0026typ.kind {\n        // If it's a reference to an inferred type variable, substitute it\n        TypeKind::Reference(type_ref) if type_ref.type_arguments.is_none() =\u003e {\n            let type_name = type_ref.name.node.to_string();\n            if let Some(inferred_type) = inferred.get(\u0026type_name) {\n                Ok(inferred_type.clone())\n            } else {\n                Ok(typ.clone())\n            }\n        }\n\n        // Recursively substitute in compound types\n        TypeKind::Array(elem) =\u003e {\n            let substituted_elem = substitute_inferred_types(elem, inferred)?;\n            Ok(Type::new(\n                TypeKind::Array(Box::new(substituted_elem)),\n                typ.span,\n            ))\n        }\n\n        TypeKind::Union(types) =\u003e {\n            let substituted: Result\u003cVec\u003c_\u003e, _\u003e = types\n                .iter()\n                .map(|t| substitute_inferred_types(t, inferred))\n                .collect();\n            Ok(Type::new(TypeKind::Union(substituted?), typ.span))\n        }\n\n        TypeKind::Intersection(types) =\u003e {\n            let substituted: Result\u003cVec\u003c_\u003e, _\u003e = types\n                .iter()\n                .map(|t| substitute_inferred_types(t, inferred))\n                .collect();\n            Ok(Type::new(TypeKind::Intersection(substituted?), typ.span))\n        }\n\n        TypeKind::Tuple(types) =\u003e {\n            let substituted: Result\u003cVec\u003c_\u003e, _\u003e = types\n                .iter()\n                .map(|t| substitute_inferred_types(t, inferred))\n                .collect();\n            Ok(Type::new(TypeKind::Tuple(substituted?), typ.span))\n        }\n\n        // For other types, return as-is\n        _ =\u003e Ok(typ.clone()),\n    }\n}\n\n/// Extract keys from a type for mapped type iteration\n/// Currently supports: string literal unions and type references to them\nfn extract_keys_from_type(\n    typ: \u0026Type,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    match \u0026typ.kind {\n        TypeKind::Literal(Literal::String(s)) =\u003e Ok(vec![s.clone()]),\n        TypeKind::Union(types) =\u003e {\n            let mut keys = Vec::new();\n            for t in types {\n                match \u0026t.kind {\n                    TypeKind::Literal(Literal::String(s)) =\u003e {\n                        keys.push(s.clone());\n                    }\n                    TypeKind::Reference(type_ref) =\u003e {\n                        let type_name = interner.resolve(type_ref.name.node).to_string();\n                        match type_env.lookup_type(\u0026type_name) {\n                            Some(resolved_type) =\u003e {\n                                let resolved_keys =\n                                    extract_keys_from_type(resolved_type, type_env, interner)?;\n                                keys.extend(resolved_keys);\n                            }\n                            None =\u003e {\n                                return Err(format!(\n                                    \"Type '{}' not found in type environment\",\n                                    type_name\n                                ));\n                            }\n                        }\n                    }\n                    _ =\u003e {\n                        return Err(\n                            \"Mapped type currently only supports string literal unions\".to_string()\n                        );\n                    }\n                }\n            }\n            Ok(keys)\n        }\n        // Type reference - resolve it using the type environment\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = interner.resolve(type_ref.name.node).to_string();\n            match type_env.lookup_type(\u0026type_name) {\n                Some(resolved_type) =\u003e extract_keys_from_type(resolved_type, type_env, interner),\n                None =\u003e Err(format!(\n                    \"Type '{}' not found in type environment\",\n                    type_name\n                )),\n            }\n        }\n        // Future: support keyof T\n        _ =\u003e Err(\n            \"Mapped type 'in' clause must be a string literal or union of string literals\"\n                .to_string(),\n        ),\n    }\n}\n\n// Helper functions\n\n/// Extract string literal keys from a type (for Pick/Omit)\nfn extract_string_literal_keys(typ: \u0026Type) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    match \u0026typ.kind {\n        TypeKind::Literal(Literal::String(s)) =\u003e Ok(vec![s.clone()]),\n        TypeKind::Union(types) =\u003e types\n            .iter()\n            .map(|t| match \u0026t.kind {\n                TypeKind::Literal(Literal::String(s)) =\u003e Ok(s.clone()),\n                _ =\u003e Err(\n                    \"Pick/Omit key type must be string literal or union of string literals\"\n                        .to_string(),\n                ),\n            })\n            .collect(),\n        _ =\u003e {\n            Err(\"Pick/Omit key type must be string literal or union of string literals\".to_string())\n        }\n    }\n}\n\n/// Check if a type is nil or void\nfn is_nil_or_void(typ: \u0026Type) -\u003e bool {\n    matches!(\n        typ.kind,\n        TypeKind::Primitive(PrimitiveType::Nil) | TypeKind::Primitive(PrimitiveType::Void)\n    )\n}\n\n/// Simple type assignability check\nfn is_assignable_to(source: \u0026Type, target: \u0026Type) -\u003e bool {\n    use crate::core::type_compat::TypeCompatibility;\n    TypeCompatibility::is_assignable(source, target)\n}\n\n/// Evaluate a template literal type to a union of string literals\n/// For example: `Hello ${T}` where T = \"World\" | \"Rust\" becomes \"Hello World\" | \"Hello Rust\"\npub fn evaluate_template_literal_type(\n    template: \u0026typedlua_parser::ast::types::TemplateLiteralType,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cType, String\u003e {\n    use typedlua_parser::ast::types::TemplateLiteralTypePart;\n\n    // Extract all interpolated types and get their possible values\n    let mut part_expansions: Vec\u003cVec\u003cString\u003e\u003e = Vec::new();\n\n    for part in \u0026template.parts {\n        match part {\n            TemplateLiteralTypePart::String(s) =\u003e {\n                // Static string - single value\n                part_expansions.push(vec![s.clone()]);\n            }\n            TemplateLiteralTypePart::Type(ty) =\u003e {\n                // Type interpolation - expand to all possible string values\n                let values = expand_type_to_strings(ty, type_env, interner)?;\n                if values.is_empty() {\n                    return Err(\n                        \"Template literal type interpolation produced no values\".to_string()\n                    );\n                }\n                part_expansions.push(values);\n            }\n        }\n    }\n\n    // Generate all combinations\n    let combinations = cartesian_product(\u0026part_expansions);\n\n    // Limit the number of combinations to prevent exponential explosion\n    // TypeScript uses 100,000 as the limit\n    const MAX_TEMPLATE_LITERAL_COMBINATIONS: usize = 10000;\n\n    if combinations.len() \u003e MAX_TEMPLATE_LITERAL_COMBINATIONS {\n        return Err(format!(\n            \"Template literal type expansion resulted in {} combinations, which exceeds the limit of {}. \\\n             Consider using a broader type like 'string' instead.\",\n            combinations.len(),\n            MAX_TEMPLATE_LITERAL_COMBINATIONS\n        ));\n    }\n\n    // If there's only one combination, return a single string literal\n    // Otherwise, return a union of string literals\n    if combinations.len() == 1 {\n        Ok(Type::new(\n            TypeKind::Literal(Literal::String(combinations[0].clone())),\n            template.span,\n        ))\n    } else {\n        let literal_types: Vec\u003cType\u003e = combinations\n            .into_iter()\n            .map(|s| Type::new(TypeKind::Literal(Literal::String(s)), template.span))\n            .collect();\n\n        Ok(Type::new(TypeKind::Union(literal_types), template.span))\n    }\n}\n\n/// Expand a type to all possible string literal values\nfn expand_type_to_strings(\n    ty: \u0026Type,\n    type_env: \u0026TypeEnvironment,\n    interner: \u0026StringInterner,\n) -\u003e Result\u003cVec\u003cString\u003e, String\u003e {\n    // First resolve any type references\n    let resolved = match \u0026ty.kind {\n        TypeKind::Reference(type_ref) =\u003e {\n            let type_name = interner.resolve(type_ref.name.node).to_string();\n            if let Some(resolved) = type_env.lookup_type(\u0026type_name) {\n                resolved\n            } else {\n                ty\n            }\n        }\n        _ =\u003e ty,\n    };\n\n    match \u0026resolved.kind {\n        TypeKind::Literal(Literal::String(s)) =\u003e Ok(vec![s.clone()]),\n        TypeKind::Literal(Literal::Number(n)) =\u003e Ok(vec![n.to_string()]),\n        TypeKind::Literal(Literal::Boolean(b)) =\u003e Ok(vec![b.to_string()]),\n        TypeKind::Literal(Literal::Nil) =\u003e Ok(vec![\"nil\".to_string()]),\n        TypeKind::Primitive(PrimitiveType::String) =\u003e {\n            Err(\"Cannot interpolate primitive string type in template literal - use string literal union instead\".to_string())\n        }\n        TypeKind::Primitive(PrimitiveType::Number) =\u003e {\n            Err(\"Cannot interpolate primitive number type in template literal - use number literal union instead\".to_string())\n        }\n        TypeKind::Union(types) =\u003e types\n            .iter()\n            .map(|t| expand_type_to_strings(t, type_env, interner))\n            .collect::\u003cResult\u003cVec\u003c_\u003e, _\u003e\u003e()\n            .map(|v| v.into_iter().flatten().collect()),\n        _ =\u003e Err(format!(\n            \"Cannot interpolate type {:?} in template literal - only string/number/boolean literals and unions are supported\",\n            resolved.kind\n        )),\n    }\n}\n\n/// Generate cartesian product of string vectors\n/// For example: [[\"a\", \"b\"], [\"1\", \"2\"]] -\u003e [\"a1\", \"a2\", \"b1\", \"b2\"]\nfn cartesian_product(vecs: \u0026[Vec\u003cString\u003e]) -\u003e Vec\u003cString\u003e {\n    if vecs.is_empty() {\n        return vec![String::new()];\n    }\n\n    if vecs.len() == 1 {\n        return vecs[0].clone();\n    }\n\n    vecs.iter().fold(vec![String::new()], |acc, v| {\n        acc.iter()\n            .flat_map(|existing| {\n                v.iter().map(move |item| {\n                    let mut new_item = existing.clone();\n                    new_item.push_str(item);\n                    new_item\n                })\n            })\n            .collect()\n    })\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::Ident;\n\n    fn make_span() -\u003e Span {\n        Span::new(0, 0, 0, 0)\n    }\n\n    fn make_object_type(properties: Vec\u003c(\u0026str, Type, bool, bool)\u003e) -\u003e Type {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        make_object_type_with_interner(\u0026interner, properties)\n    }\n\n    fn make_object_type_with_interner(\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n        properties: Vec\u003c(\u0026str, Type, bool, bool)\u003e,\n    ) -\u003e Type {\n        let members = properties\n            .into_iter()\n            .map(|(name, typ, optional, readonly)| {\n                let name_id = interner.intern(name);\n                ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: readonly,\n                    name: Ident::new(name_id, make_span()),\n                    is_optional: optional,\n                    type_annotation: typ,\n                    span: make_span(),\n                })\n            })\n            .collect();\n\n        Type::new(\n            TypeKind::Object(ObjectType {\n                members,\n                span: make_span(),\n            }),\n            make_span(),\n        )\n    }\n\n    #[test]\n    fn test_partial() {\n        let obj = make_object_type(vec![\n            (\n                \"name\",\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                false,\n                false,\n            ),\n            (\n                \"age\",\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                false,\n                false,\n            ),\n        ]);\n\n        let result = partial(\u0026[obj], make_span()).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            for member in \u0026obj_type.members {\n                if let ObjectTypeMember::Property(prop) = member {\n                    assert!(\n                        prop.is_optional,\n                        \"Property {} should be optional\",\n                        prop.name.node\n                    );\n                }\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_required() {\n        let obj = make_object_type(vec![\n            (\n                \"name\",\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                true,\n                false,\n            ),\n            (\n                \"age\",\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                true,\n                false,\n            ),\n        ]);\n\n        let result = required(\u0026[obj], make_span()).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            for member in \u0026obj_type.members {\n                if let ObjectTypeMember::Property(prop) = member {\n                    assert!(\n                        !prop.is_optional,\n                        \"Property {} should be required\",\n                        prop.name.node\n                    );\n                }\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_readonly() {\n        let obj = make_object_type(vec![\n            (\n                \"name\",\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                false,\n                false,\n            ),\n            (\n                \"age\",\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                false,\n                false,\n            ),\n        ]);\n\n        let result = readonly(\u0026[obj], make_span()).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            for member in \u0026obj_type.members {\n                if let ObjectTypeMember::Property(prop) = member {\n                    assert!(\n                        prop.is_readonly,\n                        \"Property {} should be readonly\",\n                        prop.name.node\n                    );\n                }\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_record() {\n        let key_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            assert!(matches!(obj_type.members[0], ObjectTypeMember::Index(_)));\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_exclude() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n        let exclude = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = self::exclude(\u0026[union, exclude], make_span()).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n            assert!(types\n                .iter()\n                .all(|t| !matches!(t.kind, TypeKind::Primitive(PrimitiveType::String))));\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_non_nilable() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = non_nilable(\u0026[union], make_span()).unwrap();\n\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_nilable() {\n        let typ = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let result = nilable(\u0026[typ], make_span()).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::String))));\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::Nil))));\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_return_type() {\n        use typedlua_parser::ast::types::FunctionType;\n\n        let func = Type::new(\n            TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    make_span(),\n                )),\n                throws: None,\n                span: make_span(),\n            }),\n            make_span(),\n        );\n\n        let result = return_type(\u0026[func], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_pick() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"email\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Pick\u003cObj, \"name\" | \"age\"\u003e\n        let keys = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"name\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"age\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n\n        let result = pick(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            // Should have name and age, but not email\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_pick_single_key() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Pick\u003cObj, \"name\"\u003e\n        let keys = Type::new(\n            TypeKind::Literal(Literal::String(\"name\".to_string())),\n            make_span(),\n        );\n\n        let result = pick(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_omit() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"email\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Omit\u003cObj, \"email\"\u003e\n        let keys = Type::new(\n            TypeKind::Literal(Literal::String(\"email\".to_string())),\n            make_span(),\n        );\n\n        let result = omit(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 2);\n            // Should have name and age, but not email\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_omit_multiple_keys() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let obj = make_object_type_with_interner(\n            \u0026interner,\n            vec![\n                (\n                    \"name\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"age\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    false,\n                    false,\n                ),\n                (\n                    \"email\",\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    false,\n                    false,\n                ),\n            ],\n        );\n\n        // Omit\u003cObj, \"name\" | \"age\"\u003e\n        let keys = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"name\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"age\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n\n        let result = omit(\u0026[obj, keys], make_span(), \u0026interner).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            // Should only have email\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Tests\n    // ========================================================================\n\n    #[test]\n    fn test_extract() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n        let extract_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = extract(\u0026[union, extract_type], make_span()).unwrap();\n\n        // Should extract just string\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_extract_multiple() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n\n        // Extract string | number\n        let extract_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = extract(\u0026[union, extract_type], make_span()).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_parameters() {\n        use typedlua_parser::ast::pattern::Pattern;\n        use typedlua_parser::ast::statement::Parameter;\n        use typedlua_parser::ast::types::FunctionType;\n\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n\n        let func = Type::new(\n            TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![\n                    Parameter {\n                        pattern: Pattern::Identifier(Ident::new(x_id, make_span())),\n                        type_annotation: Some(Type::new(\n                            TypeKind::Primitive(PrimitiveType::String),\n                            make_span(),\n                        )),\n                        default: None,\n                        is_rest: false,\n                        is_optional: false,\n                        span: make_span(),\n                    },\n                    Parameter {\n                        pattern: Pattern::Identifier(Ident::new(y_id, make_span())),\n                        type_annotation: Some(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Number),\n                            make_span(),\n                        )),\n                        default: None,\n                        is_rest: false,\n                        is_optional: false,\n                        span: make_span(),\n                    },\n                ],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Void),\n                    make_span(),\n                )),\n                throws: None,\n                span: make_span(),\n            }),\n            make_span(),\n        );\n\n        let result = parameters(\u0026[func], make_span()).unwrap();\n\n        if let TypeKind::Tuple(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n            assert!(matches!(\n                types[0].kind,\n                TypeKind::Primitive(PrimitiveType::String)\n            ));\n            assert!(matches!(\n                types[1].kind,\n                TypeKind::Primitive(PrimitiveType::Number)\n            ));\n        } else {\n            panic!(\"Expected tuple type\");\n        }\n    }\n\n    #[test]\n    fn test_apply_utility_type_partial() {\n        let obj = make_object_type(vec![(\n            \"name\",\n            Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n            false,\n            false,\n        )]);\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result =\n            apply_utility_type(\"Partial\", \u0026[obj], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            if let ObjectTypeMember::Property(prop) = \u0026obj_type.members[0] {\n                assert!(prop.is_optional);\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_apply_utility_type_unknown() {\n        let obj = make_object_type(vec![]);\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = apply_utility_type(\"UnknownType\", \u0026[obj], make_span(), \u0026interner, \u0026common_ids);\n\n        assert!(result.is_err());\n        assert!(result.unwrap_err().contains(\"Unknown utility type\"));\n    }\n\n    #[test]\n    fn test_partial_wrong_arg_count() {\n        let obj = make_object_type(vec![]);\n        let result = partial(\u0026[], make_span());\n        assert!(result.is_err());\n\n        let result = partial(\u0026[obj.clone(), obj], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_partial_non_object() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let result = partial(\u0026[string_type], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_required_wrong_arg_count() {\n        let _obj = make_object_type(vec![]);\n        let result = required(\u0026[], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_readonly_array() {\n        let array_type = Type::new(\n            TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            ))),\n            make_span(),\n        );\n\n        let result = readonly(std::slice::from_ref(\u0026array_type), make_span()).unwrap();\n        // Arrays are returned as-is for now\n        assert!(matches!(result.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_record_number_keys() {\n        let key_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            if let ObjectTypeMember::Index(idx) = \u0026obj_type.members[0] {\n                assert!(matches!(idx.key_type, IndexKeyType::Number));\n            }\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_record_union_string_literals() {\n        // Record\u003c\"a\" | \"b\", number\u003e\n        let key_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"a\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"b\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids).unwrap();\n\n        if let TypeKind::Object(obj_type) = \u0026result.kind {\n            assert_eq!(obj_type.members.len(), 1);\n            assert!(matches!(obj_type.members[0], ObjectTypeMember::Index(_)));\n        } else {\n            panic!(\"Expected object type\");\n        }\n    }\n\n    #[test]\n    fn test_record_invalid_key_type() {\n        let key_type = Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span());\n        let value_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let (interner, common_ids) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n        let result = record(\u0026[key_type, value_type], make_span(), \u0026interner, \u0026common_ids);\n\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_exclude_non_union() {\n        // Exclude\u003cstring, number\u003e should return string (since string is not assignable to number)\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let result = exclude(\u0026[string_type.clone(), number_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_all_types() {\n        // Exclude\u003cstring, string\u003e should return never\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = exclude(\u0026[string_type.clone(), string_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_extract_non_union_match() {\n        // Extract\u003cstring, string\u003e should return string\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = extract(\u0026[string_type.clone(), string_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_extract_non_union_no_match() {\n        // Extract\u003cstring, number\u003e should return never\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let result = extract(\u0026[string_type, number_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_non_nilable_nullable_type() {\n        let nullable = Type::new(\n            TypeKind::Nullable(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            ))),\n            make_span(),\n        );\n\n        let result = non_nilable(\u0026[nullable], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_non_nilable_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = non_nilable(\u0026[string_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_non_nilable_only_nil() {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n\n        let result = non_nilable(\u0026[nil_type], make_span()).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_nilable_already_nilable() {\n        let union = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = nilable(std::slice::from_ref(\u0026union), make_span()).unwrap();\n        // Should return the same type since it already has nil\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_nilable_nullable() {\n        let nullable = Type::new(\n            TypeKind::Nullable(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            ))),\n            make_span(),\n        );\n\n        let result = nilable(std::slice::from_ref(\u0026nullable), make_span()).unwrap();\n        // Should return the same nullable type\n        assert!(matches!(result.kind, TypeKind::Nullable(_)));\n    }\n\n    #[test]\n    fn test_return_type_non_function() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = return_type(\u0026[string_type], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_parameters_non_function() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        let result = parameters(\u0026[string_type], make_span());\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_is_nil_or_void() {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let void_type = Type::new(TypeKind::Primitive(PrimitiveType::Void), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        assert!(is_nil_or_void(\u0026nil_type));\n        assert!(is_nil_or_void(\u0026void_type));\n        assert!(!is_nil_or_void(\u0026string_type));\n    }\n\n    #[test]\n    fn test_extract_string_literal_keys() {\n        let single_key = Type::new(\n            TypeKind::Literal(Literal::String(\"name\".to_string())),\n            make_span(),\n        );\n        let keys = extract_string_literal_keys(\u0026single_key).unwrap();\n        assert_eq!(keys, vec![\"name\"]);\n\n        let union_keys = Type::new(\n            TypeKind::Union(vec![\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"a\".to_string())),\n                    make_span(),\n                ),\n                Type::new(\n                    TypeKind::Literal(Literal::String(\"b\".to_string())),\n                    make_span(),\n                ),\n            ]),\n            make_span(),\n        );\n        let keys = extract_string_literal_keys(\u0026union_keys).unwrap();\n        assert_eq!(keys.len(), 2);\n    }\n\n    #[test]\n    fn test_extract_string_literal_keys_invalid() {\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let result = extract_string_literal_keys(\u0026number_type);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_cartesian_product() {\n        let vecs = vec![\n            vec![\"a\".to_string(), \"b\".to_string()],\n            vec![\"1\".to_string(), \"2\".to_string()],\n        ];\n\n        let result = cartesian_product(\u0026vecs);\n        assert_eq!(result.len(), 4);\n        assert!(result.contains(\u0026\"a1\".to_string()));\n        assert!(result.contains(\u0026\"a2\".to_string()));\n        assert!(result.contains(\u0026\"b1\".to_string()));\n        assert!(result.contains(\u0026\"b2\".to_string()));\n    }\n\n    #[test]\n    fn test_cartesian_product_empty() {\n        let vecs: Vec\u003cVec\u003cString\u003e\u003e = vec![];\n        let result = cartesian_product(\u0026vecs);\n        assert_eq!(result.len(), 1);\n        assert_eq!(result[0], \"\");\n    }\n\n    #[test]\n    fn test_cartesian_product_single() {\n        let vecs = vec![vec![\"a\".to_string(), \"b\".to_string()]];\n        let result = cartesian_product(\u0026vecs);\n        assert_eq!(result.len(), 2);\n        assert!(result.contains(\u0026\"a\".to_string()));\n        assert!(result.contains(\u0026\"b\".to_string()));\n    }\n}\n","traces":[{"line":14,"address":[],"length":0,"stats":{"Line":24}},{"line":21,"address":[],"length":0,"stats":{"Line":24}},{"line":22,"address":[],"length":0,"stats":{"Line":36}},{"line":23,"address":[],"length":0,"stats":{"Line":26}},{"line":24,"address":[],"length":0,"stats":{"Line":24}},{"line":25,"address":[],"length":0,"stats":{"Line":31}},{"line":26,"address":[],"length":0,"stats":{"Line":21}},{"line":27,"address":[],"length":0,"stats":{"Line":19}},{"line":28,"address":[],"length":0,"stats":{"Line":15}},{"line":29,"address":[],"length":0,"stats":{"Line":13}},{"line":30,"address":[],"length":0,"stats":{"Line":8}},{"line":31,"address":[],"length":0,"stats":{"Line":7}},{"line":32,"address":[],"length":0,"stats":{"Line":6}},{"line":33,"address":[],"length":0,"stats":{"Line":5}},{"line":34,"address":[],"length":0,"stats":{"Line":1}},{"line":39,"address":[],"length":0,"stats":{"Line":8}},{"line":40,"address":[],"length":0,"stats":{"Line":8}},{"line":41,"address":[],"length":0,"stats":{"Line":4}},{"line":42,"address":[],"length":0,"stats":{"Line":4}},{"line":43,"address":[],"length":0,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":12}},{"line":48,"address":[],"length":0,"stats":{"Line":6}},{"line":49,"address":[],"length":0,"stats":{"Line":5}},{"line":50,"address":[],"length":0,"stats":{"Line":10}},{"line":51,"address":[],"length":0,"stats":{"Line":5}},{"line":53,"address":[],"length":0,"stats":{"Line":17}},{"line":54,"address":[],"length":0,"stats":{"Line":12}},{"line":55,"address":[],"length":0,"stats":{"Line":12}},{"line":56,"address":[],"length":0,"stats":{"Line":12}},{"line":57,"address":[],"length":0,"stats":{"Line":24}},{"line":58,"address":[],"length":0,"stats":{"Line":36}},{"line":59,"address":[],"length":0,"stats":{"Line":12}},{"line":60,"address":[],"length":0,"stats":{"Line":24}},{"line":61,"address":[],"length":0,"stats":{"Line":12}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":10}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":72,"address":[],"length":0,"stats":{"Line":5}},{"line":73,"address":[],"length":0,"stats":{"Line":5}},{"line":75,"address":[],"length":0,"stats":{"Line":5}},{"line":78,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":4}},{"line":84,"address":[],"length":0,"stats":{"Line":4}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":2}},{"line":87,"address":[],"length":0,"stats":{"Line":1}},{"line":91,"address":[],"length":0,"stats":{"Line":6}},{"line":92,"address":[],"length":0,"stats":{"Line":3}},{"line":93,"address":[],"length":0,"stats":{"Line":3}},{"line":94,"address":[],"length":0,"stats":{"Line":6}},{"line":95,"address":[],"length":0,"stats":{"Line":3}},{"line":97,"address":[],"length":0,"stats":{"Line":9}},{"line":98,"address":[],"length":0,"stats":{"Line":6}},{"line":99,"address":[],"length":0,"stats":{"Line":6}},{"line":100,"address":[],"length":0,"stats":{"Line":6}},{"line":101,"address":[],"length":0,"stats":{"Line":12}},{"line":102,"address":[],"length":0,"stats":{"Line":18}},{"line":103,"address":[],"length":0,"stats":{"Line":6}},{"line":104,"address":[],"length":0,"stats":{"Line":12}},{"line":105,"address":[],"length":0,"stats":{"Line":6}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":113,"address":[],"length":0,"stats":{"Line":6}},{"line":114,"address":[],"length":0,"stats":{"Line":3}},{"line":115,"address":[],"length":0,"stats":{"Line":3}},{"line":116,"address":[],"length":0,"stats":{"Line":3}},{"line":118,"address":[],"length":0,"stats":{"Line":3}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[],"length":0,"stats":{"Line":4}},{"line":127,"address":[],"length":0,"stats":{"Line":4}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":8}},{"line":135,"address":[],"length":0,"stats":{"Line":4}},{"line":136,"address":[],"length":0,"stats":{"Line":3}},{"line":137,"address":[],"length":0,"stats":{"Line":6}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":140,"address":[],"length":0,"stats":{"Line":10}},{"line":141,"address":[],"length":0,"stats":{"Line":7}},{"line":142,"address":[],"length":0,"stats":{"Line":7}},{"line":143,"address":[],"length":0,"stats":{"Line":7}},{"line":144,"address":[],"length":0,"stats":{"Line":7}},{"line":145,"address":[],"length":0,"stats":{"Line":21}},{"line":146,"address":[],"length":0,"stats":{"Line":14}},{"line":147,"address":[],"length":0,"stats":{"Line":14}},{"line":148,"address":[],"length":0,"stats":{"Line":7}},{"line":151,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":6}},{"line":157,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":7}},{"line":180,"address":[],"length":0,"stats":{"Line":7}},{"line":181,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":187,"address":[],"length":0,"stats":{"Line":14}},{"line":188,"address":[],"length":0,"stats":{"Line":14}},{"line":191,"address":[],"length":0,"stats":{"Line":12}},{"line":193,"address":[],"length":0,"stats":{"Line":4}},{"line":197,"address":[],"length":0,"stats":{"Line":1}},{"line":198,"address":[],"length":0,"stats":{"Line":1}},{"line":200,"address":[],"length":0,"stats":{"Line":1}},{"line":202,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[],"length":0,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":214,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":224,"address":[],"length":0,"stats":{"Line":12}},{"line":226,"address":[],"length":0,"stats":{"Line":24}},{"line":228,"address":[],"length":0,"stats":{"Line":12}},{"line":232,"address":[],"length":0,"stats":{"Line":12}},{"line":233,"address":[],"length":0,"stats":{"Line":6}},{"line":234,"address":[],"length":0,"stats":{"Line":12}},{"line":235,"address":[],"length":0,"stats":{"Line":6}},{"line":237,"address":[],"length":0,"stats":{"Line":6}},{"line":242,"address":[],"length":0,"stats":{"Line":4}},{"line":243,"address":[],"length":0,"stats":{"Line":4}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":250,"address":[],"length":0,"stats":{"Line":8}},{"line":251,"address":[],"length":0,"stats":{"Line":8}},{"line":253,"address":[],"length":0,"stats":{"Line":4}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":256,"address":[],"length":0,"stats":{"Line":12}},{"line":258,"address":[],"length":0,"stats":{"Line":12}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":15}},{"line":262,"address":[],"length":0,"stats":{"Line":11}},{"line":263,"address":[],"length":0,"stats":{"Line":11}},{"line":265,"address":[],"length":0,"stats":{"Line":44}},{"line":266,"address":[],"length":0,"stats":{"Line":22}},{"line":267,"address":[],"length":0,"stats":{"Line":7}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":8}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":4}},{"line":281,"address":[],"length":0,"stats":{"Line":4}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":4}},{"line":292,"address":[],"length":0,"stats":{"Line":4}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":8}},{"line":300,"address":[],"length":0,"stats":{"Line":8}},{"line":302,"address":[],"length":0,"stats":{"Line":4}},{"line":303,"address":[],"length":0,"stats":{"Line":4}},{"line":305,"address":[],"length":0,"stats":{"Line":12}},{"line":307,"address":[],"length":0,"stats":{"Line":12}},{"line":308,"address":[],"length":0,"stats":{"Line":4}},{"line":310,"address":[],"length":0,"stats":{"Line":16}},{"line":311,"address":[],"length":0,"stats":{"Line":12}},{"line":312,"address":[],"length":0,"stats":{"Line":12}},{"line":314,"address":[],"length":0,"stats":{"Line":48}},{"line":315,"address":[],"length":0,"stats":{"Line":24}},{"line":316,"address":[],"length":0,"stats":{"Line":7}},{"line":318,"address":[],"length":0,"stats":{"Line":5}},{"line":322,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":8}},{"line":328,"address":[],"length":0,"stats":{"Line":4}},{"line":329,"address":[],"length":0,"stats":{"Line":4}},{"line":330,"address":[],"length":0,"stats":{"Line":4}},{"line":332,"address":[],"length":0,"stats":{"Line":4}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":5}},{"line":341,"address":[],"length":0,"stats":{"Line":5}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":10}},{"line":349,"address":[],"length":0,"stats":{"Line":10}},{"line":351,"address":[],"length":0,"stats":{"Line":5}},{"line":352,"address":[],"length":0,"stats":{"Line":3}},{"line":353,"address":[],"length":0,"stats":{"Line":9}},{"line":355,"address":[],"length":0,"stats":{"Line":30}},{"line":359,"address":[],"length":0,"stats":{"Line":6}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":3}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[],"length":0,"stats":{"Line":6}},{"line":369,"address":[],"length":0,"stats":{"Line":6}},{"line":370,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":379,"address":[],"length":0,"stats":{"Line":6}},{"line":380,"address":[],"length":0,"stats":{"Line":6}},{"line":381,"address":[],"length":0,"stats":{"Line":0}},{"line":382,"address":[],"length":0,"stats":{"Line":0}},{"line":383,"address":[],"length":0,"stats":{"Line":0}},{"line":387,"address":[],"length":0,"stats":{"Line":12}},{"line":388,"address":[],"length":0,"stats":{"Line":12}},{"line":390,"address":[],"length":0,"stats":{"Line":6}},{"line":391,"address":[],"length":0,"stats":{"Line":4}},{"line":392,"address":[],"length":0,"stats":{"Line":12}},{"line":394,"address":[],"length":0,"stats":{"Line":40}},{"line":398,"address":[],"length":0,"stats":{"Line":8}},{"line":399,"address":[],"length":0,"stats":{"Line":0}},{"line":400,"address":[],"length":0,"stats":{"Line":4}},{"line":401,"address":[],"length":0,"stats":{"Line":3}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":408,"address":[],"length":0,"stats":{"Line":6}},{"line":409,"address":[],"length":0,"stats":{"Line":1}},{"line":411,"address":[],"length":0,"stats":{"Line":2}},{"line":418,"address":[],"length":0,"stats":{"Line":5}},{"line":419,"address":[],"length":0,"stats":{"Line":5}},{"line":420,"address":[],"length":0,"stats":{"Line":0}},{"line":421,"address":[],"length":0,"stats":{"Line":0}},{"line":422,"address":[],"length":0,"stats":{"Line":0}},{"line":426,"address":[],"length":0,"stats":{"Line":10}},{"line":428,"address":[],"length":0,"stats":{"Line":5}},{"line":429,"address":[],"length":0,"stats":{"Line":2}},{"line":430,"address":[],"length":0,"stats":{"Line":6}},{"line":432,"address":[],"length":0,"stats":{"Line":10}},{"line":436,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":2}},{"line":439,"address":[],"length":0,"stats":{"Line":1}},{"line":441,"address":[],"length":0,"stats":{"Line":2}},{"line":444,"address":[],"length":0,"stats":{"Line":2}},{"line":446,"address":[],"length":0,"stats":{"Line":4}},{"line":447,"address":[],"length":0,"stats":{"Line":2}},{"line":449,"address":[],"length":0,"stats":{"Line":1}},{"line":456,"address":[],"length":0,"stats":{"Line":4}},{"line":457,"address":[],"length":0,"stats":{"Line":4}},{"line":458,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":0}},{"line":460,"address":[],"length":0,"stats":{"Line":0}},{"line":464,"address":[],"length":0,"stats":{"Line":8}},{"line":467,"address":[],"length":0,"stats":{"Line":8}},{"line":468,"address":[],"length":0,"stats":{"Line":0}},{"line":471,"address":[],"length":0,"stats":{"Line":4}},{"line":472,"address":[],"length":0,"stats":{"Line":1}},{"line":474,"address":[],"length":0,"stats":{"Line":2}},{"line":475,"address":[],"length":0,"stats":{"Line":1}},{"line":477,"address":[],"length":0,"stats":{"Line":0}},{"line":478,"address":[],"length":0,"stats":{"Line":0}},{"line":479,"address":[],"length":0,"stats":{"Line":0}},{"line":484,"address":[],"length":0,"stats":{"Line":1}},{"line":486,"address":[],"length":0,"stats":{"Line":4}},{"line":487,"address":[],"length":0,"stats":{"Line":4}},{"line":488,"address":[],"length":0,"stats":{"Line":6}},{"line":489,"address":[],"length":0,"stats":{"Line":4}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":497,"address":[],"length":0,"stats":{"Line":3}},{"line":498,"address":[],"length":0,"stats":{"Line":3}},{"line":499,"address":[],"length":0,"stats":{"Line":0}},{"line":500,"address":[],"length":0,"stats":{"Line":0}},{"line":501,"address":[],"length":0,"stats":{"Line":0}},{"line":505,"address":[],"length":0,"stats":{"Line":6}},{"line":507,"address":[],"length":0,"stats":{"Line":3}},{"line":508,"address":[],"length":0,"stats":{"Line":4}},{"line":509,"address":[],"length":0,"stats":{"Line":1}},{"line":514,"address":[],"length":0,"stats":{"Line":3}},{"line":515,"address":[],"length":0,"stats":{"Line":3}},{"line":516,"address":[],"length":0,"stats":{"Line":0}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":6}},{"line":524,"address":[],"length":0,"stats":{"Line":3}},{"line":525,"address":[],"length":0,"stats":{"Line":2}},{"line":526,"address":[],"length":0,"stats":{"Line":6}},{"line":527,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":10}},{"line":532,"address":[],"length":0,"stats":{"Line":4}},{"line":534,"address":[],"length":0,"stats":{"Line":1}},{"line":540,"address":[],"length":0,"stats":{"Line":13}},{"line":546,"address":[],"length":0,"stats":{"Line":26}},{"line":547,"address":[],"length":0,"stats":{"Line":5}},{"line":549,"address":[],"length":0,"stats":{"Line":20}},{"line":551,"address":[],"length":0,"stats":{"Line":16}},{"line":555,"address":[],"length":0,"stats":{"Line":65}},{"line":557,"address":[],"length":0,"stats":{"Line":39}},{"line":559,"address":[],"length":0,"stats":{"Line":42}},{"line":560,"address":[],"length":0,"stats":{"Line":116}},{"line":563,"address":[],"length":0,"stats":{"Line":58}},{"line":564,"address":[],"length":0,"stats":{"Line":11}},{"line":565,"address":[],"length":0,"stats":{"Line":0}},{"line":566,"address":[],"length":0,"stats":{"Line":18}},{"line":570,"address":[],"length":0,"stats":{"Line":58}},{"line":571,"address":[],"length":0,"stats":{"Line":10}},{"line":572,"address":[],"length":0,"stats":{"Line":0}},{"line":573,"address":[],"length":0,"stats":{"Line":19}},{"line":576,"address":[],"length":0,"stats":{"Line":29}},{"line":577,"address":[],"length":0,"stats":{"Line":58}},{"line":578,"address":[],"length":0,"stats":{"Line":116}},{"line":579,"address":[],"length":0,"stats":{"Line":58}},{"line":580,"address":[],"length":0,"stats":{"Line":58}},{"line":581,"address":[],"length":0,"stats":{"Line":29}},{"line":586,"address":[],"length":0,"stats":{"Line":26}},{"line":587,"address":[],"length":0,"stats":{"Line":13}},{"line":588,"address":[],"length":0,"stats":{"Line":13}},{"line":589,"address":[],"length":0,"stats":{"Line":13}},{"line":591,"address":[],"length":0,"stats":{"Line":13}},{"line":596,"address":[],"length":0,"stats":{"Line":9}},{"line":602,"address":[],"length":0,"stats":{"Line":18}},{"line":603,"address":[],"length":0,"stats":{"Line":5}},{"line":604,"address":[],"length":0,"stats":{"Line":20}},{"line":605,"address":[],"length":0,"stats":{"Line":10}},{"line":606,"address":[],"length":0,"stats":{"Line":15}},{"line":607,"address":[],"length":0,"stats":{"Line":0}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":613,"address":[],"length":0,"stats":{"Line":9}},{"line":614,"address":[],"length":0,"stats":{"Line":9}},{"line":615,"address":[],"length":0,"stats":{"Line":27}},{"line":616,"address":[],"length":0,"stats":{"Line":9}},{"line":618,"address":[],"length":0,"stats":{"Line":27}},{"line":619,"address":[],"length":0,"stats":{"Line":48}},{"line":620,"address":[],"length":0,"stats":{"Line":16}},{"line":621,"address":[],"length":0,"stats":{"Line":16}},{"line":623,"address":[],"length":0,"stats":{"Line":6}},{"line":624,"address":[],"length":0,"stats":{"Line":2}},{"line":625,"address":[],"length":0,"stats":{"Line":2}},{"line":628,"address":[],"length":0,"stats":{"Line":0}},{"line":632,"address":[],"length":0,"stats":{"Line":18}},{"line":633,"address":[],"length":0,"stats":{"Line":2}},{"line":634,"address":[],"length":0,"stats":{"Line":1}},{"line":635,"address":[],"length":0,"stats":{"Line":1}},{"line":637,"address":[],"length":0,"stats":{"Line":8}},{"line":638,"address":[],"length":0,"stats":{"Line":0}},{"line":640,"address":[],"length":0,"stats":{"Line":16}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":0}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":652,"address":[],"length":0,"stats":{"Line":2}},{"line":660,"address":[],"length":0,"stats":{"Line":4}},{"line":661,"address":[],"length":0,"stats":{"Line":4}},{"line":664,"address":[],"length":0,"stats":{"Line":6}},{"line":665,"address":[],"length":0,"stats":{"Line":6}},{"line":667,"address":[],"length":0,"stats":{"Line":2}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":674,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":2}},{"line":681,"address":[],"length":0,"stats":{"Line":0}},{"line":683,"address":[],"length":0,"stats":{"Line":0}},{"line":685,"address":[],"length":0,"stats":{"Line":0}},{"line":686,"address":[],"length":0,"stats":{"Line":0}},{"line":687,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":689,"address":[],"length":0,"stats":{"Line":0}},{"line":690,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":0}},{"line":699,"address":[],"length":0,"stats":{"Line":0}},{"line":700,"address":[],"length":0,"stats":{"Line":0}},{"line":704,"address":[],"length":0,"stats":{"Line":0}},{"line":706,"address":[],"length":0,"stats":{"Line":0}},{"line":708,"address":[],"length":0,"stats":{"Line":0}},{"line":709,"address":[],"length":0,"stats":{"Line":0}},{"line":712,"address":[],"length":0,"stats":{"Line":0}},{"line":716,"address":[],"length":0,"stats":{"Line":8}},{"line":717,"address":[],"length":0,"stats":{"Line":8}},{"line":720,"address":[],"length":0,"stats":{"Line":6}},{"line":721,"address":[],"length":0,"stats":{"Line":1}},{"line":723,"address":[],"length":0,"stats":{"Line":1}},{"line":728,"address":[],"length":0,"stats":{"Line":4}},{"line":729,"address":[],"length":0,"stats":{"Line":4}},{"line":730,"address":[],"length":0,"stats":{"Line":0}},{"line":731,"address":[],"length":0,"stats":{"Line":0}},{"line":732,"address":[],"length":0,"stats":{"Line":0}},{"line":733,"address":[],"length":0,"stats":{"Line":0}},{"line":734,"address":[],"length":0,"stats":{"Line":0}},{"line":737,"address":[],"length":0,"stats":{"Line":8}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":743,"address":[],"length":0,"stats":{"Line":0}},{"line":744,"address":[],"length":0,"stats":{"Line":0}},{"line":745,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":0}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":753,"address":[],"length":0,"stats":{"Line":2}},{"line":754,"address":[],"length":0,"stats":{"Line":2}},{"line":755,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":0}},{"line":757,"address":[],"length":0,"stats":{"Line":0}},{"line":758,"address":[],"length":0,"stats":{"Line":0}},{"line":760,"address":[],"length":0,"stats":{"Line":0}},{"line":761,"address":[],"length":0,"stats":{"Line":0}},{"line":762,"address":[],"length":0,"stats":{"Line":0}},{"line":763,"address":[],"length":0,"stats":{"Line":0}},{"line":764,"address":[],"length":0,"stats":{"Line":0}},{"line":766,"address":[],"length":0,"stats":{"Line":0}},{"line":767,"address":[],"length":0,"stats":{"Line":0}},{"line":769,"address":[],"length":0,"stats":{"Line":0}},{"line":770,"address":[],"length":0,"stats":{"Line":2}},{"line":775,"address":[],"length":0,"stats":{"Line":0}},{"line":781,"address":[],"length":0,"stats":{"Line":0}},{"line":783,"address":[],"length":0,"stats":{"Line":0}},{"line":784,"address":[],"length":0,"stats":{"Line":0}},{"line":785,"address":[],"length":0,"stats":{"Line":0}},{"line":789,"address":[],"length":0,"stats":{"Line":0}},{"line":790,"address":[],"length":0,"stats":{"Line":0}},{"line":791,"address":[],"length":0,"stats":{"Line":0}},{"line":793,"address":[],"length":0,"stats":{"Line":0}},{"line":798,"address":[],"length":0,"stats":{"Line":0}},{"line":800,"address":[],"length":0,"stats":{"Line":0}},{"line":802,"address":[],"length":0,"stats":{"Line":0}},{"line":804,"address":[],"length":0,"stats":{"Line":0}},{"line":805,"address":[],"length":0,"stats":{"Line":0}},{"line":809,"address":[],"length":0,"stats":{"Line":0}},{"line":810,"address":[],"length":0,"stats":{"Line":0}},{"line":811,"address":[],"length":0,"stats":{"Line":0}},{"line":812,"address":[],"length":0,"stats":{"Line":0}},{"line":814,"address":[],"length":0,"stats":{"Line":0}},{"line":816,"address":[],"length":0,"stats":{"Line":0}},{"line":817,"address":[],"length":0,"stats":{"Line":0}},{"line":819,"address":[],"length":0,"stats":{"Line":0}},{"line":820,"address":[],"length":0,"stats":{"Line":0}},{"line":823,"address":[],"length":0,"stats":{"Line":0}},{"line":828,"address":[],"length":0,"stats":{"Line":0}},{"line":829,"address":[],"length":0,"stats":{"Line":0}},{"line":831,"address":[],"length":0,"stats":{"Line":0}},{"line":832,"address":[],"length":0,"stats":{"Line":0}},{"line":835,"address":[],"length":0,"stats":{"Line":0}},{"line":836,"address":[],"length":0,"stats":{"Line":0}},{"line":838,"address":[],"length":0,"stats":{"Line":0}},{"line":839,"address":[],"length":0,"stats":{"Line":0}},{"line":840,"address":[],"length":0,"stats":{"Line":0}},{"line":841,"address":[],"length":0,"stats":{"Line":0}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":844,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":851,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":853,"address":[],"length":0,"stats":{"Line":0}},{"line":856,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":862,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":869,"address":[],"length":0,"stats":{"Line":0}},{"line":871,"address":[],"length":0,"stats":{"Line":0}},{"line":878,"address":[],"length":0,"stats":{"Line":0}},{"line":884,"address":[],"length":0,"stats":{"Line":0}},{"line":888,"address":[],"length":0,"stats":{"Line":0}},{"line":890,"address":[],"length":0,"stats":{"Line":0}},{"line":891,"address":[],"length":0,"stats":{"Line":0}},{"line":892,"address":[],"length":0,"stats":{"Line":0}},{"line":893,"address":[],"length":0,"stats":{"Line":0}},{"line":895,"address":[],"length":0,"stats":{"Line":0}},{"line":900,"address":[],"length":0,"stats":{"Line":0}},{"line":901,"address":[],"length":0,"stats":{"Line":0}},{"line":902,"address":[],"length":0,"stats":{"Line":0}},{"line":903,"address":[],"length":0,"stats":{"Line":0}},{"line":904,"address":[],"length":0,"stats":{"Line":0}},{"line":908,"address":[],"length":0,"stats":{"Line":0}},{"line":909,"address":[],"length":0,"stats":{"Line":0}},{"line":911,"address":[],"length":0,"stats":{"Line":0}},{"line":913,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":919,"address":[],"length":0,"stats":{"Line":0}},{"line":921,"address":[],"length":0,"stats":{"Line":0}},{"line":924,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":939,"address":[],"length":0,"stats":{"Line":16}},{"line":944,"address":[],"length":0,"stats":{"Line":1}},{"line":945,"address":[],"length":0,"stats":{"Line":3}},{"line":946,"address":[],"length":0,"stats":{"Line":13}},{"line":947,"address":[],"length":0,"stats":{"Line":26}},{"line":948,"address":[],"length":0,"stats":{"Line":71}},{"line":949,"address":[],"length":0,"stats":{"Line":28}},{"line":950,"address":[],"length":0,"stats":{"Line":56}},{"line":951,"address":[],"length":0,"stats":{"Line":84}},{"line":953,"address":[],"length":0,"stats":{"Line":1}},{"line":954,"address":[],"length":0,"stats":{"Line":4}},{"line":955,"address":[],"length":0,"stats":{"Line":2}},{"line":956,"address":[],"length":0,"stats":{"Line":1}},{"line":957,"address":[],"length":0,"stats":{"Line":1}},{"line":958,"address":[],"length":0,"stats":{"Line":4}},{"line":959,"address":[],"length":0,"stats":{"Line":3}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":970,"address":[],"length":0,"stats":{"Line":0}},{"line":971,"address":[],"length":0,"stats":{"Line":0}},{"line":976,"address":[],"length":0,"stats":{"Line":13}},{"line":979,"address":[],"length":0,"stats":{"Line":2}},{"line":980,"address":[],"length":0,"stats":{"Line":8}},{"line":981,"address":[],"length":0,"stats":{"Line":4}},{"line":982,"address":[],"length":0,"stats":{"Line":10}},{"line":983,"address":[],"length":0,"stats":{"Line":0}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":985,"address":[],"length":0,"stats":{"Line":0}},{"line":991,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":1000,"address":[],"length":0,"stats":{"Line":11}},{"line":1001,"address":[],"length":0,"stats":{"Line":5}},{"line":1002,"address":[],"length":0,"stats":{"Line":15}},{"line":1003,"address":[],"length":0,"stats":{"Line":10}},{"line":1005,"address":[],"length":0,"stats":{"Line":15}},{"line":1006,"address":[],"length":0,"stats":{"Line":20}},{"line":1007,"address":[],"length":0,"stats":{"Line":0}},{"line":1008,"address":[],"length":0,"stats":{"Line":0}},{"line":1009,"address":[],"length":0,"stats":{"Line":0}},{"line":1014,"address":[],"length":0,"stats":{"Line":1}},{"line":1020,"address":[],"length":0,"stats":{"Line":15}},{"line":1021,"address":[],"length":0,"stats":{"Line":10}},{"line":1022,"address":[],"length":0,"stats":{"Line":12}},{"line":1028,"address":[],"length":0,"stats":{"Line":25}},{"line":1030,"address":[],"length":0,"stats":{"Line":75}},{"line":1035,"address":[],"length":0,"stats":{"Line":11}},{"line":1043,"address":[],"length":0,"stats":{"Line":33}},{"line":1045,"address":[],"length":0,"stats":{"Line":61}},{"line":1046,"address":[],"length":0,"stats":{"Line":25}},{"line":1047,"address":[],"length":0,"stats":{"Line":24}},{"line":1049,"address":[],"length":0,"stats":{"Line":48}},{"line":1051,"address":[],"length":0,"stats":{"Line":13}},{"line":1053,"address":[],"length":0,"stats":{"Line":65}},{"line":1054,"address":[],"length":0,"stats":{"Line":26}},{"line":1055,"address":[],"length":0,"stats":{"Line":0}},{"line":1056,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":39}},{"line":1065,"address":[],"length":0,"stats":{"Line":33}},{"line":1071,"address":[],"length":0,"stats":{"Line":11}},{"line":1072,"address":[],"length":0,"stats":{"Line":0}},{"line":1073,"address":[],"length":0,"stats":{"Line":0}},{"line":1074,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1082,"address":[],"length":0,"stats":{"Line":11}},{"line":1083,"address":[],"length":0,"stats":{"Line":6}},{"line":1084,"address":[],"length":0,"stats":{"Line":3}},{"line":1085,"address":[],"length":0,"stats":{"Line":3}},{"line":1088,"address":[],"length":0,"stats":{"Line":24}},{"line":1090,"address":[],"length":0,"stats":{"Line":74}},{"line":1093,"address":[],"length":0,"stats":{"Line":16}},{"line":1098,"address":[],"length":0,"stats":{"Line":34}},{"line":1104,"address":[],"length":0,"stats":{"Line":68}},{"line":1105,"address":[],"length":0,"stats":{"Line":13}},{"line":1106,"address":[],"length":0,"stats":{"Line":52}},{"line":1107,"address":[],"length":0,"stats":{"Line":39}},{"line":1108,"address":[],"length":0,"stats":{"Line":13}},{"line":1110,"address":[],"length":0,"stats":{"Line":0}},{"line":1113,"address":[],"length":0,"stats":{"Line":21}},{"line":1116,"address":[],"length":0,"stats":{"Line":0}},{"line":1117,"address":[],"length":0,"stats":{"Line":60}},{"line":1118,"address":[],"length":0,"stats":{"Line":9}},{"line":1119,"address":[],"length":0,"stats":{"Line":6}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":18}},{"line":1129,"address":[],"length":0,"stats":{"Line":93}},{"line":1131,"address":[],"length":0,"stats":{"Line":45}},{"line":1132,"address":[],"length":0,"stats":{"Line":0}},{"line":1133,"address":[],"length":0,"stats":{"Line":0}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1141,"address":[],"length":0,"stats":{"Line":14}},{"line":1142,"address":[],"length":0,"stats":{"Line":28}},{"line":1143,"address":[],"length":0,"stats":{"Line":2}},{"line":1146,"address":[],"length":0,"stats":{"Line":13}},{"line":1147,"address":[],"length":0,"stats":{"Line":4}},{"line":1150,"address":[],"length":0,"stats":{"Line":81}},{"line":1151,"address":[],"length":0,"stats":{"Line":26}},{"line":1152,"address":[],"length":0,"stats":{"Line":59}},{"line":1153,"address":[],"length":0,"stats":{"Line":116}},{"line":1154,"address":[],"length":0,"stats":{"Line":150}},{"line":1155,"address":[],"length":0,"stats":{"Line":150}},{"line":1156,"address":[],"length":0,"stats":{"Line":50}},{"line":1159,"address":[],"length":0,"stats":{"Line":26}}],"covered":370,"coverable":576},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","utils","mod.rs"],"content":"pub mod narrowing_integration;\npub mod symbol_table;\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","utils","narrowing_integration.rs"],"content":"/// Integration module for type narrowing with the type checker\n/// This provides the scaffolding for how narrowing will be used during type checking\nuse crate::visitors::{narrow_type_from_condition, NarrowingContext};\nuse rustc_hash::FxHashMap;\nuse typedlua_parser::ast::expression::Expression;\nuse typedlua_parser::ast::types::Type;\nuse typedlua_parser::string_interner::{StringId, StringInterner};\n\n/// Demonstration of how type narrowing integrates with if statement checking\n///\n/// This is a template/example showing how the type checker would use narrowing\n/// when checking if statements. Full integration requires statement type checking\n/// which is not yet implemented.\npub struct IfStatementNarrowingExample;\n\nimpl IfStatementNarrowingExample {\n    /// Example: How to narrow types when type checking an if statement\n    ///\n    /// ```text\n    /// // Given code:\n    /// local x: string | nil = getValue()\n    /// if x != nil then\n    ///     -- In this branch, x is narrowed to string\n    ///     print(x.upper(x))  // Valid: x is string here\n    /// else\n    ///     -- In this branch, x is nil\n    ///     print(\"x is nil\")\n    /// end\n    /// ```\n    #[allow(dead_code)]\n    pub fn check_if_statement_with_narrowing(\n        condition: \u0026Expression,\n        base_context: \u0026NarrowingContext,\n        variable_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n        interner: \u0026StringInterner,\n    ) -\u003e (NarrowingContext, NarrowingContext) {\n        // Step 1: Analyze the condition to produce narrowed contexts\n        let (then_context, else_context) =\n            narrow_type_from_condition(condition, base_context, variable_types, interner);\n\n        (then_context, else_context)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::expression::{BinaryOp, ExpressionKind, Literal};\n    use typedlua_parser::ast::types::{PrimitiveType, TypeKind};\n    use typedlua_parser::ast::Spanned;\n    use typedlua_parser::span::Span;\n    use typedlua_parser::string_interner::StringId;\n\n    fn make_span() -\u003e Span {\n        Span::new(0, 0, 0, 0)\n    }\n\n    fn get_string_id(s: \u0026str, interner: \u0026StringInterner) -\u003e StringId {\n        interner.intern(s)\n    }\n\n    #[test]\n    fn test_if_statement_narrowing_example() {\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        // Setup: x: string | nil\n        let mut variable_types = FxHashMap::default();\n        let x_id = get_string_id(\"x\", \u0026interner);\n        variable_types.insert(\n            x_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Condition: x != nil\n        let condition = Expression::new(\n            ExpressionKind::Binary(\n                BinaryOp::NotEqual,\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(x_id),\n                    make_span(),\n                )),\n                Box::new(Expression::new(\n                    ExpressionKind::Literal(Literal::Nil),\n                    make_span(),\n                )),\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: x should be narrowed to string\n        let then_type = then_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            then_type.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // In else branch: x should be nil\n        let else_type = else_ctx\n            .get_narrowed_type(x_id)\n            .unwrap_or_else(|| variable_types.get(\u0026x_id).unwrap());\n        assert!(matches!(\n            else_type.kind,\n            TypeKind::Primitive(PrimitiveType::Nil)\n        ));\n    }\n\n    #[test]\n    fn test_typeof_narrowing_example() {\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        let mut variable_types = FxHashMap::default();\n        let x_id = get_string_id(\"x\", \u0026interner);\n        let typeof_id = get_string_id(\"typeof\", \u0026interner);\n        variable_types.insert(\n            x_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Condition: typeof(x) == \"string\"\n        let condition = Expression::new(\n            ExpressionKind::Binary(\n                BinaryOp::Equal,\n                Box::new(Expression::new(\n                    ExpressionKind::Call(\n                        Box::new(Expression::new(\n                            ExpressionKind::Identifier(typeof_id),\n                            make_span(),\n                        )),\n                        vec![typedlua_parser::ast::expression::Argument {\n                            value: Expression::new(ExpressionKind::Identifier(x_id), make_span()),\n                            is_spread: false,\n                            span: make_span(),\n                        }],\n                        None,\n                    ),\n                    make_span(),\n                )),\n                Box::new(Expression::new(\n                    ExpressionKind::Literal(Literal::String(\"string\".to_string())),\n                    make_span(),\n                )),\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: x should be string\n        let then_type = then_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            then_type.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // In else branch: x should be number\n        let else_type = else_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            else_type.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_type_guard_narrowing() {\n        use typedlua_parser::ast::types::{FunctionType, TypePredicate};\n\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        // Setup: x: string | number | nil\n        let mut variable_types = FxHashMap::default();\n        let x_id = get_string_id(\"x\", \u0026interner);\n        let is_string_id = get_string_id(\"isString\", \u0026interner);\n\n        // Register the variable type\n        variable_types.insert(\n            x_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                    Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Register isString as a type guard function: (x: any) =\u003e x is string\n        let type_predicate = TypePredicate {\n            parameter_name: Spanned::new(x_id, make_span()),\n            type_annotation: Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            )),\n            span: make_span(),\n        };\n        let func_type = FunctionType {\n            type_parameters: None,\n            parameters: vec![],\n            return_type: Box::new(Type::new(\n                TypeKind::TypePredicate(type_predicate),\n                make_span(),\n            )),\n            throws: None,\n            span: make_span(),\n        };\n        variable_types.insert(\n            is_string_id,\n            Type::new(TypeKind::Function(func_type), make_span()),\n        );\n\n        // Condition: isString(x)\n        let condition = Expression::new(\n            ExpressionKind::Call(\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(is_string_id),\n                    make_span(),\n                )),\n                vec![typedlua_parser::ast::expression::Argument {\n                    value: Expression::new(ExpressionKind::Identifier(x_id), make_span()),\n                    is_spread: false,\n                    span: make_span(),\n                }],\n                None,\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: x should be narrowed to string\n        let then_type = then_ctx.get_narrowed_type(x_id).unwrap();\n        assert!(matches!(\n            then_type.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // In else branch: x should be number | nil\n        let else_type = else_ctx.get_narrowed_type(x_id).unwrap();\n        if let TypeKind::Union(types) = \u0026else_type.kind {\n            assert_eq!(types.len(), 2);\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::Number))));\n            assert!(types\n                .iter()\n                .any(|t| matches!(t.kind, TypeKind::Primitive(PrimitiveType::Nil))));\n        } else {\n            panic!(\"Expected union type for else branch\");\n        }\n    }\n\n    #[test]\n    fn test_instanceof_narrowing() {\n        use typedlua_parser::ast::expression::ExpressionKind;\n        use typedlua_parser::ast::types::TypeReference;\n\n        let (interner, _) =\n            typedlua_parser::string_interner::StringInterner::new_with_common_identifiers();\n\n        let mut variable_types = FxHashMap::default();\n        let pet_id = get_string_id(\"pet\", \u0026interner);\n        let animal_id = get_string_id(\"Animal\", \u0026interner);\n        let dog_id = get_string_id(\"Dog\", \u0026interner);\n        variable_types.insert(\n            pet_id,\n            Type::new(\n                TypeKind::Union(vec![\n                    Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: Spanned::new(animal_id, make_span()),\n                            type_arguments: None,\n                            span: make_span(),\n                        }),\n                        make_span(),\n                    ),\n                    Type::new(\n                        TypeKind::Reference(TypeReference {\n                            name: Spanned::new(dog_id, make_span()),\n                            type_arguments: None,\n                            span: make_span(),\n                        }),\n                        make_span(),\n                    ),\n                ]),\n                make_span(),\n            ),\n        );\n\n        // Condition: pet instanceof Dog\n        let condition = Expression::new(\n            ExpressionKind::Binary(\n                BinaryOp::Instanceof,\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(pet_id),\n                    make_span(),\n                )),\n                Box::new(Expression::new(\n                    ExpressionKind::Identifier(dog_id),\n                    make_span(),\n                )),\n            ),\n            make_span(),\n        );\n\n        let base_context = NarrowingContext::new();\n\n        // Apply narrowing\n        let (then_ctx, _else_ctx) = IfStatementNarrowingExample::check_if_statement_with_narrowing(\n            \u0026condition,\n            \u0026base_context,\n            \u0026variable_types,\n            \u0026interner,\n        );\n\n        // In then branch: pet should be narrowed to Dog\n        let then_type = then_ctx.get_narrowed_type(pet_id).unwrap();\n        if let TypeKind::Reference(type_ref) = \u0026then_type.kind {\n            assert_eq!(type_ref.name.node, dog_id);\n        } else {\n            panic!(\"Expected reference type for then branch\");\n        }\n    }\n}\n","traces":[{"line":31,"address":[],"length":0,"stats":{"Line":4}},{"line":38,"address":[],"length":0,"stats":{"Line":8}},{"line":39,"address":[],"length":0,"stats":{"Line":16}},{"line":41,"address":[],"length":0,"stats":{"Line":4}}],"covered":4,"coverable":4},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","utils","symbol_table.rs"],"content":"use rustc_hash::FxHashMap;\nuse serde::{Deserialize, Serialize};\nuse typedlua_parser::ast::types::Type;\nuse typedlua_parser::span::Span;\n\n/// Kind of symbol (variable, function, class, etc.)\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum SymbolKind {\n    Variable,\n    Const,\n    Function,\n    Class,\n    Interface,\n    TypeAlias,\n    Enum,\n    Parameter,\n    Namespace,\n}\n\n/// A symbol in the symbol table\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct Symbol {\n    pub name: String,\n    pub kind: SymbolKind,\n    pub typ: Type,\n    pub span: Span,\n    pub is_exported: bool,\n    pub references: Vec\u003cSpan\u003e,\n}\n\nimpl Symbol {\n    pub fn new(name: String, kind: SymbolKind, typ: Type, span: Span) -\u003e Self {\n        Self {\n            name,\n            kind,\n            typ,\n            span,\n            is_exported: false,\n            references: Vec::new(),\n        }\n    }\n\n    /// Add a reference to this symbol\n    pub fn add_reference(\u0026mut self, span: Span) {\n        self.references.push(span);\n    }\n}\n\n/// A scope containing symbols\n#[derive(Debug, Clone)]\npub struct Scope {\n    symbols: FxHashMap\u003cString, Symbol\u003e,\n}\n\nimpl Scope {\n    pub fn new() -\u003e Self {\n        Self {\n            symbols: FxHashMap::default(),\n        }\n    }\n\n    /// Declare a symbol in this scope\n    pub fn declare(\u0026mut self, symbol: Symbol) -\u003e Result\u003c(), String\u003e {\n        if self.symbols.contains_key(\u0026symbol.name) {\n            return Err(format!(\n                \"Symbol '{}' already declared in this scope\",\n                symbol.name\n            ));\n        }\n        self.symbols.insert(symbol.name.clone(), symbol);\n        Ok(())\n    }\n\n    /// Look up a symbol in this scope only\n    pub fn lookup(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbols.get(name)\n    }\n\n    /// Look up a symbol only in this scope (not parent scopes)\n    pub fn lookup_local(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.symbols.get(name)\n    }\n\n    /// Get all symbols in this scope\n    pub fn symbols(\u0026self) -\u003e impl Iterator\u003cItem = \u0026Symbol\u003e {\n        self.symbols.values()\n    }\n}\n\nimpl Default for Scope {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Symbol table managing scopes\n#[derive(Debug)]\npub struct SymbolTable {\n    current_scope: Scope,\n    scope_stack: Vec\u003cScope\u003e,\n}\n\nimpl SymbolTable {\n    pub fn new() -\u003e Self {\n        Self {\n            current_scope: Scope::new(),\n            scope_stack: Vec::new(),\n        }\n    }\n\n    /// Enter a new scope (O(1) - no cloning)\n    pub fn enter_scope(\u0026mut self) {\n        let parent = std::mem::take(\u0026mut self.current_scope);\n        self.scope_stack.push(parent);\n    }\n\n    /// Exit current scope\n    pub fn exit_scope(\u0026mut self) {\n        if let Some(parent) = self.scope_stack.pop() {\n            self.current_scope = parent;\n        }\n    }\n\n    /// Declare a symbol in the current scope\n    pub fn declare(\u0026mut self, symbol: Symbol) -\u003e Result\u003c(), String\u003e {\n        self.current_scope.declare(symbol)\n    }\n\n    /// Look up a symbol in current scope, then walk the scope stack (most recent first)\n    pub fn lookup(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        if let Some(symbol) = self.current_scope.symbols.get(name) {\n            return Some(symbol);\n        }\n        for scope in self.scope_stack.iter().rev() {\n            if let Some(symbol) = scope.symbols.get(name) {\n                return Some(symbol);\n            }\n        }\n        None\n    }\n\n    /// Look up a symbol only in the current scope\n    pub fn lookup_local(\u0026self, name: \u0026str) -\u003e Option\u003c\u0026Symbol\u003e {\n        self.current_scope.lookup_local(name)\n    }\n\n    /// Add a reference to a symbol\n    /// Returns true if the symbol was found and reference was added\n    pub fn add_reference(\u0026mut self, name: \u0026str, span: Span) -\u003e bool {\n        // Try current scope first\n        if let Some(symbol) = self.current_scope.symbols.get_mut(name) {\n            symbol.add_reference(span);\n            return true;\n        }\n\n        // Walk the scope stack (most recent first)\n        for scope in self.scope_stack.iter_mut().rev() {\n            if let Some(symbol) = scope.symbols.get_mut(name) {\n                symbol.add_reference(span);\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Get the current scope\n    pub fn current_scope(\u0026self) -\u003e \u0026Scope {\n        \u0026self.current_scope\n    }\n\n    /// Get all symbols visible from the current scope (current + all parent scopes on stack)\n    pub fn all_visible_symbols(\u0026self) -\u003e FxHashMap\u003cString, \u0026Symbol\u003e {\n        let mut result = FxHashMap::default();\n\n        // Add from oldest scope to newest so newer scopes shadow older ones\n        for scope in \u0026self.scope_stack {\n            for (name, symbol) in \u0026scope.symbols {\n                result.insert(name.clone(), symbol);\n            }\n        }\n\n        // Current scope shadows everything\n        for (name, symbol) in \u0026self.current_scope.symbols {\n            result.insert(name.clone(), symbol);\n        }\n\n        result\n    }\n}\n\nimpl Default for SymbolTable {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n/// Serializable representation of a symbol with scope depth\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SerializableSymbol {\n    pub name: String,\n    pub kind: SymbolKind,\n    pub typ: Type,\n    pub span: Span,\n    pub is_exported: bool,\n    pub references: Vec\u003cSpan\u003e,\n    pub scope_depth: usize,\n}\n\n/// Serializable representation of SymbolTable (flattened scopes)\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SerializableSymbolTable {\n    pub symbols: Vec\u003cSerializableSymbol\u003e,\n}\n\nimpl SymbolTable {\n    /// Convert to serializable format by flattening scope hierarchy\n    pub fn to_serializable(\u0026self) -\u003e SerializableSymbolTable {\n        let mut symbols = Vec::new();\n\n        // Scope stack: depth 0 = oldest (bottom of stack), increasing depth\n        for (depth, scope) in self.scope_stack.iter().enumerate() {\n            for symbol in scope.symbols.values() {\n                symbols.push(SerializableSymbol {\n                    name: symbol.name.clone(),\n                    kind: symbol.kind,\n                    typ: symbol.typ.clone(),\n                    span: symbol.span,\n                    is_exported: symbol.is_exported,\n                    references: symbol.references.clone(),\n                    scope_depth: depth,\n                });\n            }\n        }\n\n        // Current scope is the deepest\n        let current_depth = self.scope_stack.len();\n        for symbol in self.current_scope.symbols.values() {\n            symbols.push(SerializableSymbol {\n                name: symbol.name.clone(),\n                kind: symbol.kind,\n                typ: symbol.typ.clone(),\n                span: symbol.span,\n                is_exported: symbol.is_exported,\n                references: symbol.references.clone(),\n                scope_depth: current_depth,\n            });\n        }\n\n        SerializableSymbolTable { symbols }\n    }\n\n    /// Reconstruct from serializable format\n    pub fn from_serializable(data: SerializableSymbolTable) -\u003e Self {\n        // Group symbols by scope depth\n        let mut symbols_by_depth: FxHashMap\u003cusize, Vec\u003cSerializableSymbol\u003e\u003e = FxHashMap::default();\n        for symbol in data.symbols {\n            symbols_by_depth\n                .entry(symbol.scope_depth)\n                .or_default()\n                .push(symbol);\n        }\n\n        let max_depth = symbols_by_depth.keys().max().copied().unwrap_or(0);\n\n        // Build scope stack from depth 0 to max_depth-1, current_scope = max_depth\n        let mut scope_stack = Vec::new();\n        for depth in 0..max_depth {\n            let mut scope = Scope::new();\n            if let Some(symbols) = symbols_by_depth.get(\u0026depth) {\n                for serializable in symbols {\n                    let symbol = Symbol {\n                        name: serializable.name.clone(),\n                        kind: serializable.kind,\n                        typ: serializable.typ.clone(),\n                        span: serializable.span,\n                        is_exported: serializable.is_exported,\n                        references: serializable.references.clone(),\n                    };\n                    scope.symbols.insert(symbol.name.clone(), symbol);\n                }\n            }\n            scope_stack.push(scope);\n        }\n\n        // Current scope is the deepest level\n        let mut current_scope = Scope::new();\n        if let Some(symbols) = symbols_by_depth.get(\u0026max_depth) {\n            for serializable in symbols {\n                let symbol = Symbol {\n                    name: serializable.name.clone(),\n                    kind: serializable.kind,\n                    typ: serializable.typ.clone(),\n                    span: serializable.span,\n                    is_exported: serializable.is_exported,\n                    references: serializable.references.clone(),\n                };\n                current_scope.symbols.insert(symbol.name.clone(), symbol);\n            }\n        }\n\n        SymbolTable {\n            current_scope,\n            scope_stack,\n        }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::ast::types::{PrimitiveType, TypeKind};\n\n    fn make_test_type() -\u003e Type {\n        Type::new(\n            TypeKind::Primitive(PrimitiveType::Number),\n            Span::new(0, 0, 0, 0),\n        )\n    }\n\n    #[test]\n    fn test_scope_declare_and_lookup() {\n        let mut scope = Scope::new();\n        let symbol = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n\n        scope.declare(symbol).unwrap();\n        assert!(scope.lookup(\"x\").is_some());\n        assert!(scope.lookup(\"y\").is_none());\n    }\n\n    #[test]\n    fn test_scope_duplicate_declaration() {\n        let mut scope = Scope::new();\n        let symbol1 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        let symbol2 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n\n        scope.declare(symbol1).unwrap();\n        assert!(scope.declare(symbol2).is_err());\n    }\n\n    #[test]\n    fn test_symbol_table_scopes() {\n        let mut table = SymbolTable::new();\n\n        // Declare in global scope\n        let symbol1 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        table.declare(symbol1).unwrap();\n\n        // Enter new scope\n        table.enter_scope();\n\n        // Should still see x from parent scope via stack walk\n        assert!(table.lookup(\"x\").is_some());\n\n        // Declare y in inner scope\n        let symbol2 = Symbol::new(\n            \"y\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        table.declare(symbol2).unwrap();\n\n        assert!(table.lookup(\"y\").is_some());\n\n        // Exit scope\n        table.exit_scope();\n\n        // y should no longer be visible\n        assert!(table.lookup(\"y\").is_none());\n        // x should still be visible\n        assert!(table.lookup(\"x\").is_some());\n    }\n\n    #[test]\n    fn test_symbol_table_shadowing() {\n        let mut table = SymbolTable::new();\n\n        // Declare x in global scope\n        let symbol1 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Variable,\n            make_test_type(),\n            Span::new(0, 0, 0, 0),\n        );\n        table.declare(symbol1).unwrap();\n\n        // Enter new scope and shadow x\n        table.enter_scope();\n        let symbol2 = Symbol::new(\n            \"x\".to_string(),\n            SymbolKind::Const,\n            make_test_type(),\n            Span::new(1, 1, 1, 1),\n        );\n        table.declare(symbol2).unwrap();\n\n        // Should see the inner x\n        let x = table.lookup(\"x\").unwrap();\n        assert_eq!(x.kind, SymbolKind::Const);\n\n        // Exit scope\n        table.exit_scope();\n\n        // Should see the outer x again\n        let x = table.lookup(\"x\").unwrap();\n        assert_eq!(x.kind, SymbolKind::Variable);\n    }\n}\n","traces":[{"line":32,"address":[],"length":0,"stats":{"Line":1690}},{"line":39,"address":[],"length":0,"stats":{"Line":1690}},{"line":44,"address":[],"length":0,"stats":{"Line":104}},{"line":45,"address":[],"length":0,"stats":{"Line":312}},{"line":56,"address":[],"length":0,"stats":{"Line":726}},{"line":58,"address":[],"length":0,"stats":{"Line":726}},{"line":63,"address":[],"length":0,"stats":{"Line":1881}},{"line":64,"address":[],"length":0,"stats":{"Line":5643}},{"line":65,"address":[],"length":0,"stats":{"Line":10}},{"line":66,"address":[],"length":0,"stats":{"Line":10}},{"line":67,"address":[],"length":0,"stats":{"Line":10}},{"line":70,"address":[],"length":0,"stats":{"Line":9355}},{"line":71,"address":[],"length":0,"stats":{"Line":1871}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":12}},{"line":80,"address":[],"length":0,"stats":{"Line":7}},{"line":81,"address":[],"length":0,"stats":{"Line":21}},{"line":85,"address":[],"length":0,"stats":{"Line":2}},{"line":86,"address":[],"length":0,"stats":{"Line":4}},{"line":91,"address":[],"length":0,"stats":{"Line":351}},{"line":92,"address":[],"length":0,"stats":{"Line":351}},{"line":104,"address":[],"length":0,"stats":{"Line":366}},{"line":106,"address":[],"length":0,"stats":{"Line":366}},{"line":107,"address":[],"length":0,"stats":{"Line":366}},{"line":112,"address":[],"length":0,"stats":{"Line":351}},{"line":113,"address":[],"length":0,"stats":{"Line":1053}},{"line":114,"address":[],"length":0,"stats":{"Line":1053}},{"line":118,"address":[],"length":0,"stats":{"Line":345}},{"line":119,"address":[],"length":0,"stats":{"Line":1033}},{"line":120,"address":[],"length":0,"stats":{"Line":344}},{"line":125,"address":[],"length":0,"stats":{"Line":1870}},{"line":126,"address":[],"length":0,"stats":{"Line":5610}},{"line":130,"address":[],"length":0,"stats":{"Line":301}},{"line":131,"address":[],"length":0,"stats":{"Line":713}},{"line":132,"address":[],"length":0,"stats":{"Line":111}},{"line":134,"address":[],"length":0,"stats":{"Line":5420}},{"line":135,"address":[],"length":0,"stats":{"Line":10257}},{"line":136,"address":[],"length":0,"stats":{"Line":177}},{"line":139,"address":[],"length":0,"stats":{"Line":13}},{"line":143,"address":[],"length":0,"stats":{"Line":2}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":149,"address":[],"length":0,"stats":{"Line":103}},{"line":151,"address":[],"length":0,"stats":{"Line":307}},{"line":152,"address":[],"length":0,"stats":{"Line":303}},{"line":153,"address":[],"length":0,"stats":{"Line":101}},{"line":157,"address":[],"length":0,"stats":{"Line":5}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":159,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":168,"address":[],"length":0,"stats":{"Line":1}},{"line":169,"address":[],"length":0,"stats":{"Line":1}},{"line":173,"address":[],"length":0,"stats":{"Line":20}},{"line":174,"address":[],"length":0,"stats":{"Line":40}},{"line":177,"address":[],"length":0,"stats":{"Line":76}},{"line":178,"address":[],"length":0,"stats":{"Line":156}},{"line":179,"address":[],"length":0,"stats":{"Line":128}},{"line":184,"address":[],"length":0,"stats":{"Line":4052}},{"line":185,"address":[],"length":0,"stats":{"Line":4032}},{"line":188,"address":[],"length":0,"stats":{"Line":20}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":228,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":0}},{"line":246,"address":[],"length":0,"stats":{"Line":0}},{"line":254,"address":[],"length":0,"stats":{"Line":0}},{"line":256,"address":[],"length":0,"stats":{"Line":0}},{"line":257,"address":[],"length":0,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[],"length":0,"stats":{"Line":0}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":264,"address":[],"length":0,"stats":{"Line":0}},{"line":267,"address":[],"length":0,"stats":{"Line":0}},{"line":268,"address":[],"length":0,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":0}},{"line":270,"address":[],"length":0,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":273,"address":[],"length":0,"stats":{"Line":0}},{"line":274,"address":[],"length":0,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[],"length":0,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[],"length":0,"stats":{"Line":0}},{"line":280,"address":[],"length":0,"stats":{"Line":0}},{"line":283,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":294,"address":[],"length":0,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":298,"address":[],"length":0,"stats":{"Line":0}}],"covered":60,"coverable":114},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","access_control","access_control_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::visitors::{\n        AccessControl, AccessControlVisitor, ClassContext, ClassMemberInfo, ClassMemberKind,\n        TypeCheckVisitor,\n    };\n    use typedlua_parser::ast::statement::AccessModifier;\n    use typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\n    use typedlua_parser::prelude::OperatorKind;\n    use typedlua_parser::span::Span;\n\n    fn create_test_member(name: \u0026str, access: AccessModifier) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Property {\n                type_annotation: Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    Span::default(),\n                ),\n            },\n            is_final: false,\n        }\n    }\n\n    fn create_test_method(name: \u0026str, access: AccessModifier) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Method {\n                parameters: vec![],\n                return_type: None,\n                is_abstract: false,\n            },\n            is_final: false,\n        }\n    }\n\n    fn create_test_getter(\n        name: \u0026str,\n        access: AccessModifier,\n        return_type: Type,\n    ) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Getter { return_type },\n            is_final: false,\n        }\n    }\n\n    fn create_test_setter(name: \u0026str, access: AccessModifier, param_type: Type) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: false,\n            kind: ClassMemberKind::Setter {\n                parameter_type: param_type,\n            },\n            is_final: false,\n        }\n    }\n\n    fn create_test_operator(\n        name: \u0026str,\n        access: AccessModifier,\n        operator: OperatorKind,\n    ) -\u003e ClassMemberInfo {\n        ClassMemberInfo {\n            name: name.to_string(),\n            access,\n            _is_static: true,\n            kind: ClassMemberKind::Operator {\n                operator,\n                parameters: vec![],\n                return_type: None,\n            },\n            is_final: false,\n        }\n    }\n\n    #[test]\n    fn test_access_control_visitor_name() {\n        let access_control = AccessControl::new();\n        assert_eq!(access_control.name(), \"AccessControl\");\n    }\n\n    #[test]\n    fn test_public_member_accessible_from_anywhere() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a public member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"publicProp\", AccessModifier::Public),\n        );\n\n        // Access from outside the class (no current class context)\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"publicProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Public members should be accessible from anywhere\"\n        );\n    }\n\n    #[test]\n    fn test_private_member_accessible_within_same_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a private member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n\n        // Access from within the same class\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Private members should be accessible within the same class\"\n        );\n    }\n\n    #[test]\n    fn test_private_member_not_accessible_from_other_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a private member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n\n        // Try to access from a different class\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Private members should not be accessible from other classes\"\n        );\n        let err = result.unwrap_err();\n        assert!(\n            err.message.contains(\"private\"),\n            \"Error message should mention 'private'\"\n        );\n        assert!(\n            err.message.contains(\"privateProp\"),\n            \"Error message should mention the member name\"\n        );\n    }\n\n    #[test]\n    fn test_private_member_not_accessible_from_outside() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a private member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n\n        // Try to access from outside any class\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Private members should not be accessible from outside classes\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_accessible_within_same_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a protected member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Access from within the same class\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected members should be accessible within the same class\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_accessible_from_subclass() {\n        let mut access_control = AccessControl::new();\n\n        // Register a parent class with a protected member\n        access_control.register_class(\"ParentClass\", None);\n        access_control.register_member(\n            \"ParentClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Register a child class\n        access_control.register_class(\"ChildClass\", Some(\"ParentClass\".to_string()));\n\n        // Access from the child class context\n        let current_class = Some(ClassContext {\n            name: \"ChildClass\".to_string(),\n            parent: Some(\"ParentClass\".to_string()),\n            extends_type: None,\n        });\n\n        // Set the current class for is_subclass check\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"ParentClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected members should be accessible from subclasses\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_not_accessible_from_unrelated_class() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a protected member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Try to access from an unrelated class\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Protected members should not be accessible from unrelated classes\"\n        );\n        let err = result.unwrap_err();\n        assert!(\n            err.message.contains(\"protected\"),\n            \"Error message should mention 'protected'\"\n        );\n    }\n\n    #[test]\n    fn test_protected_member_not_accessible_from_outside() {\n        let mut access_control = AccessControl::new();\n\n        // Register a class with a protected member\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        // Try to access from outside any class\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Protected members should not be accessible from outside classes\"\n        );\n    }\n\n    #[test]\n    fn test_member_not_found_allows_access() {\n        let access_control = AccessControl::new();\n\n        // Try to access a member that doesn't exist\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"nonExistentProp\",\n            Span::default(),\n        );\n\n        assert!(result.is_err(), \"Access to nonexistent members should fail\");\n    }\n\n    #[test]\n    fn test_class_registration() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"TestClass\", Some(\"ParentClass\".to_string()));\n\n        // Verify class is registered by checking we can add members\n        access_control.register_member(\n            \"TestClass\",\n            create_test_member(\"prop\", AccessModifier::Public),\n        );\n        let members = access_control.get_class_members(\"TestClass\");\n        assert!(members.is_some(), \"Class should be registered\");\n        assert_eq!(members.unwrap().len(), 1, \"Class should have one member\");\n    }\n\n    #[test]\n    fn test_final_class_marking() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"FinalClass\", None);\n        assert!(\n            !access_control.is_class_final(\"FinalClass\"),\n            \"Class should not be final by default\"\n        );\n\n        access_control.mark_class_final(\"FinalClass\", true);\n        assert!(\n            access_control.is_class_final(\"FinalClass\"),\n            \"Class should be marked as final\"\n        );\n\n        access_control.mark_class_final(\"FinalClass\", false);\n        assert!(\n            !access_control.is_class_final(\"FinalClass\"),\n            \"Class should no longer be final\"\n        );\n    }\n\n    #[test]\n    fn test_current_class_context() {\n        let mut access_control = AccessControl::new();\n\n        // Initially no current class\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Should have no current class initially\"\n        );\n\n        // Set current class\n        let context = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: Some(\"ParentClass\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(context.clone());\n\n        let retrieved = access_control.get_current_class();\n        assert!(retrieved.is_some(), \"Should have a current class\");\n        assert_eq!(\n            retrieved.as_ref().unwrap().name,\n            \"MyClass\",\n            \"Current class name should match\"\n        );\n        assert_eq!(\n            retrieved.as_ref().unwrap().parent,\n            Some(\"ParentClass\".to_string()),\n            \"Parent class should match\"\n        );\n\n        // Clear current class\n        access_control.set_current_class(None);\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Current class should be cleared\"\n        );\n    }\n\n    #[test]\n    fn test_is_subclass_direct_parent() {\n        let mut access_control = AccessControl::new();\n\n        // Register parent and child\n        access_control.register_class(\"ParentClass\", None);\n        access_control.register_class(\"ChildClass\", Some(\"ParentClass\".to_string()));\n\n        // Set current class context for the child\n        access_control.set_current_class(Some(ClassContext {\n            name: \"ChildClass\".to_string(),\n            parent: Some(\"ParentClass\".to_string()),\n            extends_type: None,\n        }));\n\n        assert!(\n            access_control.is_subclass(\"ChildClass\", \"ParentClass\"),\n            \"ChildClass should be a subclass of ParentClass\"\n        );\n        assert!(\n            !access_control.is_subclass(\"ParentClass\", \"ChildClass\"),\n            \"ParentClass should not be a subclass of ChildClass\"\n        );\n    }\n\n    #[test]\n    fn test_is_subclass_unrelated_classes() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"ClassA\", None);\n        access_control.register_class(\"ClassB\", None);\n\n        access_control.set_current_class(Some(ClassContext {\n            name: \"ClassA\".to_string(),\n            parent: None,\n            extends_type: None,\n        }));\n\n        assert!(\n            !access_control.is_subclass(\"ClassA\", \"ClassB\"),\n            \"Unrelated classes should not be subclasses\"\n        );\n    }\n\n    #[test]\n    fn test_multiple_members_same_class() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"publicProp\", AccessModifier::Public),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"privateProp\", AccessModifier::Private),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        let members = access_control.get_class_members(\"MyClass\").unwrap();\n        assert_eq!(members.len(), 3, \"Class should have three members\");\n    }\n\n    #[test]\n    fn test_method_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_method(\"publicMethod\", AccessModifier::Public),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_method(\"privateMethod\", AccessModifier::Private),\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        // Public method should be accessible\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"publicMethod\",\n            Span::default(),\n        );\n        assert!(result.is_ok(), \"Public method should be accessible\");\n\n        // Private method should be accessible within same class\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"privateMethod\",\n            Span::default(),\n        );\n        assert!(\n            result.is_ok(),\n            \"Private method should be accessible within same class\"\n        );\n    }\n\n    #[test]\n    fn test_error_message_contains_relevant_info() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"secret\", AccessModifier::Private),\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"secret\",\n            Span::default(),\n        );\n        let err = result.unwrap_err();\n\n        assert!(\n            err.message.contains(\"secret\"),\n            \"Error should mention the member name\"\n        );\n        assert!(\n            err.message.contains(\"MyClass\"),\n            \"Error should mention the class name\"\n        );\n        assert!(\n            err.message.contains(\"private\"),\n            \"Error should mention the access modifier\"\n        );\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Access Control Tests\n    // ========================================================================\n\n    #[test]\n    fn test_protected_access_from_grandchild_class() {\n        let mut access_control = AccessControl::new();\n\n        // Set up inheritance hierarchy: GrandParent -\u003e Parent -\u003e Child\n        access_control.register_class(\"GrandParent\", None);\n        access_control.register_member(\n            \"GrandParent\",\n            create_test_member(\"familySecret\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"Parent\", Some(\"GrandParent\".to_string()));\n        access_control.register_class(\"Child\", Some(\"Parent\".to_string()));\n\n        // Access from grandchild\n        // Note: Current is_subclass implementation only checks direct parent\n        // For full hierarchy support, the context would need grandparent info\n        let current_class = Some(ClassContext {\n            name: \"Child\".to_string(),\n            parent: Some(\"GrandParent\".to_string()), // Directly set to GrandParent for test\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"GrandParent\",\n            \"familySecret\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected members should be accessible from grandchild classes\"\n        );\n    }\n\n    #[test]\n    fn test_protected_access_from_sibling_class() {\n        let mut access_control = AccessControl::new();\n\n        // Set up sibling classes with common parent\n        access_control.register_class(\"Parent\", None);\n        access_control.register_member(\n            \"Parent\",\n            create_test_member(\"protectedProp\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"Child1\", Some(\"Parent\".to_string()));\n        access_control.register_class(\"Child2\", Some(\"Parent\".to_string()));\n\n        // Both siblings can access the protected member from Parent\n        // because they both inherit from Parent\n        let current_class = Some(ClassContext {\n            name: \"Child2\".to_string(),\n            parent: Some(\"Parent\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"Parent\",\n            \"protectedProp\",\n            Span::default(),\n        );\n\n        // Child2 can access Parent's protected member because Child2 is a subclass of Parent\n        assert!(\n            result.is_ok(),\n            \"Child2 should be able to access Parent's protected member\"\n        );\n    }\n\n    #[test]\n    fn test_static_public_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticProp\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        // Static public members should be accessible from anywhere\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"staticProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Static public members should be accessible from anywhere\"\n        );\n    }\n\n    #[test]\n    fn test_static_private_member_access_from_same_class() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticPrivate\".to_string(),\n                access: AccessModifier::Private,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"staticPrivate\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Static private members should be accessible within the same class\"\n        );\n    }\n\n    #[test]\n    fn test_static_private_member_not_accessible_from_other_class() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticPrivate\".to_string(),\n                access: AccessModifier::Private,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"OtherClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"staticPrivate\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_err(),\n            \"Static private members should not be accessible from other classes\"\n        );\n    }\n\n    #[test]\n    fn test_access_nonexistent_member() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        // Don't register any members\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"nonexistent\",\n            Span::default(),\n        );\n\n        // Nonexistent members should fail\n        assert!(result.is_err(), \"Accessing nonexistent member should fail\");\n    }\n\n    #[test]\n    fn test_access_nonexistent_class() {\n        let access_control = AccessControl::new();\n\n        let current_class: Option\u003cClassContext\u003e = None;\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"NonexistentClass\",\n            \"someProp\",\n            Span::default(),\n        );\n\n        // Nonexistent classes should fail\n        assert!(\n            result.is_err(),\n            \"Accessing member of nonexistent class should fail\"\n        );\n    }\n\n    #[test]\n    fn test_is_not_subclass_of_unrelated() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"ClassA\", None);\n        access_control.register_class(\"ClassB\", None);\n\n        // Set current class context\n        let context = Some(ClassContext {\n            name: \"ClassA\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        access_control.set_current_class(context);\n\n        assert!(\n            !access_control.is_subclass(\"ClassA\", \"ClassB\"),\n            \"ClassA should not be subclass of ClassB\"\n        );\n    }\n\n    #[test]\n    fn test_get_class_members() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"prop1\", AccessModifier::Public),\n        );\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"prop2\", AccessModifier::Private),\n        );\n\n        let members = access_control.get_class_members(\"MyClass\");\n        assert!(members.is_some(), \"Should return Some for existing class\");\n        assert_eq!(members.unwrap().len(), 2, \"Should return all class members\");\n    }\n\n    #[test]\n    fn test_get_class_members_nonexistent() {\n        let access_control = AccessControl::new();\n\n        let members = access_control.get_class_members(\"NonexistentClass\");\n        assert!(members.is_none(), \"Nonexistent class should return None\");\n    }\n\n    #[test]\n    fn test_class_final_status() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n\n        // Initially not final\n        assert!(\n            !access_control.is_class_final(\"MyClass\"),\n            \"Class should not be final initially\"\n        );\n\n        // Mark as final\n        access_control.mark_class_final(\"MyClass\", true);\n        assert!(\n            access_control.is_class_final(\"MyClass\"),\n            \"Class should be final after marking\"\n        );\n\n        // Mark as not final again\n        access_control.mark_class_final(\"MyClass\", false);\n        assert!(\n            !access_control.is_class_final(\"MyClass\"),\n            \"Class should not be final after unmarking\"\n        );\n    }\n\n    #[test]\n    fn test_final_class_cannot_be_extended() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"FinalClass\", None);\n        access_control.mark_class_final(\"FinalClass\", true);\n\n        // Check that the class is marked as final\n        assert!(\n            access_control.is_class_final(\"FinalClass\"),\n            \"Class should be final\"\n        );\n    }\n\n    #[test]\n    fn test_set_and_get_current_class() {\n        let mut access_control = AccessControl::new();\n\n        // Initially no current class\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Should have no current class initially\"\n        );\n\n        // Set current class\n        let context = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n        access_control.set_current_class(context.clone());\n\n        // Verify current class is set\n        let current = access_control.get_current_class();\n        assert!(current.is_some(), \"Should have current class after setting\");\n        assert_eq!(\n            current.as_ref().unwrap().name,\n            \"MyClass\",\n            \"Current class name should match\"\n        );\n\n        // Clear current class\n        access_control.set_current_class(None);\n        assert!(\n            access_control.get_current_class().is_none(),\n            \"Should have no current class after clearing\"\n        );\n    }\n\n    #[test]\n    fn test_getter_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"value\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Getter {\n                    return_type: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result =\n            access_control.check_member_access(\u0026current_class, \"MyClass\", \"value\", Span::default());\n\n        assert!(result.is_ok(), \"Getter should be accessible\");\n    }\n\n    #[test]\n    fn test_setter_member_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"value\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Setter {\n                    parameter_type: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"MyClass\".to_string(),\n            parent: None,\n            extends_type: None,\n        });\n\n        let result =\n            access_control.check_member_access(\u0026current_class, \"MyClass\", \"value\", Span::default());\n\n        assert!(result.is_ok(), \"Setter should be accessible\");\n    }\n\n    #[test]\n    fn test_operator_overload_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"__add\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Operator {\n                    operator: OperatorKind::Add,\n                    parameters: vec![],\n                    return_type: None,\n                },\n                is_final: false,\n            },\n        );\n\n        let current_class: Option\u003cClassContext\u003e = None;\n\n        let result =\n            access_control.check_member_access(\u0026current_class, \"MyClass\", \"__add\", Span::default());\n\n        assert!(result.is_ok(), \"Operator overload should be accessible\");\n    }\n\n    #[test]\n    fn test_final_property_access() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            create_test_member(\"constProp\", AccessModifier::Public),\n        );\n        access_control.register_class(\"MyClass\", None);\n        let mut member = create_test_member(\"constProp\", AccessModifier::Public);\n        member.is_final = true;\n        access_control.register_member(\"MyClass\", member);\n\n        let current_class: Option\u003cClassContext\u003e = None;\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"MyClass\",\n            \"constProp\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Final property should be accessible for reading\"\n        );\n    }\n\n    #[test]\n    fn test_protected_access_from_great_grandchild() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"GreatGrandParent\", None);\n        access_control.register_member(\n            \"GreatGrandParent\",\n            create_test_member(\"ancestral\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"GrandParent\", Some(\"GreatGrandParent\".to_string()));\n        access_control.register_class(\"Parent\", Some(\"GrandParent\".to_string()));\n        access_control.register_class(\"Child\", Some(\"Parent\".to_string()));\n\n        let current_class = Some(ClassContext {\n            name: \"Child\".to_string(),\n            parent: Some(\"Parent\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        let result = access_control.check_member_access(\n            \u0026current_class,\n            \"GreatGrandParent\",\n            \"ancestral\",\n            Span::default(),\n        );\n\n        assert!(\n            result.is_ok(),\n            \"Protected member should be accessible from great-grandchild\"\n        );\n    }\n\n    #[test]\n    fn test_is_class_final_nonexistent() {\n        let access_control = AccessControl::new();\n\n        assert!(\n            !access_control.is_class_final(\"NonExistentClass\"),\n            \"Nonexistent class should not be considered final\"\n        );\n    }\n\n    #[test]\n    fn test_register_class_implements() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_class_implements(\n            \"MyClass\",\n            vec![\"Printable\".to_string(), \"Cloneable\".to_string()],\n        );\n\n        let interfaces = access_control.get_class_implements(\"MyClass\");\n        assert!(\n            interfaces.is_some(),\n            \"Should return Some for existing class\"\n        );\n        let interfaces = interfaces.unwrap();\n        assert_eq!(interfaces.len(), 2, \"Should have two interfaces\");\n        assert!(interfaces.contains(\u0026\"Printable\".to_string()));\n        assert!(interfaces.contains(\u0026\"Cloneable\".to_string()));\n    }\n\n    #[test]\n    fn test_get_class_implements_nonexistent() {\n        let access_control = AccessControl::new();\n\n        let interfaces = access_control.get_class_implements(\"NonExistentClass\");\n        assert!(interfaces.is_none(), \"Nonexistent class should return None\");\n    }\n\n    #[test]\n    fn test_mixed_static_and_instance_members() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"MyClass\", None);\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"instanceProp\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: false,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n        access_control.register_member(\n            \"MyClass\",\n            ClassMemberInfo {\n                name: \"staticProp\".to_string(),\n                access: AccessModifier::Public,\n                _is_static: true,\n                kind: ClassMemberKind::Property {\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                },\n                is_final: false,\n            },\n        );\n\n        let members = access_control.get_class_members(\"MyClass\").unwrap();\n        assert_eq!(members.len(), 2, \"Class should have both members\");\n    }\n\n    #[test]\n    fn test_protected_with_same_named_member_in_child() {\n        let mut access_control = AccessControl::new();\n\n        access_control.register_class(\"Parent\", None);\n        access_control.register_member(\n            \"Parent\",\n            create_test_member(\"value\", AccessModifier::Protected),\n        );\n\n        access_control.register_class(\"Child\", Some(\"Parent\".to_string()));\n        access_control.register_member(\n            \"Child\",\n            create_test_member(\"value\", AccessModifier::Private),\n        );\n\n        let current_class = Some(ClassContext {\n            name: \"Child\".to_string(),\n            parent: Some(\"Parent\".to_string()),\n            extends_type: None,\n        });\n        access_control.set_current_class(current_class.clone());\n\n        // Child should be able to access its own private member\n        let result =\n            access_control.check_member_access(\u0026current_class, \"Child\", \"value\", Span::default());\n        assert!(result.is_ok(), \"Child should access its own private member\");\n\n        // Parent's protected member should still be accessible\n        let result =\n            access_control.check_member_access(\u0026current_class, \"Parent\", \"value\", Span::default());\n        assert!(\n            result.is_ok(),\n            \"Child should access parent's protected member\"\n        );\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","access_control.rs"],"content":"use super::TypeCheckVisitor;\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse typedlua_parser::ast::statement::{AccessModifier, Parameter};\nuse typedlua_parser::ast::types::Type;\nuse typedlua_parser::prelude::OperatorKind;\nuse typedlua_parser::span::Span;\n\n/// Information about a class member for access checking\n#[derive(Clone)]\npub struct ClassMemberInfo {\n    pub(crate) name: String,\n    pub(crate) access: AccessModifier,\n    pub(crate) _is_static: bool,\n    pub(crate) kind: ClassMemberKind,\n    pub(crate) is_final: bool,\n}\n\n#[derive(Clone)]\npub enum ClassMemberKind {\n    Property {\n        type_annotation: Type,\n    },\n    Method {\n        parameters: Vec\u003cParameter\u003e,\n        return_type: Option\u003cType\u003e,\n        is_abstract: bool,\n    },\n    Getter {\n        return_type: Type,\n    },\n    Setter {\n        parameter_type: Type,\n    },\n    Operator {\n        operator: OperatorKind,\n        parameters: Vec\u003cParameter\u003e,\n        return_type: Option\u003cType\u003e,\n    },\n}\n\n/// Context for tracking the current class during type checking\n#[derive(Clone)]\npub struct ClassContext {\n    pub(crate) name: String,\n    pub(crate) parent: Option\u003cString\u003e,\n    /// The full extends type (preserves type arguments for generic parent classes)\n    pub(crate) extends_type: Option\u003ctypedlua_parser::ast::types::Type\u003e,\n}\n\n/// Trait for access control checks on class members\npub trait AccessControlVisitor: TypeCheckVisitor {\n    /// Check if access to a class member is allowed based on access modifier\n    fn check_member_access(\n        \u0026self,\n        current_class: \u0026Option\u003cClassContext\u003e,\n        class_name: \u0026str,\n        member_name: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e;\n\n    /// Check if a class is a subclass of another\n    fn is_subclass(\u0026self, child: \u0026str, ancestor: \u0026str) -\u003e bool;\n\n    /// Register a class with its members\n    fn register_class(\u0026mut self, name: \u0026str, parent: Option\u003cString\u003e);\n\n    /// Register a class member\n    fn register_member(\u0026mut self, class_name: \u0026str, member: ClassMemberInfo);\n\n    /// Mark a class as final\n    fn mark_class_final(\u0026mut self, name: \u0026str, is_final: bool);\n\n    /// Check if a class is marked as final\n    fn is_class_final(\u0026self, name: \u0026str) -\u003e bool;\n\n    /// Get class members\n    fn get_class_members(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cClassMemberInfo\u003e\u003e;\n\n    /// Get parent class name\n    fn get_parent_class(\u0026self, class_name: \u0026str) -\u003e Option\u003cString\u003e;\n\n    /// Set current class context\n    fn set_current_class(\u0026mut self, class: Option\u003cClassContext\u003e);\n\n    /// Get current class context\n    fn get_current_class(\u0026self) -\u003e \u0026Option\u003cClassContext\u003e;\n\n    /// Register the interfaces that a class implements\n    fn register_class_implements(\u0026mut self, class_name: \u0026str, interfaces: Vec\u003cString\u003e);\n\n    /// Get the interfaces implemented by a class\n    fn get_class_implements(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cString\u003e\u003e;\n}\n\n/// Default implementation of access control\n#[derive(Default)]\npub struct AccessControl {\n    class_members: FxHashMap\u003cString, Vec\u003cClassMemberInfo\u003e\u003e,\n    final_classes: FxHashMap\u003cString, bool\u003e,\n    class_parents: FxHashMap\u003cString, Option\u003cString\u003e\u003e, // Store class hierarchy\n    class_implements: FxHashMap\u003cString, Vec\u003cString\u003e\u003e, // Store class -\u003e interfaces mapping\n    current_class: Option\u003cClassContext\u003e,\n}\n\nimpl AccessControl {\n    pub fn new() -\u003e Self {\n        Self::default()\n    }\n\n    /// Find a member by walking the class hierarchy (current class, then parent, etc.)\n    /// Also checks implemented interfaces for default method implementations\n    fn find_member_in_hierarchy(\n        \u0026self,\n        class_name: \u0026str,\n        member_name: \u0026str,\n    ) -\u003e Option\u003c\u0026ClassMemberInfo\u003e {\n        let mut current = class_name;\n        loop {\n            if let Some(members) = self.class_members.get(current) {\n                if let Some(info) = members.iter().find(|m| m.name == member_name) {\n                    return Some(info);\n                }\n            }\n            // Walk to parent class\n            if let Some(Some(parent_name)) = self.class_parents.get(current) {\n                // Strip generic arguments from parent name (e.g. \"DataStore\u003cnumber\u003e\" -\u003e \"DataStore\")\n                let base_name = if let Some(idx) = parent_name.find('\u003c') {\n                    \u0026parent_name[..idx]\n                } else {\n                    parent_name.as_str()\n                };\n                if base_name == current {\n                    break; // Prevent infinite loop\n                }\n                current = base_name;\n            } else {\n                break;\n            }\n        }\n\n        // If not found in class hierarchy, check implemented interfaces\n        self.find_member_in_interfaces(class_name, member_name)\n    }\n\n    /// Find a member in the interfaces implemented by a class\n    fn find_member_in_interfaces(\n        \u0026self,\n        class_name: \u0026str,\n        member_name: \u0026str,\n    ) -\u003e Option\u003c\u0026ClassMemberInfo\u003e {\n        if let Some(interfaces) = self.class_implements.get(class_name) {\n            for interface_name in interfaces {\n                // Strip generic arguments from interface name\n                let base_name = if let Some(idx) = interface_name.find('\u003c') {\n                    \u0026interface_name[..idx]\n                } else {\n                    interface_name.as_str()\n                };\n\n                if let Some(members) = self.class_members.get(base_name) {\n                    if let Some(info) = members.iter().find(|m| m.name == member_name) {\n                        return Some(info);\n                    }\n                }\n            }\n        }\n        None\n    }\n}\n\nimpl TypeCheckVisitor for AccessControl {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"AccessControl\"\n    }\n}\n\nimpl AccessControlVisitor for AccessControl {\n    fn check_member_access(\n        \u0026self,\n        current_class: \u0026Option\u003cClassContext\u003e,\n        class_name: \u0026str,\n        member_name: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // Get the member info - check current class and parent classes\n        let member_info = self.find_member_in_hierarchy(class_name, member_name);\n\n        if let Some(info) = member_info {\n            match \u0026info.access {\n                AccessModifier::Public =\u003e {\n                    // Public members are accessible from anywhere\n                    Ok(())\n                }\n                AccessModifier::Private =\u003e {\n                    // Private members are only accessible from within the same class\n                    if let Some(ref current) = current_class {\n                        if current.name == class_name {\n                            Ok(())\n                        } else {\n                            Err(TypeCheckError::new(\n                                format!(\n                                    \"Property '{}' is private and only accessible within class '{}'\",\n                                    member_name, class_name\n                                ),\n                                span,\n                            ))\n                        }\n                    } else {\n                        Err(TypeCheckError::new(\n                            format!(\n                                \"Property '{}' is private and only accessible within class '{}'\",\n                                member_name, class_name\n                            ),\n                            span,\n                        ))\n                    }\n                }\n                AccessModifier::Protected =\u003e {\n                    // Protected members are accessible from within the class and subclasses\n                    if let Some(ref current) = current_class {\n                        if current.name == class_name {\n                            // Same class - allowed\n                            Ok(())\n                        } else if self.is_subclass(\u0026current.name, class_name) {\n                            // Subclass - allowed\n                            Ok(())\n                        } else {\n                            Err(TypeCheckError::new(\n                                format!(\n                                    \"Property '{}' is protected and only accessible within class '{}' and its subclasses\",\n                                    member_name, class_name\n                                ),\n                                span,\n                            ))\n                        }\n                    } else {\n                        Err(TypeCheckError::new(\n                            format!(\n                                \"Property '{}' is protected and only accessible within class '{}' and its subclasses\",\n                                member_name, class_name\n                            ),\n                            span,\n                        ))\n                    }\n                }\n            }\n        } else {\n            // Check if class exists\n            if !self.class_members.contains_key(class_name) {\n                return Err(TypeCheckError::new(\n                    format!(\"Class or type '{}' not found\", class_name),\n                    span,\n                ));\n            }\n\n            // Class exists but member not found\n            Err(TypeCheckError::new(\n                format!(\n                    \"Member '{}' not found in class '{}'\",\n                    member_name, class_name\n                ),\n                span,\n            ))\n        }\n    }\n\n    fn is_subclass(\u0026self, child: \u0026str, ancestor: \u0026str) -\u003e bool {\n        // Use stored class hierarchy to check subclass relationship\n        let mut current = child;\n\n        while let Some(parent) = self.class_parents.get(current) {\n            if let Some(ref parent_name) = parent {\n                if parent_name == ancestor {\n                    return true;\n                }\n                current = parent_name;\n            } else {\n                break;\n            }\n        }\n\n        false\n    }\n\n    fn register_class(\u0026mut self, name: \u0026str, parent: Option\u003cString\u003e) {\n        self.class_members.entry(name.to_string()).or_default();\n        self.final_classes.entry(name.to_string()).or_insert(false);\n        self.class_parents.insert(name.to_string(), parent);\n    }\n\n    fn register_member(\u0026mut self, class_name: \u0026str, member: ClassMemberInfo) {\n        if let Some(members) = self.class_members.get_mut(class_name) {\n            members.push(member);\n        }\n    }\n\n    fn mark_class_final(\u0026mut self, name: \u0026str, is_final: bool) {\n        self.final_classes.insert(name.to_string(), is_final);\n    }\n\n    fn is_class_final(\u0026self, name: \u0026str) -\u003e bool {\n        *self.final_classes.get(name).unwrap_or(\u0026false)\n    }\n\n    fn get_class_members(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cClassMemberInfo\u003e\u003e {\n        self.class_members.get(class_name)\n    }\n\n    fn get_parent_class(\u0026self, class_name: \u0026str) -\u003e Option\u003cString\u003e {\n        self.class_parents.get(class_name).cloned().flatten()\n    }\n\n    fn set_current_class(\u0026mut self, class: Option\u003cClassContext\u003e) {\n        self.current_class = class;\n    }\n\n    fn get_current_class(\u0026self) -\u003e \u0026Option\u003cClassContext\u003e {\n        \u0026self.current_class\n    }\n\n    fn register_class_implements(\u0026mut self, class_name: \u0026str, interfaces: Vec\u003cString\u003e) {\n        self.class_implements\n            .insert(class_name.to_string(), interfaces);\n    }\n\n    fn get_class_implements(\u0026self, class_name: \u0026str) -\u003e Option\u003c\u0026Vec\u003cString\u003e\u003e {\n        self.class_implements.get(class_name)\n    }\n}\n\n#[cfg(test)]\nmod access_control_tests;\n","traces":[{"line":107,"address":[],"length":0,"stats":{"Line":380}},{"line":108,"address":[],"length":0,"stats":{"Line":380}},{"line":113,"address":[],"length":0,"stats":{"Line":34}},{"line":118,"address":[],"length":0,"stats":{"Line":68}},{"line":120,"address":[],"length":0,"stats":{"Line":100}},{"line":121,"address":[],"length":0,"stats":{"Line":163}},{"line":122,"address":[],"length":0,"stats":{"Line":31}},{"line":126,"address":[],"length":0,"stats":{"Line":9}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[],"length":0,"stats":{"Line":3}},{"line":143,"address":[],"length":0,"stats":{"Line":12}},{"line":147,"address":[],"length":0,"stats":{"Line":3}},{"line":152,"address":[],"length":0,"stats":{"Line":6}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[],"length":0,"stats":{"Line":0}},{"line":156,"address":[],"length":0,"stats":{"Line":0}},{"line":158,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":3}},{"line":173,"address":[],"length":0,"stats":{"Line":1}},{"line":174,"address":[],"length":0,"stats":{"Line":1}},{"line":179,"address":[],"length":0,"stats":{"Line":34}},{"line":187,"address":[],"length":0,"stats":{"Line":170}},{"line":189,"address":[],"length":0,"stats":{"Line":65}},{"line":190,"address":[],"length":0,"stats":{"Line":31}},{"line":193,"address":[],"length":0,"stats":{"Line":14}},{"line":197,"address":[],"length":0,"stats":{"Line":17}},{"line":198,"address":[],"length":0,"stats":{"Line":8}},{"line":199,"address":[],"length":0,"stats":{"Line":5}},{"line":201,"address":[],"length":0,"stats":{"Line":6}},{"line":202,"address":[],"length":0,"stats":{"Line":6}},{"line":203,"address":[],"length":0,"stats":{"Line":3}},{"line":204,"address":[],"length":0,"stats":{"Line":3}},{"line":206,"address":[],"length":0,"stats":{"Line":3}},{"line":210,"address":[],"length":0,"stats":{"Line":2}},{"line":211,"address":[],"length":0,"stats":{"Line":2}},{"line":212,"address":[],"length":0,"stats":{"Line":1}},{"line":213,"address":[],"length":0,"stats":{"Line":1}},{"line":215,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":7}},{"line":224,"address":[],"length":0,"stats":{"Line":1}},{"line":225,"address":[],"length":0,"stats":{"Line":24}},{"line":227,"address":[],"length":0,"stats":{"Line":5}},{"line":229,"address":[],"length":0,"stats":{"Line":2}},{"line":230,"address":[],"length":0,"stats":{"Line":2}},{"line":231,"address":[],"length":0,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":234,"address":[],"length":0,"stats":{"Line":1}},{"line":238,"address":[],"length":0,"stats":{"Line":2}},{"line":239,"address":[],"length":0,"stats":{"Line":2}},{"line":240,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":1}},{"line":250,"address":[],"length":0,"stats":{"Line":6}},{"line":251,"address":[],"length":0,"stats":{"Line":4}},{"line":252,"address":[],"length":0,"stats":{"Line":4}},{"line":253,"address":[],"length":0,"stats":{"Line":2}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":2}},{"line":260,"address":[],"length":0,"stats":{"Line":1}},{"line":261,"address":[],"length":0,"stats":{"Line":1}},{"line":263,"address":[],"length":0,"stats":{"Line":1}},{"line":268,"address":[],"length":0,"stats":{"Line":10}},{"line":270,"address":[],"length":0,"stats":{"Line":20}},{"line":272,"address":[],"length":0,"stats":{"Line":38}},{"line":273,"address":[],"length":0,"stats":{"Line":21}},{"line":274,"address":[],"length":0,"stats":{"Line":9}},{"line":275,"address":[],"length":0,"stats":{"Line":6}},{"line":277,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":3}},{"line":283,"address":[],"length":0,"stats":{"Line":4}},{"line":286,"address":[],"length":0,"stats":{"Line":124}},{"line":287,"address":[],"length":0,"stats":{"Line":620}},{"line":288,"address":[],"length":0,"stats":{"Line":620}},{"line":289,"address":[],"length":0,"stats":{"Line":620}},{"line":292,"address":[],"length":0,"stats":{"Line":229}},{"line":293,"address":[],"length":0,"stats":{"Line":916}},{"line":294,"address":[],"length":0,"stats":{"Line":458}},{"line":298,"address":[],"length":0,"stats":{"Line":46}},{"line":299,"address":[],"length":0,"stats":{"Line":230}},{"line":302,"address":[],"length":0,"stats":{"Line":16}},{"line":303,"address":[],"length":0,"stats":{"Line":64}},{"line":306,"address":[],"length":0,"stats":{"Line":24}},{"line":307,"address":[],"length":0,"stats":{"Line":72}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":314,"address":[],"length":0,"stats":{"Line":94}},{"line":315,"address":[],"length":0,"stats":{"Line":188}},{"line":318,"address":[],"length":0,"stats":{"Line":115}},{"line":319,"address":[],"length":0,"stats":{"Line":115}},{"line":322,"address":[],"length":0,"stats":{"Line":5}},{"line":323,"address":[],"length":0,"stats":{"Line":5}},{"line":324,"address":[],"length":0,"stats":{"Line":20}},{"line":327,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":6}}],"covered":88,"coverable":103},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","inference","inference_tests.rs"],"content":"#[cfg(test)]\nmod tests {\n    use crate::cli::diagnostics::{CollectingDiagnosticHandler, DiagnosticHandler};\n    use crate::core::type_environment::TypeEnvironment;\n    use crate::utils::symbol_table::SymbolTable;\n    use crate::visitors::{AccessControl, TypeCheckVisitor, TypeInferenceVisitor, TypeInferrer};\n    use crate::NarrowingContext;\n    use std::sync::Arc;\n    use typedlua_parser::ast::expression::*;\n    use typedlua_parser::ast::types::*;\n    use typedlua_parser::ast::Ident;\n    use typedlua_parser::prelude::*;\n    use typedlua_parser::span::Span;\n    use typedlua_parser::string_interner::StringInterner;\n\n    fn create_test_inferrer\u003c'a\u003e(\n        symbol_table: \u0026'a mut SymbolTable,\n        type_env: \u0026'a mut TypeEnvironment,\n        narrowing_context: \u0026'a mut NarrowingContext,\n        access_control: \u0026'a AccessControl,\n        interner: \u0026'a StringInterner,\n        diagnostic_handler: \u0026'a Arc\u003cdyn DiagnosticHandler\u003e,\n    ) -\u003e TypeInferrer\u003c'a\u003e {\n        TypeInferrer::new(\n            symbol_table,\n            type_env,\n            narrowing_context,\n            access_control,\n            interner,\n            diagnostic_handler,\n        )\n    }\n\n    #[test]\n    fn test_infer_literal_number() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Literal(Literal::Number(n)) if n == 42.0));\n    }\n\n    #[test]\n    fn test_infer_literal_string() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Literal(Literal::String(_))));\n    }\n\n    #[test]\n    fn test_infer_literal_boolean() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Literal(Literal::Boolean(true))\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_add() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Add, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_concat() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::String(\" world\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Concatenate, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_infer_unary_op_negate() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::Negate, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_unary_op_not() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::Not, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_infer_array() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let elements = vec![\n            ArrayElement::Expression(Expression {\n                kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                span: Span::default(),\n                annotated_type: None,\n                receiver_class: None,\n            }),\n            ArrayElement::Expression(Expression {\n                kind: ExpressionKind::Literal(Literal::Number(2.0)),\n                span: Span::default(),\n                annotated_type: None,\n                receiver_class: None,\n            }),\n        ];\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(elements),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_empty_array() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(vec![]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_conditional() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let cond = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let then_expr = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let else_expr = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Conditional(cond, then_expr, else_expr),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Conditional with different literal numbers returns a union\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_binary_op_comparison() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::LessThan, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_visitor_name() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        assert_eq!(inferrer.name(), \"TypeInferrer\");\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Type Inference Tests\n    // ========================================================================\n\n    #[test]\n    fn test_infer_literal_nil() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Literal(Literal::Nil)));\n    }\n\n    #[test]\n    fn test_infer_array_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        // Array of numbers: [1, 2, 3]\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(vec![\n                ArrayElement::Expression(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                ArrayElement::Expression(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(2.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                ArrayElement::Expression(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(3.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n            ]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should infer as Array\u003cnumber\u003e\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_array_empty() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        // Empty array: []\n        let mut expr = Expression {\n            kind: ExpressionKind::Array(vec![]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should infer as Array\u003cunknown\u003e\n        assert!(matches!(typ.kind, TypeKind::Array(_)));\n    }\n\n    #[test]\n    fn test_infer_binary_op_sub() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Subtract, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_mul() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(6.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(7.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Multiply, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_div() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Divide, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_mod() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Modulo, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_eq() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Equal, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_and() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(false)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::And, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // In Lua, 'and' returns one of its operands, so type is Unknown\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_or() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(false)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Or, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // In Lua, 'or' returns one of its operands, so type is Unknown\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_infer_unary_op_len() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::Length, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Length operator returns number\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_parenthesized() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let inner = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Parenthesized(inner),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Parenthesized expressions now correctly infer the type of their inner expression\n        assert!(\n            matches!(typ.kind, TypeKind::Literal(Literal::Number(n)) if (n - 42.0).abs() \u003c f64::EPSILON)\n        );\n    }\n\n    #[test]\n    fn test_infer_type_assertion() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let inner = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let assert_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        let mut expr = Expression {\n            kind: ExpressionKind::TypeAssertion(inner, assert_type),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Type assertions currently return Unknown (not yet fully implemented)\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Unknown)\n        ));\n    }\n\n    #[test]\n    fn test_infer_object_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        // Object literal: { x: 1, y: 2 }\n        let name_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Object(vec![\n                ObjectProperty::Property {\n                    key: Ident::new(name_id, Span::default()),\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n                ObjectProperty::Property {\n                    key: Ident::new(y_id, Span::default()),\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Literal(Literal::Number(2.0)),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n            ]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should infer as object type\n        assert!(matches!(typ.kind, TypeKind::Object(_)));\n    }\n\n    #[test]\n    fn test_infer_identifier_not_found() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let x_id = interner.intern(\"x\");\n        let mut expr = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        // Should fail because x is not defined\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_infer_identifier_with_type() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        // Register a variable with a type\n        let x_id = interner.intern(\"x\");\n        let x_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"x\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                x_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_power() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::Power, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_integer_divide() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(10.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::IntegerDivide, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_bitwise() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(3.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::BitwiseAnd, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_shift() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::ShiftLeft, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_binary_op_not_equal() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(1.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(2.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::NotEqual, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Boolean)\n        ));\n    }\n\n    #[test]\n    fn test_infer_null_coalesce() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(42.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Binary(BinaryOp::NullCoalesce, left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // null ?? number should return number\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Literal(Literal::Number(n)) if n == 42.0\n        ));\n    }\n\n    #[test]\n    fn test_infer_optional_member() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let obj_id = interner.intern(\"obj\");\n        let obj_type = Type {\n            kind: TypeKind::Object(ObjectType {\n                members: vec![ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: false,\n                    name: Ident::new(interner.intern(\"prop\"), Span::default()),\n                    is_optional: false,\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::Number),\n                        Span::default(),\n                    ),\n                    span: Span::default(),\n                })],\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"obj\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                obj_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj = Box::new(Expression {\n            kind: ExpressionKind::Identifier(obj_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let member = typedlua_parser::ast::Spanned::new(interner.intern(\"prop\"), Span::default());\n\n        let mut expr = Expression {\n            kind: ExpressionKind::OptionalMember(obj, member),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        // Should return an optional type (T | nil)\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_optional_index() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let arr_id = interner.intern(\"arr\");\n        let arr_type = Type {\n            kind: TypeKind::Array(Box::new(Type::new(\n                TypeKind::Primitive(PrimitiveType::Number),\n                Span::default(),\n            ))),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"arr\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                arr_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj = Box::new(Expression {\n            kind: ExpressionKind::Identifier(arr_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let index = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(0.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::OptionalIndex(obj, index),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should return an optional type (T | nil)\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_optional_call() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let func_id = interner.intern(\"maybeFunc\");\n        let func_type = Type {\n            kind: TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    Span::default(),\n                )),\n                throws: None,\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"maybeFunc\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                func_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let callee = Box::new(Expression {\n            kind: ExpressionKind::Identifier(func_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::OptionalCall(callee, vec![], None),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Should return an optional type\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_function_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Function(FunctionExpression {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: None,\n                body: Block {\n                    statements: vec![],\n                    span: Span::default(),\n                },\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Function(_)));\n    }\n\n    #[test]\n    fn test_infer_function_expression_with_return() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Function(FunctionExpression {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: None,\n                body: Block {\n                    statements: vec![],\n                    span: Span::default(),\n                },\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Function(_)));\n    }\n\n    #[test]\n    fn test_infer_arrow_function_basic() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Arrow(ArrowFunction {\n                parameters: vec![],\n                body: ArrowBody::Expression(Box::new(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                })),\n                return_type: None,\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_infer_object_spread() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let other_id = interner.intern(\"other\");\n        let other_type = Type {\n            kind: TypeKind::Object(ObjectType {\n                members: vec![ObjectTypeMember::Property(PropertySignature {\n                    is_readonly: false,\n                    name: Ident::new(interner.intern(\"a\"), Span::default()),\n                    is_optional: false,\n                    type_annotation: Type::new(\n                        TypeKind::Primitive(PrimitiveType::String),\n                        Span::default(),\n                    ),\n                    span: Span::default(),\n                })],\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"other\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                other_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj_x = interner.intern(\"x\");\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Object(vec![\n                ObjectProperty::Spread {\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Identifier(other_id),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n                ObjectProperty::Property {\n                    key: Ident::new(obj_x, Span::default()),\n                    value: Box::new(Expression {\n                        kind: ExpressionKind::Literal(Literal::Number(42.0)),\n                        span: Span::default(),\n                        annotated_type: None,\n                        receiver_class: None,\n                    }),\n                    span: Span::default(),\n                },\n            ]),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(typ.kind, TypeKind::Object(_)));\n    }\n\n    #[test]\n    fn test_infer_try_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Try(TryExpression {\n                expression: Box::new(Expression {\n                    kind: ExpressionKind::Literal(Literal::Number(1.0)),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                catch_variable: Ident::new(interner.intern(\"e\"), Span::default()),\n                catch_expression: Box::new(Expression {\n                    kind: ExpressionKind::Literal(Literal::String(\"error\".to_string())),\n                    span: Span::default(),\n                    annotated_type: None,\n                    receiver_class: None,\n                }),\n                span: Span::default(),\n            }),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Try should return union of both types\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_error_chain() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let result_id = interner.intern(\"result\");\n        let result_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"result\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                result_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Identifier(result_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::ErrorChain(left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_infer_pipe_expression() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let double_id = interner.intern(\"double\");\n        let double_type = Type {\n            kind: TypeKind::Function(FunctionType {\n                type_parameters: None,\n                parameters: vec![],\n                return_type: Box::new(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Number),\n                    Span::default(),\n                )),\n                throws: None,\n                span: Span::default(),\n            }),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"double\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                double_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let left = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let right = Box::new(Expression {\n            kind: ExpressionKind::Identifier(double_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Pipe(left, right),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n    }\n\n    #[test]\n    fn test_infer_index_on_tuple() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let tuple_id = interner.intern(\"tuple\");\n        let tuple_type = Type {\n            kind: TypeKind::Tuple(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), Span::default()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), Span::default()),\n            ]),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"tuple\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                tuple_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let obj = Box::new(Expression {\n            kind: ExpressionKind::Identifier(tuple_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let index = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(0.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Index(obj, index),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // Index on tuple should return union of element types\n        assert!(matches!(typ.kind, TypeKind::Union(_)));\n    }\n\n    #[test]\n    fn test_infer_unary_op_bitwise_not() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let operand = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Number(5.0)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Unary(UnaryOp::BitwiseNot, operand),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n\n    #[test]\n    fn test_infer_conditional_same_types() {\n        let interner = StringInterner::new();\n        let mut symbol_table = SymbolTable::new();\n        let mut type_env = TypeEnvironment::new();\n        let mut narrowing_context = NarrowingContext::new();\n        let access_control = AccessControl::new();\n\n        let diagnostic_handler: Arc\u003cdyn DiagnosticHandler\u003e =\n            Arc::new(CollectingDiagnosticHandler::new());\n\n        let x_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n        let num_type = Type {\n            kind: TypeKind::Primitive(PrimitiveType::Number),\n            span: Span::default(),\n        };\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"x\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                num_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        symbol_table\n            .declare(crate::utils::symbol_table::Symbol::new(\n                \"y\".to_string(),\n                crate::utils::symbol_table::SymbolKind::Variable,\n                num_type.clone(),\n                Span::default(),\n            ))\n            .unwrap();\n\n        let mut inferrer = create_test_inferrer(\n            \u0026mut symbol_table,\n            \u0026mut type_env,\n            \u0026mut narrowing_context,\n            \u0026access_control,\n            \u0026interner,\n            \u0026diagnostic_handler,\n        );\n\n        let cond = Box::new(Expression {\n            kind: ExpressionKind::Literal(Literal::Boolean(true)),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let then_expr = Box::new(Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n        let else_expr = Box::new(Expression {\n            kind: ExpressionKind::Identifier(y_id),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        });\n\n        let mut expr = Expression {\n            kind: ExpressionKind::Conditional(cond, then_expr, else_expr),\n            span: Span::default(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = inferrer.infer_expression(\u0026mut expr);\n        assert!(result.is_ok());\n        let typ = result.unwrap();\n        // When both branches have the same type, should return that type directly (not union)\n        assert!(matches!(\n            typ.kind,\n            TypeKind::Primitive(PrimitiveType::Number)\n        ));\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","inference.rs"],"content":"use super::super::visitors::{AccessControl, AccessControlVisitor, ClassMemberKind};\nuse super::TypeCheckVisitor;\nuse crate::cli::diagnostics::DiagnosticHandler;\nuse crate::core::type_compat::TypeCompatibility;\nuse crate::core::type_environment::TypeEnvironment;\nuse crate::types::generics::infer_type_arguments;\nuse crate::utils::symbol_table::{Symbol, SymbolKind, SymbolTable};\nuse crate::TypeCheckError;\nuse rustc_hash::FxHashMap;\nuse std::sync::Arc;\nuse tracing::{debug, error, instrument, span, Level};\nuse typedlua_parser::ast::expression::*;\nuse typedlua_parser::ast::pattern::{ArrayPatternElement, Pattern};\nuse typedlua_parser::ast::statement::{Block, OperatorKind, Statement};\nuse typedlua_parser::ast::types::*;\nuse typedlua_parser::prelude::{\n    Argument, MatchArm, MatchArmBody, MatchExpression, PropertySignature,\n};\nuse typedlua_parser::span::Span;\nuse typedlua_parser::string_interner::StringInterner;\n\n/// Represents a variable binding from a pattern\n#[derive(Debug, Clone)]\nstruct PatternBinding {\n    typ: Type,\n    span: Span,\n}\n\n/// Collection of bindings from a pattern\n#[derive(Debug, Clone)]\nstruct PatternBindings {\n    bindings: FxHashMap\u003cString, PatternBinding\u003e,\n}\n\n/// Trait for type inference operations\npub trait TypeInferenceVisitor: TypeCheckVisitor {\n    /// Infer the type of an expression\n    fn infer_expression(\u0026mut self, expr: \u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of binary operation\n    fn infer_binary_op(\n        \u0026self,\n        op: BinaryOp,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of unary operation\n    fn infer_unary_op(\n        \u0026self,\n        op: UnaryOp,\n        operand: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of function call\n    fn infer_call(\n        \u0026mut self,\n        callee_type: \u0026Type,\n        args: \u0026mut [Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of a method call on an object\n    fn infer_method(\n        \u0026self,\n        obj_type: \u0026Type,\n        method_name: \u0026str,\n        _args: \u0026[Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of member access\n    fn infer_member(\n        \u0026self,\n        obj_type: \u0026Type,\n        member: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Infer type of index access\n    fn infer_index(\u0026self, obj_type: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Make a type optional by adding nil to the union\n    fn make_optional(\u0026self, typ: Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Remove nil from a type\n    fn remove_nil(\u0026self, typ: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Check if a type is nil\n    fn is_nil(\u0026self, typ: \u0026Type) -\u003e bool;\n\n    /// Infer type of null coalescing operation\n    fn infer_null_coalesce(\n        \u0026self,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Check match expression and return result type\n    fn check_match(\u0026mut self, match_expr: \u0026mut MatchExpression) -\u003e Result\u003cType, TypeCheckError\u003e;\n\n    /// Check a pattern and bind variables\n    fn check_pattern(\n        \u0026mut self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e;\n}\n\n/// Type inference implementation\npub struct TypeInferrer\u003c'a\u003e {\n    symbol_table: \u0026'a mut SymbolTable,\n    type_env: \u0026'a mut TypeEnvironment,\n    narrowing_context: \u0026'a mut super::NarrowingContext,\n    access_control: \u0026'a AccessControl,\n    interner: \u0026'a StringInterner,\n    diagnostic_handler: \u0026'a Arc\u003cdyn DiagnosticHandler\u003e,\n}\n\nimpl\u003c'a\u003e TypeInferrer\u003c'a\u003e {\n    pub fn new(\n        symbol_table: \u0026'a mut SymbolTable,\n        type_env: \u0026'a mut TypeEnvironment,\n        narrowing_context: \u0026'a mut super::NarrowingContext,\n        access_control: \u0026'a AccessControl,\n        interner: \u0026'a StringInterner,\n        diagnostic_handler: \u0026'a Arc\u003cdyn DiagnosticHandler\u003e,\n    ) -\u003e Self {\n        Self {\n            symbol_table,\n            type_env,\n            narrowing_context,\n            access_control,\n            interner,\n            diagnostic_handler,\n        }\n    }\n}\n\nimpl TypeCheckVisitor for TypeInferrer\u003c'_\u003e {\n    fn name(\u0026self) -\u003e \u0026'static str {\n        \"TypeInferrer\"\n    }\n}\n\nimpl TypeInferenceVisitor for TypeInferrer\u003c'_\u003e {\n    #[instrument(skip(self, expr), fields(expr_kind))]\n    fn infer_expression(\u0026mut self, expr: \u0026mut Expression) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let span = expr.span;\n        let expr_kind = format!(\"{:?}\", expr.kind);\n\n        span!(Level::DEBUG, \"infer_expression\", kind = %expr_kind);\n\n        match \u0026mut expr.kind {\n            ExpressionKind::Literal(lit) =\u003e {\n                debug!(literal = ?lit, \"Inferring literal type\");\n                Ok(Type::new(TypeKind::Literal(lit.clone()), span))\n            }\n\n            ExpressionKind::Identifier(name) =\u003e {\n                let name_str = self.interner.resolve(*name);\n                debug!(name = %name_str, \"Inferring identifier type\");\n\n                // Check for narrowed type first\n                if let Some(narrowed_type) = self.narrowing_context.get_narrowed_type(*name) {\n                    debug!(name = %name_str, \"Found narrowed type\");\n                    return Ok(narrowed_type.clone());\n                }\n\n                // Fall back to symbol table\n                if let Some(symbol) = self.symbol_table.lookup(\u0026name_str) {\n                    debug!(name = %name_str, type = ?symbol.typ, \"Found in symbol table\");\n                    Ok(symbol.typ.clone())\n                } else {\n                    error!(name = %name_str, \"Undefined variable\");\n                    Err(TypeCheckError::new(\n                        format!(\"Undefined variable '{}'\", name_str),\n                        span,\n                    ))\n                }\n            }\n\n            ExpressionKind::Binary(op, left, right) =\u003e {\n                debug!(op = ?op, \"Inferring binary operation type\");\n                let left_type = self.infer_expression(left)?;\n                let right_type = self.infer_expression(right)?;\n                self.infer_binary_op(*op, \u0026left_type, \u0026right_type, span)\n            }\n\n            ExpressionKind::Unary(op, operand) =\u003e {\n                debug!(op = ?op, \"Inferring unary operation type\");\n                let operand_type = self.infer_expression(operand)?;\n                self.infer_unary_op(*op, \u0026operand_type, span)\n            }\n\n            ExpressionKind::Call(callee, args, ref mut stored_type_args) =\u003e {\n                let callee_type = self.infer_expression(callee)?;\n\n                // If callee is a generic function, infer and store type arguments\n                if let TypeKind::Function(func_type) = \u0026callee_type.kind {\n                    if let Some(type_params) = \u0026func_type.type_parameters {\n                        // Infer argument types\n                        let mut arg_types = Vec::with_capacity(args.len());\n                        for arg in args.iter_mut() {\n                            let arg_type =\n                                self.infer_expression(\u0026mut arg.value).unwrap_or_else(|_| {\n                                    Type::new(\n                                        TypeKind::Primitive(PrimitiveType::Unknown),\n                                        arg.value.span,\n                                    )\n                                });\n                            arg_types.push(arg_type);\n                        }\n\n                        // Infer type arguments from function signature and argument types\n                        if let Ok(inferred_types) =\n                            infer_type_arguments(type_params, \u0026func_type.parameters, \u0026arg_types)\n                        {\n                            *stored_type_args = Some(inferred_types);\n                        }\n                    }\n                }\n\n                self.infer_call(\u0026callee_type, args, span)\n            }\n\n            ExpressionKind::MethodCall(object, method, args, _) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let method_name = self.interner.resolve(method.node);\n                let method_type = self.infer_method(\u0026obj_type, \u0026method_name, args, span)?;\n\n                // Set receiver_class based on inferred type (not variable name)\n                // This enables method-to-function conversion optimization\n                if let TypeKind::Reference(type_ref) = \u0026obj_type.kind {\n                    let type_name = self.interner.resolve(type_ref.name.node);\n                    // Only set for classes (not interfaces) - check class_members\n                    if self.access_control.get_class_members(\u0026type_name).is_some() {\n                        expr.receiver_class = Some(ReceiverClassInfo {\n                            class_name: type_ref.name.node,\n                            is_static: false,\n                        });\n                    }\n                }\n\n                expr.annotated_type = Some(method_type.clone());\n                Ok(method_type)\n            }\n\n            ExpressionKind::Member(object, member) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let member_name = self.interner.resolve(member.node);\n                self.infer_member(\u0026obj_type, \u0026member_name, span)\n            }\n\n            ExpressionKind::Index(object, index) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let _index_type = self.infer_expression(index)?;\n                self.infer_index(\u0026obj_type, span)\n            }\n\n            ExpressionKind::OptionalMember(object, member) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let member_name = self.interner.resolve(member.node);\n                let member_type = self.infer_member(\u0026obj_type, \u0026member_name, span)?;\n                self.make_optional(member_type, span)\n            }\n\n            ExpressionKind::OptionalIndex(object, index) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let _index_type = self.infer_expression(index)?;\n                let indexed_type = self.infer_index(\u0026obj_type, span)?;\n                self.make_optional(indexed_type, span)\n            }\n\n            ExpressionKind::OptionalCall(callee, args, ref mut stored_type_args) =\u003e {\n                let callee_type = self.infer_expression(callee)?;\n\n                // If callee is a generic function, infer and store type arguments\n                if let TypeKind::Function(func_type) = \u0026callee_type.kind {\n                    if let Some(type_params) = \u0026func_type.type_parameters {\n                        let mut arg_types = Vec::with_capacity(args.len());\n                        for arg in args.iter_mut() {\n                            let arg_type =\n                                self.infer_expression(\u0026mut arg.value).unwrap_or_else(|_| {\n                                    Type::new(\n                                        TypeKind::Primitive(PrimitiveType::Unknown),\n                                        arg.value.span,\n                                    )\n                                });\n                            arg_types.push(arg_type);\n                        }\n\n                        if let Ok(inferred_types) =\n                            infer_type_arguments(type_params, \u0026func_type.parameters, \u0026arg_types)\n                        {\n                            *stored_type_args = Some(inferred_types);\n                        }\n                    }\n                }\n\n                let return_type = self.infer_call(\u0026callee_type, args, span)?;\n                self.make_optional(return_type, span)\n            }\n\n            ExpressionKind::OptionalMethodCall(object, method, args, _) =\u003e {\n                let obj_type = self.infer_expression(object)?;\n                let method_name = self.interner.resolve(method.node);\n                let method_type = self.infer_method(\u0026obj_type, \u0026method_name, args, span)?;\n                self.make_optional(method_type, span)\n            }\n\n            ExpressionKind::Array(elements) =\u003e {\n                if elements.is_empty() {\n                    // Empty array has unknown element type\n                    return Ok(Type::new(\n                        TypeKind::Array(Box::new(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            span,\n                        ))),\n                        span,\n                    ));\n                }\n\n                // Collect all element types, including from spreads\n                let mut element_types = Vec::new();\n\n                for elem in elements {\n                    match elem {\n                        ArrayElement::Expression(expr) =\u003e {\n                            let elem_type = self.infer_expression(expr)?;\n                            element_types.push(elem_type);\n                        }\n                        ArrayElement::Spread(expr) =\u003e {\n                            // Spread expression should be an array\n                            let spread_type = self.infer_expression(expr)?;\n                            match \u0026spread_type.kind {\n                                TypeKind::Array(elem_type) =\u003e {\n                                    // Extract the element type from the spread array\n                                    element_types.push((**elem_type).clone());\n                                }\n                                _ =\u003e {\n                                    return Err(TypeCheckError::new(\n                                        format!(\n                                            \"Cannot spread non-array type: {:?}\",\n                                            spread_type.kind\n                                        ),\n                                        expr.span,\n                                    ));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                // Find common type or create union\n                if element_types.is_empty() {\n                    return Ok(Type::new(\n                        TypeKind::Array(Box::new(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            span,\n                        ))),\n                        span,\n                    ));\n                }\n\n                let mut result_type = element_types[0].clone();\n                for elem_type in \u0026element_types[1..] {\n                    if !TypeCompatibility::is_assignable(\u0026result_type, elem_type)\n                        \u0026\u0026 !TypeCompatibility::is_assignable(elem_type, \u0026result_type)\n                    {\n                        // Types are incompatible, create union\n                        match \u0026mut result_type.kind {\n                            TypeKind::Union(types) =\u003e {\n                                if !types\n                                    .iter()\n                                    .any(|t| TypeCompatibility::is_assignable(t, elem_type))\n                                {\n                                    types.push(elem_type.clone());\n                                }\n                            }\n                            _ =\u003e {\n                                result_type = Type::new(\n                                    TypeKind::Union(vec![result_type.clone(), elem_type.clone()]),\n                                    span,\n                                );\n                            }\n                        }\n                    }\n                }\n\n                Ok(Type::new(TypeKind::Array(Box::new(result_type)), span))\n            }\n\n            ExpressionKind::Object(props) =\u003e {\n                // Infer object type from properties\n                let mut members = Vec::new();\n\n                for prop in props {\n                    match prop {\n                        ObjectProperty::Property {\n                            key,\n                            value,\n                            span: prop_span,\n                        } =\u003e {\n                            // Infer the type of the value\n                            let value_type = self.infer_expression(value)?;\n\n                            // Create a property signature\n                            let prop_sig = PropertySignature {\n                                is_readonly: false,\n                                name: key.clone(),\n                                is_optional: false,\n                                type_annotation: value_type,\n                                span: *prop_span,\n                            };\n\n                            members.push(ObjectTypeMember::Property(prop_sig));\n                        }\n                        ObjectProperty::Computed {\n                            key,\n                            value,\n                            span: computed_span,\n                        } =\u003e {\n                            // Type check the key expression - should be string or number\n                            let key_type = self.infer_expression(key)?;\n                            match \u0026key_type.kind {\n                                TypeKind::Primitive(PrimitiveType::String)\n                                | TypeKind::Primitive(PrimitiveType::Number)\n                                | TypeKind::Primitive(PrimitiveType::Integer)\n                                | TypeKind::Literal(_) =\u003e {\n                                    // Valid key type\n                                }\n                                _ =\u003e {\n                                    return Err(TypeCheckError::new(\n                                        format!(\"Computed property key must be string or number, got {:?}\", key_type.kind),\n                                        *computed_span,\n                                    ));\n                                }\n                            }\n\n                            // Type check the value expression\n                            self.infer_expression(value)?;\n\n                            // Note: We can't add computed properties to the static object type\n                            // since we don't know the key at compile time, but we still validate them\n                        }\n                        ObjectProperty::Spread {\n                            value,\n                            span: spread_span,\n                        } =\u003e {\n                            // Spread object properties\n                            let spread_type = self.infer_expression(value)?;\n                            match \u0026spread_type.kind {\n                                TypeKind::Object(obj_type) =\u003e {\n                                    // Add all members from the spread object\n                                    for member in \u0026obj_type.members {\n                                        members.push(member.clone());\n                                    }\n                                }\n                                _ =\u003e {\n                                    return Err(TypeCheckError::new(\n                                        format!(\n                                            \"Cannot spread non-object type: {:?}\",\n                                            spread_type.kind\n                                        ),\n                                        *spread_span,\n                                    ));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                Ok(Type::new(\n                    TypeKind::Object(ObjectType { members, span }),\n                    span,\n                ))\n            }\n\n            ExpressionKind::Function(func_expr) =\u003e {\n                // Enter a new scope for the function expression\n                self.symbol_table.enter_scope();\n\n                // Register parameters in the scope\n                for param in \u0026func_expr.parameters {\n                    if let Pattern::Identifier(ident) = \u0026param.pattern {\n                        let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                            // Use the declared type\n                            type_ann.clone()\n                        } else {\n                            // No type annotation - use unknown\n                            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                        };\n\n                        let symbol = Symbol::new(\n                            self.interner.resolve(ident.node).to_string(),\n                            SymbolKind::Variable,\n                            param_type,\n                            ident.span,\n                        );\n                        let _ = self.symbol_table.declare(symbol);\n                    }\n                }\n\n                // Infer the return type from the block body\n                let mut body = func_expr.body.clone();\n                let body_type = match self.infer_block_return_type(\u0026mut body)? {\n                    Some(return_type) =\u003e return_type,\n                    None =\u003e {\n                        // No return statements found - void function\n                        Type::new(TypeKind::Primitive(PrimitiveType::Void), span)\n                    }\n                };\n\n                // Check return type if specified\n                if let Some(declared_return_type) = \u0026func_expr.return_type {\n                    if !TypeCompatibility::is_assignable(\u0026body_type, declared_return_type) {\n                        self.diagnostic_handler.error(\n                            span,\n                            \u0026format!(\n                                \"Function expression return type mismatch: expected '{:?}', found '{:?}'\",\n                                declared_return_type.kind, body_type.kind\n                            ),\n                        );\n                    }\n                }\n\n                // Exit the function scope\n                self.symbol_table.exit_scope();\n\n                // Build the function type\n                let func_type = FunctionType {\n                    type_parameters: func_expr.type_parameters.clone(),\n                    parameters: func_expr.parameters.clone(),\n                    return_type: Box::new(\n                        func_expr\n                            .return_type\n                            .clone()\n                            .unwrap_or_else(|| body_type.clone()),\n                    ),\n                    throws: None,\n                    span,\n                };\n\n                Ok(Type::new(TypeKind::Function(func_type), span))\n            }\n\n            ExpressionKind::Arrow(arrow_fn) =\u003e {\n                // Enter a new scope for the arrow function\n                self.symbol_table.enter_scope();\n\n                // Register parameters in the scope\n                for param in \u0026arrow_fn.parameters {\n                    if let Pattern::Identifier(ident) = \u0026param.pattern {\n                        let param_type = if let Some(type_ann) = \u0026param.type_annotation {\n                            // Use the declared type\n                            type_ann.clone()\n                        } else {\n                            // No type annotation - use unknown\n                            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), param.span)\n                        };\n\n                        let symbol = Symbol::new(\n                            self.interner.resolve(ident.node).to_string(),\n                            SymbolKind::Variable,\n                            param_type,\n                            ident.span,\n                        );\n                        let _ = self.symbol_table.declare(symbol);\n                    }\n                }\n\n                // Infer the body type\n                let body_type = match \u0026arrow_fn.body {\n                    ArrowBody::Expression(expr_box) =\u003e {\n                        // Make a mutable copy to infer\n                        let mut expr_copy = (**expr_box).clone();\n                        self.infer_expression(\u0026mut expr_copy)?\n                    }\n                    ArrowBody::Block(_block) =\u003e {\n                        // Block bodies not fully supported yet\n                        Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)\n                    }\n                };\n\n                // Check return type if specified\n                if let Some(declared_return_type) = \u0026arrow_fn.return_type {\n                    if !TypeCompatibility::is_assignable(\u0026body_type, declared_return_type) {\n                        self.diagnostic_handler.error(\n                            span,\n                            \u0026format!(\n                                \"Arrow function return type mismatch: expected '{:?}', found '{:?}'\",\n                                declared_return_type.kind, body_type.kind\n                            ),\n                        );\n                    }\n                }\n\n                // Exit the arrow function scope\n                self.symbol_table.exit_scope();\n\n                // Return a function type\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n\n            ExpressionKind::Conditional(cond, then_expr, else_expr) =\u003e {\n                let _cond_type = self.infer_expression(cond)?;\n                let then_type = self.infer_expression(then_expr)?;\n                let else_type = self.infer_expression(else_expr)?;\n\n                // Return union of both branches\n                if TypeCompatibility::is_assignable(\u0026then_type, \u0026else_type) {\n                    Ok(else_type)\n                } else if TypeCompatibility::is_assignable(\u0026else_type, \u0026then_type) {\n                    Ok(then_type)\n                } else {\n                    Ok(Type::new(TypeKind::Union(vec![then_type, else_type]), span))\n                }\n            }\n\n            ExpressionKind::Match(match_expr) =\u003e self.check_match(match_expr),\n\n            ExpressionKind::Pipe(left_expr, right_expr) =\u003e {\n                // Pipe operator: left |\u003e right\n                // The right side should be a function, and we apply left as the first argument\n                let _left_type = self.infer_expression(left_expr)?;\n\n                // For now, we'll infer the result type by checking the right expression\n                // In a full implementation, we'd check if right is a function and apply left to it\n                // For simplicity, we'll type check right and return its type\n                // (This handles cases like: value |\u003e func where func returns something)\n                self.infer_expression(right_expr)\n            }\n\n            ExpressionKind::Try(try_expr) =\u003e {\n                let expr_type = self.infer_expression(\u0026mut try_expr.expression)?;\n                let catch_type = self.infer_expression(\u0026mut try_expr.catch_expression)?;\n\n                if TypeCompatibility::is_assignable(\u0026expr_type, \u0026catch_type) {\n                    Ok(catch_type)\n                } else if TypeCompatibility::is_assignable(\u0026catch_type, \u0026expr_type) {\n                    Ok(expr_type)\n                } else {\n                    Ok(Type::new(\n                        TypeKind::Union(vec![expr_type, catch_type]),\n                        span,\n                    ))\n                }\n            }\n\n            ExpressionKind::ErrorChain(left_expr, right_expr) =\u003e {\n                let _left_type = self.infer_expression(left_expr)?;\n                self.infer_expression(right_expr)\n            }\n\n            ExpressionKind::New(callee, _args, type_args) =\u003e {\n                // Infer the class type from the callee expression\n                // For `new ClassName(args)`, callee is Identifier(\"ClassName\")\n                // For `new ClassName\u003cT\u003e(args)`, type_args carries the \u003cT\u003e\n                match \u0026callee.kind {\n                    ExpressionKind::Identifier(name) =\u003e {\n                        let class_name = self.interner.resolve(*name);\n\n                        // Check if the class is abstract\n                        if self.type_env.is_abstract_class(\u0026class_name) {\n                            return Err(TypeCheckError::new(\n                                format!(\"Cannot instantiate abstract class '{}'\", class_name),\n                                span,\n                            ));\n                        }\n\n                        // Return a Reference type to the class, preserving type arguments\n                        Ok(Type::new(\n                            TypeKind::Reference(TypeReference {\n                                name: typedlua_parser::ast::Spanned::new(*name, span),\n                                type_arguments: type_args.clone(),\n                                span,\n                            }),\n                            span,\n                        ))\n                    }\n                    _ =\u003e {\n                        // For complex callee expressions, infer the callee type\n                        // and use it as the result type\n                        Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n                    }\n                }\n            }\n\n            ExpressionKind::Parenthesized(inner) =\u003e {\n                // Parenthesized expressions have the same type as their inner expression\n                self.infer_expression(inner)\n            }\n\n            _ =\u003e {\n                // For unimplemented expression types, return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n        }\n    }\n\n    fn infer_binary_op(\n        \u0026self,\n        op: BinaryOp,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match op {\n            BinaryOp::Add\n            | BinaryOp::Subtract\n            | BinaryOp::Multiply\n            | BinaryOp::Divide\n            | BinaryOp::Modulo\n            | BinaryOp::Power\n            | BinaryOp::IntegerDivide =\u003e {\n                // Check for operator overload on the left operand's class\n                if let Some(return_type) = self.check_operator_overload(left, op) {\n                    return Ok(return_type);\n                }\n\n                // Check that both operands are numbers\n                let left_is_number = matches!(\n                    left.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                        | TypeKind::Literal(Literal::Number(_))\n                );\n                let right_is_number = matches!(\n                    right.kind,\n                    TypeKind::Primitive(PrimitiveType::Number)\n                        | TypeKind::Literal(Literal::Number(_))\n                );\n\n                if !left_is_number {\n                    self.diagnostic_handler.error(\n                        span,\n                        \u0026format!(\n                            \"Left operand of arithmetic operation must be a number, found {:?}\",\n                            left.kind\n                        ),\n                    );\n                }\n                if !right_is_number {\n                    self.diagnostic_handler.error(\n                        span,\n                        \u0026format!(\n                            \"Right operand of arithmetic operation must be a number, found {:?}\",\n                            right.kind\n                        ),\n                    );\n                }\n\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span))\n            }\n            BinaryOp::Concatenate =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::String), span))\n            }\n            BinaryOp::Equal\n            | BinaryOp::NotEqual\n            | BinaryOp::LessThan\n            | BinaryOp::LessThanOrEqual\n            | BinaryOp::GreaterThan\n            | BinaryOp::GreaterThanOrEqual\n            | BinaryOp::Instanceof =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span))\n            }\n            BinaryOp::And | BinaryOp::Or =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            BinaryOp::NullCoalesce =\u003e self.infer_null_coalesce(left, right, span),\n            BinaryOp::BitwiseAnd\n            | BinaryOp::BitwiseOr\n            | BinaryOp::BitwiseXor\n            | BinaryOp::ShiftLeft\n            | BinaryOp::ShiftRight =\u003e {\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span))\n            }\n        }\n    }\n\n    fn infer_unary_op(\n        \u0026self,\n        op: UnaryOp,\n        _operand: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match op {\n            UnaryOp::Negate =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n            UnaryOp::Not =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span)),\n            UnaryOp::Length =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n            UnaryOp::BitwiseNot =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n        }\n    }\n\n    #[instrument(skip(self, callee_type, args), fields(args_count = args.len(), return_type))]\n    fn infer_call(\n        \u0026mut self,\n        callee_type: \u0026Type,\n        args: \u0026mut [Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        debug!(callee_type = ?callee_type.kind, \"Inferring function call type\");\n\n        match \u0026callee_type.kind {\n            TypeKind::Function(func_type) =\u003e {\n                // Check argument count\n                let actual_args = args.len();\n                debug!(actual_args, \"Checking function call argument count\");\n\n                // Count required parameters (non-optional, non-rest)\n                let required_params = func_type\n                    .parameters\n                    .iter()\n                    .filter(|p| !p.is_rest \u0026\u0026 !p.is_optional)\n                    .count();\n\n                // Check if the last parameter is a rest parameter\n                let has_rest_param = func_type\n                    .parameters\n                    .last()\n                    .map(|p| p.is_rest)\n                    .unwrap_or(false);\n\n                // Count optional parameters\n                let optional_params = func_type\n                    .parameters\n                    .iter()\n                    .filter(|p| p.is_optional \u0026\u0026 !p.is_rest)\n                    .count();\n\n                let max_params = if has_rest_param {\n                    usize::MAX\n                } else {\n                    required_params + optional_params\n                };\n\n                // Check minimum required arguments\n                if actual_args \u003c required_params {\n                    error!(\n                        expected_min = required_params,\n                        actual = actual_args,\n                        \"Too few arguments\"\n                    );\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Function expects at least {} arguments but received {}\",\n                            required_params, actual_args\n                        ),\n                        span,\n                    ));\n                }\n\n                // Check maximum allowed arguments (unless rest parameter)\n                if !has_rest_param \u0026\u0026 actual_args \u003e max_params {\n                    error!(\n                        expected_max = max_params,\n                        actual = actual_args,\n                        \"Too many arguments\"\n                    );\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Function expects at most {} arguments but received {}\",\n                            max_params, actual_args\n                        ),\n                        span,\n                    ));\n                }\n\n                // Check argument types match parameter types\n                for (i, arg) in args.iter_mut().enumerate() {\n                    if i \u003c func_type.parameters.len() {\n                        let param = \u0026func_type.parameters[i];\n\n                        // Infer the argument type\n                        if let Ok(arg_type) = self.infer_expression(\u0026mut arg.value) {\n                            if let Some(param_type) = \u0026param.type_annotation {\n                                // Check if argument type is assignable to parameter type\n                                if !TypeCompatibility::is_assignable(\u0026arg_type, param_type) {\n                                    self.diagnostic_handler.error(\n                                        arg.value.span,\n                                        \u0026format!(\n                                            \"Type mismatch in function call: argument {} has type '{:?}' which is not assignable to parameter type '{:?}'\",\n                                            i + 1,\n                                            arg_type.kind,\n                                            param_type.kind\n                                        ),\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n\n                Ok((*func_type.return_type).clone())\n            }\n            _ =\u003e {\n                // Non-function called - return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n        }\n    }\n\n    fn infer_method(\n        \u0026self,\n        obj_type: \u0026Type,\n        method_name: \u0026str,\n        _args: \u0026[Argument],\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        // Look up the method in the object type\n        match \u0026obj_type.kind {\n            TypeKind::Object(obj) =\u003e {\n                for member in \u0026obj.members {\n                    if let ObjectTypeMember::Method(method) = member {\n                        if self.interner.resolve(method.name.node) == method_name {\n                            // Return the return type of the method\n                            return Ok(method.return_type.clone());\n                        }\n                    }\n                }\n                // Method not found - return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            TypeKind::Reference(type_ref) =\u003e {\n                let type_name = self.interner.resolve(type_ref.name.node);\n                if let Some(class_members) = self.access_control.get_class_members(\u0026type_name) {\n                    for member in class_members {\n                        if member.name == method_name {\n                            if let ClassMemberKind::Method { return_type, .. } = \u0026member.kind {\n                                return Ok(return_type.clone().unwrap_or_else(|| {\n                                    Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)\n                                }));\n                            }\n                        }\n                    }\n                }\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            _ =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)),\n        }\n    }\n\n    fn infer_member(\n        \u0026self,\n        obj_type: \u0026Type,\n        member: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match \u0026obj_type.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                let type_name = self.interner.resolve(type_ref.name.node);\n\n                // Check if this is a generic type alias with type arguments\n                if let Some(type_args) = \u0026type_ref.type_arguments {\n                    if let Some(generic_alias) = self.type_env.get_generic_type_alias(\u0026type_name) {\n                        // Instantiate the generic type alias with the provided type arguments\n                        use crate::types::generics::instantiate_type;\n                        let instantiated = instantiate_type(\n                            \u0026generic_alias.typ,\n                            \u0026generic_alias.type_parameters,\n                            type_args,\n                        )\n                        .map_err(|e| TypeCheckError::new(e, span))?;\n                        return self.infer_member(\u0026instantiated, member, span);\n                    }\n                }\n\n                // Check if this is a type parameter with a constraint\n                // If so, resolve member access on the constraint type\n                if let Some(constraint) = self.type_env.get_type_param_constraint(\u0026type_name) {\n                    return self.infer_member(constraint, member, span);\n                }\n\n                // Check access modifiers for class members (only for actual classes)\n                self.check_member_access(\u0026type_name, member, span)?;\n\n                // Try to resolve the type reference to get the actual type\n                // Use lookup_type to check both type aliases and interfaces\n                if let Some(resolved) = self.type_env.lookup_type(\u0026type_name) {\n                    // Check for infinite recursion - if resolved type is the same as input, avoid loop\n                    if matches!(resolved.kind, TypeKind::Reference(_)) {\n                        // If resolved is still a reference, check if it's the same reference\n                        if let TypeKind::Reference(resolved_ref) = \u0026resolved.kind {\n                            if resolved_ref.name.node == type_ref.name.node {\n                                // Same type reference - check if it's a field of the enum\n                                // For enums, we need to check fields defined in the enum declaration\n                                // For now, return unknown to avoid infinite loop\n                                // The field will be looked up from the symbol table instead\n                                return Ok(Type::new(\n                                    TypeKind::Primitive(PrimitiveType::Unknown),\n                                    span,\n                                ));\n                            }\n                        }\n                    }\n                    return self.infer_member(resolved, member, span);\n                }\n\n                // Fall back to access_control for class property/getter types.\n                // Only use concrete type annotations (no unresolved type parameters).\n                // Generic class members contain raw type params like T that need\n                // substitution, so we skip those and fall through to Unknown.\n                if let Some(class_members) = self.access_control.get_class_members(\u0026type_name) {\n                    for m in class_members {\n                        if m.name == member {\n                            match \u0026m.kind {\n                                ClassMemberKind::Property { type_annotation }\n                                    if !self.type_has_unresolved_params(type_annotation) =\u003e\n                                {\n                                    return Ok(type_annotation.clone());\n                                }\n                                ClassMemberKind::Getter { return_type }\n                                    if !self.type_has_unresolved_params(return_type) =\u003e\n                                {\n                                    return Ok(return_type.clone());\n                                }\n                                ClassMemberKind::Method {\n                                    return_type: Some(rt),\n                                    ..\n                                } if !self.type_has_unresolved_params(rt) =\u003e {\n                                    return Ok(rt.clone());\n                                }\n                                _ =\u003e {}\n                            }\n                        }\n                    }\n                }\n\n                // If not resolvable, return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n            TypeKind::Object(obj) =\u003e {\n                // Find member in object type\n                let member_id = self.interner.intern(member);\n                for obj_member in \u0026obj.members {\n                    match obj_member {\n                        ObjectTypeMember::Property(prop) =\u003e {\n                            if prop.name.node == member_id {\n                                return Ok(prop.type_annotation.clone());\n                            }\n                        }\n                        ObjectTypeMember::Method(method) =\u003e {\n                            if method.name.node == member_id {\n                                return Ok(Type::new(\n                                    TypeKind::Primitive(PrimitiveType::Unknown),\n                                    span,\n                                ));\n                            }\n                        }\n                        _ =\u003e {}\n                    }\n                }\n                // Member not found\n                Err(TypeCheckError::new(\n                    format!(\"Property '{}' does not exist\", member),\n                    span,\n                ))\n            }\n            TypeKind::Union(types) =\u003e {\n                // For union types, try to find the member in each non-nil variant\n                let non_nil_types: Vec\u003c\u0026Type\u003e = types.iter().filter(|t| !self.is_nil(t)).collect();\n\n                if non_nil_types.is_empty() {\n                    // All types are nil - member access on nil returns nil\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Nil), span))\n                } else if non_nil_types.len() == 1 {\n                    // Single non-nil type - look up member on that\n                    self.infer_member(non_nil_types[0], member, span)\n                } else {\n                    // Multiple non-nil types - try to look up member on first valid one\n                    // For simplicity, we try each type and return the first successful lookup\n                    for typ in non_nil_types {\n                        if let Ok(member_type) = self.infer_member(typ, member, span) {\n                            return Ok(member_type);\n                        }\n                    }\n                    // If none succeeded, return unknown\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n                }\n            }\n            TypeKind::Nullable(inner) =\u003e {\n                // For nullable types, look up member on the inner type\n                self.infer_member(inner, member, span)\n            }\n            _ =\u003e {\n                // Non-object member access - return unknown\n                Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span))\n            }\n        }\n    }\n\n    fn infer_index(\u0026self, obj_type: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match \u0026obj_type.kind {\n            TypeKind::Array(elem_type) =\u003e Ok((**elem_type).clone()),\n            TypeKind::Tuple(types) =\u003e {\n                // For now, return union of all tuple types\n                if types.is_empty() {\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n                } else if types.len() == 1 {\n                    Ok(types[0].clone())\n                } else {\n                    Ok(Type::new(TypeKind::Union(types.clone()), span))\n                }\n            }\n            _ =\u003e Ok(Type::new(TypeKind::Primitive(PrimitiveType::Unknown), span)),\n        }\n    }\n\n    fn make_optional(\u0026self, typ: Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), span);\n        Ok(Type::new(TypeKind::Union(vec![typ, nil_type]), span))\n    }\n\n    fn remove_nil(\u0026self, typ: \u0026Type, span: Span) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match \u0026typ.kind {\n            TypeKind::Union(types) =\u003e {\n                let non_nil_types: Vec\u003cType\u003e =\n                    types.iter().filter(|t| !self.is_nil(t)).cloned().collect();\n                if non_nil_types.is_empty() {\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n                } else if non_nil_types.len() == 1 {\n                    Ok(non_nil_types[0].clone())\n                } else {\n                    Ok(Type::new(TypeKind::Union(non_nil_types), span))\n                }\n            }\n            _ =\u003e {\n                if self.is_nil(typ) {\n                    Ok(Type::new(TypeKind::Primitive(PrimitiveType::Never), span))\n                } else {\n                    Ok(typ.clone())\n                }\n            }\n        }\n    }\n\n    fn is_nil(\u0026self, typ: \u0026Type) -\u003e bool {\n        match \u0026typ.kind {\n            TypeKind::Primitive(PrimitiveType::Nil) =\u003e true,\n            TypeKind::Literal(Literal::Nil) =\u003e true,\n            TypeKind::Nullable(inner) =\u003e self.is_nil(inner),\n            _ =\u003e false,\n        }\n    }\n\n    fn infer_null_coalesce(\n        \u0026self,\n        left: \u0026Type,\n        right: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        // If left is T | nil, the result is T (left without nil)\n        // If left is just nil, the result is the type of right\n        // Otherwise, the result is the type of left\n        let left_without_nil = self.remove_nil(left, span)?;\n\n        // If left was just nil, return right's type\n        // Otherwise return left's type without nil\n        let result = if matches!(\n            left_without_nil.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ) {\n            right.clone()\n        } else {\n            left_without_nil\n        };\n\n        Ok(result)\n    }\n\n    #[instrument(skip(self, match_expr), fields(arms = match_expr.arms.len()))]\n    fn check_match(\u0026mut self, match_expr: \u0026mut MatchExpression) -\u003e Result\u003cType, TypeCheckError\u003e {\n        debug!(span = ?match_expr.span, \"Checking match expression\");\n\n        // Type check the value being matched\n        let value_type = self.infer_expression(\u0026mut match_expr.value)?;\n        debug!(value_type = ?value_type.kind, \"Matched value type\");\n\n        if match_expr.arms.is_empty() {\n            error!(\"Match expression has no arms\");\n            return Err(TypeCheckError::new(\n                \"Match expression must have at least one arm\".to_string(),\n                match_expr.span,\n            ));\n        }\n\n        // Check exhaustiveness\n        self.check_exhaustiveness(\u0026match_expr.arms, \u0026value_type, match_expr.span)?;\n\n        // Check for unreachable patterns\n        self.check_unreachable_patterns(\u0026match_expr.arms);\n\n        // Type check each arm and collect result types\n        let mut arm_types = Vec::new();\n\n        for arm in match_expr.arms.iter_mut() {\n            // Enter a new scope for this arm\n            self.symbol_table.enter_scope();\n\n            // First check that the pattern is compatible with the value type\n            self.check_pattern(\u0026arm.pattern, \u0026value_type)?;\n\n            // Then narrow the type based on the pattern for variable bindings\n            let _narrowed_type = self.narrow_type_by_pattern(\u0026arm.pattern, \u0026value_type)?;\n\n            // Check the guard if present\n            if let Some(guard) = \u0026mut arm.guard {\n                let guard_type = self.infer_expression(guard)?;\n                // Guard should be boolean (primitive or literal)\n                let is_boolean =\n                    matches!(guard_type.kind, TypeKind::Primitive(PrimitiveType::Boolean))\n                        || matches!(guard_type.kind, TypeKind::Literal(Literal::Boolean(_)));\n\n                if !is_boolean {\n                    return Err(TypeCheckError::new(\n                        format!(\"Match guard must be boolean, found {:?}\", guard_type.kind),\n                        guard.span,\n                    ));\n                }\n            }\n\n            // Check the arm body\n            let arm_type = match \u0026mut arm.body {\n                MatchArmBody::Expression(expr) =\u003e self.infer_expression(expr)?,\n                MatchArmBody::Block(block) =\u003e {\n                    // Type check the block\n                    for _stmt in \u0026mut block.statements {\n                        // For now, we can't easily check statements here\n                        // This would require access to the full type checker\n                    }\n                    // Return type is void for blocks without explicit return\n                    Type::new(TypeKind::Primitive(PrimitiveType::Void), block.span)\n                }\n            };\n\n            arm_types.push(arm_type);\n\n            // Exit the arm scope\n            self.symbol_table.exit_scope();\n        }\n\n        // All arms should have compatible types - return a union\n        if arm_types.is_empty() {\n            return Ok(Type::new(\n                TypeKind::Primitive(PrimitiveType::Never),\n                match_expr.span,\n            ));\n        }\n\n        // Find the common type or create a union\n        let mut result_type = arm_types[0].clone();\n        for arm_type in \u0026arm_types[1..] {\n            if TypeCompatibility::is_assignable(\u0026result_type, arm_type) {\n                // Keep result_type\n            } else if TypeCompatibility::is_assignable(arm_type, \u0026result_type) {\n                result_type = arm_type.clone();\n            } else {\n                // Types are incompatible, create a union\n                match \u0026mut result_type.kind {\n                    TypeKind::Union(types) =\u003e {\n                        types.push(arm_type.clone());\n                    }\n                    _ =\u003e {\n                        result_type = Type::new(\n                            TypeKind::Union(vec![result_type.clone(), arm_type.clone()]),\n                            match_expr.span,\n                        );\n                    }\n                }\n            }\n        }\n\n        Ok(result_type)\n    }\n\n    fn check_pattern(\n        \u0026mut self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        match pattern {\n            Pattern::Identifier(ident) =\u003e {\n                // Bind the identifier to the expected type\n                let symbol = Symbol::new(\n                    self.interner.resolve(ident.node).to_string(),\n                    SymbolKind::Variable,\n                    expected_type.clone(),\n                    ident.span,\n                );\n                self.symbol_table\n                    .declare(symbol)\n                    .map_err(|e| TypeCheckError::new(e, ident.span))?;\n                Ok(())\n            }\n            Pattern::Literal(lit, span) =\u003e {\n                // Check that the literal pattern type is compatible with the expected type\n                // For example, a string literal pattern should not match a number value\n                let pattern_is_number = matches!(lit, Literal::Number(_) | Literal::Integer(_));\n                let pattern_is_string = matches!(lit, Literal::String(_));\n                let pattern_is_boolean = matches!(lit, Literal::Boolean(_));\n                let pattern_is_nil = matches!(lit, Literal::Nil);\n\n                let expected_is_number = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Number | PrimitiveType::Integer)\n                        | TypeKind::Literal(Literal::Number(_) | Literal::Integer(_))\n                );\n                let expected_is_string = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::String)\n                        | TypeKind::Literal(Literal::String(_))\n                );\n                let expected_is_boolean = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Boolean)\n                        | TypeKind::Literal(Literal::Boolean(_))\n                );\n                let expected_is_nil = matches!(\n                    expected_type.kind,\n                    TypeKind::Primitive(PrimitiveType::Nil) | TypeKind::Literal(Literal::Nil)\n                );\n\n                let is_compatible = (pattern_is_number \u0026\u0026 expected_is_number)\n                    || (pattern_is_string \u0026\u0026 expected_is_string)\n                    || (pattern_is_boolean \u0026\u0026 expected_is_boolean)\n                    || (pattern_is_nil \u0026\u0026 expected_is_nil);\n\n                if !is_compatible {\n                    self.diagnostic_handler.error(\n                        *span,\n                        \u0026format!(\n                            \"Pattern type mismatch: cannot match literal '{:?}' against type '{:?}'\",\n                            lit, expected_type.kind\n                        ),\n                    );\n                }\n                Ok(())\n            }\n            Pattern::Wildcard(_) =\u003e {\n                // Wildcard matches anything\n                Ok(())\n            }\n            Pattern::Array(array_pattern) =\u003e {\n                // Expected type should be an array\n                match \u0026expected_type.kind {\n                    TypeKind::Array(elem_type) =\u003e {\n                        for elem in \u0026array_pattern.elements {\n                            match elem {\n                                ArrayPatternElement::Pattern(pat) =\u003e {\n                                    self.check_pattern(pat, elem_type)?;\n                                }\n                                ArrayPatternElement::Rest(ident) =\u003e {\n                                    // Rest pattern gets the array type\n                                    let symbol = Symbol::new(\n                                        self.interner.resolve(ident.node).to_string(),\n                                        SymbolKind::Variable,\n                                        expected_type.clone(),\n                                        ident.span,\n                                    );\n                                    self.symbol_table\n                                        .declare(symbol)\n                                        .map_err(|e| TypeCheckError::new(e, ident.span))?;\n                                }\n                                ArrayPatternElement::Hole =\u003e {\n                                    // Hole doesn't bind anything\n                                }\n                            }\n                        }\n                        Ok(())\n                    }\n                    _ =\u003e Err(TypeCheckError::new(\n                        format!(\n                            \"Array pattern requires array type, found {:?}\",\n                            expected_type.kind\n                        ),\n                        array_pattern.span,\n                    )),\n                }\n            }\n            Pattern::Object(object_pattern) =\u003e {\n                // Extract property types from the expected object type\n                match \u0026expected_type.kind {\n                    TypeKind::Object(obj_type) =\u003e {\n                        for prop in \u0026object_pattern.properties {\n                            // Find the property type in the object\n                            let prop_type = obj_type\n                                .members\n                                .iter()\n                                .find_map(|member| {\n                                    if let ObjectTypeMember::Property(prop_sig) = member {\n                                        if prop_sig.name.node == prop.key.node {\n                                            return Some(prop_sig.type_annotation.clone());\n                                        }\n                                    }\n                                    None\n                                })\n                                .unwrap_or_else(|| {\n                                    Type::new(\n                                        TypeKind::Primitive(PrimitiveType::Unknown),\n                                        prop.span,\n                                    )\n                                });\n\n                            if let Some(value_pattern) = \u0026prop.value {\n                                self.check_pattern(value_pattern, \u0026prop_type)?;\n                            } else {\n                                // Shorthand: bind the key as a variable\n                                let symbol = Symbol::new(\n                                    self.interner.resolve(prop.key.node).to_string(),\n                                    SymbolKind::Variable,\n                                    prop_type,\n                                    prop.key.span,\n                                );\n                                self.symbol_table\n                                    .declare(symbol)\n                                    .map_err(|e| TypeCheckError::new(e, prop.key.span))?;\n                            }\n                        }\n                        Ok(())\n                    }\n                    _ =\u003e {\n                        // If it's not an object type, accept any object pattern for now\n                        // This handles cases like Table type\n                        for prop in \u0026object_pattern.properties {\n                            let prop_type =\n                                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), prop.span);\n\n                            if let Some(value_pattern) = \u0026prop.value {\n                                self.check_pattern(value_pattern, \u0026prop_type)?;\n                            } else {\n                                let symbol = Symbol::new(\n                                    self.interner.resolve(prop.key.node).to_string(),\n                                    SymbolKind::Variable,\n                                    prop_type,\n                                    prop.key.span,\n                                );\n                                self.symbol_table\n                                    .declare(symbol)\n                                    .map_err(|e| TypeCheckError::new(e, prop.key.span))?;\n                            }\n                        }\n                        Ok(())\n                    }\n                }\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // Validate that all alternatives bind the same variables with compatible types\n                self.validate_or_pattern_bindings(or_pattern, expected_type)?;\n\n                // Type check and declare symbols from the first alternative only\n                // All alternatives are guaranteed to have the same bindings due to validation above\n                if let Some(first) = or_pattern.alternatives.first() {\n                    self.check_pattern(first, expected_type)?;\n                }\n\n                Ok(())\n            }\n        }\n    }\n}\n\nimpl TypeInferrer\u003c'_\u003e {\n    /// Check if a type contains unresolved type parameters (References that aren't\n    /// known types, interfaces, or classes). Used to guard the access_control fallback\n    /// in infer_member so we don't return raw type annotations with unsubstituted\n    /// type parameters from generic classes.\n    fn type_has_unresolved_params(\u0026self, ty: \u0026Type) -\u003e bool {\n        match \u0026ty.kind {\n            TypeKind::Reference(type_ref) =\u003e {\n                let name = self.interner.resolve(type_ref.name.node);\n                self.type_env.lookup_type(\u0026name).is_none()\n                    \u0026\u0026 self.access_control.get_class_members(\u0026name).is_none()\n            }\n            TypeKind::Union(types) | TypeKind::Intersection(types) | TypeKind::Tuple(types) =\u003e {\n                types.iter().any(|t| self.type_has_unresolved_params(t))\n            }\n            TypeKind::Array(elem) | TypeKind::Nullable(elem) | TypeKind::Parenthesized(elem) =\u003e {\n                self.type_has_unresolved_params(elem)\n            }\n            _ =\u003e false,\n        }\n    }\n\n    /// Check if a type has an operator overload for the given binary operation.\n    /// Returns the operator's return type if found.\n    fn check_operator_overload(\u0026self, operand_type: \u0026Type, op: BinaryOp) -\u003e Option\u003cType\u003e {\n        let op_kind = match op {\n            BinaryOp::Add =\u003e OperatorKind::Add,\n            BinaryOp::Subtract =\u003e OperatorKind::Subtract,\n            BinaryOp::Multiply =\u003e OperatorKind::Multiply,\n            BinaryOp::Divide =\u003e OperatorKind::Divide,\n            BinaryOp::Modulo =\u003e OperatorKind::Modulo,\n            BinaryOp::Power =\u003e OperatorKind::Power,\n            BinaryOp::IntegerDivide =\u003e OperatorKind::FloorDivide,\n            BinaryOp::Concatenate =\u003e OperatorKind::Concatenate,\n            BinaryOp::Equal =\u003e OperatorKind::Equal,\n            BinaryOp::NotEqual =\u003e OperatorKind::NotEqual,\n            BinaryOp::LessThan =\u003e OperatorKind::LessThan,\n            BinaryOp::LessThanOrEqual =\u003e OperatorKind::LessThanOrEqual,\n            BinaryOp::GreaterThan =\u003e OperatorKind::GreaterThan,\n            BinaryOp::GreaterThanOrEqual =\u003e OperatorKind::GreaterThanOrEqual,\n            BinaryOp::BitwiseAnd =\u003e OperatorKind::BitwiseAnd,\n            BinaryOp::BitwiseOr =\u003e OperatorKind::BitwiseOr,\n            BinaryOp::BitwiseXor =\u003e OperatorKind::BitwiseXor,\n            BinaryOp::ShiftLeft =\u003e OperatorKind::ShiftLeft,\n            BinaryOp::ShiftRight =\u003e OperatorKind::ShiftRight,\n            _ =\u003e return None,\n        };\n\n        // Get the class name from the operand type\n        let class_name = match \u0026operand_type.kind {\n            TypeKind::Reference(type_ref) =\u003e self.interner.resolve(type_ref.name.node),\n            _ =\u003e return None,\n        };\n\n        // Look up class members for operator overloads\n        let members = self.access_control.get_class_members(\u0026class_name)?;\n        for member in members {\n            if let ClassMemberKind::Operator {\n                operator,\n                return_type,\n                ..\n            } = \u0026member.kind\n            {\n                if *operator == op_kind {\n                    return return_type.clone();\n                }\n            }\n        }\n\n        None\n    }\n\n    /// Extract all variable bindings from a pattern\n    fn extract_pattern_bindings(\n        \u0026self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003cPatternBindings, TypeCheckError\u003e {\n        let mut bindings = PatternBindings {\n            bindings: FxHashMap::default(),\n        };\n        self.extract_pattern_bindings_recursive(pattern, expected_type, \u0026mut bindings)?;\n        Ok(bindings)\n    }\n\n    /// Recursive helper for extracting bindings from a pattern\n    fn extract_pattern_bindings_recursive(\n        \u0026self,\n        pattern: \u0026Pattern,\n        expected_type: \u0026Type,\n        bindings: \u0026mut PatternBindings,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        match pattern {\n            Pattern::Identifier(ident) =\u003e {\n                // Add binding for the identifier\n                let name = self.interner.resolve(ident.node).to_string();\n                let binding = PatternBinding {\n                    typ: expected_type.clone(),\n                    span: ident.span,\n                };\n                bindings.bindings.insert(name, binding);\n                Ok(())\n            }\n            Pattern::Array(array_pattern) =\u003e {\n                // Extract element type and recurse into elements\n                let elem_type_box: Box\u003cType\u003e = match \u0026expected_type.kind {\n                    TypeKind::Array(et) =\u003e et.clone(),\n                    _ =\u003e {\n                        // If expected type is not an array, use Unknown as element type\n                        // This allows us to extract bindings even when type info is incomplete\n                        Box::new(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Unknown),\n                            expected_type.span,\n                        ))\n                    }\n                };\n\n                for elem in \u0026array_pattern.elements {\n                    match elem {\n                        ArrayPatternElement::Pattern(pat) =\u003e {\n                            self.extract_pattern_bindings_recursive(pat, \u0026elem_type_box, bindings)?;\n                        }\n                        ArrayPatternElement::Rest(ident) =\u003e {\n                            let name = self.interner.resolve(ident.node).to_string();\n                            let binding = PatternBinding {\n                                typ: expected_type.clone(),\n                                span: ident.span,\n                            };\n                            bindings.bindings.insert(name, binding);\n                        }\n                        ArrayPatternElement::Hole =\u003e {\n                            // Hole doesn't bind anything\n                        }\n                    }\n                }\n                Ok(())\n            }\n            Pattern::Object(object_pattern) =\u003e {\n                // Extract property types and recurse\n                for prop in \u0026object_pattern.properties {\n                    let prop_type = match \u0026expected_type.kind {\n                        TypeKind::Object(obj_type) =\u003e obj_type\n                            .members\n                            .iter()\n                            .find_map(|member| {\n                                if let ObjectTypeMember::Property(prop_sig) = member {\n                                    if prop_sig.name.node == prop.key.node {\n                                        return Some(prop_sig.type_annotation.clone());\n                                    }\n                                }\n                                None\n                            })\n                            .unwrap_or_else(|| {\n                                Type::new(TypeKind::Primitive(PrimitiveType::Unknown), prop.span)\n                            }),\n                        _ =\u003e {\n                            // If expected type is not an object, use Unknown for property type\n                            Type::new(TypeKind::Primitive(PrimitiveType::Unknown), prop.span)\n                        }\n                    };\n\n                    if let Some(value_pattern) = \u0026prop.value {\n                        self.extract_pattern_bindings_recursive(\n                            value_pattern,\n                            \u0026prop_type,\n                            bindings,\n                        )?;\n                    } else {\n                        // Shorthand: { x } means { x: x }\n                        let name = self.interner.resolve(prop.key.node).to_string();\n                        let binding = PatternBinding {\n                            typ: prop_type,\n                            span: prop.key.span,\n                        };\n                        bindings.bindings.insert(name, binding);\n                    }\n                }\n                Ok(())\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // For or-patterns, we'll handle this at a higher level\n                // For now, just extract from the first alternative\n                if let Some(first) = or_pattern.alternatives.first() {\n                    self.extract_pattern_bindings_recursive(first, expected_type, bindings)?;\n                }\n                Ok(())\n            }\n            Pattern::Literal(_, _) | Pattern::Wildcard(_) =\u003e {\n                // No bindings\n                Ok(())\n            }\n        }\n    }\n\n    /// Validate that all alternatives in an or-pattern bind the same variables with compatible types\n    fn validate_or_pattern_bindings(\n        \u0026self,\n        or_pattern: \u0026typedlua_parser::ast::pattern::OrPattern,\n        expected_type: \u0026Type,\n    ) -\u003e Result\u003cPatternBindings, TypeCheckError\u003e {\n        use rustc_hash::FxHashSet;\n\n        if or_pattern.alternatives.is_empty() {\n            return Err(TypeCheckError::new(\n                \"Or-pattern must have at least one alternative\",\n                or_pattern.span,\n            ));\n        }\n\n        // Extract bindings from first alternative (reference)\n        let first_alt = \u0026or_pattern.alternatives[0];\n        let first_bindings = self.extract_pattern_bindings(first_alt, expected_type)?;\n\n        // Check each subsequent alternative\n        for (i, alt) in or_pattern.alternatives.iter().enumerate().skip(1) {\n            let alt_bindings = self.extract_pattern_bindings(alt, expected_type)?;\n\n            // Check 1: Same variable names\n            let first_names: FxHashSet\u003c\u0026String\u003e = first_bindings.bindings.keys().collect();\n            let alt_names: FxHashSet\u003c\u0026String\u003e = alt_bindings.bindings.keys().collect();\n\n            // Variables in first but not in alt\n            if let Some(missing) = first_names.difference(\u0026alt_names).next() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Or-pattern alternative {} does not bind variable '{}' (bound in alternative 0)\",\n                        i, missing\n                    ),\n                    alt.span(),\n                ));\n            }\n\n            // Variables in alt but not in first\n            if let Some(extra) = alt_names.difference(\u0026first_names).next() {\n                return Err(TypeCheckError::new(\n                    format!(\n                        \"Or-pattern alternative {} binds variable '{}' not present in alternative 0\",\n                        i, extra\n                    ),\n                    alt.span(),\n                ));\n            }\n\n            // Check 2: Type compatibility for common variables\n            for (name, first_binding) in \u0026first_bindings.bindings {\n                let alt_binding = \u0026alt_bindings.bindings[name];\n\n                // Types must be mutually assignable\n                if !TypeCompatibility::is_assignable(\u0026first_binding.typ, \u0026alt_binding.typ)\n                    \u0026\u0026 !TypeCompatibility::is_assignable(\u0026alt_binding.typ, \u0026first_binding.typ)\n                {\n                    return Err(TypeCheckError::new(\n                        format!(\n                            \"Variable '{}' has incompatible types across or-pattern alternatives: {:?} vs {:?}\",\n                            name, first_binding.typ.kind, alt_binding.typ.kind\n                        ),\n                        alt_binding.span,\n                    ));\n                }\n            }\n        }\n\n        Ok(first_bindings)\n    }\n\n    /// Check if an earlier pattern subsumes a later pattern\n    /// Returns true if all values matching the later pattern would also match the earlier pattern\n    fn pattern_subsumes(\u0026self, earlier: \u0026Pattern, later: \u0026Pattern) -\u003e bool {\n        match (earlier, later) {\n            // Wildcard and identifier always subsume everything\n            (Pattern::Wildcard(_), _) | (Pattern::Identifier(_), _) =\u003e true,\n\n            // Nothing subsumes wildcard/identifier (they're most general)\n            (_, Pattern::Wildcard(_)) | (_, Pattern::Identifier(_)) =\u003e false,\n\n            // Literal subsumption: exact match only\n            (Pattern::Literal(a, _), Pattern::Literal(b, _)) =\u003e a == b,\n\n            // Or-pattern subsumption cases\n            (Pattern::Or(or1), Pattern::Or(or2)) =\u003e {\n                self.or_pattern_subsumes_or_pattern(\u0026or1.alternatives, \u0026or2.alternatives)\n            }\n            (Pattern::Or(or_pat), later_pat) =\u003e {\n                self.or_pattern_subsumes_pattern(\u0026or_pat.alternatives, later_pat)\n            }\n            (earlier_pat, Pattern::Or(or_pat)) =\u003e {\n                self.pattern_subsumes_or_pattern(earlier_pat, \u0026or_pat.alternatives)\n            }\n\n            // Array pattern subsumption\n            (Pattern::Array(arr1), Pattern::Array(arr2)) =\u003e self.array_pattern_subsumes(arr1, arr2),\n\n            // Object pattern subsumption\n            (Pattern::Object(obj1), Pattern::Object(obj2)) =\u003e {\n                self.object_pattern_subsumes(obj1, obj2)\n            }\n\n            // Different pattern types don't subsume each other\n            _ =\u003e false,\n        }\n    }\n\n    /// Or-pattern subsumes single pattern if ANY alternative subsumes it\n    fn or_pattern_subsumes_pattern(\u0026self, or_alts: \u0026[Pattern], later: \u0026Pattern) -\u003e bool {\n        or_alts.iter().any(|alt| self.pattern_subsumes(alt, later))\n    }\n\n    /// Single pattern subsumes or-pattern if it subsumes ALL alternatives\n    fn pattern_subsumes_or_pattern(\u0026self, earlier: \u0026Pattern, or_alts: \u0026[Pattern]) -\u003e bool {\n        or_alts\n            .iter()\n            .all(|alt| self.pattern_subsumes(earlier, alt))\n    }\n\n    /// Or-pattern subsumes or-pattern if every later alternative is subsumed by some earlier alternative\n    fn or_pattern_subsumes_or_pattern(\n        \u0026self,\n        earlier_alts: \u0026[Pattern],\n        later_alts: \u0026[Pattern],\n    ) -\u003e bool {\n        later_alts.iter().all(|later_alt| {\n            earlier_alts\n                .iter()\n                .any(|earlier_alt| self.pattern_subsumes(earlier_alt, later_alt))\n        })\n    }\n\n    /// Array pattern subsumption\n    fn array_pattern_subsumes(\n        \u0026self,\n        earlier: \u0026typedlua_parser::ast::pattern::ArrayPattern,\n        later: \u0026typedlua_parser::ast::pattern::ArrayPattern,\n    ) -\u003e bool {\n        let earlier_elems = \u0026earlier.elements;\n        let later_elems = \u0026later.elements;\n\n        // Check if patterns have rest elements\n        let earlier_has_rest = earlier_elems\n            .iter()\n            .any(|e| matches!(e, ArrayPatternElement::Rest(_)));\n        let later_has_rest = later_elems\n            .iter()\n            .any(|e| matches!(e, ArrayPatternElement::Rest(_)));\n\n        // If neither has rest, lengths must match\n        if !earlier_has_rest \u0026\u0026 !later_has_rest \u0026\u0026 earlier_elems.len() != later_elems.len() {\n            return false;\n        }\n\n        // If earlier has rest but later doesn't, earlier can match more cases\n        // Need to check that later's elements match earlier's prefix\n        if earlier_has_rest \u0026\u0026 !later_has_rest {\n            // Find the position of the rest element in earlier\n            if let Some(rest_pos) = earlier_elems\n                .iter()\n                .position(|e| matches!(e, ArrayPatternElement::Rest(_)))\n            {\n                // Check that later has at least rest_pos elements\n                if later_elems.len() \u003c rest_pos {\n                    return false;\n                }\n\n                // Check element-by-element for the prefix\n                for i in 0..rest_pos {\n                    if !self.array_elements_subsume_single(\u0026earlier_elems[i], \u0026later_elems[i]) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n\n        // Element-by-element subsumption\n        earlier_elems\n            .iter()\n            .zip(later_elems.iter())\n            .all(|(e1, e2)| self.array_elements_subsume_single(e1, e2))\n    }\n\n    /// Check if array pattern element e1 subsumes e2\n    fn array_elements_subsume_single(\n        \u0026self,\n        e1: \u0026ArrayPatternElement,\n        e2: \u0026ArrayPatternElement,\n    ) -\u003e bool {\n        match (e1, e2) {\n            (ArrayPatternElement::Pattern(p1), ArrayPatternElement::Pattern(p2)) =\u003e {\n                self.pattern_subsumes(p1, p2)\n            }\n            (ArrayPatternElement::Rest(_), ArrayPatternElement::Rest(_)) =\u003e true,\n            (ArrayPatternElement::Hole, ArrayPatternElement::Hole) =\u003e true,\n            _ =\u003e false,\n        }\n    }\n\n    /// Object pattern subsumption\n    fn object_pattern_subsumes(\n        \u0026self,\n        earlier: \u0026typedlua_parser::ast::pattern::ObjectPattern,\n        later: \u0026typedlua_parser::ast::pattern::ObjectPattern,\n    ) -\u003e bool {\n        let earlier_props = \u0026earlier.properties;\n        let later_props = \u0026later.properties;\n\n        // Earlier must have  properties (less constrained)\n        if earlier_props.len() \u003e later_props.len() {\n            return false;\n        }\n\n        // Every property in earlier must subsume corresponding property in later\n        earlier_props.iter().all(|earlier_prop| {\n            later_props.iter().any(|later_prop| {\n                // Properties must have same key\n                if earlier_prop.key.node != later_prop.key.node {\n                    return false;\n                }\n\n                // Check value pattern subsumption\n                match (\u0026earlier_prop.value, \u0026later_prop.value) {\n                    (Some(p1), Some(p2)) =\u003e self.pattern_subsumes(p1, p2),\n                    (None, None) =\u003e true,     // Both are shorthand bindings\n                    (None, Some(_)) =\u003e true,  // Earlier shorthand subsumes explicit pattern\n                    (Some(_), None) =\u003e false, // Explicit pattern more specific\n                }\n            })\n        })\n    }\n\n    /// Check for unreachable patterns in match arms\n    fn check_unreachable_patterns(\u0026self, arms: \u0026[MatchArm]) {\n        for (i, arm) in arms.iter().enumerate() {\n            // Skip checking arms with guards - they may not match\n            if arm.guard.is_some() {\n                continue;\n            }\n\n            // Check against all previous arms\n            for (j, earlier_arm) in arms[..i].iter().enumerate() {\n                // Earlier arms with guards don't guarantee subsumption\n                if earlier_arm.guard.is_some() {\n                    continue;\n                }\n\n                if self.pattern_subsumes(\u0026earlier_arm.pattern, \u0026arm.pattern) {\n                    self.emit_unreachable_warning(i, j, earlier_arm, arm);\n                    break; // Only warn once per unreachable pattern\n                }\n            }\n        }\n    }\n\n    /// Emit a warning for an unreachable pattern\n    fn emit_unreachable_warning(\n        \u0026self,\n        _current_idx: usize,\n        subsuming_idx: usize,\n        earlier_arm: \u0026MatchArm,\n        current_arm: \u0026MatchArm,\n    ) {\n        use crate::cli::diagnostics::error_codes::UNREACHABLE_PATTERN;\n\n        let message = format!(\n            \"Pattern is unreachable because it is already covered by arm {} (line {})\",\n            subsuming_idx + 1,\n            earlier_arm.pattern.span().line\n        );\n\n        let diagnostic =\n            crate::cli::diagnostics::Diagnostic::warning(current_arm.pattern.span(), message)\n                .with_code(UNREACHABLE_PATTERN);\n\n        self.diagnostic_handler.report(diagnostic);\n    }\n\n    /// Check member access permissions\n    fn check_member_access(\n        \u0026self,\n        class_name: \u0026str,\n        member_name: \u0026str,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        self.access_control.check_member_access(\n            self.access_control.get_current_class(),\n            class_name,\n            member_name,\n            span,\n        )\n    }\n\n    /// Check if match arms are exhaustive for the given type\n    /// Helper to collect all literals from a pattern, including those in or-patterns\n    fn collect_pattern_literals\u003c'a\u003e(\u0026self, pattern: \u0026'a Pattern, literals: \u0026mut Vec\u003c\u0026'a Literal\u003e) {\n        match pattern {\n            Pattern::Literal(lit, _) =\u003e {\n                literals.push(lit);\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // Recursively collect from all alternatives\n                for alt in \u0026or_pattern.alternatives {\n                    self.collect_pattern_literals(alt, literals);\n                }\n            }\n            _ =\u003e {}\n        }\n    }\n\n    fn check_exhaustiveness(\n        \u0026self,\n        arms: \u0026[MatchArm],\n        value_type: \u0026Type,\n        span: Span,\n    ) -\u003e Result\u003c(), TypeCheckError\u003e {\n        // If there's a wildcard or identifier pattern without a guard, it's exhaustive\n        let has_wildcard = arms.iter().any(|arm| {\n            let is_wildcard = matches!(arm.pattern, Pattern::Wildcard(_) | Pattern::Identifier(_))\n                \u0026\u0026 arm.guard.is_none();\n            eprintln!(\n                \"DEBUG check_exhaustiveness: arm pattern = {:?}, is_wildcard = {}\",\n                arm.pattern, is_wildcard\n            );\n            is_wildcard\n        });\n        eprintln!(\n            \"DEBUG check_exhaustiveness: has_wildcard = {}\",\n            has_wildcard\n        );\n\n        if has_wildcard {\n            return Ok(());\n        }\n\n        // Check exhaustiveness based on type\n        eprintln!(\n            \"DEBUG check_exhaustiveness: value_type.kind = {:?}\",\n            value_type.kind\n        );\n        match \u0026value_type.kind {\n            TypeKind::Primitive(PrimitiveType::Boolean) =\u003e {\n                // Boolean must match both true and false\n                let mut has_true = false;\n                let mut has_false = false;\n\n                eprintln!(\n                    \"DEBUG exhaustiveness: checking {} arms for boolean\",\n                    arms.len()\n                );\n                for arm in arms {\n                    // Collect all literals from the pattern, including those in or-patterns\n                    let mut literals = Vec::new();\n                    self.collect_pattern_literals(\u0026arm.pattern, \u0026mut literals);\n\n                    for lit in literals {\n                        if let Literal::Boolean(b) = lit {\n                            if *b {\n                                has_true = true;\n                            } else {\n                                has_false = true;\n                            }\n                        }\n                    }\n                }\n                eprintln!(\n                    \"DEBUG exhaustiveness: has_true={}, has_false={}\",\n                    has_true, has_false\n                );\n\n                if !has_true || !has_false {\n                    return Err(TypeCheckError::new(\n                        \"Non-exhaustive match: missing case for boolean type. Add patterns for both true and false, or use a wildcard (_) pattern.\".to_string(),\n                        span,\n                    ));\n                }\n                Ok(())\n            }\n            TypeKind::Union(types) =\u003e {\n                // For unions, we need to cover all union members\n                // This is a simplified check - we verify that each union member has a potential match\n                for union_type in types {\n                    let covered = arms.iter().any(|arm| {\n                        // Check if this arm could match this union member\n                        self.pattern_could_match(\u0026arm.pattern, union_type)\n                    });\n\n                    if !covered {\n                        return Err(TypeCheckError::new(\n                            format!(\"Non-exhaustive match: union type {:?} is not covered. Add a pattern to match this type or use a wildcard (_) pattern.\", union_type.kind),\n                            span,\n                        ));\n                    }\n                }\n                Ok(())\n            }\n            TypeKind::Literal(lit) =\u003e {\n                // For literal types, must match exactly that literal\n                let covered = arms.iter().any(|arm| {\n                    let mut literals = Vec::new();\n                    self.collect_pattern_literals(\u0026arm.pattern, \u0026mut literals);\n                    literals.contains(\u0026lit)\n                });\n\n                if !covered {\n                    return Err(TypeCheckError::new(\n                        format!(\"Non-exhaustive match: literal {:?} is not matched. Add a pattern to match this literal or use a wildcard (_) pattern.\", lit),\n                        span,\n                    ));\n                }\n                Ok(())\n            }\n            // For other types, we can't easily verify exhaustiveness\n            // Require a wildcard/identifier pattern or emit a warning\n            _ =\u003e {\n                // Emit a warning that exhaustiveness cannot be verified\n                // For now, we'll allow it but this could be improved\n                Ok(())\n            }\n        }\n    }\n\n    /// Helper to check if a pattern could match a type\n    fn pattern_could_match(\u0026self, pattern: \u0026Pattern, typ: \u0026Type) -\u003e bool {\n        match pattern {\n            Pattern::Wildcard(_) | Pattern::Identifier(_) =\u003e true,\n            Pattern::Literal(lit, _) =\u003e match \u0026typ.kind {\n                TypeKind::Literal(type_lit) =\u003e lit == type_lit,\n                TypeKind::Primitive(PrimitiveType::Boolean) =\u003e matches!(lit, Literal::Boolean(_)),\n                TypeKind::Primitive(PrimitiveType::Number) =\u003e matches!(lit, Literal::Number(_)),\n                TypeKind::Primitive(PrimitiveType::String) =\u003e matches!(lit, Literal::String(_)),\n                _ =\u003e false,\n            },\n            Pattern::Array(_) =\u003e matches!(typ.kind, TypeKind::Array(_) | TypeKind::Tuple(_)),\n            Pattern::Object(_) =\u003e matches!(typ.kind, TypeKind::Object(_)),\n            Pattern::Or(or_pattern) =\u003e {\n                // Or-pattern matches if ANY alternative could match\n                or_pattern\n                    .alternatives\n                    .iter()\n                    .any(|alt| self.pattern_could_match(alt, typ))\n            }\n        }\n    }\n\n    /// Narrow the type based on the pattern\n    fn narrow_type_by_pattern(\n        \u0026self,\n        pattern: \u0026Pattern,\n        typ: \u0026Type,\n    ) -\u003e Result\u003cType, TypeCheckError\u003e {\n        match pattern {\n            Pattern::Wildcard(_) | Pattern::Identifier(_) =\u003e {\n                // No narrowing for wildcard or identifier\n                Ok(typ.clone())\n            }\n            Pattern::Literal(lit, span) =\u003e {\n                // Narrow to literal type\n                Ok(Type::new(TypeKind::Literal(lit.clone()), *span))\n            }\n            Pattern::Array(_) =\u003e {\n                // For array patterns, narrow to array type if it's a union\n                match \u0026typ.kind {\n                    TypeKind::Union(types) =\u003e {\n                        // Find the array type in the union\n                        for t in types {\n                            if matches!(t.kind, TypeKind::Array(_) | TypeKind::Tuple(_)) {\n                                return Ok(t.clone());\n                            }\n                        }\n                        // No array type found, return original\n                        Ok(typ.clone())\n                    }\n                    _ =\u003e Ok(typ.clone()),\n                }\n            }\n            Pattern::Object(obj_pattern) =\u003e {\n                // For object patterns, narrow based on properties\n                match \u0026typ.kind {\n                    TypeKind::Union(types) =\u003e {\n                        // Find object types in the union that have the required properties\n                        let matching_types: Vec\u003c_\u003e = types\n                            .iter()\n                            .filter(|t| {\n                                if let TypeKind::Object(obj_type) = \u0026t.kind {\n                                    // Check if all pattern properties exist in this object type\n                                    obj_pattern.properties.iter().all(|prop| {\n                                        obj_type.members.iter().any(|member| {\n                                            if let ObjectTypeMember::Property(prop_sig) = member {\n                                                prop_sig.name.node == prop.key.node\n                                            } else {\n                                                false\n                                            }\n                                        })\n                                    })\n                                } else {\n                                    false\n                                }\n                            })\n                            .cloned()\n                            .collect();\n\n                        if matching_types.is_empty() {\n                            Ok(typ.clone())\n                        } else if matching_types.len() == 1 {\n                            Ok(matching_types[0].clone())\n                        } else {\n                            Ok(Type::new(TypeKind::Union(matching_types), typ.span))\n                        }\n                    }\n                    _ =\u003e Ok(typ.clone()),\n                }\n            }\n            Pattern::Or(or_pattern) =\u003e {\n                // Narrow to union of all narrowed alternative types\n                let mut narrowed_types = Vec::new();\n\n                for alt in \u0026or_pattern.alternatives {\n                    let narrowed = self.narrow_type_by_pattern(alt, typ)?;\n                    narrowed_types.push(narrowed);\n                }\n\n                // If all narrowed to same type, return single type\n                if narrowed_types.len() == 1 {\n                    Ok(narrowed_types[0].clone())\n                } else {\n                    // Different types - return union\n                    Ok(Type::new(TypeKind::Union(narrowed_types), typ.span))\n                }\n            }\n        }\n    }\n\n    /// Infer the return type from a block by collecting all return statements\n    /// Returns None if no return statements are found (void function)\n    fn infer_block_return_type(\n        \u0026mut self,\n        block: \u0026mut Block,\n    ) -\u003e Result\u003cOption\u003cType\u003e, TypeCheckError\u003e {\n        self.infer_block_return_type_recursive(block)\n    }\n\n    /// Recursively collect return types from a block\n    fn infer_block_return_type_recursive(\n        \u0026mut self,\n        block: \u0026mut Block,\n    ) -\u003e Result\u003cOption\u003cType\u003e, TypeCheckError\u003e {\n        let mut return_types: Vec\u003cType\u003e = Vec::new();\n\n        for stmt in \u0026mut block.statements {\n            match stmt {\n                Statement::Return(return_stmt) =\u003e {\n                    // Infer the type of the return expression(s)\n                    if return_stmt.values.is_empty() {\n                        // Void return\n                        return_types.push(Type::new(\n                            TypeKind::Primitive(PrimitiveType::Void),\n                            return_stmt.span,\n                        ));\n                    } else if return_stmt.values.len() == 1 {\n                        // Single return value\n                        let mut expr = return_stmt.values[0].clone();\n                        let typ = self.infer_expression(\u0026mut expr)?;\n                        return_types.push(typ);\n                    } else {\n                        // Multiple return values - create a tuple\n                        let mut tuple_types = Vec::new();\n                        for expr in return_stmt.values.iter_mut() {\n                            let mut expr_copy: Expression = expr.clone();\n                            let typ = self.infer_expression(\u0026mut expr_copy)?;\n                            tuple_types.push(typ);\n                        }\n                        return_types\n                            .push(Type::new(TypeKind::Tuple(tuple_types), return_stmt.span));\n                    }\n                }\n                Statement::If(if_stmt) =\u003e {\n                    // Check the then block\n                    if let Some(then_type) =\n                        self.infer_block_return_type_recursive(\u0026mut if_stmt.then_block)?\n                    {\n                        return_types.push(then_type);\n                    }\n\n                    // Check else-if blocks\n                    for else_if in \u0026mut if_stmt.else_ifs {\n                        if let Some(else_if_type) =\n                            self.infer_block_return_type_recursive(\u0026mut else_if.block)?\n                        {\n                            return_types.push(else_if_type);\n                        }\n                    }\n\n                    // Check else block\n                    if let Some(else_block) = \u0026mut if_stmt.else_block {\n                        if let Some(else_type) =\n                            self.infer_block_return_type_recursive(else_block)?\n                        {\n                            return_types.push(else_type);\n                        }\n                    }\n                }\n                Statement::Try(try_stmt) =\u003e {\n                    // Check try block\n                    if let Some(try_type) =\n                        self.infer_block_return_type_recursive(\u0026mut try_stmt.try_block)?\n                    {\n                        return_types.push(try_type);\n                    }\n\n                    // Check catch blocks\n                    for catch in \u0026mut try_stmt.catch_clauses {\n                        if let Some(catch_type) =\n                            self.infer_block_return_type_recursive(\u0026mut catch.body)?\n                        {\n                            return_types.push(catch_type);\n                        }\n                    }\n\n                    // Check finally block (though finally typically doesn't return)\n                    if let Some(finally) = \u0026mut try_stmt.finally_block {\n                        if let Some(finally_type) =\n                            self.infer_block_return_type_recursive(finally)?\n                        {\n                            return_types.push(finally_type);\n                        }\n                    }\n                }\n                Statement::While(while_stmt) =\u003e {\n                    if let Some(body_type) =\n                        self.infer_block_return_type_recursive(\u0026mut while_stmt.body)?\n                    {\n                        return_types.push(body_type);\n                    }\n                }\n                Statement::Repeat(repeat_stmt) =\u003e {\n                    if let Some(body_type) =\n                        self.infer_block_return_type_recursive(\u0026mut repeat_stmt.body)?\n                    {\n                        return_types.push(body_type);\n                    }\n                }\n                Statement::For(for_stmt) =\u003e match \u0026mut **for_stmt {\n                    typedlua_parser::ast::statement::ForStatement::Numeric(numeric) =\u003e {\n                        if let Some(body_type) =\n                            self.infer_block_return_type_recursive(\u0026mut numeric.body)?\n                        {\n                            return_types.push(body_type);\n                        }\n                    }\n                    typedlua_parser::ast::statement::ForStatement::Generic(generic) =\u003e {\n                        if let Some(body_type) =\n                            self.infer_block_return_type_recursive(\u0026mut generic.body)?\n                        {\n                            return_types.push(body_type);\n                        }\n                    }\n                },\n                _ =\u003e {\n                    // Other statements don't contain return statements at the top level\n                    // but might contain them in nested expressions (like lambdas)\n                }\n            }\n        }\n\n        if return_types.is_empty() {\n            Ok(None)\n        } else if return_types.len() == 1 {\n            Ok(Some(return_types[0].clone()))\n        } else {\n            // Multiple return types - try to find a common type\n            // For now, create a union of all return types\n            Ok(Some(Type::new(TypeKind::Union(return_types), block.span)))\n        }\n    }\n}\n\n#[cfg(test)]\nmod inference_tests;\n","traces":[{"line":124,"address":[],"length":0,"stats":{"Line":346}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":1}},{"line":151,"address":[],"length":0,"stats":{"Line":690}},{"line":152,"address":[],"length":0,"stats":{"Line":1380}},{"line":153,"address":[],"length":0,"stats":{"Line":2070}},{"line":155,"address":[],"length":0,"stats":{"Line":1380}},{"line":157,"address":[],"length":0,"stats":{"Line":690}},{"line":158,"address":[],"length":0,"stats":{"Line":294}},{"line":159,"address":[],"length":0,"stats":{"Line":294}},{"line":160,"address":[],"length":0,"stats":{"Line":588}},{"line":163,"address":[],"length":0,"stats":{"Line":169}},{"line":164,"address":[],"length":0,"stats":{"Line":676}},{"line":165,"address":[],"length":0,"stats":{"Line":169}},{"line":168,"address":[],"length":0,"stats":{"Line":347}},{"line":169,"address":[],"length":0,"stats":{"Line":9}},{"line":170,"address":[],"length":0,"stats":{"Line":9}},{"line":174,"address":[],"length":0,"stats":{"Line":477}},{"line":175,"address":[],"length":0,"stats":{"Line":157}},{"line":176,"address":[],"length":0,"stats":{"Line":157}},{"line":178,"address":[],"length":0,"stats":{"Line":3}},{"line":179,"address":[],"length":0,"stats":{"Line":6}},{"line":180,"address":[],"length":0,"stats":{"Line":6}},{"line":181,"address":[],"length":0,"stats":{"Line":3}},{"line":186,"address":[],"length":0,"stats":{"Line":264}},{"line":187,"address":[],"length":0,"stats":{"Line":88}},{"line":188,"address":[],"length":0,"stats":{"Line":352}},{"line":189,"address":[],"length":0,"stats":{"Line":352}},{"line":190,"address":[],"length":0,"stats":{"Line":528}},{"line":193,"address":[],"length":0,"stats":{"Line":20}},{"line":194,"address":[],"length":0,"stats":{"Line":10}},{"line":195,"address":[],"length":0,"stats":{"Line":40}},{"line":196,"address":[],"length":0,"stats":{"Line":50}},{"line":199,"address":[],"length":0,"stats":{"Line":72}},{"line":200,"address":[],"length":0,"stats":{"Line":96}},{"line":203,"address":[],"length":0,"stats":{"Line":42}},{"line":204,"address":[],"length":0,"stats":{"Line":23}},{"line":206,"address":[],"length":0,"stats":{"Line":20}},{"line":207,"address":[],"length":0,"stats":{"Line":16}},{"line":208,"address":[],"length":0,"stats":{"Line":6}},{"line":209,"address":[],"length":0,"stats":{"Line":24}},{"line":210,"address":[],"length":0,"stats":{"Line":0}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":18}},{"line":219,"address":[],"length":0,"stats":{"Line":5}},{"line":220,"address":[],"length":0,"stats":{"Line":15}},{"line":222,"address":[],"length":0,"stats":{"Line":5}},{"line":227,"address":[],"length":0,"stats":{"Line":120}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":237,"address":[],"length":0,"stats":{"Line":0}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[],"length":0,"stats":{"Line":0}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":248,"address":[],"length":0,"stats":{"Line":0}},{"line":249,"address":[],"length":0,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":40}},{"line":253,"address":[],"length":0,"stats":{"Line":80}},{"line":254,"address":[],"length":0,"stats":{"Line":80}},{"line":255,"address":[],"length":0,"stats":{"Line":100}},{"line":258,"address":[],"length":0,"stats":{"Line":2}},{"line":259,"address":[],"length":0,"stats":{"Line":4}},{"line":260,"address":[],"length":0,"stats":{"Line":4}},{"line":261,"address":[],"length":0,"stats":{"Line":4}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":265,"address":[],"length":0,"stats":{"Line":4}},{"line":266,"address":[],"length":0,"stats":{"Line":4}},{"line":267,"address":[],"length":0,"stats":{"Line":6}},{"line":268,"address":[],"length":0,"stats":{"Line":4}},{"line":271,"address":[],"length":0,"stats":{"Line":2}},{"line":272,"address":[],"length":0,"stats":{"Line":4}},{"line":273,"address":[],"length":0,"stats":{"Line":4}},{"line":274,"address":[],"length":0,"stats":{"Line":5}},{"line":275,"address":[],"length":0,"stats":{"Line":4}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":282,"address":[],"length":0,"stats":{"Line":2}},{"line":283,"address":[],"length":0,"stats":{"Line":1}},{"line":284,"address":[],"length":0,"stats":{"Line":0}},{"line":285,"address":[],"length":0,"stats":{"Line":0}},{"line":286,"address":[],"length":0,"stats":{"Line":0}},{"line":287,"address":[],"length":0,"stats":{"Line":0}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":290,"address":[],"length":0,"stats":{"Line":0}},{"line":293,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[],"length":0,"stats":{"Line":6}},{"line":305,"address":[],"length":0,"stats":{"Line":4}},{"line":308,"address":[],"length":0,"stats":{"Line":0}},{"line":309,"address":[],"length":0,"stats":{"Line":0}},{"line":310,"address":[],"length":0,"stats":{"Line":0}},{"line":311,"address":[],"length":0,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":315,"address":[],"length":0,"stats":{"Line":7}},{"line":316,"address":[],"length":0,"stats":{"Line":14}},{"line":318,"address":[],"length":0,"stats":{"Line":4}},{"line":319,"address":[],"length":0,"stats":{"Line":6}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":323,"address":[],"length":0,"stats":{"Line":2}},{"line":328,"address":[],"length":0,"stats":{"Line":10}},{"line":330,"address":[],"length":0,"stats":{"Line":29}},{"line":331,"address":[],"length":0,"stats":{"Line":12}},{"line":332,"address":[],"length":0,"stats":{"Line":12}},{"line":333,"address":[],"length":0,"stats":{"Line":48}},{"line":334,"address":[],"length":0,"stats":{"Line":36}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":338,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":345,"address":[],"length":0,"stats":{"Line":0}},{"line":346,"address":[],"length":0,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[],"length":0,"stats":{"Line":0}},{"line":350,"address":[],"length":0,"stats":{"Line":0}},{"line":359,"address":[],"length":0,"stats":{"Line":10}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":361,"address":[],"length":0,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":0}},{"line":369,"address":[],"length":0,"stats":{"Line":15}},{"line":370,"address":[],"length":0,"stats":{"Line":12}},{"line":371,"address":[],"length":0,"stats":{"Line":14}},{"line":372,"address":[],"length":0,"stats":{"Line":14}},{"line":375,"address":[],"length":0,"stats":{"Line":7}},{"line":376,"address":[],"length":0,"stats":{"Line":2}},{"line":377,"address":[],"length":0,"stats":{"Line":2}},{"line":378,"address":[],"length":0,"stats":{"Line":2}},{"line":379,"address":[],"length":0,"stats":{"Line":14}},{"line":381,"address":[],"length":0,"stats":{"Line":6}},{"line":384,"address":[],"length":0,"stats":{"Line":5}},{"line":385,"address":[],"length":0,"stats":{"Line":15}},{"line":386,"address":[],"length":0,"stats":{"Line":20}},{"line":387,"address":[],"length":0,"stats":{"Line":5}},{"line":394,"address":[],"length":0,"stats":{"Line":10}},{"line":397,"address":[],"length":0,"stats":{"Line":24}},{"line":399,"address":[],"length":0,"stats":{"Line":48}},{"line":401,"address":[],"length":0,"stats":{"Line":106}},{"line":402,"address":[],"length":0,"stats":{"Line":41}},{"line":404,"address":[],"length":0,"stats":{"Line":40}},{"line":405,"address":[],"length":0,"stats":{"Line":40}},{"line":406,"address":[],"length":0,"stats":{"Line":40}},{"line":409,"address":[],"length":0,"stats":{"Line":160}},{"line":414,"address":[],"length":0,"stats":{"Line":120}},{"line":417,"address":[],"length":0,"stats":{"Line":40}},{"line":420,"address":[],"length":0,"stats":{"Line":120}},{"line":423,"address":[],"length":0,"stats":{"Line":0}},{"line":424,"address":[],"length":0,"stats":{"Line":0}},{"line":425,"address":[],"length":0,"stats":{"Line":0}},{"line":428,"address":[],"length":0,"stats":{"Line":0}},{"line":429,"address":[],"length":0,"stats":{"Line":0}},{"line":433,"address":[],"length":0,"stats":{"Line":0}},{"line":437,"address":[],"length":0,"stats":{"Line":0}},{"line":438,"address":[],"length":0,"stats":{"Line":0}},{"line":439,"address":[],"length":0,"stats":{"Line":0}},{"line":445,"address":[],"length":0,"stats":{"Line":0}},{"line":451,"address":[],"length":0,"stats":{"Line":1}},{"line":452,"address":[],"length":0,"stats":{"Line":1}},{"line":455,"address":[],"length":0,"stats":{"Line":4}},{"line":456,"address":[],"length":0,"stats":{"Line":1}},{"line":457,"address":[],"length":0,"stats":{"Line":1}},{"line":459,"address":[],"length":0,"stats":{"Line":4}},{"line":460,"address":[],"length":0,"stats":{"Line":3}},{"line":464,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":0}},{"line":466,"address":[],"length":0,"stats":{"Line":0}},{"line":467,"address":[],"length":0,"stats":{"Line":0}},{"line":469,"address":[],"length":0,"stats":{"Line":0}},{"line":477,"address":[],"length":0,"stats":{"Line":48}},{"line":478,"address":[],"length":0,"stats":{"Line":24}},{"line":479,"address":[],"length":0,"stats":{"Line":24}},{"line":483,"address":[],"length":0,"stats":{"Line":14}},{"line":485,"address":[],"length":0,"stats":{"Line":28}},{"line":488,"address":[],"length":0,"stats":{"Line":30}},{"line":489,"address":[],"length":0,"stats":{"Line":16}},{"line":490,"address":[],"length":0,"stats":{"Line":22}},{"line":492,"address":[],"length":0,"stats":{"Line":12}},{"line":495,"address":[],"length":0,"stats":{"Line":6}},{"line":499,"address":[],"length":0,"stats":{"Line":24}},{"line":500,"address":[],"length":0,"stats":{"Line":8}},{"line":501,"address":[],"length":0,"stats":{"Line":8}},{"line":502,"address":[],"length":0,"stats":{"Line":8}},{"line":504,"address":[],"length":0,"stats":{"Line":16}},{"line":509,"address":[],"length":0,"stats":{"Line":42}},{"line":510,"address":[],"length":0,"stats":{"Line":56}},{"line":511,"address":[],"length":0,"stats":{"Line":20}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":519,"address":[],"length":0,"stats":{"Line":24}},{"line":520,"address":[],"length":0,"stats":{"Line":20}},{"line":521,"address":[],"length":0,"stats":{"Line":0}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":523,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":0}},{"line":525,"address":[],"length":0,"stats":{"Line":0}},{"line":532,"address":[],"length":0,"stats":{"Line":28}},{"line":536,"address":[],"length":0,"stats":{"Line":28}},{"line":537,"address":[],"length":0,"stats":{"Line":28}},{"line":538,"address":[],"length":0,"stats":{"Line":14}},{"line":548,"address":[],"length":0,"stats":{"Line":28}},{"line":551,"address":[],"length":0,"stats":{"Line":3}},{"line":553,"address":[],"length":0,"stats":{"Line":6}},{"line":556,"address":[],"length":0,"stats":{"Line":7}},{"line":557,"address":[],"length":0,"stats":{"Line":4}},{"line":558,"address":[],"length":0,"stats":{"Line":6}},{"line":560,"address":[],"length":0,"stats":{"Line":4}},{"line":563,"address":[],"length":0,"stats":{"Line":0}},{"line":567,"address":[],"length":0,"stats":{"Line":6}},{"line":568,"address":[],"length":0,"stats":{"Line":2}},{"line":569,"address":[],"length":0,"stats":{"Line":2}},{"line":570,"address":[],"length":0,"stats":{"Line":2}},{"line":572,"address":[],"length":0,"stats":{"Line":4}},{"line":577,"address":[],"length":0,"stats":{"Line":6}},{"line":578,"address":[],"length":0,"stats":{"Line":2}},{"line":580,"address":[],"length":0,"stats":{"Line":6}},{"line":581,"address":[],"length":0,"stats":{"Line":6}},{"line":583,"address":[],"length":0,"stats":{"Line":1}},{"line":585,"address":[],"length":0,"stats":{"Line":3}},{"line":590,"address":[],"length":0,"stats":{"Line":5}},{"line":591,"address":[],"length":0,"stats":{"Line":4}},{"line":592,"address":[],"length":0,"stats":{"Line":0}},{"line":593,"address":[],"length":0,"stats":{"Line":0}},{"line":594,"address":[],"length":0,"stats":{"Line":0}},{"line":595,"address":[],"length":0,"stats":{"Line":0}},{"line":596,"address":[],"length":0,"stats":{"Line":0}},{"line":603,"address":[],"length":0,"stats":{"Line":6}},{"line":606,"address":[],"length":0,"stats":{"Line":6}},{"line":609,"address":[],"length":0,"stats":{"Line":6}},{"line":610,"address":[],"length":0,"stats":{"Line":8}},{"line":611,"address":[],"length":0,"stats":{"Line":8}},{"line":612,"address":[],"length":0,"stats":{"Line":8}},{"line":615,"address":[],"length":0,"stats":{"Line":6}},{"line":616,"address":[],"length":0,"stats":{"Line":1}},{"line":617,"address":[],"length":0,"stats":{"Line":3}},{"line":618,"address":[],"length":0,"stats":{"Line":0}},{"line":620,"address":[],"length":0,"stats":{"Line":3}},{"line":624,"address":[],"length":0,"stats":{"Line":0}},{"line":626,"address":[],"length":0,"stats":{"Line":2}},{"line":629,"address":[],"length":0,"stats":{"Line":4}},{"line":635,"address":[],"length":0,"stats":{"Line":3}},{"line":638,"address":[],"length":0,"stats":{"Line":1}},{"line":639,"address":[],"length":0,"stats":{"Line":4}},{"line":640,"address":[],"length":0,"stats":{"Line":4}},{"line":642,"address":[],"length":0,"stats":{"Line":3}},{"line":643,"address":[],"length":0,"stats":{"Line":0}},{"line":644,"address":[],"length":0,"stats":{"Line":3}},{"line":645,"address":[],"length":0,"stats":{"Line":0}},{"line":647,"address":[],"length":0,"stats":{"Line":2}},{"line":648,"address":[],"length":0,"stats":{"Line":2}},{"line":649,"address":[],"length":0,"stats":{"Line":1}},{"line":654,"address":[],"length":0,"stats":{"Line":2}},{"line":655,"address":[],"length":0,"stats":{"Line":4}},{"line":656,"address":[],"length":0,"stats":{"Line":3}},{"line":659,"address":[],"length":0,"stats":{"Line":0}},{"line":663,"address":[],"length":0,"stats":{"Line":0}},{"line":664,"address":[],"length":0,"stats":{"Line":0}},{"line":665,"address":[],"length":0,"stats":{"Line":0}},{"line":668,"address":[],"length":0,"stats":{"Line":0}},{"line":669,"address":[],"length":0,"stats":{"Line":0}},{"line":670,"address":[],"length":0,"stats":{"Line":0}},{"line":671,"address":[],"length":0,"stats":{"Line":0}},{"line":676,"address":[],"length":0,"stats":{"Line":0}},{"line":677,"address":[],"length":0,"stats":{"Line":0}},{"line":678,"address":[],"length":0,"stats":{"Line":0}},{"line":679,"address":[],"length":0,"stats":{"Line":0}},{"line":680,"address":[],"length":0,"stats":{"Line":0}},{"line":682,"address":[],"length":0,"stats":{"Line":0}},{"line":688,"address":[],"length":0,"stats":{"Line":0}},{"line":693,"address":[],"length":0,"stats":{"Line":2}},{"line":695,"address":[],"length":0,"stats":{"Line":6}},{"line":700,"address":[],"length":0,"stats":{"Line":52}},{"line":705,"address":[],"length":0,"stats":{"Line":88}},{"line":712,"address":[],"length":0,"stats":{"Line":88}},{"line":721,"address":[],"length":0,"stats":{"Line":105}},{"line":722,"address":[],"length":0,"stats":{"Line":0}},{"line":726,"address":[],"length":0,"stats":{"Line":35}},{"line":727,"address":[],"length":0,"stats":{"Line":25}},{"line":731,"address":[],"length":0,"stats":{"Line":35}},{"line":732,"address":[],"length":0,"stats":{"Line":19}},{"line":737,"address":[],"length":0,"stats":{"Line":35}},{"line":738,"address":[],"length":0,"stats":{"Line":0}},{"line":739,"address":[],"length":0,"stats":{"Line":0}},{"line":740,"address":[],"length":0,"stats":{"Line":0}},{"line":741,"address":[],"length":0,"stats":{"Line":0}},{"line":742,"address":[],"length":0,"stats":{"Line":0}},{"line":746,"address":[],"length":0,"stats":{"Line":35}},{"line":747,"address":[],"length":0,"stats":{"Line":0}},{"line":748,"address":[],"length":0,"stats":{"Line":0}},{"line":749,"address":[],"length":0,"stats":{"Line":0}},{"line":750,"address":[],"length":0,"stats":{"Line":0}},{"line":751,"address":[],"length":0,"stats":{"Line":0}},{"line":756,"address":[],"length":0,"stats":{"Line":70}},{"line":759,"address":[],"length":0,"stats":{"Line":12}},{"line":768,"address":[],"length":0,"stats":{"Line":64}},{"line":771,"address":[],"length":0,"stats":{"Line":14}},{"line":773,"address":[],"length":0,"stats":{"Line":5}},{"line":779,"address":[],"length":0,"stats":{"Line":14}},{"line":784,"address":[],"length":0,"stats":{"Line":10}},{"line":790,"address":[],"length":0,"stats":{"Line":10}},{"line":791,"address":[],"length":0,"stats":{"Line":8}},{"line":792,"address":[],"length":0,"stats":{"Line":4}},{"line":793,"address":[],"length":0,"stats":{"Line":4}},{"line":794,"address":[],"length":0,"stats":{"Line":4}},{"line":799,"address":[],"length":0,"stats":{"Line":25}},{"line":805,"address":[],"length":0,"stats":{"Line":25}},{"line":807,"address":[],"length":0,"stats":{"Line":25}},{"line":808,"address":[],"length":0,"stats":{"Line":19}},{"line":810,"address":[],"length":0,"stats":{"Line":57}},{"line":811,"address":[],"length":0,"stats":{"Line":19}},{"line":814,"address":[],"length":0,"stats":{"Line":38}},{"line":815,"address":[],"length":0,"stats":{"Line":19}},{"line":817,"address":[],"length":0,"stats":{"Line":67}},{"line":821,"address":[],"length":0,"stats":{"Line":38}},{"line":822,"address":[],"length":0,"stats":{"Line":19}},{"line":824,"address":[],"length":0,"stats":{"Line":19}},{"line":828,"address":[],"length":0,"stats":{"Line":38}},{"line":829,"address":[],"length":0,"stats":{"Line":19}},{"line":831,"address":[],"length":0,"stats":{"Line":45}},{"line":834,"address":[],"length":0,"stats":{"Line":38}},{"line":835,"address":[],"length":0,"stats":{"Line":2}},{"line":837,"address":[],"length":0,"stats":{"Line":17}},{"line":841,"address":[],"length":0,"stats":{"Line":19}},{"line":842,"address":[],"length":0,"stats":{"Line":0}},{"line":845,"address":[],"length":0,"stats":{"Line":0}},{"line":847,"address":[],"length":0,"stats":{"Line":0}},{"line":848,"address":[],"length":0,"stats":{"Line":0}},{"line":849,"address":[],"length":0,"stats":{"Line":0}},{"line":850,"address":[],"length":0,"stats":{"Line":0}},{"line":852,"address":[],"length":0,"stats":{"Line":0}},{"line":857,"address":[],"length":0,"stats":{"Line":36}},{"line":858,"address":[],"length":0,"stats":{"Line":0}},{"line":861,"address":[],"length":0,"stats":{"Line":0}},{"line":863,"address":[],"length":0,"stats":{"Line":0}},{"line":864,"address":[],"length":0,"stats":{"Line":0}},{"line":865,"address":[],"length":0,"stats":{"Line":0}},{"line":866,"address":[],"length":0,"stats":{"Line":0}},{"line":868,"address":[],"length":0,"stats":{"Line":0}},{"line":873,"address":[],"length":0,"stats":{"Line":109}},{"line":874,"address":[],"length":0,"stats":{"Line":52}},{"line":875,"address":[],"length":0,"stats":{"Line":48}},{"line":878,"address":[],"length":0,"stats":{"Line":72}},{"line":879,"address":[],"length":0,"stats":{"Line":47}},{"line":881,"address":[],"length":0,"stats":{"Line":53}},{"line":882,"address":[],"length":0,"stats":{"Line":21}},{"line":883,"address":[],"length":0,"stats":{"Line":14}},{"line":884,"address":[],"length":0,"stats":{"Line":14}},{"line":885,"address":[],"length":0,"stats":{"Line":7}},{"line":886,"address":[],"length":0,"stats":{"Line":7}},{"line":887,"address":[],"length":0,"stats":{"Line":7}},{"line":888,"address":[],"length":0,"stats":{"Line":7}},{"line":897,"address":[],"length":0,"stats":{"Line":19}},{"line":901,"address":[],"length":0,"stats":{"Line":12}},{"line":906,"address":[],"length":0,"stats":{"Line":0}},{"line":914,"address":[],"length":0,"stats":{"Line":0}},{"line":915,"address":[],"length":0,"stats":{"Line":0}},{"line":916,"address":[],"length":0,"stats":{"Line":0}},{"line":917,"address":[],"length":0,"stats":{"Line":0}},{"line":918,"address":[],"length":0,"stats":{"Line":0}},{"line":920,"address":[],"length":0,"stats":{"Line":0}},{"line":925,"address":[],"length":0,"stats":{"Line":0}},{"line":927,"address":[],"length":0,"stats":{"Line":0}},{"line":928,"address":[],"length":0,"stats":{"Line":0}},{"line":929,"address":[],"length":0,"stats":{"Line":0}},{"line":930,"address":[],"length":0,"stats":{"Line":0}},{"line":931,"address":[],"length":0,"stats":{"Line":0}},{"line":932,"address":[],"length":0,"stats":{"Line":0}},{"line":933,"address":[],"length":0,"stats":{"Line":0}},{"line":934,"address":[],"length":0,"stats":{"Line":0}},{"line":940,"address":[],"length":0,"stats":{"Line":0}},{"line":942,"address":[],"length":0,"stats":{"Line":0}},{"line":946,"address":[],"length":0,"stats":{"Line":21}},{"line":952,"address":[],"length":0,"stats":{"Line":21}},{"line":953,"address":[],"length":0,"stats":{"Line":8}},{"line":954,"address":[],"length":0,"stats":{"Line":32}},{"line":957,"address":[],"length":0,"stats":{"Line":8}},{"line":958,"address":[],"length":0,"stats":{"Line":0}},{"line":962,"address":[],"length":0,"stats":{"Line":0}},{"line":963,"address":[],"length":0,"stats":{"Line":0}},{"line":964,"address":[],"length":0,"stats":{"Line":0}},{"line":966,"address":[],"length":0,"stats":{"Line":0}},{"line":967,"address":[],"length":0,"stats":{"Line":0}},{"line":973,"address":[],"length":0,"stats":{"Line":16}},{"line":974,"address":[],"length":0,"stats":{"Line":0}},{"line":978,"address":[],"length":0,"stats":{"Line":40}},{"line":982,"address":[],"length":0,"stats":{"Line":16}},{"line":984,"address":[],"length":0,"stats":{"Line":0}},{"line":986,"address":[],"length":0,"stats":{"Line":0}},{"line":987,"address":[],"length":0,"stats":{"Line":0}},{"line":992,"address":[],"length":0,"stats":{"Line":0}},{"line":993,"address":[],"length":0,"stats":{"Line":0}},{"line":994,"address":[],"length":0,"stats":{"Line":0}},{"line":999,"address":[],"length":0,"stats":{"Line":0}},{"line":1006,"address":[],"length":0,"stats":{"Line":24}},{"line":1007,"address":[],"length":0,"stats":{"Line":20}},{"line":1008,"address":[],"length":0,"stats":{"Line":10}},{"line":1009,"address":[],"length":0,"stats":{"Line":8}},{"line":1010,"address":[],"length":0,"stats":{"Line":8}},{"line":1011,"address":[],"length":0,"stats":{"Line":32}},{"line":1013,"address":[],"length":0,"stats":{"Line":8}},{"line":1015,"address":[],"length":0,"stats":{"Line":0}},{"line":1016,"address":[],"length":0,"stats":{"Line":0}},{"line":1018,"address":[],"length":0,"stats":{"Line":0}},{"line":1021,"address":[],"length":0,"stats":{"Line":0}},{"line":1023,"address":[],"length":0,"stats":{"Line":0}},{"line":1024,"address":[],"length":0,"stats":{"Line":0}},{"line":1026,"address":[],"length":0,"stats":{"Line":0}},{"line":1033,"address":[],"length":0,"stats":{"Line":0}},{"line":1035,"address":[],"length":0,"stats":{"Line":12}},{"line":1037,"address":[],"length":0,"stats":{"Line":48}},{"line":1038,"address":[],"length":0,"stats":{"Line":68}},{"line":1039,"address":[],"length":0,"stats":{"Line":34}},{"line":1040,"address":[],"length":0,"stats":{"Line":14}},{"line":1041,"address":[],"length":0,"stats":{"Line":14}},{"line":1042,"address":[],"length":0,"stats":{"Line":9}},{"line":1045,"address":[],"length":0,"stats":{"Line":20}},{"line":1046,"address":[],"length":0,"stats":{"Line":20}},{"line":1047,"address":[],"length":0,"stats":{"Line":6}},{"line":1048,"address":[],"length":0,"stats":{"Line":3}},{"line":1049,"address":[],"length":0,"stats":{"Line":3}},{"line":1053,"address":[],"length":0,"stats":{"Line":0}},{"line":1057,"address":[],"length":0,"stats":{"Line":0}},{"line":1058,"address":[],"length":0,"stats":{"Line":0}},{"line":1059,"address":[],"length":0,"stats":{"Line":0}},{"line":1062,"address":[],"length":0,"stats":{"Line":0}},{"line":1064,"address":[],"length":0,"stats":{"Line":0}},{"line":1066,"address":[],"length":0,"stats":{"Line":0}},{"line":1068,"address":[],"length":0,"stats":{"Line":0}},{"line":1069,"address":[],"length":0,"stats":{"Line":0}},{"line":1071,"address":[],"length":0,"stats":{"Line":0}},{"line":1075,"address":[],"length":0,"stats":{"Line":0}},{"line":1076,"address":[],"length":0,"stats":{"Line":0}},{"line":1077,"address":[],"length":0,"stats":{"Line":0}},{"line":1081,"address":[],"length":0,"stats":{"Line":0}},{"line":1084,"address":[],"length":0,"stats":{"Line":0}},{"line":1086,"address":[],"length":0,"stats":{"Line":0}},{"line":1090,"address":[],"length":0,"stats":{"Line":2}},{"line":1095,"address":[],"length":0,"stats":{"Line":2}},{"line":1096,"address":[],"length":0,"stats":{"Line":2}},{"line":1097,"address":[],"length":0,"stats":{"Line":2}},{"line":1098,"address":[],"length":0,"stats":{"Line":1}},{"line":1100,"address":[],"length":0,"stats":{"Line":2}},{"line":1101,"address":[],"length":0,"stats":{"Line":0}},{"line":1102,"address":[],"length":0,"stats":{"Line":1}},{"line":1103,"address":[],"length":0,"stats":{"Line":0}},{"line":1105,"address":[],"length":0,"stats":{"Line":2}},{"line":1108,"address":[],"length":0,"stats":{"Line":0}},{"line":1112,"address":[],"length":0,"stats":{"Line":3}},{"line":1113,"address":[],"length":0,"stats":{"Line":12}},{"line":1114,"address":[],"length":0,"stats":{"Line":9}},{"line":1117,"address":[],"length":0,"stats":{"Line":1}},{"line":1118,"address":[],"length":0,"stats":{"Line":1}},{"line":1119,"address":[],"length":0,"stats":{"Line":0}},{"line":1120,"address":[],"length":0,"stats":{"Line":0}},{"line":1121,"address":[],"length":0,"stats":{"Line":0}},{"line":1122,"address":[],"length":0,"stats":{"Line":0}},{"line":1123,"address":[],"length":0,"stats":{"Line":0}},{"line":1124,"address":[],"length":0,"stats":{"Line":0}},{"line":1125,"address":[],"length":0,"stats":{"Line":0}},{"line":1127,"address":[],"length":0,"stats":{"Line":0}},{"line":1131,"address":[],"length":0,"stats":{"Line":3}},{"line":1132,"address":[],"length":0,"stats":{"Line":2}},{"line":1134,"address":[],"length":0,"stats":{"Line":0}},{"line":1140,"address":[],"length":0,"stats":{"Line":1}},{"line":1141,"address":[],"length":0,"stats":{"Line":0}},{"line":1142,"address":[],"length":0,"stats":{"Line":0}},{"line":1143,"address":[],"length":0,"stats":{"Line":1}},{"line":1144,"address":[],"length":0,"stats":{"Line":0}},{"line":1145,"address":[],"length":0,"stats":{"Line":0}},{"line":1149,"address":[],"length":0,"stats":{"Line":1}},{"line":1158,"address":[],"length":0,"stats":{"Line":5}},{"line":1162,"address":[],"length":0,"stats":{"Line":1}},{"line":1163,"address":[],"length":0,"stats":{"Line":1}},{"line":1166,"address":[],"length":0,"stats":{"Line":2}},{"line":1168,"address":[],"length":0,"stats":{"Line":0}},{"line":1171,"address":[],"length":0,"stats":{"Line":1}},{"line":1175,"address":[],"length":0,"stats":{"Line":0}},{"line":1176,"address":[],"length":0,"stats":{"Line":0}},{"line":1179,"address":[],"length":0,"stats":{"Line":0}},{"line":1180,"address":[],"length":0,"stats":{"Line":0}},{"line":1182,"address":[],"length":0,"stats":{"Line":0}},{"line":1183,"address":[],"length":0,"stats":{"Line":0}},{"line":1184,"address":[],"length":0,"stats":{"Line":0}},{"line":1185,"address":[],"length":0,"stats":{"Line":0}},{"line":1186,"address":[],"length":0,"stats":{"Line":0}},{"line":1191,"address":[],"length":0,"stats":{"Line":0}},{"line":1194,"address":[],"length":0,"stats":{"Line":0}},{"line":1197,"address":[],"length":0,"stats":{"Line":0}},{"line":1199,"address":[],"length":0,"stats":{"Line":0}},{"line":1201,"address":[],"length":0,"stats":{"Line":0}},{"line":1204,"address":[],"length":0,"stats":{"Line":0}},{"line":1207,"address":[],"length":0,"stats":{"Line":0}},{"line":1210,"address":[],"length":0,"stats":{"Line":0}},{"line":1211,"address":[],"length":0,"stats":{"Line":0}},{"line":1213,"address":[],"length":0,"stats":{"Line":0}},{"line":1214,"address":[],"length":0,"stats":{"Line":0}},{"line":1215,"address":[],"length":0,"stats":{"Line":0}},{"line":1217,"address":[],"length":0,"stats":{"Line":0}},{"line":1218,"address":[],"length":0,"stats":{"Line":0}},{"line":1219,"address":[],"length":0,"stats":{"Line":0}},{"line":1220,"address":[],"length":0,"stats":{"Line":0}},{"line":1226,"address":[],"length":0,"stats":{"Line":0}},{"line":1227,"address":[],"length":0,"stats":{"Line":0}},{"line":1228,"address":[],"length":0,"stats":{"Line":0}},{"line":1230,"address":[],"length":0,"stats":{"Line":0}},{"line":1235,"address":[],"length":0,"stats":{"Line":0}},{"line":1239,"address":[],"length":0,"stats":{"Line":0}},{"line":1242,"address":[],"length":0,"stats":{"Line":0}},{"line":1246,"address":[],"length":0,"stats":{"Line":0}},{"line":1247,"address":[],"length":0,"stats":{"Line":0}},{"line":1248,"address":[],"length":0,"stats":{"Line":0}},{"line":1249,"address":[],"length":0,"stats":{"Line":0}},{"line":1254,"address":[],"length":0,"stats":{"Line":0}},{"line":1255,"address":[],"length":0,"stats":{"Line":0}},{"line":1256,"address":[],"length":0,"stats":{"Line":0}},{"line":1258,"address":[],"length":0,"stats":{"Line":0}},{"line":1259,"address":[],"length":0,"stats":{"Line":0}},{"line":1262,"address":[],"length":0,"stats":{"Line":0}},{"line":1263,"address":[],"length":0,"stats":{"Line":0}},{"line":1264,"address":[],"length":0,"stats":{"Line":0}},{"line":1266,"address":[],"length":0,"stats":{"Line":0}},{"line":1267,"address":[],"length":0,"stats":{"Line":0}},{"line":1268,"address":[],"length":0,"stats":{"Line":0}},{"line":1269,"address":[],"length":0,"stats":{"Line":0}},{"line":1276,"address":[],"length":0,"stats":{"Line":0}},{"line":1279,"address":[],"length":0,"stats":{"Line":0}},{"line":1284,"address":[],"length":0,"stats":{"Line":0}},{"line":1285,"address":[],"length":0,"stats":{"Line":0}},{"line":1288,"address":[],"length":0,"stats":{"Line":0}},{"line":1289,"address":[],"length":0,"stats":{"Line":0}},{"line":1290,"address":[],"length":0,"stats":{"Line":0}},{"line":1291,"address":[],"length":0,"stats":{"Line":0}},{"line":1293,"address":[],"length":0,"stats":{"Line":0}},{"line":1294,"address":[],"length":0,"stats":{"Line":0}},{"line":1295,"address":[],"length":0,"stats":{"Line":0}},{"line":1296,"address":[],"length":0,"stats":{"Line":0}},{"line":1298,"address":[],"length":0,"stats":{"Line":0}},{"line":1301,"address":[],"length":0,"stats":{"Line":0}},{"line":1302,"address":[],"length":0,"stats":{"Line":0}},{"line":1303,"address":[],"length":0,"stats":{"Line":0}},{"line":1304,"address":[],"length":0,"stats":{"Line":0}},{"line":1306,"address":[],"length":0,"stats":{"Line":0}},{"line":1307,"address":[],"length":0,"stats":{"Line":0}},{"line":1311,"address":[],"length":0,"stats":{"Line":0}},{"line":1312,"address":[],"length":0,"stats":{"Line":0}},{"line":1316,"address":[],"length":0,"stats":{"Line":0}},{"line":1317,"address":[],"length":0,"stats":{"Line":0}},{"line":1321,"address":[],"length":0,"stats":{"Line":0}},{"line":1322,"address":[],"length":0,"stats":{"Line":0}},{"line":1326,"address":[],"length":0,"stats":{"Line":0}},{"line":1327,"address":[],"length":0,"stats":{"Line":0}},{"line":1328,"address":[],"length":0,"stats":{"Line":0}},{"line":1329,"address":[],"length":0,"stats":{"Line":0}},{"line":1331,"address":[],"length":0,"stats":{"Line":0}},{"line":1332,"address":[],"length":0,"stats":{"Line":0}},{"line":1333,"address":[],"length":0,"stats":{"Line":0}},{"line":1334,"address":[],"length":0,"stats":{"Line":0}},{"line":1335,"address":[],"length":0,"stats":{"Line":0}},{"line":1336,"address":[],"length":0,"stats":{"Line":0}},{"line":1340,"address":[],"length":0,"stats":{"Line":0}},{"line":1344,"address":[],"length":0,"stats":{"Line":0}},{"line":1346,"address":[],"length":0,"stats":{"Line":0}},{"line":1348,"address":[],"length":0,"stats":{"Line":0}},{"line":1349,"address":[],"length":0,"stats":{"Line":0}},{"line":1350,"address":[],"length":0,"stats":{"Line":0}},{"line":1351,"address":[],"length":0,"stats":{"Line":0}},{"line":1352,"address":[],"length":0,"stats":{"Line":0}},{"line":1353,"address":[],"length":0,"stats":{"Line":0}},{"line":1355,"address":[],"length":0,"stats":{"Line":0}},{"line":1358,"address":[],"length":0,"stats":{"Line":0}},{"line":1359,"address":[],"length":0,"stats":{"Line":0}},{"line":1360,"address":[],"length":0,"stats":{"Line":0}},{"line":1361,"address":[],"length":0,"stats":{"Line":0}},{"line":1363,"address":[],"length":0,"stats":{"Line":0}},{"line":1364,"address":[],"length":0,"stats":{"Line":0}},{"line":1365,"address":[],"length":0,"stats":{"Line":0}},{"line":1367,"address":[],"length":0,"stats":{"Line":0}},{"line":1372,"address":[],"length":0,"stats":{"Line":0}},{"line":1374,"address":[],"length":0,"stats":{"Line":0}},{"line":1375,"address":[],"length":0,"stats":{"Line":0}},{"line":1376,"address":[],"length":0,"stats":{"Line":0}},{"line":1377,"address":[],"length":0,"stats":{"Line":0}},{"line":1379,"address":[],"length":0,"stats":{"Line":0}},{"line":1383,"address":[],"length":0,"stats":{"Line":0}},{"line":1385,"address":[],"length":0,"stats":{"Line":0}},{"line":1386,"address":[],"length":0,"stats":{"Line":0}},{"line":1387,"address":[],"length":0,"stats":{"Line":0}},{"line":1389,"address":[],"length":0,"stats":{"Line":0}},{"line":1390,"address":[],"length":0,"stats":{"Line":0}},{"line":1392,"address":[],"length":0,"stats":{"Line":0}},{"line":1393,"address":[],"length":0,"stats":{"Line":0}},{"line":1394,"address":[],"length":0,"stats":{"Line":0}},{"line":1395,"address":[],"length":0,"stats":{"Line":0}},{"line":1398,"address":[],"length":0,"stats":{"Line":0}},{"line":1400,"address":[],"length":0,"stats":{"Line":0}},{"line":1401,"address":[],"length":0,"stats":{"Line":0}},{"line":1402,"address":[],"length":0,"stats":{"Line":0}},{"line":1403,"address":[],"length":0,"stats":{"Line":0}},{"line":1407,"address":[],"length":0,"stats":{"Line":0}},{"line":1408,"address":[],"length":0,"stats":{"Line":0}},{"line":1412,"address":[],"length":0,"stats":{"Line":0}},{"line":1413,"address":[],"length":0,"stats":{"Line":0}},{"line":1414,"address":[],"length":0,"stats":{"Line":0}},{"line":1415,"address":[],"length":0,"stats":{"Line":0}},{"line":1417,"address":[],"length":0,"stats":{"Line":0}},{"line":1418,"address":[],"length":0,"stats":{"Line":0}},{"line":1419,"address":[],"length":0,"stats":{"Line":0}},{"line":1422,"address":[],"length":0,"stats":{"Line":0}},{"line":1427,"address":[],"length":0,"stats":{"Line":0}},{"line":1428,"address":[],"length":0,"stats":{"Line":0}},{"line":1429,"address":[],"length":0,"stats":{"Line":0}},{"line":1431,"address":[],"length":0,"stats":{"Line":0}},{"line":1432,"address":[],"length":0,"stats":{"Line":0}},{"line":1435,"address":[],"length":0,"stats":{"Line":0}},{"line":1436,"address":[],"length":0,"stats":{"Line":0}},{"line":1437,"address":[],"length":0,"stats":{"Line":0}},{"line":1438,"address":[],"length":0,"stats":{"Line":0}},{"line":1440,"address":[],"length":0,"stats":{"Line":0}},{"line":1441,"address":[],"length":0,"stats":{"Line":0}},{"line":1442,"address":[],"length":0,"stats":{"Line":0}},{"line":1445,"address":[],"length":0,"stats":{"Line":0}},{"line":1449,"address":[],"length":0,"stats":{"Line":0}},{"line":1451,"address":[],"length":0,"stats":{"Line":0}},{"line":1455,"address":[],"length":0,"stats":{"Line":0}},{"line":1456,"address":[],"length":0,"stats":{"Line":0}},{"line":1459,"address":[],"length":0,"stats":{"Line":0}},{"line":1470,"address":[],"length":0,"stats":{"Line":8}},{"line":1471,"address":[],"length":0,"stats":{"Line":8}},{"line":1472,"address":[],"length":0,"stats":{"Line":1}},{"line":1473,"address":[],"length":0,"stats":{"Line":4}},{"line":1474,"address":[],"length":0,"stats":{"Line":3}},{"line":1475,"address":[],"length":0,"stats":{"Line":0}},{"line":1477,"address":[],"length":0,"stats":{"Line":0}},{"line":1478,"address":[],"length":0,"stats":{"Line":0}},{"line":1480,"address":[],"length":0,"stats":{"Line":0}},{"line":1481,"address":[],"length":0,"stats":{"Line":0}},{"line":1483,"address":[],"length":0,"stats":{"Line":7}},{"line":1489,"address":[],"length":0,"stats":{"Line":35}},{"line":1490,"address":[],"length":0,"stats":{"Line":70}},{"line":1491,"address":[],"length":0,"stats":{"Line":17}},{"line":1492,"address":[],"length":0,"stats":{"Line":1}},{"line":1493,"address":[],"length":0,"stats":{"Line":11}},{"line":1494,"address":[],"length":0,"stats":{"Line":1}},{"line":1495,"address":[],"length":0,"stats":{"Line":2}},{"line":1496,"address":[],"length":0,"stats":{"Line":2}},{"line":1497,"address":[],"length":0,"stats":{"Line":1}},{"line":1498,"address":[],"length":0,"stats":{"Line":0}},{"line":1499,"address":[],"length":0,"stats":{"Line":0}},{"line":1500,"address":[],"length":0,"stats":{"Line":0}},{"line":1501,"address":[],"length":0,"stats":{"Line":0}},{"line":1502,"address":[],"length":0,"stats":{"Line":0}},{"line":1503,"address":[],"length":0,"stats":{"Line":0}},{"line":1504,"address":[],"length":0,"stats":{"Line":0}},{"line":1505,"address":[],"length":0,"stats":{"Line":0}},{"line":1506,"address":[],"length":0,"stats":{"Line":0}},{"line":1507,"address":[],"length":0,"stats":{"Line":0}},{"line":1508,"address":[],"length":0,"stats":{"Line":0}},{"line":1509,"address":[],"length":0,"stats":{"Line":0}},{"line":1510,"address":[],"length":0,"stats":{"Line":0}},{"line":1514,"address":[],"length":0,"stats":{"Line":35}},{"line":1515,"address":[],"length":0,"stats":{"Line":0}},{"line":1516,"address":[],"length":0,"stats":{"Line":35}},{"line":1520,"address":[],"length":0,"stats":{"Line":0}},{"line":1521,"address":[],"length":0,"stats":{"Line":0}},{"line":1523,"address":[],"length":0,"stats":{"Line":0}},{"line":1524,"address":[],"length":0,"stats":{"Line":0}},{"line":1526,"address":[],"length":0,"stats":{"Line":0}},{"line":1528,"address":[],"length":0,"stats":{"Line":0}},{"line":1529,"address":[],"length":0,"stats":{"Line":0}},{"line":1534,"address":[],"length":0,"stats":{"Line":0}},{"line":1538,"address":[],"length":0,"stats":{"Line":0}},{"line":1544,"address":[],"length":0,"stats":{"Line":0}},{"line":1546,"address":[],"length":0,"stats":{"Line":0}},{"line":1547,"address":[],"length":0,"stats":{"Line":0}},{"line":1551,"address":[],"length":0,"stats":{"Line":0}},{"line":1557,"address":[],"length":0,"stats":{"Line":0}},{"line":1558,"address":[],"length":0,"stats":{"Line":0}},{"line":1560,"address":[],"length":0,"stats":{"Line":0}},{"line":1562,"address":[],"length":0,"stats":{"Line":0}},{"line":1563,"address":[],"length":0,"stats":{"Line":0}},{"line":1565,"address":[],"length":0,"stats":{"Line":0}},{"line":1566,"address":[],"length":0,"stats":{"Line":0}},{"line":1568,"address":[],"length":0,"stats":{"Line":0}},{"line":1570,"address":[],"length":0,"stats":{"Line":0}},{"line":1571,"address":[],"length":0,"stats":{"Line":0}},{"line":1575,"address":[],"length":0,"stats":{"Line":0}},{"line":1576,"address":[],"length":0,"stats":{"Line":0}},{"line":1577,"address":[],"length":0,"stats":{"Line":0}},{"line":1582,"address":[],"length":0,"stats":{"Line":0}},{"line":1583,"address":[],"length":0,"stats":{"Line":0}},{"line":1584,"address":[],"length":0,"stats":{"Line":0}},{"line":1585,"address":[],"length":0,"stats":{"Line":0}},{"line":1587,"address":[],"length":0,"stats":{"Line":0}},{"line":1588,"address":[],"length":0,"stats":{"Line":0}},{"line":1590,"address":[],"length":0,"stats":{"Line":0}},{"line":1591,"address":[],"length":0,"stats":{"Line":0}},{"line":1593,"address":[],"length":0,"stats":{"Line":0}},{"line":1595,"address":[],"length":0,"stats":{"Line":0}},{"line":1600,"address":[],"length":0,"stats":{"Line":0}},{"line":1602,"address":[],"length":0,"stats":{"Line":0}},{"line":1604,"address":[],"length":0,"stats":{"Line":0}},{"line":1605,"address":[],"length":0,"stats":{"Line":0}},{"line":1606,"address":[],"length":0,"stats":{"Line":0}},{"line":1607,"address":[],"length":0,"stats":{"Line":0}},{"line":1609,"address":[],"length":0,"stats":{"Line":0}},{"line":1610,"address":[],"length":0,"stats":{"Line":0}},{"line":1611,"address":[],"length":0,"stats":{"Line":0}},{"line":1612,"address":[],"length":0,"stats":{"Line":0}},{"line":1615,"address":[],"length":0,"stats":{"Line":0}},{"line":1617,"address":[],"length":0,"stats":{"Line":0}},{"line":1618,"address":[],"length":0,"stats":{"Line":0}},{"line":1622,"address":[],"length":0,"stats":{"Line":0}},{"line":1626,"address":[],"length":0,"stats":{"Line":0}},{"line":1627,"address":[],"length":0,"stats":{"Line":0}},{"line":1628,"address":[],"length":0,"stats":{"Line":0}},{"line":1629,"address":[],"length":0,"stats":{"Line":0}},{"line":1630,"address":[],"length":0,"stats":{"Line":0}},{"line":1634,"address":[],"length":0,"stats":{"Line":0}},{"line":1637,"address":[],"length":0,"stats":{"Line":0}},{"line":1639,"address":[],"length":0,"stats":{"Line":0}},{"line":1642,"address":[],"length":0,"stats":{"Line":0}},{"line":1644,"address":[],"length":0,"stats":{"Line":0}},{"line":1647,"address":[],"length":0,"stats":{"Line":0}},{"line":1648,"address":[],"length":0,"stats":{"Line":0}},{"line":1650,"address":[],"length":0,"stats":{"Line":0}},{"line":1654,"address":[],"length":0,"stats":{"Line":0}},{"line":1660,"address":[],"length":0,"stats":{"Line":0}},{"line":1667,"address":[],"length":0,"stats":{"Line":0}},{"line":1668,"address":[],"length":0,"stats":{"Line":0}},{"line":1669,"address":[],"length":0,"stats":{"Line":0}},{"line":1670,"address":[],"length":0,"stats":{"Line":0}},{"line":1675,"address":[],"length":0,"stats":{"Line":0}},{"line":1676,"address":[],"length":0,"stats":{"Line":0}},{"line":1679,"address":[],"length":0,"stats":{"Line":0}},{"line":1680,"address":[],"length":0,"stats":{"Line":0}},{"line":1683,"address":[],"length":0,"stats":{"Line":0}},{"line":1684,"address":[],"length":0,"stats":{"Line":0}},{"line":1687,"address":[],"length":0,"stats":{"Line":0}},{"line":1688,"address":[],"length":0,"stats":{"Line":0}},{"line":1689,"address":[],"length":0,"stats":{"Line":0}},{"line":1690,"address":[],"length":0,"stats":{"Line":0}},{"line":1691,"address":[],"length":0,"stats":{"Line":0}},{"line":1693,"address":[],"length":0,"stats":{"Line":0}},{"line":1698,"address":[],"length":0,"stats":{"Line":0}},{"line":1699,"address":[],"length":0,"stats":{"Line":0}},{"line":1700,"address":[],"length":0,"stats":{"Line":0}},{"line":1701,"address":[],"length":0,"stats":{"Line":0}},{"line":1702,"address":[],"length":0,"stats":{"Line":0}},{"line":1704,"address":[],"length":0,"stats":{"Line":0}},{"line":1709,"address":[],"length":0,"stats":{"Line":0}},{"line":1710,"address":[],"length":0,"stats":{"Line":0}},{"line":1713,"address":[],"length":0,"stats":{"Line":0}},{"line":1714,"address":[],"length":0,"stats":{"Line":0}},{"line":1716,"address":[],"length":0,"stats":{"Line":0}},{"line":1717,"address":[],"length":0,"stats":{"Line":0}},{"line":1718,"address":[],"length":0,"stats":{"Line":0}},{"line":1719,"address":[],"length":0,"stats":{"Line":0}},{"line":1721,"address":[],"length":0,"stats":{"Line":0}},{"line":1727,"address":[],"length":0,"stats":{"Line":0}},{"line":1732,"address":[],"length":0,"stats":{"Line":0}},{"line":1733,"address":[],"length":0,"stats":{"Line":0}},{"line":1735,"address":[],"length":0,"stats":{"Line":0}},{"line":1738,"address":[],"length":0,"stats":{"Line":0}},{"line":1741,"address":[],"length":0,"stats":{"Line":0}},{"line":1744,"address":[],"length":0,"stats":{"Line":0}},{"line":1745,"address":[],"length":0,"stats":{"Line":0}},{"line":1747,"address":[],"length":0,"stats":{"Line":0}},{"line":1748,"address":[],"length":0,"stats":{"Line":0}},{"line":1750,"address":[],"length":0,"stats":{"Line":0}},{"line":1751,"address":[],"length":0,"stats":{"Line":0}},{"line":1755,"address":[],"length":0,"stats":{"Line":0}},{"line":1758,"address":[],"length":0,"stats":{"Line":0}},{"line":1759,"address":[],"length":0,"stats":{"Line":0}},{"line":1763,"address":[],"length":0,"stats":{"Line":0}},{"line":1768,"address":[],"length":0,"stats":{"Line":0}},{"line":1769,"address":[],"length":0,"stats":{"Line":0}},{"line":1773,"address":[],"length":0,"stats":{"Line":0}},{"line":1774,"address":[],"length":0,"stats":{"Line":0}},{"line":1776,"address":[],"length":0,"stats":{"Line":0}},{"line":1780,"address":[],"length":0,"stats":{"Line":0}},{"line":1785,"address":[],"length":0,"stats":{"Line":0}},{"line":1786,"address":[],"length":0,"stats":{"Line":0}},{"line":1787,"address":[],"length":0,"stats":{"Line":0}},{"line":1788,"address":[],"length":0,"stats":{"Line":0}},{"line":1793,"address":[],"length":0,"stats":{"Line":0}},{"line":1798,"address":[],"length":0,"stats":{"Line":0}},{"line":1799,"address":[],"length":0,"stats":{"Line":0}},{"line":1802,"address":[],"length":0,"stats":{"Line":0}},{"line":1804,"address":[],"length":0,"stats":{"Line":0}},{"line":1805,"address":[],"length":0,"stats":{"Line":0}},{"line":1807,"address":[],"length":0,"stats":{"Line":0}},{"line":1810,"address":[],"length":0,"stats":{"Line":0}},{"line":1811,"address":[],"length":0,"stats":{"Line":0}},{"line":1816,"address":[],"length":0,"stats":{"Line":0}},{"line":1818,"address":[],"length":0,"stats":{"Line":0}},{"line":1820,"address":[],"length":0,"stats":{"Line":0}},{"line":1823,"address":[],"length":0,"stats":{"Line":0}},{"line":1824,"address":[],"length":0,"stats":{"Line":0}},{"line":1828,"address":[],"length":0,"stats":{"Line":0}},{"line":1829,"address":[],"length":0,"stats":{"Line":0}},{"line":1830,"address":[],"length":0,"stats":{"Line":0}},{"line":1833,"address":[],"length":0,"stats":{"Line":0}},{"line":1838,"address":[],"length":0,"stats":{"Line":0}},{"line":1840,"address":[],"length":0,"stats":{"Line":0}},{"line":1841,"address":[],"length":0,"stats":{"Line":0}},{"line":1845,"address":[],"length":0,"stats":{"Line":0}},{"line":1850,"address":[],"length":0,"stats":{"Line":0}},{"line":1851,"address":[],"length":0,"stats":{"Line":0}},{"line":1852,"address":[],"length":0,"stats":{"Line":0}},{"line":1854,"address":[],"length":0,"stats":{"Line":0}},{"line":1855,"address":[],"length":0,"stats":{"Line":0}},{"line":1856,"address":[],"length":0,"stats":{"Line":0}},{"line":1861,"address":[],"length":0,"stats":{"Line":0}},{"line":1866,"address":[],"length":0,"stats":{"Line":0}},{"line":1867,"address":[],"length":0,"stats":{"Line":0}},{"line":1870,"address":[],"length":0,"stats":{"Line":0}},{"line":1871,"address":[],"length":0,"stats":{"Line":0}},{"line":1875,"address":[],"length":0,"stats":{"Line":0}},{"line":1876,"address":[],"length":0,"stats":{"Line":0}},{"line":1878,"address":[],"length":0,"stats":{"Line":0}},{"line":1879,"address":[],"length":0,"stats":{"Line":0}},{"line":1883,"address":[],"length":0,"stats":{"Line":0}},{"line":1884,"address":[],"length":0,"stats":{"Line":0}},{"line":1885,"address":[],"length":0,"stats":{"Line":0}},{"line":1886,"address":[],"length":0,"stats":{"Line":0}},{"line":1887,"address":[],"length":0,"stats":{"Line":0}},{"line":1894,"address":[],"length":0,"stats":{"Line":0}},{"line":1895,"address":[],"length":0,"stats":{"Line":0}},{"line":1897,"address":[],"length":0,"stats":{"Line":0}},{"line":1898,"address":[],"length":0,"stats":{"Line":0}},{"line":1902,"address":[],"length":0,"stats":{"Line":0}},{"line":1904,"address":[],"length":0,"stats":{"Line":0}},{"line":1905,"address":[],"length":0,"stats":{"Line":0}},{"line":1908,"address":[],"length":0,"stats":{"Line":0}},{"line":1909,"address":[],"length":0,"stats":{"Line":0}},{"line":1910,"address":[],"length":0,"stats":{"Line":0}},{"line":1917,"address":[],"length":0,"stats":{"Line":0}},{"line":1926,"address":[],"length":0,"stats":{"Line":0}},{"line":1928,"address":[],"length":0,"stats":{"Line":0}},{"line":1929,"address":[],"length":0,"stats":{"Line":0}},{"line":1932,"address":[],"length":0,"stats":{"Line":0}},{"line":1933,"address":[],"length":0,"stats":{"Line":0}},{"line":1934,"address":[],"length":0,"stats":{"Line":0}},{"line":1936,"address":[],"length":0,"stats":{"Line":0}},{"line":1940,"address":[],"length":0,"stats":{"Line":8}},{"line":1946,"address":[],"length":0,"stats":{"Line":16}},{"line":1947,"address":[],"length":0,"stats":{"Line":8}},{"line":1948,"address":[],"length":0,"stats":{"Line":8}},{"line":1949,"address":[],"length":0,"stats":{"Line":8}},{"line":1950,"address":[],"length":0,"stats":{"Line":8}},{"line":1956,"address":[],"length":0,"stats":{"Line":0}},{"line":1957,"address":[],"length":0,"stats":{"Line":0}},{"line":1958,"address":[],"length":0,"stats":{"Line":0}},{"line":1959,"address":[],"length":0,"stats":{"Line":0}},{"line":1961,"address":[],"length":0,"stats":{"Line":0}},{"line":1963,"address":[],"length":0,"stats":{"Line":0}},{"line":1964,"address":[],"length":0,"stats":{"Line":0}},{"line":1967,"address":[],"length":0,"stats":{"Line":0}},{"line":1971,"address":[],"length":0,"stats":{"Line":0}},{"line":1978,"address":[],"length":0,"stats":{"Line":0}},{"line":1979,"address":[],"length":0,"stats":{"Line":0}},{"line":1980,"address":[],"length":0,"stats":{"Line":0}},{"line":1981,"address":[],"length":0,"stats":{"Line":0}},{"line":1982,"address":[],"length":0,"stats":{"Line":0}},{"line":1985,"address":[],"length":0,"stats":{"Line":0}},{"line":1987,"address":[],"length":0,"stats":{"Line":0}},{"line":1988,"address":[],"length":0,"stats":{"Line":0}},{"line":1992,"address":[],"length":0,"stats":{"Line":0}},{"line":1993,"address":[],"length":0,"stats":{"Line":0}},{"line":1997,"address":[],"length":0,"stats":{"Line":0}},{"line":1998,"address":[],"length":0,"stats":{"Line":0}},{"line":2001,"address":[],"length":0,"stats":{"Line":0}},{"line":2004,"address":[],"length":0,"stats":{"Line":0}},{"line":2005,"address":[],"length":0,"stats":{"Line":0}},{"line":2007,"address":[],"length":0,"stats":{"Line":0}},{"line":2008,"address":[],"length":0,"stats":{"Line":0}},{"line":2009,"address":[],"length":0,"stats":{"Line":0}},{"line":2011,"address":[],"length":0,"stats":{"Line":0}},{"line":2013,"address":[],"length":0,"stats":{"Line":0}},{"line":2014,"address":[],"length":0,"stats":{"Line":0}},{"line":2016,"address":[],"length":0,"stats":{"Line":0}},{"line":2017,"address":[],"length":0,"stats":{"Line":0}},{"line":2018,"address":[],"length":0,"stats":{"Line":0}},{"line":2019,"address":[],"length":0,"stats":{"Line":0}},{"line":2021,"address":[],"length":0,"stats":{"Line":0}},{"line":2026,"address":[],"length":0,"stats":{"Line":0}},{"line":2027,"address":[],"length":0,"stats":{"Line":0}},{"line":2031,"address":[],"length":0,"stats":{"Line":0}},{"line":2032,"address":[],"length":0,"stats":{"Line":0}},{"line":2033,"address":[],"length":0,"stats":{"Line":0}},{"line":2034,"address":[],"length":0,"stats":{"Line":0}},{"line":2037,"address":[],"length":0,"stats":{"Line":0}},{"line":2039,"address":[],"length":0,"stats":{"Line":0}},{"line":2042,"address":[],"length":0,"stats":{"Line":0}},{"line":2043,"address":[],"length":0,"stats":{"Line":0}},{"line":2045,"address":[],"length":0,"stats":{"Line":0}},{"line":2048,"address":[],"length":0,"stats":{"Line":0}},{"line":2049,"address":[],"length":0,"stats":{"Line":0}},{"line":2050,"address":[],"length":0,"stats":{"Line":0}},{"line":2051,"address":[],"length":0,"stats":{"Line":0}},{"line":2055,"address":[],"length":0,"stats":{"Line":0}},{"line":2057,"address":[],"length":0,"stats":{"Line":0}},{"line":2059,"address":[],"length":0,"stats":{"Line":0}},{"line":2060,"address":[],"length":0,"stats":{"Line":0}},{"line":2061,"address":[],"length":0,"stats":{"Line":0}},{"line":2062,"address":[],"length":0,"stats":{"Line":0}},{"line":2065,"address":[],"length":0,"stats":{"Line":0}},{"line":2066,"address":[],"length":0,"stats":{"Line":0}},{"line":2067,"address":[],"length":0,"stats":{"Line":0}},{"line":2068,"address":[],"length":0,"stats":{"Line":0}},{"line":2071,"address":[],"length":0,"stats":{"Line":0}},{"line":2078,"address":[],"length":0,"stats":{"Line":0}},{"line":2084,"address":[],"length":0,"stats":{"Line":0}},{"line":2085,"address":[],"length":0,"stats":{"Line":0}},{"line":2086,"address":[],"length":0,"stats":{"Line":0}},{"line":2087,"address":[],"length":0,"stats":{"Line":0}},{"line":2088,"address":[],"length":0,"stats":{"Line":0}},{"line":2089,"address":[],"length":0,"stats":{"Line":0}},{"line":2090,"address":[],"length":0,"stats":{"Line":0}},{"line":2091,"address":[],"length":0,"stats":{"Line":0}},{"line":2092,"address":[],"length":0,"stats":{"Line":0}},{"line":2094,"address":[],"length":0,"stats":{"Line":0}},{"line":2095,"address":[],"length":0,"stats":{"Line":0}},{"line":2096,"address":[],"length":0,"stats":{"Line":0}},{"line":2098,"address":[],"length":0,"stats":{"Line":0}},{"line":2099,"address":[],"length":0,"stats":{"Line":0}},{"line":2101,"address":[],"length":0,"stats":{"Line":0}},{"line":2107,"address":[],"length":0,"stats":{"Line":0}},{"line":2112,"address":[],"length":0,"stats":{"Line":0}},{"line":2115,"address":[],"length":0,"stats":{"Line":0}},{"line":2117,"address":[],"length":0,"stats":{"Line":0}},{"line":2119,"address":[],"length":0,"stats":{"Line":0}},{"line":2123,"address":[],"length":0,"stats":{"Line":0}},{"line":2124,"address":[],"length":0,"stats":{"Line":0}},{"line":2126,"address":[],"length":0,"stats":{"Line":0}},{"line":2127,"address":[],"length":0,"stats":{"Line":0}},{"line":2128,"address":[],"length":0,"stats":{"Line":0}},{"line":2132,"address":[],"length":0,"stats":{"Line":0}},{"line":2134,"address":[],"length":0,"stats":{"Line":0}},{"line":2137,"address":[],"length":0,"stats":{"Line":0}},{"line":2139,"address":[],"length":0,"stats":{"Line":0}},{"line":2140,"address":[],"length":0,"stats":{"Line":0}},{"line":2142,"address":[],"length":0,"stats":{"Line":0}},{"line":2144,"address":[],"length":0,"stats":{"Line":0}},{"line":2145,"address":[],"length":0,"stats":{"Line":0}},{"line":2147,"address":[],"length":0,"stats":{"Line":0}},{"line":2148,"address":[],"length":0,"stats":{"Line":0}},{"line":2149,"address":[],"length":0,"stats":{"Line":0}},{"line":2150,"address":[],"length":0,"stats":{"Line":0}},{"line":2152,"address":[],"length":0,"stats":{"Line":0}},{"line":2157,"address":[],"length":0,"stats":{"Line":0}},{"line":2163,"address":[],"length":0,"stats":{"Line":0}},{"line":2164,"address":[],"length":0,"stats":{"Line":0}},{"line":2165,"address":[],"length":0,"stats":{"Line":0}},{"line":2166,"address":[],"length":0,"stats":{"Line":0}},{"line":2168,"address":[],"length":0,"stats":{"Line":0}},{"line":2171,"address":[],"length":0,"stats":{"Line":0}},{"line":2174,"address":[],"length":0,"stats":{"Line":0}},{"line":2176,"address":[],"length":0,"stats":{"Line":0}},{"line":2178,"address":[],"length":0,"stats":{"Line":0}},{"line":2179,"address":[],"length":0,"stats":{"Line":0}},{"line":2180,"address":[],"length":0,"stats":{"Line":0}},{"line":2184,"address":[],"length":0,"stats":{"Line":0}},{"line":2185,"address":[],"length":0,"stats":{"Line":0}},{"line":2188,"address":[],"length":0,"stats":{"Line":0}},{"line":2196,"address":[],"length":0,"stats":{"Line":14}},{"line":2200,"address":[],"length":0,"stats":{"Line":42}},{"line":2204,"address":[],"length":0,"stats":{"Line":14}},{"line":2208,"address":[],"length":0,"stats":{"Line":42}},{"line":2210,"address":[],"length":0,"stats":{"Line":36}},{"line":2211,"address":[],"length":0,"stats":{"Line":11}},{"line":2212,"address":[],"length":0,"stats":{"Line":10}},{"line":2214,"address":[],"length":0,"stats":{"Line":20}},{"line":2216,"address":[],"length":0,"stats":{"Line":0}},{"line":2217,"address":[],"length":0,"stats":{"Line":0}},{"line":2218,"address":[],"length":0,"stats":{"Line":0}},{"line":2220,"address":[],"length":0,"stats":{"Line":10}},{"line":2222,"address":[],"length":0,"stats":{"Line":30}},{"line":2223,"address":[],"length":0,"stats":{"Line":40}},{"line":2224,"address":[],"length":0,"stats":{"Line":30}},{"line":2227,"address":[],"length":0,"stats":{"Line":0}},{"line":2228,"address":[],"length":0,"stats":{"Line":0}},{"line":2229,"address":[],"length":0,"stats":{"Line":0}},{"line":2230,"address":[],"length":0,"stats":{"Line":0}},{"line":2231,"address":[],"length":0,"stats":{"Line":0}},{"line":2233,"address":[],"length":0,"stats":{"Line":0}},{"line":2234,"address":[],"length":0,"stats":{"Line":0}},{"line":2237,"address":[],"length":0,"stats":{"Line":0}},{"line":2239,"address":[],"length":0,"stats":{"Line":0}},{"line":2240,"address":[],"length":0,"stats":{"Line":0}},{"line":2242,"address":[],"length":0,"stats":{"Line":0}},{"line":2246,"address":[],"length":0,"stats":{"Line":0}},{"line":2247,"address":[],"length":0,"stats":{"Line":0}},{"line":2248,"address":[],"length":0,"stats":{"Line":0}},{"line":2250,"address":[],"length":0,"stats":{"Line":0}},{"line":2255,"address":[],"length":0,"stats":{"Line":0}},{"line":2256,"address":[],"length":0,"stats":{"Line":0}},{"line":2257,"address":[],"length":0,"stats":{"Line":0}},{"line":2259,"address":[],"length":0,"stats":{"Line":0}},{"line":2263,"address":[],"length":0,"stats":{"Line":0}},{"line":2265,"address":[],"length":0,"stats":{"Line":0}},{"line":2266,"address":[],"length":0,"stats":{"Line":0}},{"line":2268,"address":[],"length":0,"stats":{"Line":0}},{"line":2272,"address":[],"length":0,"stats":{"Line":0}},{"line":2273,"address":[],"length":0,"stats":{"Line":0}},{"line":2274,"address":[],"length":0,"stats":{"Line":0}},{"line":2276,"address":[],"length":0,"stats":{"Line":0}},{"line":2281,"address":[],"length":0,"stats":{"Line":0}},{"line":2282,"address":[],"length":0,"stats":{"Line":0}},{"line":2283,"address":[],"length":0,"stats":{"Line":0}},{"line":2285,"address":[],"length":0,"stats":{"Line":0}},{"line":2289,"address":[],"length":0,"stats":{"Line":0}},{"line":2290,"address":[],"length":0,"stats":{"Line":0}},{"line":2291,"address":[],"length":0,"stats":{"Line":0}},{"line":2293,"address":[],"length":0,"stats":{"Line":0}},{"line":2296,"address":[],"length":0,"stats":{"Line":0}},{"line":2297,"address":[],"length":0,"stats":{"Line":0}},{"line":2298,"address":[],"length":0,"stats":{"Line":0}},{"line":2300,"address":[],"length":0,"stats":{"Line":0}},{"line":2303,"address":[],"length":0,"stats":{"Line":0}},{"line":2304,"address":[],"length":0,"stats":{"Line":0}},{"line":2305,"address":[],"length":0,"stats":{"Line":0}},{"line":2306,"address":[],"length":0,"stats":{"Line":0}},{"line":2308,"address":[],"length":0,"stats":{"Line":0}},{"line":2311,"address":[],"length":0,"stats":{"Line":0}},{"line":2312,"address":[],"length":0,"stats":{"Line":0}},{"line":2313,"address":[],"length":0,"stats":{"Line":0}},{"line":2315,"address":[],"length":0,"stats":{"Line":0}},{"line":2319,"address":[],"length":0,"stats":{"Line":1}},{"line":2326,"address":[],"length":0,"stats":{"Line":28}},{"line":2327,"address":[],"length":0,"stats":{"Line":4}},{"line":2328,"address":[],"length":0,"stats":{"Line":10}},{"line":2329,"address":[],"length":0,"stats":{"Line":10}},{"line":2333,"address":[],"length":0,"stats":{"Line":0}}],"covered":335,"coverable":1042},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","mod.rs"],"content":"mod access_control;\nmod inference;\nmod narrowing;\n\n// GenericVisitor types are available from typechecker::generics module directly\npub use access_control::{\n    AccessControl, AccessControlVisitor, ClassContext, ClassMemberInfo, ClassMemberKind,\n};\npub use inference::{TypeInferenceVisitor, TypeInferrer};\npub use narrowing::{narrow_type_from_condition, NarrowingContext, NarrowingVisitor, TypeNarrower};\n\npub trait TypeCheckVisitor {\n    #[allow(dead_code)]\n    fn name(\u0026self) -\u003e \u0026'static str;\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","Users","forge18","Repos","typedlua-typechecker","src","visitors","narrowing.rs"],"content":"use rustc_hash::FxHashMap;\nuse typedlua_parser::ast::expression::{BinaryOp, Expression, ExpressionKind, Literal, UnaryOp};\nuse typedlua_parser::ast::types::{PrimitiveType, Type, TypeKind};\nuse typedlua_parser::string_interner::StringId;\n\n/// Trait for type narrowing operations\n///\n/// This trait defines the interface for narrowing types based on conditions and patterns.\n/// It is used by the type checker to refine variable types in conditional branches.\npub trait NarrowingVisitor {\n    /// Narrow types based on a condition expression\n    ///\n    /// Returns (then_context, else_context) with refined types for each branch.\n    /// The then_context contains types that apply when the condition is true,\n    /// and the else_context contains types that apply when the condition is false.\n    fn narrow_from_condition(\n        \u0026self,\n        condition: \u0026Expression,\n        base_ctx: \u0026NarrowingContext,\n        original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n    ) -\u003e (NarrowingContext, NarrowingContext);\n\n    /// Get the current narrowing context\n    fn get_context(\u0026self) -\u003e \u0026NarrowingContext;\n\n    /// Get a mutable reference to the narrowing context\n    fn get_context_mut(\u0026mut self) -\u003e \u0026mut NarrowingContext;\n}\n\n/// Type narrowing context - tracks refined types for variables in the current scope\n#[derive(Debug, Clone)]\npub struct NarrowingContext {\n    /// Map from variable name to narrowed type\n    narrowed_types: FxHashMap\u003cStringId, Type\u003e,\n}\n\nimpl Default for NarrowingContext {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl NarrowingContext {\n    pub fn new() -\u003e Self {\n        Self {\n            narrowed_types: FxHashMap::default(),\n        }\n    }\n\n    /// Get the narrowed type for a variable, if any\n    pub fn get_narrowed_type(\u0026self, name: StringId) -\u003e Option\u003c\u0026Type\u003e {\n        self.narrowed_types.get(\u0026name)\n    }\n\n    /// Set a narrowed type for a variable\n    pub fn set_narrowed_type(\u0026mut self, name: StringId, typ: Type) {\n        self.narrowed_types.insert(name, typ);\n    }\n\n    /// Remove a narrowed type (when variable is reassigned)\n    pub fn remove_narrowed_type(\u0026mut self, name: StringId) {\n        self.narrowed_types.remove(\u0026name);\n    }\n\n    /// Merge two narrowing contexts (for branch join points)\n    pub fn merge(then_ctx: \u0026Self, else_ctx: \u0026Self) -\u003e Self {\n        // For now, we only keep types that are the same in both branches\n        // More sophisticated: create union types for divergent branches\n        let mut merged = NarrowingContext::new();\n\n        for (name, then_type) in \u0026then_ctx.narrowed_types {\n            if let Some(else_type) = else_ctx.narrowed_types.get(name) {\n                if types_equal(then_type, else_type) {\n                    merged.narrowed_types.insert(*name, then_type.clone());\n                }\n            }\n        }\n\n        merged\n    }\n\n    /// Clone the context for a new branch\n    pub fn clone_for_branch(\u0026self) -\u003e Self {\n        self.clone()\n    }\n}\n\n/// Type narrower implementation that tracks narrowed types\npub struct TypeNarrower {\n    context: NarrowingContext,\n}\n\nimpl TypeNarrower {\n    /// Create a new type narrower with an empty context\n    pub fn new() -\u003e Self {\n        Self {\n            context: NarrowingContext::new(),\n        }\n    }\n}\n\nimpl Default for TypeNarrower {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl NarrowingVisitor for TypeNarrower {\n    fn narrow_from_condition(\n        \u0026self,\n        condition: \u0026Expression,\n        base_ctx: \u0026NarrowingContext,\n        original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n        interner: \u0026typedlua_parser::string_interner::StringInterner,\n    ) -\u003e (NarrowingContext, NarrowingContext) {\n        narrow_type_from_condition(condition, base_ctx, original_types, interner)\n    }\n\n    fn get_context(\u0026self) -\u003e \u0026NarrowingContext {\n        \u0026self.context\n    }\n\n    fn get_context_mut(\u0026mut self) -\u003e \u0026mut NarrowingContext {\n        \u0026mut self.context\n    }\n}\n\n/// Narrow a type based on a condition expression\n/// Returns (then_context, else_context) with refined types for each branch\npub fn narrow_type_from_condition(\n    condition: \u0026Expression,\n    base_ctx: \u0026NarrowingContext,\n    original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n    interner: \u0026typedlua_parser::string_interner::StringInterner,\n) -\u003e (NarrowingContext, NarrowingContext) {\n    let mut then_ctx = base_ctx.clone_for_branch();\n    let mut else_ctx = base_ctx.clone_for_branch();\n\n    match \u0026condition.kind {\n        // typeof x == \"string\"\n        ExpressionKind::Binary(BinaryOp::Equal, left, right) =\u003e {\n            if let Some((var_name, type_name)) = extract_typeof_check(interner, left, right) {\n                if let Some(narrowed_type) = typeof_string_to_type(\u0026type_name) {\n                    then_ctx.set_narrowed_type(var_name, narrowed_type.clone());\n\n                    // In else branch, exclude the checked type\n                    if let Some(original) = original_types.get(\u0026var_name) {\n                        if let Some(else_type) = exclude_type(original, \u0026narrowed_type) {\n                            else_ctx.set_narrowed_type(var_name, else_type);\n                        }\n                    }\n                }\n            } else {\n                // Check for x == nil equality narrowing\n                if let Some((var_name, is_nil)) = extract_nil_check(interner, left, right) {\n                    if is_nil {\n                        // then: x is nil\n                        then_ctx.set_narrowed_type(\n                            var_name,\n                            Type::new(TypeKind::Primitive(PrimitiveType::Nil), condition.span),\n                        );\n\n                        // else: x is non-nil\n                        if let Some(original) = original_types.get(\u0026var_name) {\n                            if let Some(non_nil) = remove_nil_from_type(original) {\n                                else_ctx.set_narrowed_type(var_name, non_nil);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // typeof x != \"string\"\n        ExpressionKind::Binary(BinaryOp::NotEqual, left, right) =\u003e {\n            if let Some((var_name, type_name)) = extract_typeof_check(interner, left, right) {\n                if let Some(narrowed_type) = typeof_string_to_type(\u0026type_name) {\n                    // Flip the narrowing for != operator\n                    else_ctx.set_narrowed_type(var_name, narrowed_type.clone());\n\n                    if let Some(original) = original_types.get(\u0026var_name) {\n                        if let Some(then_type) = exclude_type(original, \u0026narrowed_type) {\n                            then_ctx.set_narrowed_type(var_name, then_type);\n                        }\n                    }\n                }\n            } else {\n                // x != nil\n                if let Some((var_name, is_nil)) = extract_nil_check(interner, left, right) {\n                    if is_nil {\n                        // Flip for != operator\n                        // then: x is non-nil\n                        if let Some(original) = original_types.get(\u0026var_name) {\n                            if let Some(non_nil) = remove_nil_from_type(original) {\n                                then_ctx.set_narrowed_type(var_name, non_nil);\n                            }\n                        }\n\n                        // else: x is nil\n                        else_ctx.set_narrowed_type(\n                            var_name,\n                            Type::new(TypeKind::Primitive(PrimitiveType::Nil), condition.span),\n                        );\n                    }\n                }\n            }\n        }\n\n        // not condition (flip the branches)\n        ExpressionKind::Unary(UnaryOp::Not, operand) =\u003e {\n            let (inner_then, inner_else) =\n                narrow_type_from_condition(operand, base_ctx, original_types, interner);\n            return (inner_else, inner_then); // Flip!\n        }\n\n        // condition1 and condition2\n        ExpressionKind::Binary(BinaryOp::And, left, right) =\u003e {\n            // First narrow with left condition\n            let (left_then, _left_else) =\n                narrow_type_from_condition(left, base_ctx, original_types, interner);\n\n            // Then narrow the 'then' branch with right condition\n            let (final_then, _final_else) =\n                narrow_type_from_condition(right, \u0026left_then, original_types, interner);\n\n            return (final_then, else_ctx);\n        }\n\n        // condition1 or condition2\n        ExpressionKind::Binary(BinaryOp::Or, left, right) =\u003e {\n            // For 'or', we narrow in the else branch with the right condition\n            let (left_then, left_else) =\n                narrow_type_from_condition(left, base_ctx, original_types, interner);\n            let (right_then, right_else) =\n                narrow_type_from_condition(right, \u0026left_else, original_types, interner);\n\n            // Then branch: either left or right was true\n            let merged_then = NarrowingContext::merge(\u0026left_then, \u0026right_then);\n\n            return (merged_then, right_else);\n        }\n\n        // Type guard function call: isString(x)\n        ExpressionKind::Call(function, arguments, _) =\u003e {\n            if let Some((var_name, narrowed_type)) =\n                extract_type_guard_call(function, arguments, original_types)\n            {\n                // In then branch: narrow to the guarded type\n                then_ctx.set_narrowed_type(var_name, narrowed_type.clone());\n\n                // In else branch: exclude the guarded type\n                if let Some(original) = original_types.get(\u0026var_name) {\n                    if let Some(else_type) = exclude_type(original, \u0026narrowed_type) {\n                        else_ctx.set_narrowed_type(var_name, else_type);\n                    }\n                }\n            }\n        }\n\n        // instanceof check: x instanceof ClassName\n        ExpressionKind::Binary(BinaryOp::Instanceof, left, right) =\u003e {\n            if let ExpressionKind::Identifier(var_name) = \u0026left.kind {\n                if let ExpressionKind::Identifier(class_name) = \u0026right.kind {\n                    // In then branch: narrow to the class type\n                    // For now, create a reference to the class type\n                    let class_type = Type::new(\n                        TypeKind::Reference(typedlua_parser::ast::types::TypeReference {\n                            name: typedlua_parser::ast::Ident::new(*class_name, condition.span),\n                            type_arguments: None,\n                            span: condition.span,\n                        }),\n                        condition.span,\n                    );\n                    then_ctx.set_narrowed_type(*var_name, class_type.clone());\n\n                    // In else branch: exclude the class type\n                    if let Some(original) = original_types.get(var_name) {\n                        if let Some(else_type) = exclude_type(original, \u0026class_type) {\n                            else_ctx.set_narrowed_type(*var_name, else_type);\n                        }\n                    }\n                }\n            }\n        }\n\n        // Truthiness check: if x then ...\n        ExpressionKind::Identifier(name) =\u003e {\n            if let Some(original) = original_types.get(name) {\n                // In then branch: x is truthy (non-nil, non-false)\n                if let Some(truthy_type) = make_truthy_type(original) {\n                    then_ctx.set_narrowed_type(*name, truthy_type);\n                }\n\n                // In else branch: x is falsy (nil or false)\n                if let Some(falsy_type) = make_falsy_type(original) {\n                    else_ctx.set_narrowed_type(*name, falsy_type);\n                }\n            }\n        }\n\n        _ =\u003e {\n            // No narrowing for other expression types\n        }\n    }\n\n    (then_ctx, else_ctx)\n}\n\n/// Extract typeof check: typeof x == \"string\" -\u003e Some((x, \"string\"))\nfn extract_typeof_check(\n    interner: \u0026typedlua_parser::string_interner::StringInterner,\n    left: \u0026Expression,\n    right: \u0026Expression,\n) -\u003e Option\u003c(StringId, String)\u003e {\n    // Check: typeof x == \"string\"\n    if let ExpressionKind::Call(function, arguments, _) = \u0026left.kind {\n        if let ExpressionKind::Identifier(func_name) = \u0026function.kind {\n            if interner.resolve(*func_name) == \"typeof\" \u0026\u0026 arguments.len() == 1 {\n                if let ExpressionKind::Identifier(var_name) = \u0026arguments[0].value.kind {\n                    if let ExpressionKind::Literal(Literal::String(type_name)) = \u0026right.kind {\n                        return Some((*var_name, type_name.clone()));\n                    }\n                }\n            }\n        }\n    }\n\n    // Check: \"string\" == typeof x (reversed)\n    if let ExpressionKind::Literal(Literal::String(type_name)) = \u0026left.kind {\n        if let ExpressionKind::Call(function, arguments, _) = \u0026right.kind {\n            if let ExpressionKind::Identifier(func_name) = \u0026function.kind {\n                if interner.resolve(*func_name) == \"typeof\" \u0026\u0026 arguments.len() == 1 {\n                    if let ExpressionKind::Identifier(var_name) = \u0026arguments[0].value.kind {\n                        return Some((*var_name, type_name.clone()));\n                    }\n                }\n            }\n        }\n    }\n\n    None\n}\n\n/// Extract type guard function call: isString(x) -\u003e Some((x, string))\n/// Type guards are functions with return type `param is Type`\nfn extract_type_guard_call(\n    function: \u0026Expression,\n    arguments: \u0026[typedlua_parser::ast::expression::Argument],\n    original_types: \u0026FxHashMap\u003cStringId, Type\u003e,\n) -\u003e Option\u003c(StringId, Type)\u003e {\n    // Check if this is a function call with one argument\n    if arguments.len() != 1 {\n        return None;\n    }\n\n    // Get the variable being checked\n    let var_name = match \u0026arguments[0].value.kind {\n        ExpressionKind::Identifier(name) =\u003e *name,\n        _ =\u003e return None,\n    };\n\n    // Try to get the function type from the passed context\n    // This allows checking actual type signatures when available\n    if let ExpressionKind::Identifier(func_name) = \u0026function.kind {\n        // Check if we have type information for this function\n        if let Some(func_type) = original_types.get(func_name) {\n            // Check if it's a function with a TypePredicate return type\n            if let TypeKind::Function(func_sig) = \u0026func_type.kind {\n                if let TypeKind::TypePredicate(predicate) = \u0026func_sig.return_type.kind {\n                    // Verify the parameter name matches the argument\n                    if predicate.parameter_name.node == var_name {\n                        return Some((var_name, (*predicate.type_annotation).clone()));\n                    }\n                }\n            }\n        }\n    }\n\n    None\n}\n\n/// Extract nil check: x == nil -\u003e Some((x, true))\nfn extract_nil_check(\n    _interner: \u0026typedlua_parser::string_interner::StringInterner,\n    left: \u0026Expression,\n    right: \u0026Expression,\n) -\u003e Option\u003c(StringId, bool)\u003e {\n    // Check: x == nil\n    if let ExpressionKind::Identifier(var_name) = \u0026left.kind {\n        if let ExpressionKind::Literal(Literal::Nil) = \u0026right.kind {\n            return Some((*var_name, true));\n        }\n    }\n\n    // Check: nil == x (reversed)\n    if let ExpressionKind::Literal(Literal::Nil) = \u0026left.kind {\n        if let ExpressionKind::Identifier(var_name) = \u0026right.kind {\n            return Some((*var_name, true));\n        }\n    }\n\n    None\n}\n\n/// Convert typeof string to a type\nfn typeof_string_to_type(type_name: \u0026str) -\u003e Option\u003cType\u003e {\n    let span = typedlua_parser::span::Span::new(0, 0, 0, 0);\n    match type_name {\n        \"nil\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Nil), span)),\n        \"boolean\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Boolean), span)),\n        \"number\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Number), span)),\n        \"string\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::String), span)),\n        \"table\" =\u003e Some(Type::new(TypeKind::Primitive(PrimitiveType::Table), span)),\n        _ =\u003e None,\n    }\n}\n\n/// Exclude a type from a union\nfn exclude_type(typ: \u0026Type, to_exclude: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let remaining: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !types_equal(t, to_exclude))\n                .cloned()\n                .collect();\n\n            if remaining.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if remaining.len() == 1 {\n                Some(remaining.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(remaining), typ.span))\n            }\n        }\n        _ if types_equal(typ, to_exclude) =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n        _ =\u003e Some(typ.clone()),\n    }\n}\n\n/// Remove nil from a type (for non-nil narrowing)\nfn remove_nil_from_type(typ: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let remaining: Vec\u003cType\u003e = types.iter().filter(|t| !is_nil_type(t)).cloned().collect();\n\n            if remaining.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if remaining.len() == 1 {\n                Some(remaining.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(remaining), typ.span))\n            }\n        }\n        _ if is_nil_type(typ) =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n        _ =\u003e Some(typ.clone()),\n    }\n}\n\n/// Check if a type is nil (handles both Literal(Nil) and Primitive(Nil))\nfn is_nil_type(typ: \u0026Type) -\u003e bool {\n    matches!(\n        typ.kind,\n        TypeKind::Primitive(PrimitiveType::Nil) | TypeKind::Literal(Literal::Nil)\n    )\n}\n\n/// Make a type truthy (remove nil and false)\nfn make_truthy_type(typ: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let truthy: Vec\u003cType\u003e = types\n                .iter()\n                .filter(|t| !is_falsy_type(t))\n                .cloned()\n                .collect();\n\n            if truthy.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if truthy.len() == 1 {\n                Some(truthy.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(truthy), typ.span))\n            }\n        }\n        _ if is_falsy_type(typ) =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n        _ =\u003e Some(typ.clone()),\n    }\n}\n\n/// Make a type falsy (only nil or false)\nfn make_falsy_type(typ: \u0026Type) -\u003e Option\u003cType\u003e {\n    match \u0026typ.kind {\n        TypeKind::Union(types) =\u003e {\n            let falsy: Vec\u003cType\u003e = types.iter().filter(|t| is_falsy_type(t)).cloned().collect();\n\n            if falsy.is_empty() {\n                Some(Type::new(\n                    TypeKind::Primitive(PrimitiveType::Never),\n                    typ.span,\n                ))\n            } else if falsy.len() == 1 {\n                Some(falsy.into_iter().next().unwrap())\n            } else {\n                Some(Type::new(TypeKind::Union(falsy), typ.span))\n            }\n        }\n        _ if is_falsy_type(typ) =\u003e Some(typ.clone()),\n        _ =\u003e Some(Type::new(\n            TypeKind::Primitive(PrimitiveType::Never),\n            typ.span,\n        )),\n    }\n}\n\n/// Check if a type is falsy (nil or false)\nfn is_falsy_type(typ: \u0026Type) -\u003e bool {\n    matches!(\n        typ.kind,\n        TypeKind::Primitive(PrimitiveType::Nil)\n            | TypeKind::Literal(Literal::Nil)\n            | TypeKind::Literal(Literal::Boolean(false))\n    )\n}\n\n/// Simple type equality check\nfn types_equal(t1: \u0026Type, t2: \u0026Type) -\u003e bool {\n    match (\u0026t1.kind, \u0026t2.kind) {\n        (TypeKind::Primitive(p1), TypeKind::Primitive(p2)) =\u003e p1 == p2,\n        (TypeKind::Literal(l1), TypeKind::Literal(l2)) =\u003e l1 == l2,\n        _ =\u003e false,\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use typedlua_parser::span::Span;\n\n    fn make_span() -\u003e Span {\n        Span::new(0, 0, 0, 0)\n    }\n\n    #[test]\n    fn test_narrowing_context_basic() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let x_id = interner.intern(\"x\");\n        ctx.set_narrowed_type(x_id, string_type.clone());\n\n        assert!(ctx.get_narrowed_type(x_id).is_some());\n        let y_id = interner.intern(\"y\");\n        assert!(ctx.get_narrowed_type(y_id).is_none());\n\n        ctx.remove_narrowed_type(x_id);\n        assert!(ctx.get_narrowed_type(x_id).is_none());\n    }\n\n    #[test]\n    fn test_narrowing_context_merge() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut then_ctx = NarrowingContext::new();\n        let mut else_ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let x_id = interner.intern(\"x\");\n        let y_id = interner.intern(\"y\");\n\n        // Both have 'x' as string - should be kept\n        then_ctx.set_narrowed_type(x_id, string_type.clone());\n        else_ctx.set_narrowed_type(x_id, string_type.clone());\n\n        // Only then has 'y' - should not be kept\n        then_ctx.set_narrowed_type(y_id, number_type.clone());\n\n        let merged = NarrowingContext::merge(\u0026then_ctx, \u0026else_ctx);\n\n        assert!(merged.get_narrowed_type(x_id).is_some());\n        assert!(merged.get_narrowed_type(y_id).is_none());\n    }\n\n    #[test]\n    fn test_remove_nil_from_union() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let non_nil = remove_nil_from_type(\u0026union_type).unwrap();\n\n        assert!(matches!(\n            non_nil.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_make_truthy_type() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                Type::new(TypeKind::Literal(Literal::Boolean(false)), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let truthy = make_truthy_type(\u0026union_type).unwrap();\n\n        if let TypeKind::Union(types) = \u0026truthy.kind {\n            assert_eq!(types.len(), 2); // string and number\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    // ========================================================================\n    // Additional Comprehensive Tests\n    // ========================================================================\n\n    #[test]\n    fn test_narrowing_context_default() {\n        let ctx: NarrowingContext = Default::default();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n        assert!(ctx.get_narrowed_type(x_id).is_none());\n    }\n\n    #[test]\n    fn test_narrowing_context_clone_for_branch() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let x_id = interner.intern(\"x\");\n        ctx.set_narrowed_type(x_id, string_type.clone());\n\n        let cloned = ctx.clone_for_branch();\n        assert!(cloned.get_narrowed_type(x_id).is_some());\n\n        // Modifying cloned should not affect original\n        let y_id = interner.intern(\"y\");\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let mut cloned_mut = cloned;\n        cloned_mut.set_narrowed_type(y_id, number_type);\n\n        assert!(ctx.get_narrowed_type(y_id).is_none());\n        assert!(cloned_mut.get_narrowed_type(y_id).is_some());\n    }\n\n    #[test]\n    fn test_narrowing_context_merge_different_types() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let mut then_ctx = NarrowingContext::new();\n        let mut else_ctx = NarrowingContext::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        let x_id = interner.intern(\"x\");\n\n        // Different types for same variable - should not be kept\n        then_ctx.set_narrowed_type(x_id, string_type);\n        else_ctx.set_narrowed_type(x_id, number_type);\n\n        let merged = NarrowingContext::merge(\u0026then_ctx, \u0026else_ctx);\n        assert!(merged.get_narrowed_type(x_id).is_none());\n    }\n\n    #[test]\n    fn test_narrowing_context_merge_empty() {\n        let then_ctx = NarrowingContext::new();\n        let else_ctx = NarrowingContext::new();\n\n        let merged = NarrowingContext::merge(\u0026then_ctx, \u0026else_ctx);\n        // Should be empty\n        assert!(merged\n            .get_narrowed_type(typedlua_parser::string_interner::StringId::from_u32(0))\n            .is_none());\n    }\n\n    #[test]\n    fn test_type_narrower_new() {\n        let narrower = TypeNarrower::new();\n        assert!(narrower\n            .get_context()\n            .get_narrowed_type(typedlua_parser::string_interner::StringId::from_u32(0))\n            .is_none());\n    }\n\n    #[test]\n    fn test_type_narrower_default() {\n        let narrower: TypeNarrower = Default::default();\n        assert!(narrower\n            .get_context()\n            .get_narrowed_type(typedlua_parser::string_interner::StringId::from_u32(0))\n            .is_none());\n    }\n\n    #[test]\n    fn test_type_narrower_get_context_mut() {\n        let mut narrower = TypeNarrower::new();\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let x_id = interner.intern(\"x\");\n\n        {\n            let ctx = narrower.get_context_mut();\n            ctx.set_narrowed_type(x_id, string_type);\n        }\n\n        assert!(narrower.get_context().get_narrowed_type(x_id).is_some());\n    }\n\n    #[test]\n    fn test_is_nil_type() {\n        let nil_prim = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let nil_lit = Type::new(TypeKind::Literal(Literal::Nil), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        assert!(is_nil_type(\u0026nil_prim));\n        assert!(is_nil_type(\u0026nil_lit));\n        assert!(!is_nil_type(\u0026string_type));\n    }\n\n    #[test]\n    fn test_is_falsy_type() {\n        let nil_prim = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let nil_lit = Type::new(TypeKind::Literal(Literal::Nil), make_span());\n        let false_lit = Type::new(TypeKind::Literal(Literal::Boolean(false)), make_span());\n        let true_lit = Type::new(TypeKind::Literal(Literal::Boolean(true)), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        assert!(is_falsy_type(\u0026nil_prim));\n        assert!(is_falsy_type(\u0026nil_lit));\n        assert!(is_falsy_type(\u0026false_lit));\n        assert!(!is_falsy_type(\u0026true_lit));\n        assert!(!is_falsy_type(\u0026string_type));\n    }\n\n    #[test]\n    fn test_remove_nil_from_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n\n        // Non-nil type should remain unchanged\n        let result = remove_nil_from_type(\u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // Nil type should become Never\n        let result = remove_nil_from_type(\u0026nil_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_remove_nil_results_in_single_type() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let result = remove_nil_from_type(\u0026union_type).unwrap();\n        // Should result in a single type, not a union\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_make_truthy_type_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n\n        // Truthy type should remain unchanged\n        let result = make_truthy_type(\u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // Nil type should become Never\n        let result = make_truthy_type(\u0026nil_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_make_falsy_type() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span()),\n                Type::new(TypeKind::Literal(Literal::Boolean(false)), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let falsy = make_falsy_type(\u0026union_type).unwrap();\n\n        if let TypeKind::Union(types) = \u0026falsy.kind {\n            assert_eq!(types.len(), 2); // nil and false\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_make_falsy_type_non_union() {\n        let nil_type = Type::new(TypeKind::Primitive(PrimitiveType::Nil), make_span());\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n\n        // Nil type should remain unchanged\n        let result = make_falsy_type(\u0026nil_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Nil)\n        ));\n\n        // String type should become Never\n        let result = make_falsy_type(\u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_type_from_union() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Boolean), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let to_exclude = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let result = exclude_type(\u0026union_type, \u0026to_exclude).unwrap();\n\n        if let TypeKind::Union(types) = \u0026result.kind {\n            assert_eq!(types.len(), 2);\n        } else {\n            panic!(\"Expected union type\");\n        }\n    }\n\n    #[test]\n    fn test_exclude_type_results_in_single() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![\n                Type::new(TypeKind::Primitive(PrimitiveType::String), make_span()),\n                Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span()),\n            ]),\n            make_span(),\n        );\n\n        let to_exclude = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n        let result = exclude_type(\u0026union_type, \u0026to_exclude).unwrap();\n\n        // Should result in a single type\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_all_types_becomes_never() {\n        let union_type = Type::new(\n            TypeKind::Union(vec![Type::new(\n                TypeKind::Primitive(PrimitiveType::String),\n                make_span(),\n            )]),\n            make_span(),\n        );\n\n        let to_exclude = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let result = exclude_type(\u0026union_type, \u0026to_exclude).unwrap();\n\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_exclude_type_non_union() {\n        let string_type = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number_type = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        // Exclude different type - should remain unchanged\n        let result = exclude_type(\u0026string_type, \u0026number_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::String)\n        ));\n\n        // Exclude same type - should become Never\n        let result = exclude_type(\u0026string_type, \u0026string_type).unwrap();\n        assert!(matches!(\n            result.kind,\n            TypeKind::Primitive(PrimitiveType::Never)\n        ));\n    }\n\n    #[test]\n    fn test_types_equal() {\n        let string1 = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let string2 = Type::new(TypeKind::Primitive(PrimitiveType::String), make_span());\n        let number = Type::new(TypeKind::Primitive(PrimitiveType::Number), make_span());\n\n        assert!(types_equal(\u0026string1, \u0026string2));\n        assert!(!types_equal(\u0026string1, \u0026number));\n    }\n\n    #[test]\n    fn test_typeof_string_to_type() {\n        assert!(typeof_string_to_type(\"nil\").is_some());\n        assert!(typeof_string_to_type(\"boolean\").is_some());\n        assert!(typeof_string_to_type(\"number\").is_some());\n        assert!(typeof_string_to_type(\"string\").is_some());\n        assert!(typeof_string_to_type(\"table\").is_some());\n        assert!(typeof_string_to_type(\"unknown\").is_none());\n        assert!(typeof_string_to_type(\"function\").is_none());\n    }\n\n    #[test]\n    fn test_extract_nil_check_basic() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n\n        // x == nil\n        let left = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n        let right = Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = extract_nil_check(\u0026interner, \u0026left, \u0026right);\n        assert!(result.is_some());\n        let (name, is_nil) = result.unwrap();\n        assert_eq!(name, x_id);\n        assert!(is_nil);\n    }\n\n    #[test]\n    fn test_extract_nil_check_reversed() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n\n        // nil == x\n        let left = Expression {\n            kind: ExpressionKind::Literal(Literal::Nil),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n        let right = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = extract_nil_check(\u0026interner, \u0026left, \u0026right);\n        assert!(result.is_some());\n    }\n\n    #[test]\n    fn test_extract_nil_check_not_nil() {\n        let interner = typedlua_parser::string_interner::StringInterner::new();\n        let x_id = interner.intern(\"x\");\n\n        // x == \"string\" - not a nil check\n        let left = Expression {\n            kind: ExpressionKind::Identifier(x_id),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n        let right = Expression {\n            kind: ExpressionKind::Literal(Literal::String(\"hello\".to_string())),\n            span: make_span(),\n            annotated_type: None,\n            receiver_class: None,\n        };\n\n        let result = extract_nil_check(\u0026interner, \u0026left, \u0026right);\n        assert!(result.is_none());\n    }\n}\n","traces":[{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":1}},{"line":45,"address":[],"length":0,"stats":{"Line":355}},{"line":47,"address":[],"length":0,"stats":{"Line":355}},{"line":52,"address":[],"length":0,"stats":{"Line":190}},{"line":53,"address":[],"length":0,"stats":{"Line":570}},{"line":57,"address":[],"length":0,"stats":{"Line":33}},{"line":58,"address":[],"length":0,"stats":{"Line":132}},{"line":62,"address":[],"length":0,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":3}},{"line":67,"address":[],"length":0,"stats":{"Line":3}},{"line":70,"address":[],"length":0,"stats":{"Line":6}},{"line":72,"address":[],"length":0,"stats":{"Line":12}},{"line":73,"address":[],"length":0,"stats":{"Line":8}},{"line":74,"address":[],"length":0,"stats":{"Line":7}},{"line":75,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":3}},{"line":84,"address":[],"length":0,"stats":{"Line":45}},{"line":85,"address":[],"length":0,"stats":{"Line":90}},{"line":96,"address":[],"length":0,"stats":{"Line":292}},{"line":98,"address":[],"length":0,"stats":{"Line":292}},{"line":104,"address":[],"length":0,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":110,"address":[],"length":0,"stats":{"Line":18}},{"line":117,"address":[],"length":0,"stats":{"Line":90}},{"line":120,"address":[],"length":0,"stats":{"Line":37}},{"line":121,"address":[],"length":0,"stats":{"Line":37}},{"line":124,"address":[],"length":0,"stats":{"Line":352}},{"line":125,"address":[],"length":0,"stats":{"Line":352}},{"line":131,"address":[],"length":0,"stats":{"Line":22}},{"line":137,"address":[],"length":0,"stats":{"Line":66}},{"line":138,"address":[],"length":0,"stats":{"Line":66}},{"line":140,"address":[],"length":0,"stats":{"Line":21}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":143,"address":[],"length":0,"stats":{"Line":11}},{"line":144,"address":[],"length":0,"stats":{"Line":2}},{"line":145,"address":[],"length":0,"stats":{"Line":5}},{"line":148,"address":[],"length":0,"stats":{"Line":3}},{"line":149,"address":[],"length":0,"stats":{"Line":4}},{"line":150,"address":[],"length":0,"stats":{"Line":3}},{"line":156,"address":[],"length":0,"stats":{"Line":8}},{"line":157,"address":[],"length":0,"stats":{"Line":1}},{"line":159,"address":[],"length":0,"stats":{"Line":2}},{"line":160,"address":[],"length":0,"stats":{"Line":1}},{"line":161,"address":[],"length":0,"stats":{"Line":3}},{"line":165,"address":[],"length":0,"stats":{"Line":3}},{"line":166,"address":[],"length":0,"stats":{"Line":3}},{"line":167,"address":[],"length":0,"stats":{"Line":3}},{"line":176,"address":[],"length":0,"stats":{"Line":16}},{"line":177,"address":[],"length":0,"stats":{"Line":24}},{"line":178,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[],"length":0,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[],"length":0,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":40}},{"line":191,"address":[],"length":0,"stats":{"Line":8}},{"line":194,"address":[],"length":0,"stats":{"Line":24}},{"line":195,"address":[],"length":0,"stats":{"Line":24}},{"line":196,"address":[],"length":0,"stats":{"Line":24}},{"line":201,"address":[],"length":0,"stats":{"Line":16}},{"line":202,"address":[],"length":0,"stats":{"Line":8}},{"line":203,"address":[],"length":0,"stats":{"Line":24}},{"line":211,"address":[],"length":0,"stats":{"Line":0}},{"line":212,"address":[],"length":0,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":214,"address":[],"length":0,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[],"length":0,"stats":{"Line":0}},{"line":234,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":0}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":245,"address":[],"length":0,"stats":{"Line":2}},{"line":246,"address":[],"length":0,"stats":{"Line":2}},{"line":247,"address":[],"length":0,"stats":{"Line":3}},{"line":250,"address":[],"length":0,"stats":{"Line":5}},{"line":253,"address":[],"length":0,"stats":{"Line":3}},{"line":254,"address":[],"length":0,"stats":{"Line":4}},{"line":255,"address":[],"length":0,"stats":{"Line":3}},{"line":262,"address":[],"length":0,"stats":{"Line":2}},{"line":263,"address":[],"length":0,"stats":{"Line":2}},{"line":264,"address":[],"length":0,"stats":{"Line":2}},{"line":268,"address":[],"length":0,"stats":{"Line":1}},{"line":269,"address":[],"length":0,"stats":{"Line":4}},{"line":270,"address":[],"length":0,"stats":{"Line":1}},{"line":271,"address":[],"length":0,"stats":{"Line":1}},{"line":273,"address":[],"length":0,"stats":{"Line":1}},{"line":275,"address":[],"length":0,"stats":{"Line":5}},{"line":278,"address":[],"length":0,"stats":{"Line":3}},{"line":279,"address":[],"length":0,"stats":{"Line":4}},{"line":280,"address":[],"length":0,"stats":{"Line":3}},{"line":288,"address":[],"length":0,"stats":{"Line":0}},{"line":289,"address":[],"length":0,"stats":{"Line":0}},{"line":291,"address":[],"length":0,"stats":{"Line":0}},{"line":292,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":297,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":9}},{"line":307,"address":[],"length":0,"stats":{"Line":22}},{"line":311,"address":[],"length":0,"stats":{"Line":11}},{"line":317,"address":[],"length":0,"stats":{"Line":13}},{"line":318,"address":[],"length":0,"stats":{"Line":2}},{"line":319,"address":[],"length":0,"stats":{"Line":3}},{"line":320,"address":[],"length":0,"stats":{"Line":2}},{"line":321,"address":[],"length":0,"stats":{"Line":2}},{"line":322,"address":[],"length":0,"stats":{"Line":2}},{"line":330,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[],"length":0,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":342,"address":[],"length":0,"stats":{"Line":10}},{"line":347,"address":[],"length":0,"stats":{"Line":1}},{"line":353,"address":[],"length":0,"stats":{"Line":1}},{"line":354,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[],"length":0,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":2}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":365,"address":[],"length":0,"stats":{"Line":2}},{"line":367,"address":[],"length":0,"stats":{"Line":3}},{"line":369,"address":[],"length":0,"stats":{"Line":2}},{"line":370,"address":[],"length":0,"stats":{"Line":2}},{"line":372,"address":[],"length":0,"stats":{"Line":1}},{"line":373,"address":[],"length":0,"stats":{"Line":2}},{"line":380,"address":[],"length":0,"stats":{"Line":0}},{"line":384,"address":[],"length":0,"stats":{"Line":13}},{"line":390,"address":[],"length":0,"stats":{"Line":24}},{"line":391,"address":[],"length":0,"stats":{"Line":11}},{"line":392,"address":[],"length":0,"stats":{"Line":10}},{"line":397,"address":[],"length":0,"stats":{"Line":1}},{"line":398,"address":[],"length":0,"stats":{"Line":2}},{"line":399,"address":[],"length":0,"stats":{"Line":1}},{"line":403,"address":[],"length":0,"stats":{"Line":2}},{"line":407,"address":[],"length":0,"stats":{"Line":8}},{"line":408,"address":[],"length":0,"stats":{"Line":16}},{"line":409,"address":[],"length":0,"stats":{"Line":8}},{"line":410,"address":[],"length":0,"stats":{"Line":10}},{"line":411,"address":[],"length":0,"stats":{"Line":9}},{"line":412,"address":[],"length":0,"stats":{"Line":8}},{"line":413,"address":[],"length":0,"stats":{"Line":9}},{"line":414,"address":[],"length":0,"stats":{"Line":5}},{"line":415,"address":[],"length":0,"stats":{"Line":2}},{"line":420,"address":[],"length":0,"stats":{"Line":8}},{"line":421,"address":[],"length":0,"stats":{"Line":2}},{"line":422,"address":[],"length":0,"stats":{"Line":6}},{"line":423,"address":[],"length":0,"stats":{"Line":18}},{"line":425,"address":[],"length":0,"stats":{"Line":45}},{"line":429,"address":[],"length":0,"stats":{"Line":12}},{"line":430,"address":[],"length":0,"stats":{"Line":2}},{"line":431,"address":[],"length":0,"stats":{"Line":1}},{"line":432,"address":[],"length":0,"stats":{"Line":1}},{"line":434,"address":[],"length":0,"stats":{"Line":5}},{"line":435,"address":[],"length":0,"stats":{"Line":4}},{"line":437,"address":[],"length":0,"stats":{"Line":6}},{"line":440,"address":[],"length":0,"stats":{"Line":9}},{"line":441,"address":[],"length":0,"stats":{"Line":1}},{"line":442,"address":[],"length":0,"stats":{"Line":1}},{"line":444,"address":[],"length":0,"stats":{"Line":1}},{"line":449,"address":[],"length":0,"stats":{"Line":13}},{"line":450,"address":[],"length":0,"stats":{"Line":2}},{"line":451,"address":[],"length":0,"stats":{"Line":11}},{"line":452,"address":[],"length":0,"stats":{"Line":110}},{"line":454,"address":[],"length":0,"stats":{"Line":22}},{"line":455,"address":[],"length":0,"stats":{"Line":0}},{"line":456,"address":[],"length":0,"stats":{"Line":0}},{"line":457,"address":[],"length":0,"stats":{"Line":0}},{"line":459,"address":[],"length":0,"stats":{"Line":11}},{"line":460,"address":[],"length":0,"stats":{"Line":22}},{"line":462,"address":[],"length":0,"stats":{"Line":0}},{"line":465,"address":[],"length":0,"stats":{"Line":7}},{"line":466,"address":[],"length":0,"stats":{"Line":1}},{"line":467,"address":[],"length":0,"stats":{"Line":1}},{"line":469,"address":[],"length":0,"stats":{"Line":1}},{"line":474,"address":[],"length":0,"stats":{"Line":27}},{"line":475,"address":[],"length":0,"stats":{"Line":13}},{"line":476,"address":[],"length":0,"stats":{"Line":18}},{"line":482,"address":[],"length":0,"stats":{"Line":3}},{"line":483,"address":[],"length":0,"stats":{"Line":2}},{"line":484,"address":[],"length":0,"stats":{"Line":1}},{"line":485,"address":[],"length":0,"stats":{"Line":3}},{"line":487,"address":[],"length":0,"stats":{"Line":9}},{"line":491,"address":[],"length":0,"stats":{"Line":2}},{"line":492,"address":[],"length":0,"stats":{"Line":0}},{"line":493,"address":[],"length":0,"stats":{"Line":0}},{"line":494,"address":[],"length":0,"stats":{"Line":0}},{"line":496,"address":[],"length":0,"stats":{"Line":1}},{"line":497,"address":[],"length":0,"stats":{"Line":0}},{"line":499,"address":[],"length":0,"stats":{"Line":2}},{"line":502,"address":[],"length":0,"stats":{"Line":7}},{"line":503,"address":[],"length":0,"stats":{"Line":1}},{"line":504,"address":[],"length":0,"stats":{"Line":1}},{"line":506,"address":[],"length":0,"stats":{"Line":1}},{"line":511,"address":[],"length":0,"stats":{"Line":3}},{"line":512,"address":[],"length":0,"stats":{"Line":2}},{"line":513,"address":[],"length":0,"stats":{"Line":1}},{"line":514,"address":[],"length":0,"stats":{"Line":12}},{"line":516,"address":[],"length":0,"stats":{"Line":2}},{"line":517,"address":[],"length":0,"stats":{"Line":0}},{"line":518,"address":[],"length":0,"stats":{"Line":0}},{"line":519,"address":[],"length":0,"stats":{"Line":0}},{"line":521,"address":[],"length":0,"stats":{"Line":1}},{"line":522,"address":[],"length":0,"stats":{"Line":0}},{"line":524,"address":[],"length":0,"stats":{"Line":2}},{"line":527,"address":[],"length":0,"stats":{"Line":6}},{"line":528,"address":[],"length":0,"stats":{"Line":2}},{"line":529,"address":[],"length":0,"stats":{"Line":1}},{"line":530,"address":[],"length":0,"stats":{"Line":1}},{"line":536,"address":[],"length":0,"stats":{"Line":16}},{"line":537,"address":[],"length":0,"stats":{"Line":7}},{"line":538,"address":[],"length":0,"stats":{"Line":11}},{"line":546,"address":[],"length":0,"stats":{"Line":19}},{"line":547,"address":[],"length":0,"stats":{"Line":38}},{"line":548,"address":[],"length":0,"stats":{"Line":51}},{"line":549,"address":[],"length":0,"stats":{"Line":0}},{"line":550,"address":[],"length":0,"stats":{"Line":2}}],"covered":174,"coverable":224}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      },
    };
  });

  return [...folders, ...files.filter(file => file.path.length === 1)];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener('hashchange', () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.slice(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(
      ({current}) => {
        return {current: [...current, file.path[0]]};
      },
      () => this.updateHash(),
    );
  }

  back(file) {
    this.setState(
      ({current}) => {
        return {current: current.slice(0, current.length - 1)};
      },
      () => this.updateHash(),
    );
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e(
    'div',
    {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e(
      'table',
      {className: 'files-list'},
      e('thead', {className: 'files-list__head'}, e('tr', null, e('th', null, 'Path'), e('th', null, 'Coverage'))),
      e(
        'tbody',
        {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile})),
      ),
    ),
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? (file.covered / file.coverable) * 100 : -1;
  const coverageDelta =
    file.prevRun && (file.covered / file.coverable) * 100 - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'tr',
    {
      className:
        'files-list__file' +
        (coverage >= 0 && coverage < 50 ? ' files-list__file_low' : '') +
        (coverage >= 50 && coverage < 80 ? ' files-list__file_medium' : '') +
        (coverage >= 80 ? ' files-list__file_high' : '') +
        (file.is_folder ? ' files-list__file_folder' : ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e(
      'td',
      null,
      file.covered + ' / ' + file.coverable + (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
    ),
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'}, e(FileHeader, {file, onBack}), e(FileContent, {file}));
}

function FileHeader({file, onBack}) {
  const coverage = (file.covered / file.coverable) * 100;
  const coverageDelta = file.prevRun && coverage - (file.prevRun.covered / file.prevRun.coverable) * 100;

  return e(
    'div',
    {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e(
      'div',
      {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable + (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e(
        'span',
        {title: 'Change from the previous run'},
        coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : '',
      ),
      e('input', {id: 'theme-toggle', type: 'checkbox', hidden: true}),
      e('label', {for: 'theme-toggle', id: 'theme-toggle-label'}, ''),
    ),
  );
}

function FileContent({file}) {
  return e(
    'pre',
    {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      const nbHit = covered? trace.stats.Line: 0;
      return e(
        'div',
        { className: 'code-text-container' },
        e(
          'code',
          {
            className: 'code-line' + (covered ? ' code-line_covered' : '') + (uncovered ? ' code-line_uncovered' : ''),
          },
          line
        ),
        e(
          'div',
          { className: 'cover-indicator' + (covered? ' check-cover': '') + (uncovered? ' no-cover': '')},
          e(
            'div',
            { className: (covered? 'stat-line-hit': '')},
            covered? nbHit: ""
          )
        )
      );
    }),
  );
}

(function () {
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData &&
    previousData.files.forEach(file => {
      const path = file.path.slice(commonPath.length).join('/');
      prevFilesMap.set(path, file);
    });

  const files = data.files.map(file => {
    const path = file.path.slice(commonPath.length);
    const {covered = 0, coverable = 0} = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: {covered, coverable},
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    },
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));

  const toggle = document.getElementById('theme-toggle');
  const label = document.getElementById('theme-toggle-label');
  label.textContent = '';

  toggle.addEventListener('change', () => {
    if (toggle.checked) {
      document.documentElement.setAttribute('data-theme', 'dark');
      label.textContent = '';
    } else {
      document.documentElement.removeAttribute('data-theme');
      label.textContent = '';
    }
  });
})();
</script>
</body>
</html>